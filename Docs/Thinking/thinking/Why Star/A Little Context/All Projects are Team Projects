A key observation about successful software projects is that they involve teams; even if they start out as solo projects, they invariably become team projects. Furthermore, deployment targets will often extend to span a range of devices from smart phones to multi-cluster super computers. Finally, software is rarely completely useful in isolation: integration with other systems if often key to realizing the benefits of a given system. These aspects have continually influenced Star’s design.
Another strong influence on Star was the social context: We assumed that any any given software project would involve many people. This led us to conclude that features such as clear semantics, safety, strong modularization, and in particular multi-paradigm support are essential rather than being optional.
The foundations for safety in a programming language stem from an expressive type system — the more expressive the type system, the less the temptation to escape from it — and from an easy-to-reason-about semantics. These requirements favor primarily functional languages, especially when it comes to reasoning about parallel and distributed programming.
Star is not a pure language in the sense that it permits programs with assignments and stateful objects. This is both because we wish to permit programmers to build in ways that suits their needs and because some algorithms are easier to express using mutable state. However, the language encourages the programmer to program more declaratively. Star enables procedural programming whilst constraining features to avoid some pitfalls of global hidden state.