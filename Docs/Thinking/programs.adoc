[appendix]
= Example Programs

[#wordleProgram]
== The Wordle game

This game is explained in <<wordleGame>>.

[source,star]
----
test.wordle{
  import star.
  import star.io.
  import star.mbox.
  import star.assert.
  import star.sort.
  import star.system.

  import test.lib.text.

  parseWordFile:(string)=>cons[string] throws ioException.
  parseWordFile(Fn) => readLines(Fn).

  color ::= .grey | .yellow | .green.

  coloredChar:(color,char)=>string.
  coloredChar(.grey,Ch) => "\e[107m #(Ch::string) \e[0m".
  coloredChar(.green,Ch) => "\e[102m #(Ch::string) \e[0m".
  coloredChar(.yellow,Ch) => "\e[103m #(Ch::string) \e[0m".

  result ::= result{
    ch:char.
    index:integer.
    col:color
  }.

  implementation display[result] => {
    disp(result{ch=Ch. col=Col}) => coloredChar(Col,Ch)
  }

  showScore:(cons[result])=>string.
  showScore(Sc) => (Sc//disp)*.

  score:(string,string)=>string.
  score(Secret,Guess) => valof{
    S = explode(Secret);
    G = explode(Guess);
    Ix = iota(0,size(G));
    Grns = greens(S,G,Ix);
    (RestSecret,RestGuess,RestIx) = unzip3(nongreens(S,G,Ix));
    Ylws = yellows(RestSecret,RestGuess,RestIx);
    Score = sort(Grns++Ylws,compIndex);
    valis showScore(Score)
  }

  compIndex:all x,y ~~ x<~{index:integer}, y<~{index:integer} |= (x,y)=>boolean.
  compIndex(X,Y) => X.index<Y.index.

  greens:(cons[char],cons[char],cons[integer]) => cons[result].
  greens(Secret,Guess,Index) =>
    { result{index=X. col=.green. ch=C} | (C,C,X) in zip3(Secret,Guess,Index)}.

  nongreens:(cons[char],cons[char],cons[integer]) => cons[(char,char,integer)].
  nongreens(Secret,Guess,Index) =>
    { (S,G,X) | (S,G,X) in zip3(Secret,Guess,Index) && S~=G}.

  yellows:(cons[char],cons[char],cons[integer]) => cons[result].
  yellows(Se,Gu,Ix) => collect{
    SecretChars := Se;
    for (Ch,X) in zip(Gu,Ix) do{
      if Ch.<.SecretChars! then{
	SecretChars := SecretChars!\-Ch;
	elemis result{col=.yellow. ch=Ch. index=X}
      } else
      elemis result{col=.grey. ch=Ch. index=X}
    }}

  filterGuesses:(string,string,cons[string])=>cons[string].
  filterGuesses(Guess,Score,Words) => 
    { C | C in Words && score(C,Guess)==Score }.

  makeAGuess(Words) => _optval(Words[_irand([|Words|])]).

  autoplay:(string,cons[string]) => integer.
  autoplay(Secret,Words) => valof{
    WordCnt = [|Words|];
      
    Cnt := 0;
    Possibles := Words;
    while Cnt!<6 && ~isEmpty(Possibles!) do{
      Cnt := Cnt!+1;
      Guess = makeAGuess(Possibles!);
      Score = score(Secret,Guess);
      showMsg("Guess $(Cnt!)\: #(Score)");
      if Guess==Secret then{
	showMsg("Success in $(Cnt!) goes");
	valis Cnt!
      }
      else{
	Possibles := filterGuesses(Guess,Score,Possibles!);
      }
    };
    showMsg("Failed after $(Cnt!) goes");
    valis Cnt!
  }

  readGuess:() => string throws ioException.
  readGuess() => valof{
    wrText(stdout,"Next: ");
    _flushall();
    valis rdLine(stdin)
  }

  play:(string,cons[string]) => integer.
  play(Secret,Words) => valof{
    Cnt := 0;
    while Cnt! < 6 do{
      try{
	Guess = readGuess();
	Score = score(Secret,Guess);
	Cnt := Cnt!+1;
	showMsg("$(Cnt!)\:#(Score)");
	if Guess==Secret then{
	  showMsg("Success in $(Cnt!) goes");
	  valis Cnt!
	}
      } catch {
	| .pastEof => {
	  showMsg("Ending after $(Cnt!) moves");
	  exit(0)
	}
	| E => {
	  showMsg("IO error: $(E)");
	  valis 0
	}
      }
    };
    showMsg("Failed after $(Cnt!) goes\nSecret was #(Secret)");
    valis Cnt!
  }

  _main:(cons[string])=>().
  _main([S,G]) => 
    showMsg(score(S,G)).
  _main([]) => main().
         
  main:()=>().
  main() => valof{
    try{
      Words = parseWordFile("wordle.txt");
      _seed(_ticks());
      Cnt = [|Words|];
      
      if Secret ?= Words[_irand(Cnt)] then{
	autoplay(Secret,Words);
--	play(Secret,Words);
      }
    } catch {
      M => showMsg("We got an exception: $(M)")
    };
    valis ()
  }
}
----
