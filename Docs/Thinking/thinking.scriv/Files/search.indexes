<?xml version="1.0" encoding="UTF-8"?>
<SearchIndexes Version="1.0">
    <Documents>
        <Document ID="6892863E-E8E0-4F4D-86EB-0DB68050B0DC">
            <Title>Why Star</Title>
            <Text>Star is first of all a general purpose programming language. You can use it to effectively solve problems in many domains. Star was developed to help write analytical and statistical applications. However, it has evolved into a general purpose problem-oriented programming language. Many of the features and functionalities of the platform are expressed in a way that is consistent with Star. As such, it plays a key role in enabling the different elements of an application built on the platform to work smoothly together.
Like any programming language, Star represents a distinct view point on what programming languages should be. Star is a rich functional-first language with extensibility capabilities. Star is designed to be readable, powerful, safe and extensible.
In the spectrum of high-level and low-level programming languages, Star is at the higher end of the range. But, importantly, it's extensibility features enable it to support even higher level constructs.
Performance is also important, of course. However, we view performance as being guided by the principle of `fast enough is good enough'. In practice, since the compiler is based on the JVM, many Star programs have a performance profile that is commensurate with comparable Java programs.
</Text>
            <Comments>As opposed to a systems-oriented programming language like C.</Comments>
        </Document>
        <Document ID="4F250526-C9CE-4C42-ADA8-2C6D6C48FA45">
            <Title>Back Matter</Title>
        </Document>
        <Document ID="736E1C1A-3090-4A56-A9E3-AB21BDDC3B1A">
            <Title>Extending Star</Title>
            <Text>Star has three main features that contribute to developing DSLs: an extensible syntax, a powerful macro language and a module system that includes support for the first two.</Text>
        </Document>
        <Document ID="46F13B03-3EAB-4EFB-8051-40816CE6FD1C">
            <Title>Front Matter</Title>
            <Notes>Note that in the “Metadata” pane of the Inspector, under “Section Type”, the “Default Subdocument Type” is set to “Front Matter”. This setting causes all subdocuments of this folder to use the “Front Matter” section type by default (that is, when “Structure-Based” is selected as the section type).

This saves us from having to manually assign the “Front Matter” section type for each document we place into this folder.

During Compile, documents assigned the “Front Matter” section type will be laid out differently from documents in the main body of the manuscript.</Notes>
        </Document>
        <Document ID="2E6A5A54-C24C-446A-822C-2A752E0864C5">
            <Title>Query Speech</Title>
            <Text>The second form of speech action is the query. This represents a question being posed. For example, to query an (augmented) account actor for its balances one might use:
query B with
  cons of { all X where X in balances &amp;&amp;
    X.ts&gt;=yesterday}
Note that this expression combines two different elements of Star: a query speech action and a query expression. The expression
cons of { all X where X in balances and X.ts&gt;=yesterday }
represents the question:
All the X's, where X is in the balances collection and where X's time stamp is more recent than yesterday.
The answer is presented as a cons list. Different forms of query allow the result to be presented as any form of collection – or be further processed via reduction.
Query expressions have many uses. The full query expression notation has similar expressive power to that of SQL; except that instead of being restricted to flat tables, Star's query notation can be applied to a large variety of types of data.
There is no special kind of rule within an actor that is used to respond to query speech actions. Instead the response to the query is determined simply by evaluating the whole expression relative to the actor's internal environment.
However, there may be situations where this permissive approach to handling query speech actions is not appropriate. In that situation, it is possible to get behind the scenes and intercept thequery — or any speech action — and analyze it before deciding to honor the query.</Text>
        </Document>
        <Document ID="65DD6CFA-150C-41F2-9D20-DE8283BA1FBB">
            <Title>Scheduling Factories</Title>
            <Text>Star has been used for a number of applications. One of these – an application to schedule the processing of wafers in a semiconductor factory (a.k.a. fab) – illustrates how the different features of Star come together in a whole.
One of the first applications of the emerging Starview Enterprise Platform was ALPS (‘Advanced Logistics and Planning System’), a system for scheduling semiconductor fabs.
Semiconductor fabrication is a complex process, with modern microprocessors going through (on the order of) 1000 production steps going on over several weeks.
There is often significant competitive pressure to use leading edge technology. The result is that equipment is fickle and breaks down or fails to operate at specification frequently.
Moreover, many fabs are moving to highly diversified product mixes. It is not 10 times harder to make 100 products instead of 10, it is 1000’s of times harder.
Consequently, long-term planning of the fab operation is impossible, and scheduling systems need to strike a delicate balance between the planning required to make good decisions and simultaneously not relying on the fab actually executing the plans generated.
The problem is further exacerbated by problems quite specific to semiconductors: for example, some production routes – the sequences of production steps involved in making a product – involvequeue-time zones. A queue-time zone is a sub-sequence that, once entered, has to be completed within a certain time. If a wafer does not complete a queue-time zone on time, chemical processes cause it to ‘go bad’ resulting in a reworking of some of the process at best and a scrapping of work at worst.
The latest iteration of the ALPS system ‘ALPS 4’ makes use of almost all of Star's advanced facilities:
	•	ALPS uses Star's advanced type system to provide high-level compositional models of conceptual entities such as tools, wafers, and routes.
	•	Parametric polymorphism is used extensively to abstract over type definitions for concrete equipment, wafers, production recipes etc., making ALPS into a modular framework.
	•	The framework is purely functional, which enables the composition and nesting of the fab (as well as simulated fabs) with schedulers. Star enables purely functional programming with its support for higher-order programming, and through providing high-performance functional data structures for dictionaries and sequences.
	•	Advanced concepts from functional programming enable the modular composition of scheduling strategies: ALPS uses monads17 to manage the ‘hope’ that the fab will follow its scheduling instructions, and arrows18 to allow modular composition of scheduling strategies. Star provides general support for both through type contracts and computation expressions.
In particular, ALPS solves the queue-time problem through the combination of its purely functional operation and the composable scheduler framework.
Whenever ALPS encounters a wafer about to enter a queue-time zone, it starts a recursive speculative simulation of the system, and monitors the wafer to see if it would successfully completes the queue-time zone. Depending on the result, it lets the wafer enter or delays it.
Full speculative simulation is impossible with traditional scheduling systems used in the industry. A typical system operates on a live, multi-gigabyte database containing the fab state. Thus speculative simulation would entail copying the database state or snapshotting over longer sequences of transactions, each of which would be prohibitively expensive.
In the following sections we elaborate on three selected aspects of the ALPS system to show how Star supports the development of complex applications:
	•	purely functional programming to enable speculative simulation;
	•	algebraic data types to implement compositional models for routes;
	•	monads to manage scheduler expectations about the fab.
</Text>
        </Document>
        <Document ID="328772E8-E69A-42B0-9300-513F56F22591">
            <Title>Title Page</Title>
            <Synopsis>Title page to the manuscript.</Synopsis>
            <Text>Your Name
Your Address
Your phone number
Your e-mail address

(Your agent’s name)
(Your agent’s address)
&lt;$wc100&gt; words










&lt;$projecttitle&gt;

by &lt;$fullname&gt;</Text>
            <Notes>This is the title page of the manuscript. Note that its “Section Type” is automatically set to “Front Matter” in the Metadata pane of the Inspector, allowing the title page to be formatted differently from body text during Compile.

The &lt;$PROJECTTITLE&gt; and &lt;$fullname&gt; tags get replaced with metadata information you can set when compiling. Other information is taken from Contacts when the project is created.

The &lt;$wc100&gt; words tag will be replaced with the word count rounded to the nearest 100 during Compile (this and other tags can be inserted from the Insert menu).

Feel free to edit the text of the title page as required.</Notes>
        </Document>
        <Document ID="9EAB0FEF-93BD-486C-81F3-F1DDE95AFE70">
            <Title>Contents</Title>
        </Document>
        <Document ID="EA2537C0-002F-4190-8FEC-B33304E342F2">
            <Title>Defining Types</Title>
            <Text>Like most functional languages, Star supports many forms of sequence collection natively. One of the more common kinds of list is the ‘cons list’ a.k.a. single-linked list. Cons lists are defined using a type definition that introduces the type and its different ‘shapes’:
all t ~~ cons[t] ::= nil | cons(t,cons[t]).
This states that there are two forms of cons lists: the empty cons list nil, and a pairing cons(x, xs) where x is the first element, and xs is the rest of the list. The all quantifier at the beginning of the declaration of the cons type marks the type as a generic type – specifically a universal type.
All Star values can be written as literals, including user defined types like cons. For example, the cons list:
cons(“alpha”,cons(“beta”,cons(“gamma”,nil)))
contains the strings “alpha”, “beta” and “gamma”. 
The standard implementation of cons lists in Star also supports the sequence notation we saw above. So, this list can be written:
cons of [“alpha”, “beta”, “gamma”]
Note that we are not allowed to mix strings and integers in the same list. That is because Star is strongly, statically typed and such a heterogeneous list is not permitted.
Just as with sequences, we can define functions over cons lists via pattern matching:
maxCons:(cons[integer]) =&gt; integer.
maxCons(cons(x, nil)) =&gt; x.
maxCons(cons(x, xs)) default =&gt; let {
     maxRest = maxCons(xs).
   } in (x &gt; maxRest ? x : maxRest)
The first maxCons equation is for cons lists with one element, where maxCons simply returns that element. The second equation first computes the maximum of the rest of the list via a recursive call, and uses a conditional expression to compute the maximum for the entire list.
The expression
(x &gt; maxRest ? x : maxRest)
is a conditional expression: if x is greater then maxRest then it is the maximum; otherwise maxRest is. This is an example of a very well known form of expression that uses symbolic operators rather than keywords. Similar forms of expression can be found in all the major programming languages; so it would have seemed curmudgeonly to invent special keywords for it.</Text>
        </Document>
        <Document ID="C6BF1E28-CFB0-4C7E-AD6D-896763B72F0B">
            <Title>Abstract</Title>
            <Text>Star is a functional, multi-paradigm and extensible programming language. It is a full-scale language, capable of expressing many kinds of program. As such it is a rich language with many features.
Star was originally developed as part of a framework for processing a range of real-time business applications such as factory scheduling and data analytics.
This white paper explores some of the basic features of the language and shows by example how it can be used to solve problems.</Text>
        </Document>
        <Document ID="0F33A287-C84B-4E1E-AC76-6BCA9C300171">
            <Title>Actors</Title>
            <Text>Agenthood is often a useful metaphor in structuring large systems Singh3, Wooldridge4. The intuition is that an agent represents a focus of responsibility within a system: by structuring the system in terms of who is responsible for what it can make large systems more tractable. Star supports the agent metaphor with two key concepts: the concept of a speech action and the concept of an actor.
There may be many technical distinctions between agents and objects. The essential distinction is not technological, though: an agent is an embodiment of a functionally important part of a system and class notation is a technique for constructing programs. Agents reflect a division of requirements; object orientation reflects implementation.
Agenthood is also useful when the application programmer is tasked with modeling aspects of the world that are self-actuated: for example when modeling the behavior of people or of machines. Agents are also key to understanding systems that cross multiple ownership domains. Indeed, in an environment where different elements of a system reside on different machines some degree of self-responsibility is almost inevitable.
The agent metaphor suggests more; in particular two aspects: agents are typically designed to be `in charge of' their own area of responsibility and agents collaborate by `talking' to each other. There is an implication of autonomy with an agent; and agents posses the power of speech. One of the hallmarks of agents in the real world is that they chatter to each other with messages — rather than directly interfering with each other by setting variables.</Text>
        </Document>
        <Document ID="60893E0D-87D5-4336-9CFF-67CB1F21DB8F">
            <Title>Dedication</Title>
            <Text>




For the Family.</Text>
            <Notes>Feel free to delete this document if you don’t need it.</Notes>
        </Document>
        <Document ID="E5D850BA-9A24-45A0-9AA6-D3F347B5B0D6">
            <Title>Functional First</Title>
            <Text>Star is a ‘functional-first’ programming language. What this means is that Star makes it easier and more natural to write in a functional style. However, not all problems are best addressed in the functional way and it is certainly possible to write procedural Star programs.</Text>
        </Document>
        <Document ID="2A14605E-2DCA-43DC-BD82-6E71419D6B19">
            <Title>Implementing Knowledge</Title>
            <Text>As a somewhat larger demonstration of the capabilities of Star's macro language, let us look at a significant example: representing knowledge.
There are many knowledge representation languages; here we use one that is based on N3 notation15. In order to be relatively brief, we focus on a very reduced form of this notation: the knowledge triple. A statement of the form:
 
john ! parent $ sam
 
is intended to mean
john is parent of sam
more specifically,
john is the subject, parent is the relationship and sam is the object
Such a representation has many uses; one salient one for our purposes is that this kind of notation is very suited to representing configurations of various kinds.
It should also be obvious that such statements are not ordinary expressions or statements. Hence, to integrate such statements into a Star program we have a little work to do!
The first step is to bound the occurrences of such statements — to decide where they are legal. There are several ways of doing this; depending on the kind of extension we want to implement. In this case, we define a new kind of expression — the knowledge graph. N3 statements are legal only in knowledge graph expressions.
For example,
graph{
  john ! parent $ sam
}
is such a knowledge graph expression. We also have to define ! and $ as infix operators — which can be done using:
#right("!",500)
#right("\$",450)
  
We have to escape the $ because it is a special character in Star syntax.
The second step is to define how to represent such graphs. We choose to do so by using a data structure:
n3Graph(
  list of {
    triple(concept("john"),concept("parent"),concept("sam"))
  }
)
So, the task of the macro code is to translate the graph expression into an n3Graph term. The latter is readily understood by the Star compiler.
We are not addressing here how to use such graph expressions.
The core transformation of triples is handled by the macro rule:
# ?S ! ?P $ ? O ==&gt;
  triple(concept(S),concept(P),concept(O))
We use an intermediate concept of concept because the N3 language includes other kinds of concepts — such as strings and numbers.
Notice that the macro rule for triples directly matches the triples that we want to handle. This makes it very clear what the macro is intended to match against.
The concept is also transformed using a macro rule:
#concept(identifier?C) ==&gt; concept($$C)
There are many special purpose operators in the macro language. The $$ operator `converts' an identifier into a string literal. This allows us to reinterpret the john identifier as the string literal"john".
The graph itself it handled in a similar way to individual triples. Since triples are only valid inside a graph, we reflect that with the graph macro too:
#graph{?B} ==&gt; n3Graph(list of { B }) ## {
  # ?S ! ?P $ ? O ==&gt;
    triple(concept(S),concept(P),concept(O))
}
The macro replacement form:
Repl ## { Macros }
is the macro analog of a let expression: the macro rules in Macros are in scope for macro processing the expression Repl.
</Text>
        </Document>
        <Document ID="9BA3E55A-A3A3-4962-95E3-85885A5D9327">
            <Title>Explicit State</Title>
            <Text>Contrary to some expectations, it is possible to write stateful programs in a functional style. The difference is that you have to be explicit about the state. For example, the function:
addAll:(integer,integer)=&gt;integer.
addAll(from,to) =&gt; let{
  accum(ix,acc) where ix&gt;=to =&gt; acc.
  accum(ix,acc) =&gt; accum(ix+1,acc+ix).
} in accum(from,0).
is the ‘functional equivalent’ of the normal Java loop:
int addAll(int from,int to){
  int acc = 0;
  for(int ix=from;ix&lt;to;ix++)
    acc = acc+ix;
  return acc;
}
Apart from the use of recursion, the other main difference is that the ‘state’ – which in both cases is held in the acc variable – is explicitly handed down the functional program, whereas the Java program handles state implicitly.
The issue for the Java programmer is that what works for simple programs can become unmanageable for complex multi-threaded systems. On the other hand, while the functional programmer may be more burdened for simple cases, complex parallel programs are not much harder than the simple case.
Functional programming, with its declarative and explicit manipulation of state makes crafting parallel programs significantly simpler and less error-prone.
</Text>
        </Document>
        <Document ID="5CBAC46E-FCB5-417B-8706-227D1F9A9B5A">
            <Title>frontCover</Title>
        </Document>
        <Document ID="5A10A6FC-A51B-4DE6-BF2F-AA9281888DD4">
            <Title>Other Kinds of Agent</Title>
            <Text>The Star actor represents the simplest possible entity that can respond to speech actions. In that sense, a Star actor is the simplest possible mechanism for embodying responsibility.
There are other entities that also implement the speech contract; in particular, an agent could be seen as being the simplest entity that both responds to speech actions and has some awareness of its own goals and activities.
Thus actors and agents span a range of scales from the very small to the very large, but with a unified representation of `units of collaboration': the speech action. In particular, Star actors are able to operate on a reified representation of query and request speech actions, similar to (but developed independently from) LINQ's approach10.
Star's actors should not be confused with what is arguably the original definition of actor by Hewitt11. Hewitt actors are a representation of concurrent programs; Star actors may or may not be concurrent.</Text>
        </Document>
        <Document ID="FA2AF4ED-AD15-497D-8850-3E24F53FD4C7">
            <Title>Notes</Title>
            <Text>&lt;$--ENDNOTES--&gt;</Text>
            <Notes>The &lt;$--ENDNOTES--&gt; tag will be replaced by the footnotes during Compile. Using this tag allows us to have the footnotes inserted wherever we like, without having a separator placed above them.</Notes>
        </Document>
        <Document ID="09F3E4F0-4D59-4B89-B508-FF8E29E545EE">
            <Title>A Little Context</Title>
            <Text>The origins of Star lie in a platform that was originally oriented towards complex event processing applications.\cite{luckham:2012} StarRules — as it was known then — was a rules language that allowed one to express CEP-style rules succinctly.
However, as often happens, requirements evolved and CEP itself became just one of many application areas that the Starview platform can address. The same pressures for generality in the platform lead to a greater interest in extensibility and generality in the programming language.
</Text>
        </Document>
        <Document ID="F4A66BE5-387A-4F8A-A559-41548C274F0C">
            <Title>Title Page</Title>
            <Text>










&lt;$PROJECTTITLE&gt;

&lt;$author&gt;</Text>
            <Notes>These tags get replaced with the information set in the Metadata pane of Compile. Alternatively, you can simply replace this text altogether.</Notes>
        </Document>
        <Document ID="71BD88DF-F23B-4A11-ADA9-AD013A0B35D7">
            <Title>Functional Programming</Title>
            <Text>Functional programming has roots that go back to the origins of programming itself. However, it has been recently gaining in prominence because of some of the inherent advantages in the paradigm:
Its ‘declarative’ nature makes reasoning about functional programs easier than for ‘procedural’ programs.
This benefits programmers in a surprising number of ways. Of course, the most obvious one is that correctness and type safety are easier to establish than for a program built out of assignment and for-loops.
A subtler but equally critical benefit is that it can make programming itself easier: the programmer is free to focus on sub-problems without unnecessary entanglement with other sub-problems.
The impact of this benefit can be quite dramatic: similar in effect to the introduction of garbage collected memory compared to managed memory allocation.
</Text>
        </Document>
        <Document ID="3AC7ED2A-81DD-4CF7-8F63-8AC4EE05AA3E">
            <Title>Algebraic Datatypes</Title>
            <Text>While the previous section showed how ALPS 4 solves the hardest problem associated with the queue-time problem, the solution starts with a seemingly trivial aspect of the system: how to representroutes in the system.
A route lists the sequence of production steps a lot goes through as it traverses the fab. This suggests a simple list data structure to represent it. However, a route needs to represent the queue-time zones within the sequence. They could be stored in a separate list, which contains pointers or indices into the first list. However, this creates potential consistency problems between the two lists – changes in the list of steps may affect the list with the queue-time zones.
Moreover, the system also needs to represent progress within a route. Naïvely, this would be done using a pointer into the first list. In addition, the system would have to keep track of the queue-time zones that have already been entered. This creates additional potential consistency problems, and keeping the information about queue-time zones up-to-date as lots enter and exit them makes this representation hard to manipulate. Moreover, the position pointer needs to be checked against the end of the first list, and any potential queue-time zones. Moreover, the search for queue-time zones about to be entered is cumbersome and expensive.
ALPS 4 uses an alternative representation for routes that unifies the route itself and the ``position with the route'': It uses a single type RouteRem to represent the route remainder – what remains to be done of a route. In the beginning, the route remainder is the entire route, and as fabrication progresses, the route remainder gets shorter and shorter.
Ignoring queue-time zones for now, here is the simple definition of route remainders:
type RouteRem is
  RouteList(cons of RouteElement)
type RouteElement is
  RouteOp(Operation)
This Star type corresponds nicely to the definition:
A route remainder is a list of route elements.
A route element is a single operation.
Moreover, the representation is easily extensible to also handle queue-time zones: A queue-time zone is essentially a ``rub-route'' embedded in the route. An extension to the RouteElement type reflects this notion:
type RouteElement is
     RouteOp(Operation)
  or RouteQTZone(Duration, RouteRem)
Now a route element can also be a queue-time zone, consisting of a maximum duration (assuming an appropriate definition for the Duration type), and a sub-route represented by the RouteRemcomponent.
This definition is not quite complete, however: While RouteQTZone can represent a queue-time zone before it is entered, it is not sufficient to represent a queue-time zone ‘in progress’. For this, we add a case to RouteRem:
  type RouteRem is
     RouteList(cons of RouteElement)
  or RouteQTLimit(Time, RouteRem, RouteRem)
The RouteQTLimit constructor carries the time when the queue-time zone ends, as well as a route remainder within the queue-time zone and the remaining route after the queue-time zone.
While simple and elegant, this is also almost exactly the representation ALPS 4 uses for routes. In particular, it is compositional: Routes are assembled (‘composed’) from smaller routes, thus enabling flexible manipulation and construction without rigid hierarchies that are characteristic of more traditional designs. Moreover, Star's algebraic datatypes subsequently guide the design of functions operating on routes, making their implementation drastically easier than would be the case with index- or pointer-based representations. Furthermore, this representation quite naturally handles nested queue-time zones.19
In particular, this representation is easily extensible: For example, conditional branches – such as needed to insert metrology, for example – can be handled by extending the RouteElement type, and without invalidating the existing code.
Compositional representations such as the one for routes occur at all levels of the ALPS 4 systems: They describe the structure of composite tools (such as multi-chamber tools), scheduling strategies, scheduling policies, and hope. (For details on the latter, see the next section.)
</Text>
        </Document>
        <Document ID="D8F5688D-1CEE-4587-AA57-A9D4A4C5F2B2">
            <Title>More To Think About</Title>
            <Text>In the following chapters we explore some of the key features of Star in more depth. We start with the concepts of agent-hood and actors — one of the more unique aspects of Star.</Text>
        </Document>
        <Document ID="D661594B-5563-4BF5-9BFB-8BC1498475E9">
            <Title>Contracts as Interfaces</Title>
            <Text>At their most basic, contracts are a way of denoting `overloaded' functions. I.e., by giving different implementations of a contract for different types, it is possible to provide multiple implementations of a function. For example, there are several implementations of arith for integers, floats, and so on. It is also strsaightforward to implement arith for your own type.
However, another pattern of use of contracts is as an analog of interfaces. For example, we saw in Actors that actors used speech actions to express communication between them.
In fact, there are many entities that can handle speech actions. In addition to basic actors, Star also has concurrent actors — which have a completely different implementation — and ports.13
In addition to these implementations we can envisage many other entities that will want to be able to handle speech actions.
To enable all these diverse uses of speech actions we encapsulate the semantics of speech actions in a contract:14
contract all t ~~ speech[t] ::= {
  _notify:all x ~~ (t,(x)=&gt;())=&gt;().
  _query: all x,s ~~ (t,(x)=&gt;s) =&gt; s.
  _request: all x ~~ (t,(x)=&gt;())=&gt;()
}
As we shall see in Application = Policy + Mechanism, a speech action such as:
 
query A with list of { all X where X in R }
 
is translated by macros into the call to the function _query:
 
_query(A,(AA) =&gt; list of { all X where X in AA.R }))
 
Now the role of the speech contract may be highlighted: it serves as the specification of the semantics of speech actions. More informally, one can think of the language of speech actions as a kind of `ceiling': the DSL defines a language that is embedded within Star. The speech contract, on the other hand, represents a `floor' to the speech action language.
As a specification of semantics, contracts do not address all the issues. It is not possible, for example, to express that implementations of arithmetic obey the normal Peano axioms of arithmetic. However, it is possible to place assertions in a contract that are verified when the implementation is created.
</Text>
        </Document>
        <Document ID="8E6D3927-5152-47B2-B2AA-325A1256A9B1">
            <Title>Contents</Title>
        </Document>
        <Document ID="ADEEB1BB-F577-4A3A-81E2-3D2BBC67001B">
            <Title>Equations as cases</Title>
            <Text>Many functional programming languages — including Star — are based on an ‘equational style’. Equational programs are written as a series of equations; for example, in the credit function:
credit:(customer)=&gt;float.
credit(C) where inGoodStanding(C) =&gt; 0.15.
credit(C) where inDefault(C) =&gt; -0.1.
  ...
credit(_) default =&gt; 0.0.
Each line of this definition is an equation. It specifies the meaning of the credit function in a restricted setting – the complete function is understood by combining the cases together.
Using equations we can separate out the different cases for the customer’s credit and ‘work on them separately’. This allows the programmer to focus attention and allows for rapid editing and reorganization should the need arise.
Case-based approaches to programming are significantly more productive than traditional if-then-else procedural programming.
</Text>
        </Document>
        <Document ID="4A974BAC-91E4-40E2-BD39-C516D2C0DADA">
            <Title>References</Title>
            <Text>Event Processing for Business: Organizing the Real-Time Enterprise , David Luckham, John Wiley &amp; Sons, 2012

Multi-Agent Systems, A Theoretical Framework for Intentions, Know-How, and Communications,Munindar P. Singh, Springer-Verlag,1993

An Introduction to MultiAgent Systems, Wooldridge, Michael, Wiley 2009

How to do things with words, John L. Austin, Oxford : Clarendon 1962

 Speech acts: an essay in the philosophy of language, J. R. Searle, Cambridge University Press 1969

DRAFT specification of the KQML Agent Communication Language, , T. Finin and J. Weber and G. Wiederhold and M. Genesereth and R. Fritzson and D. McKay and J. McGuire and R. Pelavin and S. Shapiro and C. Beck The DARPA knowledge sharing initiative External Interfaces Working Group

The Foundation of Intelligent Physical Agents http://www.fipa.org

LINQ: reconciling object, relations and XML in the .NET framework Meijer, Erik and Beckman, Brian and Bierman, Gavin, Proceedings of the 2006 ACM SIGMOD International Conference on Management of Data, 2006

Concurrent Programming using Actors, G. Agha and C. Hewitt, {Object Oriented Concurrent Programming, MIT Press 1987

Notation3 (N3): A readable RDF syntax, Tim Berners Lee and Dan Connolly, 2011

Monads for Functional Programming, Philip Wadler, Advanced Functional Programming, Springer-Verlag, 1995

Generalising Monads to Arrows, John Hughes, Science of Computer Programming, 2000

</Text>
        </Document>
        <Document ID="58F1FE9C-75E1-4FA7-B400-3A1BA4874287">
            <Title>Accessing Collections</Title>
            <Text>Contracts are deeply embedded within the Star language. For example, consider the task of accessing a collection. This is captured in the standard indexable contract; which includes a definition of the_index function. It includes other functions too; which we omit in this discussion.
 
contract indexable over c determines (k,v) is {
  _index has type (c,k)=&gt;option of v
 ...
}
 
The _index function is rarely used directly; instead it is accessed via the index expression, as in:
 
L[34]
 
Accessing collections in this ways always introduces the element of tentativeness: it cannot normally be shown at compile time that L[34] exists. Star does not have the equivalent of Java null values; instead we make extensive use of the option type when we want to represent a tentative result.
Thus the type of L[34] is
option of integer
rather than simply integer
The indexable contract introduces an important feature of contracts: functional dependencies. The clause:
 
indexable over c determines (k,v)
 
states that any implementation of indexable for a type will `fix' two further types — in this case the `index type' and the `element type' of the elements of the collection.
For example, the implementation of indexable for lists starts with:
 
implementation indexable over list of %t
  determines (integer,%t) is …
 
This states that implementing indexable over lists requires that the index type is an integer and that the element type is the type of the element of the list. Much as one might expect. This allows expressions like L[34] to be typed as expected.
The indexable contract is also implemented for associative dictionaries. In this case the index type is the type of the keys in the dictionary and the element type is the type of the values in the dictionary:
 
implementation indexable over dictionary of (%k,%v)
  determines (%k,%v) is …
 
Thus, if we had a dictionary M whose keys were strings and whose values were integer, then the expression:
 
M["alpha"]
 
would have the type option of integer.
There is no requirement that the index type be a simple type. For example, consider the representation of JSON values. The standard infoset type allows JSON values to be represented abstractly in a way that permits easy processing of the data.
The most appropriate way of extracting elements from a JSON/infoset value is by using a path. For example, the path to the image title in the JSON value:
 
{
  "Image": {
    "Width": 800,
    "Height": 600,
    "Title": "View from 15th Floor",
    "Thumbnail": {
      "Url": "http://www.example.com/image/481989943",
      "Height": 125,
      "Width": "100"
    },
    "IDs": [116, 943, 234, 38793]
  }
}
 
may be expressed as Image.Title, and the last ID might be expressed as the path Image.IDS.3. If theinfoset of this value were bound to the variable I, then we can express these values using the expressions:
 
I[list of [kString("Image"),kString("Title")]]
 
and
 
I[list of [kString("Image"), kString("IDs"), kInt(3)]]
 
respectively.
Note that the elements of the path are not simply bare strings and integers. This is because a structure like:
 
list of [1, "fred", 2]
 
is not well typed. The elements of the path are from the iKey type which is written as an algebraic type definition:
 
type iKey is kString(string) or kInt(integer)
 
Wrapping the path elements as iKey values makes the path expression a legal Star value.
In summary, the simple contract specification for indexing can be applied to lists (arrays), to associative dictionaries and to tree-like structures. This has a powerful unifying effect on Star programs.
In the next chapter we show how syntactic features — like our indexing notation — can be implemented in Star.
</Text>
        </Document>
        <Document ID="AC3C6512-B2F7-47BD-AA92-6D1774AC7D3E">
            <Title>Application = Policy + Mechanism</Title>
            <Text>It can be said with some justification that any programs over 100 lines of code can be structured in terms of a basic engine and a policy for using the engine. The reason for this is very simple: it is often much easier to customize a general solution to a problem than to solve the specifics.
A policy tends to be different to a machine. Perhaps that is because policies express what the application is supposed to do (or not to do) where the mechanics describe how the application performs its function.
The distinction between policy and mechanism does not only apply to the overall application. It can be seen to apply at many different levels within libraries and within applications. For example, the speech actions introduced in Actors and the index notation introduced in Accessing Collections are both examples of the same policy vs mechanism distinction — albeit at a fine granularity.
There is no single `policy language' that is suitable for all purposes. Instead, Star makes it straightforward for programmers to design their own policy frameworks. This is by enabling so-calleddomain specific languages (DSLs).
A domain specific language is a complex name for a simple idea: a DSL is a notation that is tailored for specific purposes. In particular, there is no requirement that DSLs be `full languages'; this is especially true in the context of a language like Star, which has strong support for DSLs. Instead, a Star-based DSL can selectively focus on a particular kind of policy expression. This, in turn, greatly simplifies the task of designing and implementing such DSLs.
</Text>
        </Document>
        <Document ID="04BB9EC1-E0C7-488A-8475-F59BB42689AA">
            <Title>Extensible Syntax</Title>
            <Text>Star's core grammar is more of a meta-grammar than a conventional grammar. It is known as an operator precedence grammar. This is very similar to the approach taken in Prolog and similar languages.
A programmer can introduce new operators into the language, including new graphic tokens. For example:
 
#infix("&gt;\\",999)
 
defines a new infix operator &gt;\ that was previously unknown to the Star compiler.
We can also define multi-word tokens. This capability can be useful when grammar suggests multiple worded keywords. Some of Star's keywords are defined as multi-word operators; for example, the for all prefix to a universal quantifier is defined by the declaration:
 
#prefixA("for all",1005)
 
The meta-grammar allows arbitrary spaces and comments between the words of such an operator — but no other text.
</Text>
        </Document>
        <Document ID="9BAADB07-3706-4247-8A51-DBD5A1312703">
            <Title>Dedication</Title>
            <Text>










Insert dedication here.</Text>
            <Notes>Feel free to delete this document if you don’t need it.</Notes>
        </Document>
        <Document ID="1791BA7D-EC60-4DB6-B4A4-5FCB82D741DF">
            <Title>Collections</Title>
            <Text>Star has a standard way of writing sequences and collections – like lists and dictionaries. For example, the expression
list of [4, 8, 15, 16, 42]
denotes the list with the numbers 4, 8, 15, 16 and 42 in it. This notation – which is called the sequence notation – is quite general. We can denote a different kind of collection, containing cons elements for example, using:
cons of [4, 8, 15, 16, 42]
or, we can even denote a general collection without being explicit about the type of collection:
[4, 8, 15, 16, 42]
As another example, we can see that a dictionary literal is also a variation on the collection – except that we have keys as well as values:
dictionary of [ “alpha”-&gt;1, “beta”-&gt;2 ]</Text>
        </Document>
        <Document ID="AA101322-4428-4684-8F4D-86D933107166">
            <Title>Paperback</Title>
        </Document>
        <Document ID="774CA63B-75F7-4FA2-85B5-696588786EAC">
            <Title>Contracts</Title>
            <Text>The concept of a contract is fundamental to good software engineering. This is because it allows separation between the specification of a concept and its implementation.
A Star contract takes the form of a description of a set of functions and values. For example, the contract for basic arithmetic is
contract all t ~~ arith[t] ::= {
    (+) : (t,t)=&gt;t.
    (-) : (t,t)=&gt;t.
    (*) : (t,t)=&gt;t.
    (/) : (t,t)=&gt;t.
    one : t.
    zero : t.
}
This has the effect of declaring a group of functions that work together to form a basic arithmetic.
Notice that there are two identifiers defined here that may make one pause: zero and one.
These address a somewhat pernicious problem: how to handle literal numbers. By explicitly identifying zero and one as elements of the arith contract we can use them in lieu of 0 and 1 respectively without committing to integers. (Note: Star does not support implicit coercion of numeric literals.)
Once defined, a contract can be used simply by mentioning one of its members. Thus, in Star, all arithmetic depends on the arith contract:
fact(0) =&gt; 1.
fact(X) =&gt; X*fact(X-1)
Furthermore, if we want to state that the type of a variable is `something' that implements a contract we can do so by adding a constraint to the variable's type:
F : arith[t] |: t
This has the effect to declaring that F's type is a type variable — but one that is constrained such that whatever concrete type it eventually gets, it must be one that is defined for arith.12
In fact, however, this version of factorial is not the most paradigmatic (sic) version. The reason is that the type signature for fact is not generic but tied to integer:
fact:(integer)=&gt;integer
The reason that fact is not fully generic is interesting: its the presence of the literal numbers 0 and 1 in the program. The type of any literal integer is integer! This is enough to force the type of fact.  Recall that Star does not support automatic implicit coercion; that includes not coercing literals into some other type (such as float).
The solution is simple, if a little strange: we declared in the arith contract two non-function entries: zero and one. These are intended to represent the ‘0’ and ‘1’ values for the arithmetic being described. Using these, we can write a much more paradigmatic version of the factorial function:
factorial(zero) =&gt; one.
factorial(N) =&gt; factorial(N-1)*N.
This function is quite generic, and its type signature is given by:
factorial: all t ~~ arith[t] |: (t)=&gt;t.
Of course, in this case, our definition of factorial is not well defined for the real numbers; but that is a different issue!
</Text>
            <Comments>There is some Mathematical justification for this: the arith contract defines a Field which requires zero elements for the two operators (+ and *).</Comments>
        </Document>
        <Document ID="45D3FD4F-91F0-4C8E-BF2B-A4409487149E">
            <Title>Monads</Title>
            <Text>Fab scheduling poses a particularly intricate problem to schedulers: As equipment in the fab breaks down so frequently, instructions from the scheduler to the fab have only the status of recommendations. The scheduler needs to be able to deal with circumstances where its instructions do not get executed. Moreover, the fab typically will not give feedback when it cannot execute a scheduler instruction – the scheduler can only observe that actions did not happen that should be the consequence of executing an instruction.
The scheduler needs to take action when the fab does not execute an instruction: Otherwise, lots may get delayed indefinitely as the scheduler just waits fruitlessly for the result of the instruction to appear. Thus, the scheduler needs to manage hope about instructions it has issued across the board, and track when hope gets fulfilled, delayed or shattered. This is especially relevant when an instruction is part of a larger, more coordinated effort such as transporting a reticle to a lithography unit, and performing the necessary setup to enable a particular lot – which is also inbound – to be processed.
When looking at this problem, the ALPS 4 team considered implementing specialized tracking mechanisms for lot movement, reticle transport, setup etc. This quickly proved intractable, however, because of the wide variety of circumstances that are part of this general notion.
However, the use of Star enabled an elegant general solution to the problem of managing hope.
#
The Structure of Hope
The most important basic idea is that hope can be represented as a function that examines the state of the world to check on its status. In particular, one of several things can happen to a hope:
	•	A hope can be fulfilled, in which case there is a particular result (the payload) from the fulfillment.
	•	A hope can be shattered when there is no possibility that it will ever be fulfilled.
	•	A hope can be deferred in the form of a new hope, which may or may not be identical to the original hope.
As the hope checks on the world, it may also issue instructions to expedite fulfillment. Figure 3 illustrates the concept.
The two aspects of a hope interacting with the outside world – observing what has happened in the world as well as issuing instructions – are examples of handling state. Hope can observe as well as modify state. Consequently, hope functions have this type:
type Hope of (a, s) is alias of
  ((s) =&gt; HopeResult of (a, s))
The %s type parameter represents the state, and the %a represents the potential payload from the hope. The hope function can observe the state going in, and can modify it by returning a different state. The definition of the HopeResult type corresponds directly to Figure 3:
type HopeResult of (a, s) is
   HopeFulfilled(a, s)
or HopeShattered(string)
or HopeDeferred(Hope of (a, s), s)
This definition may seem simple, but is indeed the basis for all management of hope in the ALPS 4 system, and has replaced all previous, more complicated and cumbersome mechanisms in the system.
This makes the system exceedingly flexible and easy to adapt to new kinds of processes within a fab. Again, the powerful type-definition facilities in Star guides the design of simple solutions such as this one.
The definition is the outcome of viewing hope as a monad. Monads are a powerful pattern in functional programming, and thus directly accessible to Star programmers. In this case, they provide a framework for constructing hope that is compositional, providing the advantages described in the previous section.
</Text>
            <Comments>Since their original introduction into programming in the early 90s, monads have become a popular subject, with many tutorials and explanations available on the Web.</Comments>
        </Document>
        <Document ID="DBAF2454-BB2E-4B4C-909C-5BFF4B6FAC12">
            <Title>Star is rich</Title>
            <Text>Star is a full-featured language. It is an intentionally rich language. In addition to the features described here are concurrency features, data abstraction features that include the concept of existentially quantified types – that enables abstract data types – and computation expressions – that are important when designing systems that rely on being able to delay and control how expressions are evaluated; and many more.
In the chapters that follow, we will focus on three major features of Star that define much of the essence of Star: actors, contracts and the features needed to extend the syntax and capabilities of Star.</Text>
        </Document>
        <Document ID="AEA1EF44-11D5-4BDD-AB7A-AE87A9F72B71">
            <Title>frontCover</Title>
        </Document>
        <Document ID="33750B63-8C5E-4B61-8B14-942F39A45EEF">
            <Title>Speech Actions</Title>
            <Text>Speech actions were first investigated by John Austin5 in the 1940's as a vehicle for understanding the role of speech in human society. Since that time the basic ideas have been progressively formalized by Searle6 and standardized in KQML7 and FIPA.8
Within Star, a speech action can be viewed as a generalization of a method call where the method to be invoked can be a complete script or expression. Star supports three performatives: notify — which corresponds to one entity informing another that something has happened — query — which corresponds to a question — and request — which corresponds to a request to perform an action.
Star supports this simplified model of speech action with special syntax. A notify is written:
notify A with withdrawn(45.6) on account
This notify means
that the account channel should handle withdrawn(45.6)
or, in the terminology of speech act theory,
Inform agent A that withdrawn(45.6)has occurred.
The notify speech action does not explicitly refer to time. This is because there may be multiple senses in which time must be conveyed: the time of the occurrence, the time of its being noticed, or the time of this speech.
How the listening agent responds to speech actions depends of course on its internal structure. An actor reacts to a notify by means of an event rule:
A = actor{
  balance := 0.0.

  on withdrawn(Am) on account do
    balance := balance-Am
}
The type annotation for A declares that it is an actor that responds to certain speech actions; specifically, it will respond to notify actions on the account channel. When that happens, the event rule simply states that the balance will be decremented by the amount Am that is embedded within thewithdrawn message.
What is not stated here is what happens to the notifier while the responding actor handles the notification. In fact, there are several variants of entity that can respond to speech actions; each has a different way of handling the run-time semantics. However, all agents must obey the following rule:
All speech actions from one entity to another are processed in order.
This pairwise rule covers many situations; but not all. However, we leave that discussion to another document.
</Text>
            <Comments>Informally, each performative can be viewed as a kind of speech action.</Comments>
        </Document>
        <Document ID="74327C7C-18AB-4668-80B0-55033E97B3E7">
            <Title>Missing Speech</Title>
        </Document>
        <Document ID="A984E400-F2A9-4A28-A8B1-989C2083B5F6">
            <Title>Non-sequential Code</Title>
            <Text>Another benefit that perhaps explains some of the modern excitement is that functional programming represents a more tractable route to developing parallel and multi-threaded programs.
A program written in a classic von Neumann style is best understood in terms of instructions to a simple machine. Each successive instruction modifies the state of the machine in some way – such as storing values in cells or printing a result.
The issue with this programming model is that modern machines do not fit the original von Neumann model very well. It is normal now for a single computer to have eight ‘cores’, which permit up to 16 independently executing tasks to execute in parallel. Furthermore, modern graphics processors come with thousands of cores — which do not necessarily have to be processing graphics!
Traditional procedural programming languages have a very difficult time with multi-threaded and parallel programs. Because of the complexity of writing them safely, they must currently be written by ‘programming masters’.</Text>
        </Document>
        <Document ID="6CEBAA12-EC49-4A38-98B6-1C38D20C6359">
            <Title>Request Speech</Title>
            <Text>Query speech actions have an implied intention that the query expression is not intended to modify the state of the listener. The final form of speech action request assumes that the listener should do something.
For example, we can ask an actor to clear all balances that are negative using a request along the lines of:
request C to {
  for B in accounts and B.balance&lt;0 do
    clear(B)
}
Notice that the argument of a request is a whole action. In effect it is a small script. It is possible for the listener to the request to decline to perform this request. This ability (or lack of) to not react to speech actions is a characteristic of the responding actor.</Text>
        </Document>
        <Document ID="355C8964-88C4-40C3-A204-16A8272A9D22">
            <Title>Macro Language</Title>
            <Text>A macro is a program that is used to `replace' some source text with other source text. Except that we do not mean literal string text here. Star's macros operate on abstract syntax terms; i.e., the result of parsing the source text using the operator precedence grammar.
We have already seen some simple examples of macros. There are two kinds of macros in Star: macro rules, like this rule which implements a form of lambda expression:
 
# ?L &gt;\ ?E ==&gt; (L) =&gt; E
 
and code macros. Code macros are simply normal Star functions that are applied to the program rather than to input data.
The macro language is sufficiently powerful to allow arbitrary transformations of source programs. This is important because there are many occasions where the transformations required can involve expression forms and semantics that are unknown to the core Star language.
A good example of this is the built-in query notation used for conditions, queries and so on in Star. The semantics of a condition like:
 
(X,Y) in R1 and (Y,Z) in R2
 
are not based on evaluation but on satisfaction. The condition is satisfied if there are bindings for X, Yand Z that make the predicates true. In particular, it may be that one or more of these variables is completely defined within the condition and is not referenced externally.
The satisfaction semantics has to be implemented by transforming the condition into an equivalent expression that uses evaluation to compute the necessary bindings.</Text>
        </Document>
        <Document ID="26AEF1A4-1C67-42E1-A497-E022B2DEE718">
            <Title>Query Expressions</Title>
            <Text>Star has a built-in query expression notation that allows us to avoid a lot of common recursive forms of definition. For example, the apply function can be written more succinctly using:
apply(f,C) =&gt; cons of { all f(X) where X in C}
the meaning of the expression is equivalent to the recursive definition we saw of apply above.</Text>
        </Document>
        <Document ID="19DE9C04-81CF-42A2-93EF-4D5F2398F4D7">
            <Title>It's verbs as well as nouns</Title>
            <Text>Object oriented languages have a very finely developed sense of the noun. An object is intrinsically a noun; objects reference concrete or abstract things that a programmer is manipulating. The notation of classes, interfaces, inheritance and so on represents a powerful set of concepts for organizing the application’s nouns.
However, just as in spoken languages like English, verbs are also important: what you do with objects is at least as important as the objects themselves. Most OO languages do not treat verbs – a.k.a. methods – with the same respect that they confer on nouns.
The result is that methods are written using a vocabulary that a programmer in the 1970’s would be completely familiar with – even when the same programmer would find classes and interfaces novel concepts.
Functional languages give more weight to the verbs. A function is a first class value and there are many ways in which functions can be combined and abstracted. The result is that the expression of control in a functional language can be subtler and more expressive than is possible in most OO languages. This makes a material difference to the productivity of the programmer and can also make a difference in the readability of the code.</Text>
        </Document>
        <Document ID="56387395-75DC-4D3F-83C1-2A7ABA6F499F">
            <Title>Manuscript Format</Title>
        </Document>
        <Document ID="81FAAC9E-4709-4236-8E28-CD83D3FA708C">
            <Title>All Projects are Team Projects</Title>
            <Text>A key observation about successful software projects is that they involve teams; even if they start out as solo projects, they invariably become team projects. Furthermore, deployment targets will often extend to span a range of devices from smart phones to multi-cluster super computers. Finally, software is rarely completely useful in isolation: integration with other systems if often key to realizing the benefits of a given system. These aspects have continually influenced Star’s design.
Another strong influence on Star was the social context: We assumed that any any given software project would involve many people. This led us to conclude that features such as clear semantics, safety, strong modularization, and in particular multi-paradigm support are essential rather than being optional.
The foundations for safety in a programming language stem from an expressive type system — the more expressive the type system, the less the temptation to escape from it — and from an easy-to-reason-about semantics. These requirements favor primarily functional languages, especially when it comes to reasoning about parallel and distributed programming.
Star is not a pure language in the sense that it permits programs with assignments and stateful objects. This is both because we wish to permit programmers to build in ways that suits their needs and because some algorithms are easier to express using mutable state. However, the language encourages the programmer to program more declaratively. Star enables procedural programming whilst constraining features to avoid some pitfalls of global hidden state.</Text>
        </Document>
        <Document ID="0D615CD6-8C79-4067-B59D-7E2D783AC05C">
            <Title>Purely Functional Programming</Title>
            <Text>The queue-time problem described above puts a severe strain on existing scheduling solutions for semiconductor fabrication.
The scheduler needs to predict whether a given lot that is just about to enter a queue-time zone will make it through the zone in the time allotted for it. Thus, the scheduler needs to ‘see into the future’, or at least make an educated guess as to what the future might be.
To that end, ALPS implements speculative simulation: it simulates the operation of the fab up to the point where the lot in question either successfully completes the queue time zone or has exceeded its time limit to do so. The simulation is speculative in the sense that, once it is completed, the system must return to the present.
#
Speculative Simulation in ALPS 4
Figure 1 shows the basic situation with speculative simulation: Each circle represents a fab state. If the scheduler chooses to conduct a simulation based on a given fab state, it needs to represent the simulated fab states before returning to the original state.
In a traditional system, which stores the fab-state information in a relational database, speculative simulation is prohibitively expensive, as it requires creating a copy of the database upon starting the simulation in order to return to the present.
Star, in contrast, offers high-performance persistent data-structures. To understand what ‘persistent’ means, consider manipulating a data-structure such as a list in a traditional language such as Java:
List&lt;Thing&gt; lis = new List&lt;Thing&gt;();
  lis.add(thing1);
  lis.add(thing2);
  ...
This code fragment first creates an empty list lis and then adds elements to them. Each addition isdestructive in the sense that the state of the list before an addition is no longer present after it: For example, after the addition of thing1, lis has one element, and after the addition thing, it has two elements: The state where lis had one element no longer exists.
Contrast this to Star's cons lists, for example:
let {
  def lis0 is .nil
  def lis1 is cons(thing1, lis0)
  def lis2 is cons(thing2, lis1)
  ...
} in ...
In this example, even though lis2 is built from lis1, lis1 is still present and has one element, while lis2has two. Thus, lis1 persists even after the program has created lis2. Moreover, despite the fact that lis1and lis2 appear to be completely independent objects, they share the memory occupied by lis1.
￼
Star's cons lists are persistent
Figure 2 shows the memory layout of the cons lists from the example, and illustrates the sharing. Thus, it is possible for a program to have two different lists with a million elements each, and have them share the memory for identical portions, and using significantly less memory than would be needed for two completely different lists.
Similarly to cons lists, Star's sets and dictionaries are persistent. Albeit, their implementation is considerably more complicated, involving tree data structures. The exact implementation is not usually important for the Star programmer however: What matters is that modifying a dictionary – which creates a new dictionary and preserves the ‘old’ one – essentially uses storage only to represent the delta between the old and new dictionary.
This way of building up data structures is surprisingly efficient, even though it creates new objects at a high rate: modern JVMs can allocate objects extremely quickly. Furthermore, the long term cost of allocation becomes essentially zero; due to the use of generational garbage collection – when an ‘old’ dictionary is no longer needed, the JVM's garbage collection can reclaim the memory used by it.
Applied to speculative scheduling, this means that a simulation step only needs to store the delta between one fab state to the next.
Although the size of a complete factory state is large, it is not too large for modern multi-gigabyte laptops. As a result, ALPS 4 does not keep the fab state in a relational database, but rather replicates the fab state using Star's native data structures.
This makes speculative scheduling not only feasible, but also natural and easy to implement. In fact, ALPS 4 uses only persistent data structures, and is thus a purely functional program.
Doing this in a purely functional manner has numerous other advantages: In particular, the program becomes immediately amenable to parallelization, as no state mutations need to be coordinated between threads. Moreover, transactional integrity is never a problem with the management of the factory state, as no inconsistent intermediate states are ever globally visible. More specifically, schedulers in ALPS 4 can call other schedulers without having to fear interference.
With speculative simulation in place, addressing the queue-time problem is surprisingly easy: ALPS 4 runs a simulation inside the scheduler, monitoring the lots that are inside a queue-time zone until completion or failure. Once the simulation has determined how many lots about to enter a queue-time zone would fail, it simply delays moving those lots along, thus preventing the queue-time violations predicted by the simulation.
ALPS 4 implements a number of other optimizations to further address the queue-time problem: For instance, it records the progress of the lots in a queue-time zone during the simulation, and ensures that the lots make similar progress in actual fabrication: If a lot falls behind the recorded trace – and is thus likely to fail completing the queue-time zone on time – ALPS 4 will speed its processing until it again matches the predicted schedule.


</Text>
        </Document>
        <Document ID="0A7F9529-5F7D-473A-9AF3-3D55AD6848E0">
            <Title>Ebook</Title>
        </Document>
        <Document ID="8CC0CD50-63EF-45B0-AF5F-F5E1DB9AB30D">
            <Title>Copyright</Title>
            <Text>
















Copyright © &lt;$year&gt; &lt;$author&gt;
All rights reserved.
ISBN:
ISBN-13:
</Text>
            <Notes>Feel free to delete this document if you don’t need it, or edit it for your needs.</Notes>
        </Document>
        <Document ID="1CEB916D-6B78-461D-834D-5AAC7E58D9F0">
            <Title>Higher-order Functions</Title>
            <Text>Star supports higher-order functions. The following apply function corresponds to the familiar map function from other functional languages.
apply:all s,t ~~ ((s)=&gt;t,cons[s])=&gt;cons[t].
apply(f, nil) =&gt; nil.
apply(f, cons(x, xs)) =&gt;
      cons(f(x), apply(f, xs)).
Although Star has a sophisticated type system that supports automatic type inference, we strongly recommend that programmers supply type annotations, which often improve readability. Here the type annotation for apply:
apply:all s,t ~~ ((s)=&gt;t,cons[s])=&gt;cons[t].
states that apply is a generic function – in two types – that takes a function and a cons list and returns a new cons list.
Without the explicit type annotation, the Star compiler could actually infer a different type for applythat may not meet the programmer's intentions.</Text>
        </Document>
        <Document ID="541A3B09-1410-481D-BBBD-A13834988EEC">
            <Title>Endnotes</Title>
            <Text>&lt;$--ENDNOTES--&gt;</Text>
            <Notes>The &lt;$--ENDNOTES--&gt; tag will be replaced by the footnotes during Compile. Using this tag allows us to have the footnotes inserted wherever we like, without having a separator placed above them.</Notes>
        </Document>
        <Document ID="A52CD2C7-FDCF-4FFF-843E-ACB7908C6244">
            <Title>Validation</Title>
            <Text>If you actually try to run this program you will get an error along the lines of:
`!(john, (parent, sam))' not a valid statement
In general, new syntax elements that a DSL author adds to Star are not already valid expressions in the language. To help with this, Star also has a tool for extending Star's concept of valid forms. In this case, we need to tell the compiler that the graph expression is a special kind of expression that has triples in it. We can do that with the two rules:
#graph{?B} :: expression :- B;*triple

#?S ! ?P $ ?O :: triple
These rules declare that graph expressions are expressions.16 provided that they contain only triples.
Together, these validation rules, the operator declarations, and the macro rules allow Star to process a new form of expression.
The complete package to implement this tiny DSL is just a few lines:
miniN3 is package{
  #right((!),500)
  #right(($),450)

  type n3Graph is n3Graph(list of triple)

  type triple is triple(concept,concept,concept)

  type concept is concept(string)

  #graph{?B} :: expression :- B;*triple

  #?S ! ?P $ ?O :: triple

  #graph{?B} ==&gt; n3Graph(list of { B }) ## {
    # ?S ! ?P $ ?O ==&gt; triple(concept(S),concept(P),concept(O))
    #concept(identifier?I) ==&gt; concept($$I)
  }
}
We can use this DSL simply by importing the package in our code:
worksheet{
  import miniN3
  def G is graph{
    john ! parent $ sam
    sam ! parent $ joe
  }
  show G
}
which results in:
n3Graph(list of [
  triple(concept("sam"), concept("parent"), concept("joe")),
  triple(concept("john"), concept("parent"), concept("sam"))
])
being displayed.
However, the DSL author's task is not yet complete: she must also provide ways of interpreting and using the resulting n3Graph expressions. But that is a task for another day.
</Text>
        </Document>
        <Document ID="2A3096C2-2857-4A9F-BD1D-04D123A179F1">
            <Title>Texture</Title>
            <Text>All programming languages can be said to have a particular style or texture. This is often so strong that it only needs a single line of source code to be able to identify a programming language. In the case of Star, this line might be (we explain what it means a bit later on):
factorial:all t ~~ arith[t] |: (t)=&gt;t.
Overall, the texture of Star is designed to enhance the readability of programs. Readability is important because many people have to be able to read programs; perhaps more than are involved in writing them. Even with an emphasis on readability, the power of the language is such that Star programs tend to be shorter than their equivalents written in languages like Java.
On the other hand, Star is not COBOL! Some symbols have an almost universally consistent meaning and Star uses them where it is appropriate.
To convey a sense of what Star programs look like we start with some simple examples. Here is a simple Star function definition with (hopefully) obvious semantics:
doubleMe:(integer)=&gt;integer.
doubleMe(x) =&gt; x + x.
Although not mandatory, in most cases we strongly favor a programming style where the type of functions and other top-level definitions are called out explicitly. Here is another function calling the just-defined doubleMe:
doubleUs:(integer,integer)=&gt;integer.
doubleUs(x, y) =&gt; doubleMe(x) + doubleMe(y).
A complete Star program that uses these functions to print a result is:
sample.first{
  doubleMe:(integer)=&gt;integer.
  doubleMe(x) =&gt; x + x.

  doubleUs:(integer,integer)=&gt;integer.
  doubleUs(x, y) =&gt; doubleMe(x) + doubleMe(y).

  main:()=&gt;().
  main() do {
    logMsg(info,"double trouble is \(doubleUs(3,4))")
  }
}
Function definitions can use multiple clauses, pattern matching, and guards:
lucky:(integer)=&gt;string.
lucky(7) =&gt; "LUCKY NUMBER SEVEN!".
lucky(x) default =&gt; "Sorry, you’re out of luck, pal!"

factorial:(integer)=&gt;integer.
factorial(0) =&gt; 1.
factorial(n) where n &gt; 0 =&gt; n * factorial(n-1)
In fact, this last function is not fully paradigmatic of Star. A better, albeit more complex, version of this would be:
factorial:all t ~~ arith[t] |: (t)=&gt;t.
factorial(zero) =&gt; one.
factorial(n) where n &gt; zero =&gt; n * factorial(n-one)
This version of factorial will work with integers, floats anything that can do arithmetic.</Text>
        </Document>
        <Document ID="5D5167CC-1EB7-402F-BA83-0A5A174665F8">
            <Title>Manuscript Format</Title>
        </Document>
        <Document ID="EAE54815-00B1-47BB-A3F4-BB401EE1A887">
            <Title>Pattern Matching</Title>
            <Text>Patterns and pattern matching are ubiquitous in Star. Nearly all literal forms have a pattern equivalent that allows matching and, most importantly, de-structuring such values.
For example, we can define functions over collections that allow us to (say) compute the maximum element in a collection:
maximum:all t ~~ arith[t] |: (list[t],t)=&gt;t.
maximum([H,..T]) =&gt; let{
  max([],Mx) =&gt; Mx.
  max([F,..R],Mx) where F&gt;Mx =&gt; max(R,F).
  max([_,..R],Mx) default =&gt; max(R,Mx).
} in max(T,H)
The max function enclosed in the let body uses patterns to match against the successive elements of the collection. It is important to note that the max and the maximum functions will work over any kind of collection.
The pattern form:
[H,..T]
matches any non-empty sequence; and binds the first element of the sequence to the variable H and the remainder of the sequence to T.
The pattern form:
[]
only matches an empty collection.
The maximum function is written in terms of a local function – max – and a call to that local function. The let expression is one of the foundations and cornerstones of functional programming.</Text>
        </Document>
        <Document ID="39437858-1B0A-46E3-8374-F91A904D849B">
            <Title>Requirements Change, Features Evolve</Title>
            <Text>One particular scenario played out several times: we developed some high-level but specific feature that was designed to meet a particular goal; but, in order to address a slightly different goal we were forced to evolve to a simpler but more general form.
For example, initially Star had a high-level concurrency model to allow multiple agents to process events with some degree of parallelism. This model was elegant and had an intuitive semantics, but did not fit certain kinds of applications that we also wanted to be able to support. At this point we had a choice: to develop additional forms of concurrency to address the new requirements or to modify the original.
We chose to refactor the concurrency model with a more general one. The main reason being that we could not be certain that other variants of concurrency would also be important in the future.
This refactor also had the side-effect of making the concurrency framework lower-level. This process of replacing specific but high-level features with more general but lower-level ones occurred several times: for concurrency, relational data structures and the rules formalism itself.
It was partly in response to this that we invested effort in making the Star language extensible via an extensible grammar and macros. In effect, we adopted a domain-specific language methodology for the design of Star itself. Using these extensibility facilities means that we are often able to present high-level features while basing them on more general more low-level capabilities.</Text>
        </Document>
        <Document ID="3AB586C5-F272-4F48-980D-1943CD96BC02">
            <Title>Paperback</Title>
        </Document>
    </Documents>
</SearchIndexes>