{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
\f3\fnil\fcharset0 Georgia;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 The concept of a contract is fundamental to good software engineering. This is because it allows separation between the 
\i specification
\i0  of a concept and its 
\i implementation
\i0 .\
A Star 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 contract
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  takes the form of a description of a set of functions and values - in effect a type. For example, the contract for basic arithmetic is
\f3\fs24 \cf2 \expnd0\expndtw0\kerning0
\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1 \cf2 <$Scr_Ps::0>
\f2 contract all t ~~ arith[t] ::= \{\
    (+) : (t,t)=>t.\
    (-) : (t,t)=>t.\
    (*) : (t,t)=>t.\
    (/) : (t,t)=>t.\
    one : t.\
    zero : t.\
\}\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1 \cf0 \kerning1\expnd0\expndtw0 <!$Scr_Ps::0>
\f0\fs26 This has the effect of declaring a group of functions that work together to form a basic arithmetic.\
Once defined, a contract can be used simply by mentioning one of its members. Thus, in Star, all arithmetic depends on the 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 arith
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  contract:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<$Scr_Ps::0>
\f2 fact(0) => 1.\
fact(X) => X*fact(X-1)\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1 \cf0 \kerning1\expnd0\expndtw0 <!$Scr_Ps::0>
\f0\fs26 Furthermore, if we want to state that the type of a variable is `something' that implements a contract we can do so by adding a constraint to the variable's type:
\f3\fs24 \cf2 \expnd0\expndtw0\kerning0
\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1 \cf2 <$Scr_Ps::0>
\f2 F : arith[t] |: t\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1 \cf0 \kerning1\expnd0\expndtw0 <!$Scr_Ps::0>
\f0\fs26 This has the effect to declaring that 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 F
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26 's type is a type variable \'97 but one that is constrained such that whatever concrete type it eventually gets, it must be one that is defined for 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 arith
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26 .{\field{\*\fldinst{HYPERLINK "applewebdata://148FDBFF-73E9-4528-99C1-D8FDEC92DDB7/Text/footnotes.xhtml#fn12"}}{\fldrslt 12}}\
In fact, however, this version of factorial is not the most 
\i paradigmatic
\i0  (sic) version. The reason is that the type signature for 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 fact
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  is not generic but tied to 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 integer
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26 :\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<$Scr_Ps::0>
\f2 fact
\f1 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 :
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f2 (integer)=>integer\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1 \cf0 \kerning1\expnd0\expndtw0 <!$Scr_Ps::0>
\f0\fs26 The reason that 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 fact
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  is not fully generic is interesting: it\'92s the presence of the literal numbers 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 0
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  and 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 1
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  in the program. The type of any literal integer is 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 integer
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26 ! This is enough to force the type of 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 fact
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  to be restricted to integers.  In particular, Star does not support implicit coercion, including coercion of literal numbers from integer to any other type.\
The solution is simple, if a little strange: we declared in the arith contract two non-function entries: 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 zero
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  and 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 one
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26 .  By explicitly identifying zero and one as elements of the 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 arith
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  contract we can use them in lieu of 0 and 1 respectively without committing to {\field{\*\fldinst{HYPERLINK "scrivcmt://307C2271-8192-4486-A373-A2E375F125E8"}}{\fldrslt integers.}} \
Using these, we can write a much more paradigmatic version of the factorial function:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<$Scr_Ps::0>
\f2 factorial(zero) => one.\
factorial(N) => factorial(N-one)*N.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1 \cf0 \kerning1\expnd0\expndtw0 <!$Scr_Ps::0>
\f0\i\fs26 This
\i0  function is quite generic, and its type signature is given by:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<$Scr_Ps::0>
\f2 factorial: all t ~~ arith[t] |: {\field{\*\fldinst{HYPERLINK "scrivcmt://57E7F6C4-B124-4AF1-BC0C-16D60EF9490A"}}{\fldrslt (t)=>t.
\f1 <!$Scr_Ps::0>}}}