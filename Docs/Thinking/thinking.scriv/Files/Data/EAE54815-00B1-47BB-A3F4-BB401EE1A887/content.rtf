{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
\f3\fnil\fcharset0 Georgia;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 Patterns and pattern matching are ubiquitous in Star. Nearly all literal forms have a pattern equivalent that allows matching and, most importantly, de-structuring such values.\
For example, we can define functions over collections that allow us to (say) compute the maximum element in a collection:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<$Scr_Ps::0>
\f2 maximum:all t ~~ arith[t] |: (list[t],t)=>t.\
maximum([H,..T]) => let\{\
  max([],Mx) => Mx.\
  max([F,..R],Mx) where F>Mx => max(R,F).\
  max([_,..R],Mx) default => max(R,Mx).\
\} in max(T,H)\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1 \cf0 \kerning1\expnd0\expndtw0 <!$Scr_Ps::0>
\f0\fs26 The 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 max
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  function enclosed in the let body uses patterns to match against the successive elements of the collection. It is important to note that the max and the maximum functions will work over any kind of collection.\
The pattern form:
\f3\fs24 \cf2 \expnd0\expndtw0\kerning0
\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1 \cf2 <$Scr_Ps::0>
\f2 [H,..T]\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1 \cf0 \kerning1\expnd0\expndtw0 <!$Scr_Ps::0>
\f0\fs26 matches any non-empty sequence; and binds the first element of the sequence to the variable 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 H
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  and the remainder of the sequence to 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 T
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26 .\
The pattern form:
\f3\fs24 \cf2 \expnd0\expndtw0\kerning0
\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1 \cf2 <$Scr_Ps::0>
\f2 []\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1 \cf0 \kerning1\expnd0\expndtw0 <!$Scr_Ps::0>
\f0\fs26 only matches an empty collection.\
The 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 maximum
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  function is written in terms of a local function \'96 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 max
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  \'96 and a call to that local function. The 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 let
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  expression is one of the foundations and cornerstones of functional programming.}