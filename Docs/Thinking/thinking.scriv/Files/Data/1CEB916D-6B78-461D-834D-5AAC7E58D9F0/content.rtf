{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
\f3\fnil\fcharset0 Georgia;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 Star supports higher-order functions. The following apply function corresponds to the familiar map function from other functional languages.\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<$Scr_Ps::0>
\f2 apply:all s,t ~~ ((s)=>t,cons[s])=>cons[t].\
apply(f, nil) => nil.\
apply(f, cons(x, xs)) =>\
      cons(f(x), apply(f, xs)).\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1 \cf0 \kerning1\expnd0\expndtw0 <!$Scr_Ps::0>
\f0\fs26 Although Star has a sophisticated type system that supports automatic type inference, we strongly recommend that programmers supply type annotations, which often improve readability. Here the type annotation for apply:
\f3\fs24 \cf2 \expnd0\expndtw0\kerning0
\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1 \cf2 <$Scr_Ps::0>
\f2 apply:all s,t ~~ ((s)=>t,cons[s])=>cons[t].\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1 \cf0 \kerning1\expnd0\expndtw0 <!$Scr_Ps::0>
\f0\fs26 states that 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 apply
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  is a generic function \'96 in two types \'96 that takes a function and a cons list and returns a new cons list.\
Without the explicit type annotation, the Star compiler could actually infer a different type for applythat may not meet the programmer's intentions.}