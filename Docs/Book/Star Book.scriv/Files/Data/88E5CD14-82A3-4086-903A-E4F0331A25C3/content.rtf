{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 The wait for operator takes a rendezvous and yields a task that waits for the event described by the rendezvous to happen. So, for example:\
wait for timeoutRv(2000)\
is a task that, when performed, does nothing for 2 seconds, and yields the () value.\
Note that wait for returns a task - it does not execute it. To actually wait for an event, the task must be performed. Typically, within a task block, it is used like so:\
task \{\
  ...\
  perform wait for timeoutRv(2000)\
  ...\
\}\
There are quite a few pieces here: the timeoutRv event itself, the wait for task function and the performance of the task itself.\
This separation into distinct phases helps in flexibility of the concurrency features but, of course, can make straightforward scenarios complex to construct. We shall see below that there is a library of concurrency features that are quite high-level and may be more appropriate than \'91rolling your own\'92 setup.}