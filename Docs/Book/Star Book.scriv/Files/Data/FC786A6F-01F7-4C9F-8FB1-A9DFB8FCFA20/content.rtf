{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 In many cases the requirement for synchronization between tasks is based on needing reliable communication between them. Instead of building communication on top of a model of \'91shared resources\'92, we use direct \'91message passing\'92: one task sends a message to another. The mechanism we use is called the channel.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\b \cf2 Channel\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\b0 \cf2 A channel is a means by which two (or more) tasks can pass data in a type-safe way between themselves.\
Channels are 
\i synchronous
\i0 : in order for data to be passed between tasks they must both be paused. There are rendezvous associated with receiving messages from a channel and for placing messages on a channel \'97 actual communication only occurs when both the sender and the receiver have waited for the event to occur.\
One might ask \'91why is communication synchronous?\'92 Why not asynchronous? The basic answer is that synchronous communication seems to be more basic than asynchronous communication.\
It is straightforward to implement a more asynchronous communication pattern based on synchronous primitives. It is harder to do the converse: to implement synchronous communication using asynchronous primitives.\
However, it is also true that synchronous communication is essentially impossible when that communication involves multiple computers. The concurrency features in 
\b Star
\b0  support multiple threads of activity within a single application but do not directly support networked applications. We believe that, for other reasons, such networked applications are better served with different features \'97 features that directly address issues involving agenthood. We shall see some of these in our treatment of [Concurrent Actors][concurrent-actors].\
The channel function creates such a synchronous channel:\
channel:for all t ~~ () => channel[t]\
There are two rendezvous operators for sending and for receiving data on a channel:\
sendRv:for all t ~~\
  (channel[t], t) => rendezvous of ()\
recvRv:for all t ~~\
  (channel[t]) => rendezvous of t\
Notice that the sendRV operator returns a void-valued rendezvous; whereas the recvRv operator returns a rendezvous with a value.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\i \cf2 Type safety
\i0  is ensured by the type carried by the channel value: the sender and receiver of a channel must also agree on the type of the data being communicated. Channels have no fixed concept of direction. A task can send a message over a channel in one step, and receive a message over the same channel in the next.\
Here is a simple scenario involving a transmission over a channel:\
def ch is channel()\
ignore background task \{\
  def msg is valof (wait for recRv(ch))\
\}\
ignore background task \{\
  perform wait for sendRv(ch,15)\
\}\
The communication occurs when both backgrounded tasks reach their appropriate rendezvous: one is waiting for the message to arrive and the other waiting to be able to send it.\
In our message passing sequence, we actually do 
\i not
\i0  want the task arguments to complete in a sequential order \'97 so ignoreing (sic) the task is the appropriate command.}