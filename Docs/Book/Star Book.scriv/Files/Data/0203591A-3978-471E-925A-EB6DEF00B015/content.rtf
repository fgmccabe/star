{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
The function _set_indexed is used to add an element to a collection associating it with a particular index position; and the function delete_indexed removes an identified element from the collection.\
Both of these functions have a property often seen in functional programming languages and not often seen elsewhere: they are defined to return a complete new collection rather than simply side-effecting the collection. This is inline with an emphasis on _persistent data structures_
\f1\fs24 \{\\Scrv_fn=
\f0\fs26 A 
\i \cf2 persistent
\i0 \cf2  structure is one which is never modified.
\f1\fs24 \\end_Scrv_fn\}
\f0\fs26  and on 
\i \cf2 declarative programming
\i0 \cf2 .\
One might believe that this is a bit wasteful and expensive \'97 returning new collections instead of side-effecting the collection. However, that is something of a misconception: modern functional data structures have excellent computational properties and approach the best side-effecting structures in efficiency. At the same time, persistent data structures have many advantages \'97 including substantially better correctness properties and behavior in parallel execution contexts.\
It should also be stressed that the indexable contract allows and encourages persistence but does not 
\i \cf2 enforce
\i0 \cf2  it. It is quite possible to implement indexing for data structures that are not persistent.}