{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
The function _set_indexed is used to add an element to a collection associating it with a particular index position; and the function delete_indexed removes an identified element from the collection.\
Both of these functions have a property often seen in functional programming languages and not often seen elsewhere: they are defined to return a complete new collection rather than simply side-effecting the collection. This is inline with an emphasis on 
\i persistent data {\field{\*\fldinst{HYPERLINK "scrivcmt://D7B1E737-79DA-4764-8B93-CDB01F6EABB4"}}{\fldrslt structures}}
\i0  and on 
\i declarative programming
\i0 .\
One might believe that this is a bit wasteful and expensive \'97 returning new collections instead of side-effecting the collection. However, that is something of a misconception: modern functional data structures have excellent computational properties and approach the best side-effecting structures in efficiency. At the same time, persistent data structures have many advantages \'97 including substantially better correctness properties and behavior in parallel execution contexts.\
It should also be stressed that the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::0>
\f2\fs22 indexable
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::0>
\f0\fs26  contract allows and encourages persistence but does not 
\i enforce
\i0  it. It is quite possible to implement indexing for data structures that are not persistent.}