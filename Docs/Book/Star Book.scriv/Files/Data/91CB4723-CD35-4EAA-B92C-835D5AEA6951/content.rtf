{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 So far we have discussed what talkative agents say to each other but not on how they are built. The simplest structure that responds to this is the actor. Actors are lightweight entities that can respond to speech actions. For example, this actor models some aspects of a bank:\
agentBank is actor\{\
  private var accts := dictionary of []\
  fun balance(N) where accts[N] matches Ac is Ac.balance()\
  prc transfer(F,T,Amt) do\{\
    def Fr is accts[F]\
    def To is accts[T]\
    Fr.debit(Amt)\
    To.credit(Amt)\
  \}\
\}\
The public elements of the actor determine the kinds of speech actions it can respond to. This actor can respond to a balance query:\
query agentBank with balance("fred")\
and can also respond to a request to transfer some money between two of its accounts:\
request agentBank to transfer("fred","tom",100.0)\
If we wanted our bank to be able to respond to events, such as check posting events then we need to add an occurrence handler for them. Occurrence handlers take the form of an on...do rule, such as:\
on deposit(Nm,Amnt) on cashier do\
  accts[Nm].debit(Amnt)\
There are three parts to an on...do rule: the 
\i pattern
\i0  that denotes the kind of events this rule will respond to, a 
\i channel
\i0  identifier and an 
\i action
\i0  that is performed when a suitable event is received. The complete rule is effectively a program that has type: occurrence of 
\i type
\i0 ; or in the case of this rule:\
cashier:occurrence of moneyTransaction\
assuming that deposit was a constructor in the type:\
type moneyTransaction is\
  deposit(string,float) or\
  withdraw(string,float)\
Multiple rules for the same channel may be present, and if two or more rules fire for a given occurrence then they all will be executed \'96 although the relative order of performing the rules is 
\i not
\i0  defined. This multiple rule firing is useful at times; for example it makes it easier to implement over-arching processing as well as specific processing:\
on Tx on cashier do\
  logMsg(info,"Transaction $Tx")\
on deposit(Nm,Amnt) on cashier do\
  accts[Nm].debit(Amnt)\
In this case two actions will take place when a deposit is received: it will be logged and the appropriate account will be debited.\
If two occurrence rules fire for a given notify the order of their firing is not defined: it may be either order. Therefore, you should make sure that occurrence rules that overlap should not overlap in their actions.\
Actors have a type of the form actor of 
\i recordType
\i0 ; where 
\i recordType
\i0  is the actor\'92s API. For example, if we include our occurrence processing rules in our agentBank; then its type will be:\
agentBank:actor of \{\
  balance:(string)=>float\
  transfer:(string,string)=>()\
  cashier:occurrence of moneyTransaction\
\}\
One common technique when programming with actors is to use functions that generate actors. One is likely to need only a single bank actor in a system, but one may well need multiple client actors.}