{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
A critical aspect of human communication is the vocabulary employed \'96 more formally the 
\i ontology
\i0  being referenced. The natural analog of this in software systems is the Application Programming Interface (API). An API specifies which functions you may invoke, what their types are and what the expected results of invoking the functions should be.\
The major semantic difference between an API and an Ontology is that the latter can often convey more semantics. For example, it is possible, in an ontology but not in a typical API, to express the fact that a function called plus adds its numbers {\field{\*\fldinst{HYPERLINK "scrivcmt://7412559C-13D8-4106-8F35-CBCD8652FDFB"}}{\fldrslt together.}}\
As it happens, 
\b \cf2 Star
\b0 \cf2  has a natural way of expressing a complete API \'96 by using the 
\i record type
\i0 . For example, the record type defined with the type alias:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 myAPI <~ \{\
  products:list[(string,string)].\
  quantity:(string)=>integer\
\}\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 can be viewed as the specification of an API. We are not limited to exposing functions in APIs: we can expose literal values, variables and even types.\
Having a type that can represent an entire API also allows us to be careful about distinguishing the API from 
\i access
\i0  to the API. We determine access to an API by computing a value whose type is the API \'96 for example by having a variable of the right type:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 A:myAPI\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 Here the API is determined by the myAPI type; access to it is mediated via the variable A. We access the API by accessing A, as in:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 show list of \{ all y where\
    (y,"1in-washer") in A.products and\
    A.quantity(y)>20 \}\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 While perfectly serviceable, there are some substantial issues with this approach to accessing APIs. For example, we have this A variable showing up everywhere; and it is hard \'96 at first glance \'96 to see how this style of API can help us with building distributed systems.}