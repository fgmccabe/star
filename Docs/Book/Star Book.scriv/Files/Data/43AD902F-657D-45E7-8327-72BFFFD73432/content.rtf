{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 A 
\i catalog
\i0  is a mapping from identifiers to package URIs; i.e., it is the missing link between package identifiers and package URIs. Catalogs are sometimes written explicitly \'97 in the form of a file that you can place in the same directory as your source files \'97 but usually the compiler makes an automatic catalog depending on where the source code of a package is actually located.\
Like other features, the catalog system is under-pinned by a contract \'96 in this case, the contract is used by the compiler to access the source URIs. \
The catalog contract looks like:\
contract catalog ::= \{\
  defltVersion: version.\
  catalogEntry:(string)=>uri.\
\}\
Having the catalog be driven by a contract allows for multiple potential implementations. One standard implementation is via JSON files.\
A sample JSON catalog file looks like:\
\{\
  "content": \{\
    "sample.factorial": "factorial.star"\
  \},\
  "fallback" : "../Star/catalog",\
  "version": "2.3.1"\
\}\
Other implementations of catalogs are possible; one of the other standard catalog structures automatically populates a catalog based on the contents of a directory.\
For most projects you will not need to be very aware of code repositories, catalogs and so on. However, the code product architecture is an important part of 
\b Star
\b0 \'92s strategy for helping you building all scales of system. }