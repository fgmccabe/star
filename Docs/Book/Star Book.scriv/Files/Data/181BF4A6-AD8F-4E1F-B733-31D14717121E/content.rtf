{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\b\fs26 \cf2 \expnd0\expndtw0\kerning0
Star
\b0 \cf2  is a multi-paradigm high-level 
\i symbolic
\i0  language. It is designed to be scalable, readable, accurate, high performing and extensible.\
Paradoxically, scalability in a programming language is always about large and small chunks of code. Scalability in 
\b \cf2 Star
\b0 \cf2  is fostered by a range of elements that facilitate composition, change and re-use:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl264\slmult1\pardirnatural\partightenfactor0
\ls1\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
The language is strongly statically typed. This encourages both safety and documentation.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
The type system is strong enough that there is very limited need to escape the type system. For example, modules can be given a first-class type semantics. This is important because it facilitates programmatic manipulation of modules in a safe manner.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}Programs are defined in terms of rules; for example, \expnd0\expndtw0\kerning0
functions are defined in terms of equations. Apart from being more readable, rules are also a natural unit of change in an evolving system.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
A meta-language based on logical annotations makes it possible to build meaningfully connected documentation and facilitates processes such as code re-use, issue tracking, and code lifetime management.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
The package system is intrinsically versioned and abstracted away from any underlying storage system.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0
\cf2 The syntax of 
\b \cf2 Star
\b0 \cf2  is oriented towards readability rather than strict conciseness. The reason for this is that the programmer is only one of the stake holders in a given program. A readable program is one that is more easily trusted by non-programmers.\
Experience also suggests that readability enhances programmer productivity also: much of team-based development involves comprehending and modifying other programmers\'92 code.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\b \cf2 Star
\b0 \cf2  is a strongly, statically typed language. The purpose of a strong type system is to facilitate the communication of intent of the programmer. The purpose of static typing is to ensure that the compiler can rapidly \'91fail\'92 incorrect programs without requiring the program to be run. Furthermore, static type checking minimizes any run-time penalty for imposing type constraints.\
Although 
\b \cf2 Star
\b0 \cf2  is strongly typed, it uses 
\i type inference
\i0  to eliminate much of the clutter that some type systems impose on the programmer \'96 which itself is a productivity sink of course.\
Generally, the 
\i stronger
\i0  the type system, the more the language system can detect errors before programs are run. In addition, the more 
\i expressive
\i0  the type system is, the less the temptation to try to subvert or bypass the type system.\
However, even though it is technically feasible to completely eliminate type declarations of functions; doing so is in conflict with some of the other goals behind 
\b \cf2 Star
\b0 \cf2 . For example, type declarations act as a form of documentation; and when there is a type error in your program, having 
\i no
\i0  explicit type declarations can make tracking the culprit of the error very difficult. So all top-level variable definitions (typically functions) are required in 
\b \cf2 Star
\b0 \cf2  to have explicit type {\field{\*\fldinst{HYPERLINK "scrivcmt://9DA9499E-E6BF-4723-879D-82C3628DA438"}}{\fldrslt 
\i \cf2 annotations
\i0 .}}\

\b \cf2 Star
\b0 \cf2  has a range of features that make exploiting parallelism easier to manage. For example, it has support for 
\i computation expressions
\i0  and 
\i actors
\i0 . Partitioning an application into different 
\i agents
\i0  allows programming to follow a more human approach. Computation expressions allow the programmer to manipulate computations as easily as they do data values; that in turns greatly eases the development of parallel and concurrent applications.\
There is no one technology that can solve all problems. This is as true for programming as for other domains. 
\b \cf2 Star
\b0 \cf2  supports a range of programming paradigms that allows the developer to \'91use the best tool for the job\'92. However, we go beyond this \'91swiss army knife\'92 stance and make it straightforward to extend the language.\
Virtually every non-trivial program can be factored into a combination of general purpose mechanism and specific policy for applying the mechanism. 
\b \cf2 Star
\b0 \cf2  has powerful self-extension features that allow programmers to design their own policy structures (a.k.a. domain specific languages).\
Many of 
\b \cf2 Star
\b0 \cf2 \'92s own features \'96 such as its query notation and its actor notation \'96 are built using these extension mechanisms.}