{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\
The sequence notation also allows for the specification of partial sequences; this is particularly useful in writing functions that construct and traverse sequences. The sequence term:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 [1,2,..X]\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 denotes the sequence whose first two elements are 1 and 2 and whose remainder is denoted by the variable X \'97 which must also be a sequence of the correct type. Similarly, the term:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 [F..,23]\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 denotes the sequence obtained by gluing 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 23
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  to the back of the sequence 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 F
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26 .\
There is a strong relationship between the normal sequence notation and the partial sequence notation. In particular, the sequence expression\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 cons of [1,2]\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 is equivalent to:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 cons of [1,..cons of [2,..cons of []]]\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 However, we are not permitted to use both of 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 ,..
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  and 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 ..,
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  in the same expression:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 [F..,2,3,..B]\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 is not permitted (since it amounts to a concatenation of two sequences which implies a non-deterministic decomposition when used as a pattern).\
The major benefit of general sequence notation is that it allows us to construct programs involving collections that are independent of type 
\i and
\i0  to do so in a syntax which is concise: the only constraint is the sequence contract.\
For example, we can use sequence notation to write functions over sequences; such as the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 concat
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  function that concatenates two sequences:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 concat:all c,e ~~ sequence[c->>e] |: (c,c)=>c.\
concat([],X) => X.\
concat([E,..X],Y) => [E,..concat(X,Y)].\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 This function will work equally well with 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 cons
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  lists, lists, strings, even your own collection types. All that is required is that there is an implementation of the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 sequence
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  contract for the actual type being concatenated.}