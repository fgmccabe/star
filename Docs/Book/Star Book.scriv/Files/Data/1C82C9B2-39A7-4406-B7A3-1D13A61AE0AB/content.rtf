{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
Like other values, tasks are first class: they can be assigned to variables, kept in data structures, passed to and from functions and so forth. This flexibility leads to great expressive power \'97 many patterns of computations can be readily encoded as task-valued functions.\
For example, consider the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 mp
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  function \'97 which is a facsimile of the standard 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 fmap
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  function specialized for list values:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 mp:all s,t ~~ ((s)=>t,list[s])=>list[t].\
mp(F,[]) => [].\
mp(F,[X,..Y]) => [F(X),..mp(Y)].\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 In this mp {\field{\*\fldinst{HYPERLINK "scrivcmt://66BE424B-3860-42B6-B734-754D500EB0C9"}}{\fldrslt function,}} the functional variable 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 F
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  denotes the computation to be applied to each element of the input list. Suppose that each computation of 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 F
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  were non-trivial, and we wanted to spread the load across multiple cores \'97 i.e., to perform the map operations in parallel. The task notation, in particular background tasks will help us to achieve that.\
Recall that 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 fmap
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  is a standard 
\b \cf2 Star
\b0 \cf2  function that is defined in the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 functor
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  contract and is implemented for many different collection types.\
We will first of all transform mp to use tasks rather than simply calling the function:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 taskmap:all s,t ~~ ((s)=>t,list[s])=>list[t].\
taskmap(F,[]) => [].\
taskmap(F,[X,..Y]) => [valof task\{ valis F(X) \} ,.. taskmap(F,Y)].\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 As it stands, this function has very similar performance characteristics to 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 mp
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26 ; except that we are using the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 task
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  expression notation. In order to run the different elements in parallel we need to also use the background operator:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 parmap1:all s,t ~~ ((s)=>t,list[s])=>list[t].\
parmap1(F,[]) => [].\
parmap1(F,[X,..Y]) => [valof background task\{valis F(X)\} ,.. parmap1(F,Y)].\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 This program computes each element of the result in a separate background task. However, it is not a true parallel 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 fmap
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  because we wait for each element before continuing to the next element.\
A better approach is to first of all construct a list of tasks and then to separately collect their values in a second phase:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 parmap2:all s,t ~~ ((s)=>t,list[s])=>list[t].\
parmap2(F,L) => let\{\
  spread:(list[s])=>list[task[t]].\
  spread([]) => [].\
  spread([X,..Y]) => [background task\{ valis F(X)\} ,.. spread(Y)].\
\
  collect:(list[task[t]])=>list[t].\
  collect([]) => [].\
  collect([T,..Ts]) => [valof T,..collect(Ts)].\
\} in collect(spread(L))\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 This function does not wait for any task to complete until they have all been spun out into background activities. This gives the maximum opportunity for the independent tasks to complete before we actually need their values.\
A good rule of thumb is:\
\pard\tx720\tx1080\tx1440\li720\sl264\slmult1\sb240\sa240\pardirnatural\partightenfactor0

\f1\fs24 \cf2 <$Scr_Ps::1>
\f0 when you are programming with tasks, everything that is not a completely task-less subcomputation should be enclosed in task brackets.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1 \cf2 <!$Scr_Ps::1>
\f0\fs26 So, a more idiomatic way of writing the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 parmap
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  function is to make it a 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 task
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  valued function; we also generalize away from the specific list collection type and use the standard 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 fmap
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  function to allow for any collection type:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 parmap:all s,t,c/1 ~~ functor[c] |: ((s)=>t,c[s])=>task[c[t]].\
parmap(F,L) => let\{\
  spread:()=>list[task[t]].\
  spread() => map((X)=>background task\{valis F(X)\},L).\
  collect:(list[task[t]])=>list[t].\
  collect(Lt) is fmap((T)=>valof T,Lt).\
\} in task\{\
  valis collect(spread())\
\}
\f1\fs24 <!$Scr_Ps::0>}