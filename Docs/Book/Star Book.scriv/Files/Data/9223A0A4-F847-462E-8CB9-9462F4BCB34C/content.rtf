{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\b\fs26 \cf2 \expnd0\expndtw0\kerning0
Star
\b0  does not support automatic type casting, as found in languages like Java and C/C++. This is for many reasons, not the least of which is safety and predictability of code.\
Casting in many languages is really two kinds of operations-in-one which we can refer to as 
\i \cf2 casting
\i0 \cf2  and 
\i \cf2 coercion
\i0 \cf2 . Casting is mapping of a value from one type to another without changing the value itself; and coercion involves converting a value from one type to another.\
For example, the Java cast expression:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 (Person)X\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 amounts to a request to verify that X is actually a Person object. In particular, this only checks the value of X to see if it is a Person. On the other hand, casting an integer to a double involves changing the value to conform to the floating point representation.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\b \cf2 Star
\b0  does not support casting, but does support coercion. However, coercion in 
\b Star
\b0  is never silent or implicit \'97 as it can be in Java and C/C++. An expression of the form:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 3+4.5\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 will fail to type in 
\b Star
\b0  \'97 because there is an attempt to add an integer to a floating point number.\
The reason for signaling an error is strongly related to safety and predictability: automatic conversion of integers to floating point can be a common source of errors in languages like C \'97 because such coercions are not always guaranteed to be semantics preserving (not all integers can be represented as floating point values). The implicit coercion of numeric values is easy to miss when reading arithmetic expressions.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\b \cf2 Star
\b0  provides a coercion notation that allows programmers to be precise in their expectations:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 (3 :: float)+4.5\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 denotes the explicit coercion of the integer 3 to a float and type checks as expected.\
In fact, type coercion in 
\b Star
\b0  is mediated via a contract and this expression is equivalent to\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 (_coerce(3):float)+4.5\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 where _coerce is defined in the coercion contract involving two types:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 contract all s,t ~~ coercion[s,t] ::= \{\
  _coerce :: (s)=>t\
\}\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 The coercion contract is an interface, but has no analog in most OO languages: it involves two types \'97 the source type and the destination type. Each implementation of coercion specifies both types. For example, the implementation of coercion between integers and floating point is explicitly given:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 implementation coercion[integer,float] => \{ ... \}\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 This implementation gives the implementation for coercing integers to floats. Other implementation statements give the definitions for other forms of coercion.\
Having coercion as a contract makes it straightforward to add new forms of coercion. This is used quite extensively within 
\b Star
\b0  itself: for example, parsing JSON can be viewed as coercion from string values to json values. Thus the interface to parsers can be standard across all types and parsers.}