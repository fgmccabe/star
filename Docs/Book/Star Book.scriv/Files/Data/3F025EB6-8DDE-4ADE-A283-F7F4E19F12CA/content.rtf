{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Unlike the cons or list type, the dictionary type is oriented for access by arbitrary keys. The dictionary is also quite different to hash trees as found in Java (say), the dictionary type is 
\i persistent
\i0 : the functions that access dictionaries such as by adding or removing elements return new dictionaries rather than modifying a single shared structure. However, the efficiency of the dictionary is quite comparable to Java\'92s HashMap.\
The template for the dictionary type is:\
all k,v ~~ equality[k] |: dictionary[k,v]\
Notice that there is an implied constraint here: the dictionary assumes that the keys in the dictionary can be compared for equality.\
A dictionary value can be written using the sequence notation, using tuple pairs for the key-value pairs:\
dictionary of [(1,"alpha"),(2,"beta")]\
Dictionaries also have a special variant of the sequence notation; instead of writing the pairs as tuples we can use an arrow notation for dictionary terms:\
dictionary of [1->"alpha", 2->"beta"]\
Dictionaries also have their own special variant of a 
\i query search condition
\i0 . A condition of the form\
K->V in D\
where D is a dictionary will be satisfied if there is a key/value pair in D corresponding to K and V. For example, the condition:\
K->V in dictionary of [1->"alpha", 2->"beta"] && V=="alpha"\
is satisfied for only one pair of K and V: 1 and "alpha" respectively.\
For the curious, dictionaries are implemented using techniques similar to Ideal Hash Trees, as described by Bagwell [#Bagwell01idealhash]. This results in a structure with an effective O(1) cost for accessing elements 
\i and
\i0  for modifying the dictionary \'97 all the while offering an applicative data structure.}