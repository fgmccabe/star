{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Once we have at least an approximate conceptualization, our next step is to design the syntax. Syntax is important because it encodes the manner in which different features of the DSL can be expressed and combined.\
There is an inevitable requirement for 
\i taste
\i0  in designing the syntax of a language extension. One of the foundations for this taste is knowledge of the existing syntactic patterns in the host language. Another is an awareness of the combinatorial potential in the language \'97 i.e., what can be combined with what.\
Notice that we identify a 
\i graph
\i0  as being a sub-class of 
\i expression
\i0 ; this represents an important choice point in DSL design: whether we are extending 
\i expressions
\i0 , 
\i statements
\i0 , 
\i actions
\i0 , or 
\i types
\i0 . Of course, in complex projects you may find yourself implementing multiple kinds of extensions. We choose to model graphs as 
\i expressions
\i0  as that gives us the maximum flexibility in using triple graphs to represent policies.}