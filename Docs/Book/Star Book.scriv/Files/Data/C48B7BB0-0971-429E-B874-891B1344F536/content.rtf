{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 If we look at the signature for _index we can see that this function does not directly return a value from the collection, but instead returns an option value. This bears further explanation.\
The great unknown of accessing elements of a collection is \'91is it there?\'92. Its not guaranteed of course, and we need to be able to handle failure.\
This is where the concept of \'91tentative computation\'92 becomes important.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\b \cf2 Tentative Computation\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\b0 \cf2 A tentative computation is denoted by an expression that is inherently plausible to not have a value.\
When we want to open a file, access an element of a dictionary, parse a string with a regular expression we need to be able to express the possibility of failure as well as of success. There are also times when \'91no answer\'92 is a legitimate response.\
We encode this tentativeness (sic) in the option type. The type definition for option is straightforward:\
all t ~~ option[t] ::= none | some(t).\
where none is intended to denote the non-existence of a value and some denotes an actual value.\
The option type is intended to be used in cases where functions are known to be partial.\{\\SCRV_FN=A partial function does not have a value across the whole range of its arguments.\\END_SCRV_FN\} The option return type signals that the function may not always have a value.\
In the case of the _index function, its responsibility is to either return a value wrapped as a some value \'97 if the index lookup is successful \'97 or the signal none if the index lookup fails. Just to be clear, _index can act both as a lookup 
\i and
\i0  as a test for membership in the collection.\
In addition to the option type, there are a series of operators that make tentative computations easier to express: these are the optional field access operator \'97 ?. \'97 the option default operator \'97 ?| \'97 and the ?.= binding predicate.\
The ?| operator allows one to unpack an optional value but to give a default in the case that the optional value is none.\
We can see where the latter may be useful when accessing dictionaries. For example, the fillIn function accesses a dictionary for a key but uses a default value when it is not there:\
fillIn:all k,v ~~ (dictionary[k,v],k,v)=>v.\
fillIn(Tr,Ky,Def) where Vl ?.= _index(Tr,Ky) => Vl.\
fillIn(Tr,_,Def) => Def.\
The condition Vl ?.= _index(Tr,Ky) is satisfied if the _index call returns a proper value and it also binds the variable Vl to that value (specifically, it 
\i matches
\i0  the value against the variable Vl.\
While the ?.= operator is very useful in unpacking an optional value, the ?| operator allows us to handle cases where we always need to be able to give the optional a value. For example, normally a dictionary returns none if an entry is not present. However, a 
\i cache
\i0  is structured differently: if a value is not present in a cache then we must go fetch it:\
cacheValue(K) => cache[K] ?| fetch(K)\
There is, clearly, a strong relationship between ?.= and ?|: each can be expressed in terms of the other.\
The option type \'97 and the some and none values \'97 play some of the same roles as NULL does in other languages.\
For someone approaching a functional language from most imperative languages they will be struck \'97 and maybe upset \'97 by the lack of a null (or nil or NULL or undefined). After all, if it\'92s good enough for Java, why can\'92t 
\b Star
\b0  have it too?\
Perhaps the biggest single reasons for not having a universal NULL value are that it corrupts the type system and that it makes reasoning about programs harder.\
In a language which has a universal NULL value, the programmer (and the compiler) must be ever vigilant about references: is the value actually a NULL value? This is true even in those cases where the programmer knows values cannot be NULL. By isolating nullability (sic) into a single concept it allows the programmer to use the feature where it is actually needed.\
In a language like Java which has a universal NULL value, the type assigned to NULL turns out to be a little strange. Under most circumstances, a value can be assigned a single unique type; but a universal NULL can be literally of any type. So, universal NULL is a value that denotes no actual value, yet it can be of any type.\
This distorts the logic of the type system by introducing a bottom value into the type lattice. 
\b Star
\b0 \'92s type system is not based on the concept of sub-types; which makes a universal NULL value even more difficult to accommodate.\
Overall, the option type is part of an elegant approach to nullability that is easily incorporated into 
\b Star
\b0 \'92s (and similar) type system.}