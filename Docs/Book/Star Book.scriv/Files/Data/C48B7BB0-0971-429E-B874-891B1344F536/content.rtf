{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
If we look at the signature for 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 _index
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  we can see that this function does not directly return a value from the collection, but instead returns an 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 option
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  value. This bears further explanation.\
The great unknown of accessing elements of a collection is \'91is it there?\'92. Its not guaranteed of course, and we need to be able to handle failure.\
This is where the concept of \'91tentative computation\'92 becomes important.\
\pard\tx720\tx1080\tx1440\li720\sl264\slmult1\sb240\sa240\pardirnatural\partightenfactor0

\f1\fs24 \cf2 <$Scr_Ps::0>
\f0\b Tentative Computation\

\b0 \cf2 A tentative computation is denoted by an expression that is inherently plausible to not have a value.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1 \cf2 <!$Scr_Ps::0>
\f0\fs26 When we want to open a file, access an element of a dictionary, parse a string with a regular expression we need to be able to express the possibility of failure as well as of success. There are also times when \'91no answer\'92 is a legitimate response.\
We encode this tentativeness (sic) in the option type. The type definition for option is straightforward:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::1>
\f2\fs22 all t ~~ option[t] ::= none | some(t).\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::1>
\f0\fs26 where 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 none
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  is intended to denote the non-existence of a value and some denotes an actual value.\
The option type is intended to be used in cases where functions are known to be {\field{\*\fldinst{HYPERLINK "scrivcmt://482B1423-E63B-4FBA-B016-E9EA9E1B9D3C"}}{\fldrslt partial.}} The 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 option
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  return type signals that the function may not always have a value.\
In the case of the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 _index
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  function, its responsibility is to either return a value wrapped as a 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 some
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  value \'97 if the index lookup is successful \'97 or the signal 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 none
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  if the index lookup fails. Just to be clear, 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 _index
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  can act both as a lookup 
\i and
\i0  as a test for membership in the collection.\
In addition to the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 option
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  type, there are a series of operators that make tentative computations easier to express: these are the optional field access operator \'97 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 ?.
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  \'97 the option default operator \'97 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 ?|
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  \'97 and the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 ?.=
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  optional binding predicate.\
The 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 ?|
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  operator allows one to unpack an optional value but to give a default in the case that the optional value is 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 none
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26 .\
We can see where the latter may be useful when accessing dictionaries. For example, the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 fillIn
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  function accesses a dictionary for a key but uses a default value when it is not there:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::1>
\f2\fs22 fillIn:all k,v ~~ (dictionary[k,v],k,v)=>v.\
fillIn(Tr,Ky,Def) where Vl ?.= _index(Tr,Ky) => Vl.\
fillIn(Tr,_,Def) => Def.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::1>
\f0\fs26 The condition 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 Vl ?.= _index(Tr,Ky) 
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26 is satisfied if the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 _index
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  call returns a proper value and it also binds the variable Vl to that value (specifically, it 
\i matches
\i0  the value against the variable Vl.\
While the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 ?.=
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  {\field{\*\fldinst{HYPERLINK "scrivcmt://E8A953FF-D704-47BF-BE07-763A8B3D1859"}}{\fldrslt operator}} is very useful in unpacking an optional value, the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 ?|
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  operator allows us to handle cases where we always need to be able to give some kind of value. For example, normally a dictionary returns 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 none
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  if an entry is not present. However, a 
\i cache
\i0  is structured differently: if a value is not present in a cache then we must go fetch it:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::1>
\f2\fs22 cacheValue(K) => cache[K] ?| fetch(K)\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::1>
\f0\fs26 There is, clearly, a strong relationship between 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 ?.=
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  and 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 ?|
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  \'97 each can be expressed in terms of the other.\
The 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 option
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  type \'97 and the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 some
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  and 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 none
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  values \'97 play some of the same roles as NULL does in other languages.\
For someone approaching a functional language from most imperative languages they will be struck \'97 and maybe upset \'97 by the lack of a null (or nil or NULL or undefined). After all, if it\'92s good enough for Java, why can\'92t 
\b \cf2 Star
\b0 \cf2  have it too?\
Perhaps the biggest single reasons for not having a universal NULL value are that it corrupts the type system and that it makes reasoning about programs harder.\
In a language which has a universal NULL value, the programmer (and the compiler) must be ever vigilant about references: is the value actually a NULL value? This is true even in those cases where the programmer knows values cannot be NULL. By isolating nullability (sic) into a single concept it allows the programmer to use the feature where it is actually needed.\
In a language like Java which has a universal NULL value, the type assigned to NULL turns out to be a little strange. Under most circumstances, a value can be assigned a single unique type; but a universal NULL can be literally of any type. So, universal NULL is a value that denotes no actual value, yet it can be of any type.\
This distorts the logic of the type system by introducing a bottom value into the type lattice. 
\b \cf2 Star
\b0 \cf2 \'92s type system is not based on the concept of sub-types; which makes a universal NULL value even more difficult to accommodate.\
Overall, the option type is part of an elegant approach to nullability that is easily incorporated into 
\b \cf2 Star
\b0 \cf2 \'92s (and similar) type system.}