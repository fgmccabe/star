{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 We stated at the beginning that \'91synchronous communication was more basic\'92 than asynchronous communication. Nevertheless, there are times when asynchronous communication is called for.\
In general, asynchrony increases the potential for parallelism; it also increases the complexity of coordination.\
One pattern that makes inherent use of asynchronous communication is the worker-queue pattern. The worker-queue pattern consists of a source of \'91work\'92, a queue to hold unfinished work items and one or more \'91workers\'92 that perform a typically compute intensive task on each item. For example, an image rendering farm might consist of an image generator, a queue and a set of image renderers. (Image rendering, such as resizing an image encoded in JPEG or converting from one form to another, often takes considerable compute resources.)\
Our focus here will be on the implementation of the queue, rather than the implementation of any image rendering process.\
Other patterns that make use of asynchronous communications include the 
\i publish-subscribe
\i0  and the 
\i actor
\i0  patterns. In applications where there is essentially a one-way flow of information from publishers to subscribers there is less need to tightly synchronize communications. Similarly, actors denote semi-autonomous activities that collaborate with each other to solve shared 
\i goals
\i0 . In fact, almost 
\i every
\i0  multi-user application can be modeled in terms of agents.}