{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 One of the reasons that we are so interested in establishing a \'91normal\'92 semantics for modules and ADTs is that we can develop systems where the contents of a module depends on some additional computation; i.e., we can use 
\i functions over modules
\i0 . For example, we can show that 
\i aspect oriented programming
\i0  and 
\i dependency injection
\i0  can be realized just using normal code structuring with functions and let environments.\
Techniques like dependency injection are typically applied to large programs; unfortunately that makes constructing small examples a little forced. So, we\'92ll use a crow-bar to open a soda bottle. Imagine, if you will, that we needed to define a new arithmetic type that supported arbitrary fractions.\
Floating point numbers are fractions. But they do not permit the representation of all fractions \'97 e.g., it is not possible to represent 1/3 exactly in IEEE 754.\
However, while we want to expose the type, and a set of operator functions, we definitely do not want to expose anything about the implementation of fractional numbers: as far as users are to be concerned, the type fraction is to be completely opaque and might be implemented in any way.\
Let us start with an interface; which in this case will take the form of a record type:\
type fractionals is fracts\{\
  fraction has kind type\
  frPlus:(fraction,fraction)=>fraction\
  frToString:(fraction)=>string\
  frParse:(string)=>fraction\
  fraction:(integer,integer)=>fraction\
\}\
One of the first things to note here is that fraction is existentially quantified; secondly we need to ensure that the set of operators we expose is complete. Our interface is not really complete, but includes two critical operators: a means of constructing fractions and a means of escaping from the world of fractions to other types (in this case string).\
Here we are mostly concerned with 
\i using
\i0  fractions, so we will assume that we have at least one implementation \'97 courtesy of the FR variable:\
FR:fractionals\
One way to use our implementation of fractions would be to reference the needed operators via the FR variable:\
def F0 is FR.frParse("3/4")\
def F1 is FR.fraction(1,2)\
def F2 is FR.frPlus(F0,F1)\
show FR.frToString(F2)   -- results in 5/4\
However, we can do rather better than this in 
\b Star
\b0 . We have already encountered the import statement; there is an analogous statement that allows us to unwrap a record like FR in a binding environment \'97 such as a let:\
let\{\
  open FR\
  def F0 is frParse("3/4")\
  def F1 is fraction(1,2)\
  def F2 is frPlus(F0,F1)\
\} do\
  show frToString(F2)   -- results in 5/4\
The open statement has a similar effect to the package import: it enables the functions, types and other elements that are embedded in a record to be made available as normal identifiers within the normal scope of the let action (or expression).\
Of course, this code is still fairly clumsy; since we would like to use normal arithmetic notation over fractions; which we can do by implementing the arithmetic contract:\
let\{\
  open FR\
  implementation arithmetic over fraction is \{\
    X+Y is frPlus(X,Y)\
   ... -- more operators needed\
  \}\
\} do \{\
   def F0 is frParse("3/4")\
   def F1 is fraction(1,2)\
   def F2 is F0+F1\
   show frString(F2)\
\}\
We can improve this further by also implementing the coercion contract between strings and fractions:\
let\{\
  open FR\
  implementation arithmetic over fraction is \{\
    X+Y is frPlus(X,Y)\
   ... -- more operators needed\
  \}\
  implementation coercion over (string,fraction) is \{\
    coerce(S) is frParse(S)\
  \}\
  implementation coercion over (fraction,string) is \{\
    coerce(F) is frToString(F)\
  \}\
\}\
This allows us to use a more natural notation for expressions involving our fractions:\
let\{\
  open FR\
  ...\
\} do \{\
   def F0 is "3/4" as fraction\
   def F1 is fraction(1,2)\
   show F0+F1\
\}\
While much better than our original, we still have too much code to write to use the fraction type: we have to get the type and then demonstrate the appropriate implementations. We want to be able to combine everything that is important about fractions into a single structure.\
There is a straightforward way we can do this. Our original signature for fractionals simply required the presence of the fraction type. What we can do is further require that the arithmetic and appropriate coercion contracts are also implemented; we do this by constraining the type definition for fractionals:\
 type fractionals is fracts\{\
  fraction has kind type where arithmetic over fraction\
       and coercion over (string,fraction)\
       and coercion over (fraction,string)\
  frPlus:(fraction,fraction)=>fraction\
  fraction:(integer,integer)=>fraction\
\}\
Since we are using contracts we do not need the explicit frParse and frToString functions in the signature any more.\
When we instantiate a fracts record we must provide \'97 within the record itself \'97 appropriate implementations of arithmetic and coercion:\
def FX is fracts\{\
  type myFraction counts as fraction\
  implementation arithmetic over myFraction is \{\
    fun X+Y is frPlus(X,Y)\
   ... \'97 more operators needed\
  \}\
  implementation coercion over (string,myFraction) is \{\
    fun coerce(S) is frParse(S);\
  \}\
  implementation coercion over (myFraction,string) is \{\
    fun coerce(F) is frToString(F)\
  \}\
  ...\
\}\
Notice that we implemented arithmetic for the internal myFraction type. We could have equally implemented the contract for fraction type too; the key requirement is to provide evidence that arithmetic is implemented for the type.\
The FX record now has everything we want to expose about fractional numbers.\{\\SCRV_FN=Assuming that we added the missing operators that we would actually need.\\END_SCRV_FN\} If we open the structure then indeed we can write programs like:\
let\{\
  open FX\
\} do \{\
   def F0 is "3/4" as fraction\
   def F1 is fraction(1,2)\
   show F0+F1\
\}\
This is virtually equivalent to the code we might have written if we were importing a package with the definition of the fraction type in it. The difference is that we have access to the full expressive power of the language in computing FX.}