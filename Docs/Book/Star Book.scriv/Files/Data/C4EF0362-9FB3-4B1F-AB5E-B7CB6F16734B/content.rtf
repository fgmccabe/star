{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
One of the intentions behind boxes-and-arrows diagrams is to call out the major functional pieces of an {\field{\*\fldinst{HYPERLINK "scrivcmt://375D9279-B25C-4FC0-9782-844563EE2F22"}}{\fldrslt application}}. The intuition is that individual components have a specific role in the application; but that they are typically \'91quite large\'92. We have already seen that a component may have multiple ports but we have not exposed what kind of computation may be going on inside.\
One of the non-goals of boxes-and-arrows diagrams is to be a complete programming language. Instead, the idea is to capture the large scale granularity in a picture but to use text for the actual programming of components. Actually building components is best left to \'91real\'92 code; in our case, we denote the code of a component as a 
\b \cf2 Star
\b0 \cf2  component; which is a special form of package.\
The one exception to the strategy of using written code to build components is with 
\i composite components
\i0  \'96 components built by assembling and wiring other components. However, this is outside the scope of this book.\
The code for a component must implement the various ports that the component has on the diagram and must also implement the functionality of the component. For example, our SplitComponent may start it\'92s implementation with:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 import boxesNarrows.\
component splitComponent => \{\
  respond incoming : \{\
    orders:event[order].\
  \}\
  incoming = respond\{\
    on O on order do\
      processOrder(O)\
  \}\
  publish suppliers : \{\
    discriminator:(string)=>port[\{order:event[order]\}].\
  \}\
  originate parts : \{\
    assembly:set[(part,list[part])].\
    supplier:set[(part,list[supplier])].\
  \}\
  ...\
\}\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 The ports that are surfaced in the order processing diagram are also represented in the code for the splitComponent. Responding ports have a body that essentially the same as for an actor (or concurrent actor); typically most of the activity within a component is initiated by code that is present in or referred from responding ports.\
Notice that, unlike regular actors, outgoing speech actions are also strongly indicated. Any outgoing speech actions must be \'91applied\'92 to one of the originating ports. For example, part of processing a parts order will be a query to the partsDB component; but the partsDB component is not explicitly identified in the splitComponent. Instead, the query is directed to the parts originating port:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 assemblySuppliers:(part)=>list[supplier].\
assemblySuppliers(A) =>\
  query parts with list of \{ unique S where\
      (A,Ps) in assembly && P in Ps &&\
      (P,Ss) in supplier &&\
      S in Ss\
    \}\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 This function can be used by the order processing code to query the parts database for all the suppliers involved in a given assembly. It works by formulating the appropriate query speech action to the originating parts port.\
The unique keyword here implies that the result will have duplicates eliminated from it.\
Using a publishing port is slightly more complex than using a regular originating port. Since there may be any number of components attached to a publishing port we must first of all select which one we want to address our speech action to. We do this using the embedded 
\i discriminator function
\i0  that is part of the publishing port. For example, to place a parts order for the supplier \'93Alpha Wheels Inc.\'94" we perform:\
placeOrder(S,parts) do\
  notify suppliers.discriminator(S.name) with\
    order\{ content=parts \} on order\
Notice that this is a regular speech action; the primary difference is that instead of a fixed recipient we compute who the recipient will be \'96 based on the name of the supplier.}