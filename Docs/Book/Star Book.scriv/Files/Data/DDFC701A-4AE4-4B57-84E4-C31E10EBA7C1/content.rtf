{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 There are two basic ways of importing a package\{\\SCRV_FN=You cannot import a worksheet.\\END_SCRV_FN\} into your code: the 
\i open import
\i0  and the 
\i named import
\i0 . The open import is the simplest; to import a package you just import it (sic):\
worksheet\{\
  import myPackage.\
\
  -- Use definitions from myPackage\
\}\
You can also import packages outside the worksheet structure:\
import myPackage.\
worksheet\{\
  -- Use definitions from myPackage\
\}\
Any definition that is contained in myPackage is available throughout the worksheet (or other package if you are building a package).\
Like other forms of definition, the import statement may appear anywhere at the top-level of the importing worksheet or package. However, it is normally at the beginning of the package.\
The second way of importing a package is to use the 
\i named import
\i0 . As suggested, a named import associates a local identifier with the import:\
worksheet\{\
  import myPackage as mP.\
\
  -- Use definitions from myPackage via mP\
\}\
For example, suppose that myPackage looked like:\
myPackage\{\
  public all t ~~ foo[t] ::= foo(t) | bar.\
\
  public unFoo:all t ~~ (foo[t]) => t.\
  unFoo(foo(X)) => X.\
\}\
To use the unFoo function in our second worksheet, we simply reference it as a field in the mP variable:\
worksheet\{\
  import myPackage as mP.\
\
  getTheStuff:all t ~~ (mP.foo[t])=>t.\
  getTheStuff(F) is mP.unFoo(F).\
\}\
What may be a little surprising is that this applies to the foo type also, and also to the foo and bar constructors:\
worksheet\{\
  import myPackage as mP.\
\
  wrapF:all t ~~ (option[t])=>foo[t].\
  wrapF(none) => mP.bar.\
  wrapF(some(X)) => mP.foo(X).\
\}\
One of the benefits of the named import is that it makes it possible to import packages even when there are potential clashes amongst the packages being imported and/or definitions in the importing package itself.\
By using named imports the effect is to establish a local 
\i namespace
\i0  for the imported package. Different definitions imported from different places can be reliably distinguished using the normal record field access syntax (i.e., a period).}