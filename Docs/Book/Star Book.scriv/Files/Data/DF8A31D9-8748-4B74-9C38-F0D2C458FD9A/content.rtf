{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 We now take a look at how we can process collections using actions rather than expressions. Iteration is one of those areas where history has resulted in two quite different traditions: OO-style languages and functional languages have markedly different approaches to iteration; and yet, as we will see, they can be seen as twins of each other.\
A classic iteration over a collection, written in Java in this case, looks something like:\
int len = 0;\
for(String s:myColl)\{\
  len = len+s.length();  // do something with s\
\}\
As we have seen, the functional approach to this kind of computation would be to capture the implicit recursion into a use of leftFold:\
leftFold((A,E)=>A+size(E),0,myColl)\
Although the Java and 
\b Star
\b0  code fragments are computing the same value \'97 the total length of string data in the collection \'97 and even though they are nearly the same length; there are radical differences between the two, differences that can make a substantial difference in large programs.\
The first salient point is that the iteration/recursion is exposed in the Java code and hidden in the 
\b Star
\b0  code. This is potentially very significant in the event that we want to change how the iteration is implemented \'97 replace a sequential iteration by a parallel one, for example. More subtly, if there are any 
\i access
\i0  issues with the collection \'97 if access to it requires special care with locking or related features \'97 these same issues can be dealt with once \'97 in the implementation of leftFold rather than repeatedly for each loop.\
The second salient feature is that the relationship between the iteration and the body of the iteration is inverted. We can see this if we unpack the Java loop, which involves an explicit Iterator object:\
int len = 0;\
for(Iterator<String> it=myColl.iterator();it.hasNext();)\{\
  String s = it.next();\
  len = len+s.length();  // do something with s\
\}\
The Iterator object \'91carries\'92 most of the information needed to process the collection properly. Each call to next results in s being bound to the next element of myColl.\
If we squint appropriately, we can see that the body of the Java loop \'91drives\'92 the iteration \'97 via the call to it.next(). In effect, the body code is the 
\i client
\i0  of the collection, and the Iterator object is the server in the code fragment.\
In the case of the functional code, the loop is encapsulated in the leftFold function which drives the loop by calling the \'91body function\'92 when needed. It is possible to write Java code that approximates to this style; it would be something like:\
Folding.leftFold((A,E)->\{return A+E.length()\},0,myColl)\
assuming that leftFold were a static function in the Folding class.\{\\SCRV_FN=This relies on new syntax introduced in Java 8. The leftFold would be much clumsier in earlier versions of the language.\\END_SCRV_FN\}\
The third saliency is not actually obvious from these fragments, but the functional approach has more variability in the loop structures than Java. Java has several forms of loop, but there is only one loop that is oriented to processing collections \'97 the \'91for each\'92 loop. On the other hand, in 
\b Star
\b0  \'97 like most functional programming languages \'97 we have map to transform a collection, filter to remove unwanted elements, leftFold and its relatives to reduce collections.\
The range of looping functions reflects an underlying vocabulary of \'91things we do\'92 to collections.\
The final, perhaps most unexpected point, is that the fundamental computational cost of the two styles of iteration is almost identical! Under reasonable assumptions of optimization for both Java and 
\b Star
\b0 , it is possible to show that the number of steps needed to compute the two fragments is very similar. The details are beyond the scope of this book.}