{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 In addition to the basic quote notation for expressions, it also has support for 
\i meta-variables
\i0 . Meta variables are variables embedded in quoted terms \'97 they are variables of the quoted term, not variables in the 
\i object language
\i0 . They are very useful in programs that process quoted expressions \'97 both as expressions and as patterns.\
For example, to denote a triple 
\i pattern
\i0  one may construct the quoted pattern:\
<| ?S ! ?P $ ?O |>\
where S, P and O are meta-variables that would be bound to the subject, predicate and object of the triple respectively. This quoted pattern is equivalent to the normally written term:\
applyAst(nameAst("n3Triple"),tupleAst(list of [S,P,O]))\
Note that the type of meta-variables is always quoted.\
If we wanted to construct a quoted triple using the quoted notation we might have the following sequence:\
var S is <| :john |>\
var P is <| :name |>\
var O is <| "John Smith" |>\
var T is <| ?S ! ?P $ ?O |>\
As a result of this, the variable T would be bound to the equivalent of the term:\
var T is <| :john ! :name $ "John Smith" |>\
The quoted notation is sufficiently powerful to almost never require explicit use of the constructors that actually make of the quoted type definition. This is reinforced by the implementation of the coercion contract between standard types and quoted.}