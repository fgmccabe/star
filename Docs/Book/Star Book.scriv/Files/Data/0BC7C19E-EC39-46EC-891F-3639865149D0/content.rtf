{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Translating a DSL into core 
\b Star
\b0  is not always the end of the story. In addition it is important to consider what other ways it should be integrated with the language. For example, we designed a new condition so that triple graphs could participate in queries. In addition, there may be one or more standard contracts that should be implemented for elements of the DSL.\
Finally, we recall that we fixed on the representation of a triple graph as a list of triples, specifically of n3Triple terms. However, this was, perhaps not the best ultimate representation \'97 who is to say that a list is the best way of representing all graphs? In fact, fixing on lists to represent graphs represents a premature commitment: and no single choice is necessarily any better than lists.\
A better approach is to insulate the architectural choice point by introducing a contract layer. The purpose of the contract is to delay the actual implementation choice to a point where the choice is easier to make. The contract should encapsulate the choice point; in this case we would specify the operations we might expect of a triple graph:\
contract graphStructure over t is \{\
  emptyGraph:t\
  addToGraph:(t,n3Triple)=>t\
  findAllSubjects:(t,n3Concept)=>list[n3Triple]\
  findAllPredicates:(t,n3Concept)=>list[n3Triple]\
  findAllObjects:(t,n3Concept)=>list[n3Triple]\
  removeFromGraph:(t,n3Triple)=>t\
\}\
Using such a contract as an underlying specification of requirements for implementation has the merit of allowing evolution in the representation of triple graphs; because, like all languages, we should expect our DSL to evolve too.}