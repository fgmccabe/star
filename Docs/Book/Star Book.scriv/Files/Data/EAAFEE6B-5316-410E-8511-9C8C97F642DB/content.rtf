{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
If we take a slightly deeper look at 
\b Star
\b0 \'92s package we will see some surprising features; features that are sadly not very common in programming languages.\
Let\'92s start with a super simple source package:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 ss\{\
  public double:(integer)=>integer.\
  double(X) is X*2.\
\}\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 This package structure is semantically equivalent to a function:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 ss:\{double:(integer)=>integer\}.\
ss = let\{\
  public double:(integer)=>integer.\
  double(X) is X*2\
\} in \{. double=double .\}\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 In effect, a package reduces to a variable declaration whose type is a record type and whose value is an anonymous record of all the functions defined in the package.\
The special form:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 \{. double=double .\}
\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 <!$Scr_Ps::0>
\f0\fs26 is a record structure; the periods in the braces signify that the record is not 
\i recursive
\i0 : the definitions within the record cannot reference each {\field{\*\fldinst{HYPERLINK "scrivcmt://EF9BAB80-C5B1-40BA-9ADB-8D1F02184050"}}{\fldrslt other.}}\
What about types though? Like other programming languagesm 
\b Star
\b0  allows us to export types from packages too:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 simple\{\
  all t ~~ foo[t] ::= foo(t) | bar.\
\
  fooMe:all t ~~ (t)=>foo[t].\
  fooMe(X) => foo(X)\
\}\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 Exporting types \'97 and their constructors \'97 is an extremely important part of the package functionality. However, it turns out that we can account for types too in our semantics of packages. Similarly to our previous unfolding, the simple package is equivalent to:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 simple: exists f/1 ~~ \{\
  type foo/1.\
  foo:all t ~~ (t)<=>f[t].\
  bar:all t ~~ f[t].\
  fooMe:all t ~~ (t)=>f[t].\
\}\
simple = let\{\
  all t ~~ foo[t] ::= foo(t) | bar.\
\
  fooMe:all t ~~ (t)=>foo[t].\
  fooMe(X) => foo(X)\
\} in \{. type f=foo. foo=foo. bar=bar. fooMe=fooMe .\}\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 This is clearly quite a bit more complex than our super-simple example; but the basic story is still there: a package consists of a variable definition whose value is an anonymous record. In this case, the anonymous record contains a type, two constructors as well as a regular function.\
Having constructors in a type is only a small extension to the conventional notion of a record \'97 while many languages restrict records to containing just data values, most functional programming languages do allow functions in records. A constructor is just a special kind of function.\
On the other hand, having a type in a record is quite different.}