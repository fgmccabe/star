{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
If we take a slightly deeper look at 
\b Star
\b0 \'92s package we will see some surprising features; features that are sadly not very common in programming languages.\
Let\'92s start with a super simple source package:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 ss\{\
  public double:(integer)=>integer.\
  double(X) is X*2.\
\}\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 This package structure is semantically equivalent to a function:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 ss:\{double:(integer)=>integer\}.\
ss = let\{\
  public double:(integer)=>integer.\
  double(X) is X*2\
\} in \{. double=double .\}\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 In effect, a package reduces to a variable declaration whose type is a record type and whose value is an anonymous record of all the functions defined in the package.\
The special form:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 \{. double=double .\}
\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 <!$Scr_Ps::0>
\f0\fs26 is a record structure; the periods in the braces signify that the record is not 
\i recursive
\i0 : the definitions within the record cannot reference each {\field{\*\fldinst{HYPERLINK "scrivcmt://EF9BAB80-C5B1-40BA-9ADB-8D1F02184050"}}{\fldrslt \cf2 other.}} We use this slightly complicated way of defining the package record because not all members of the package are public \'97 and this formulation allows us to be precise in what elements of the package record can be seen by others.\
What about types though? Like other programming languages 
\b Star
\b0  allows us to export types from packages too:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 simple\{\
  public all t ~~ foo[t] ::= foo(t) | bar.\
\
  public fooMe:all t ~~ (t)=>foo[t].\
  fooMe(X) => foo(X)\
\}\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 The ability to export types \'97 and their constructors \'97 is an extremely important part of the package functionality. However, having types in records is not a common feature in programming languages \'97 this may be one reason why the correspondence between packages and records is not more widely understood.\
It turns out that we can account for types too in our semantics of packages. Similarly to our previous unfolding, the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 simple
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  package is equivalent to:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 simple: exists foo/1 ~~ \{\
  type foo/1.\
  foo:all t ~~ (t) <=> foo[t].\
  bar:all t ~~ foo[t].\
  fooMe:all t ~~ (t)=>foo[t].\
\}\
simple = \{\
  all t ~~ foo[t] ::= foo(t) | bar.\
\
  fooMe:all t ~~ (t)=>foo[t].\
  fooMe(X) => foo(X).\
\}\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 This is clearly quite a bit more complex than our super-simple example; but the basic story is still there: a package consists of a variable definition whose value is an anonymous record. In this case, the anonymous record contains a type, two constructors as well as a regular function. It also includes a 
\i type
\i0  statement that, in this case, informs the type system that the existentially quantified type 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 foo
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  type should also be viewed as being part of the record.\
Having constructors in a type is only a small extension to the conventional notion of a record \'97 while many languages restrict records to containing just data values, most functional programming languages do allow functions in records. A constructor is just a special kind of function.\
On the other hand, having a type in a record is quite different.}