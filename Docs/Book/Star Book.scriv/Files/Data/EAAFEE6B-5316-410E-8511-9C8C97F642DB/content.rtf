{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 If we take a slightly deeper look at the package we will see some surprising features; features that are sadly not very common in programming languages.\
Lets start with a super simple source package:\
ss\{\
  public double:(integer)=>integer.\
  double(X) is X*2.\
\}\
This package structure is semantically equivalent to:\
ss:\{double:(integer)=>integer\}.\
ss = let\{\
  public double:(integer)=>integer.\
  double(X) is X*2\
\} in \{. double=double .\}\
In effect, a package reduces to a variable declaration whose type is a record type and whose value is an anonymous record of all the functions defined in the package.\
What about types though? 
\b Star
\b0  allows us to export types from packages too:\
simple\{\
  all t ~~ foo[t] ::= foo(t) | bar.\
\
  fooMe:all t ~~ (t)=>foo[t].\
  fooMe(X) => foo(X)\
\}\
Exporting types \'97 and their constructors \'97 is an extremely important part of the package functionality. However, it turns out that we can account for types too in our semantics of packages. Similarly to our previous unfolding, the simple package is equivalent to:\
simple: exists foo/1 ~~ \{\
  foo:all t ~~ (t)<=>foo[t].\
  bar:all t ~~ foo[t].\
  fooMe:all t ~~ (t)=>foo[t].\
\}\
simple = let\{\
  all t ~~ foo[t] ::= foo(t) | bar.\
\
  fooMe:all t ~~ (t)=>foo[t].\
  fooMe(X) => foo(X)\
\} in \{. type foo=foo. foo=foo. bar=bar. fooMe=fooMe .\}\
. This is clearly quite a bit more complex than our super-simple example; but the basic story is still there: a package consists of a variable definition whose value is an anonymous record. In this case, the anonymous record contains a type, two constructors as well as a regular function.\
Having constructors in a type is only a small extension to the conventional notion of a record \'97 while many languages restrict records to containing just data values, most functional programming languages do allow functions in records. A constructor is just a special kind of function.\
On the other hand, having a type in a record is quite different.}