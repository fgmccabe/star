{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Of course, this includes our own types. For example, before, when looking at [generic types][generic-types] we saw the tree type:\
all t ~~ tree[t] ::= tEmpty | tNode(tree[t],t,tree[t]).\
We can define an implementation for the indexable contract for this type \'97 if we arrange for the tree to be a tree of key-value pairs:\
implementation all k,v ~~\
    comparable[k], equality[k] |:\
      indexable[tree[(k,v)]->>k,v] => \{\
  _index(T,K) => findInTree(T,K).\
  _set_indexed(T,K,V) => setKinTree(T,K,V).\
  _delete_indexed(T,K) => removeKfromTree(T,K).\
\}\
The form of the type expression tree[(k,v)] is required to avoid confusion \'97 tree takes a single type argument that, in this case, is a tuple type. The extra set of parentheses ensures that tree is not interpreted (incorrectly) as a type that takes two type arguments.\
With this statement in scope, we can treat appropriate tree expressions as though they were regular arrays or dictionaries:\
T : tree[(string,string)].\
T = tNode(tEmpty,("alpha","one"),tEmpty)\
assert T["alpha"]=="one".\
U : tree[(string,string)].\
U = T["beta"->"two"]. -- Add in "beta"\
assert U["alpha"]=="one".\
assert present U["beta"].\
assert \\+ present U["gamma"].\
The implementation statement relies on another feature of 
\b Star
\b0 \'92s type system \'97 we need to constrain the implementation of indexable to a certain subset of possible instances of tree types \'97 namely, where the element type of the tree is a 
\i pair
\i0  \'97 a two-tuple \'97 and secondly we require that the first element of the pair is comparable \'97 i.e., it has the comparable contract defined for it.\
This is captured in the contract clause of the implementation statement:\
implementation all k,v ~~\
    comparable[k], equality[k] |:\
      indexable[tree[(k,v)]->>k,v] => ...\
This implementation statement is fairly long, and the type constraints are fairly complex; but it is exquisitely targeted at precisely the right kind of tree without us having to make any unnecessary assumptions.\
It is also true that most programmers will not be constructing new implementations of the indexable contract very frequently.\
Implementing the indexable contract requires us to implement three functions: findInTree, setKinTree and removeKfromTree. The findInTree function is quite straightforward:\
findInTree:all k,v ~~ (tree[(k,v)],k)=>option[v].\
findInTree(tEmpty,_) => none.\
findInTree(tNode(_,(K,V),_),K) => some(V).\
findInTree(tNode(L,(K1,_),_),K) where K1>K => findInTree(L,K).\
findInTree(tNode(_,(K1,_),R),K) where K1<K => findInTree(R,K).\
Notice that each \'91label\'92 in the tree is a 2-tuple \'97 consisting of the key and the value. This function is also where we need the key type to be both comparable and supporting equality. The comparable constraint has an obvious source: we perform inequality tests on the key.\
The equality constraint comes from a slightly less obvious source: the repeated occurrence of the K variable in the second equation. This equation is actually equivalent to:\
findInTree(tNode(_,(K,V),_),K1) where K==K1 => some(V)\
We leave the implementations of setKinTree and removeKfromTree as an exercise for the reader.\
Along with the implementation of indexable, we should also implement sequence for our trees:\
implementation all k,v ~~ comparable[k], equality[k] |:\
    sequence[tree[(k,v)]->(k,v)] => \{\
  _nil() => tEmpty.\
  _cons((K,V),T) => setKinTree(T,K,V).\
  ...\
\}\
where, again, we leave the implementation of the remaining part of the contract to the reader.\{\\SCRV_FN=It is not completely obvious what one should do when matching the head of a tree. The standard library chooses to match against the left-most leaf of the tree and return a new tree containing all the other elements for the tail of the match. This has the effect of making tree expressions like tree of [1->"alpha",2->"beta"\\END_SCRV_FN\} be equivalent to tree of [2->"beta",1->"alpah"].]}