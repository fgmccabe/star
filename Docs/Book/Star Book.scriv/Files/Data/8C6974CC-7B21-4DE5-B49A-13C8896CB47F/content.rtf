{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Underlying the sequence notation is the sequence contract. This contract contains type signatures in it that can be used to construct and to match against sequence values. The sequence notation is realized by the compiler translating sequence terms to a series of calls to those functions.\
The actual sequence contract is\
contract sequence[t->>e] ::= \{\
  _nil:()=>t.     -- empty sequence\
  _cons:(e,t)=>t. -- add to front\
  _apnd:(t,e)=>e. -- add to back\
  _empty:()<=t.   -- match empty sequence\
  _pair:(e,t)<=t. -- match front\
  _back:(t,e)<=t. -- match back\
\}\
The first three entries in this contract should be fairly self-evident:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl264\slmult1\pardirnatural\partightenfactor0
\ls1\ilvl0\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 _nil is a function that returns an empty sequence;\{\\SCRV_FN=This could also have been a simple value.\\END_SCRV_FN\}\
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 _cons is a function that \'91glues\'92 a new element to the front of the collection; and\
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 _apnd appends elements to the 
\i back
\i0  of the collection.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0
\cf2 The compiler uses these three functions to transform sequence expressions into function calls. For example, the sequence expression:\
[1,2,3]\
is transformed into\
_cons(1,_cons(2,_cons(3,_nil())))\
If a sequence expression has an explicit type marker on it, then its translation is slightly different \'97 to allow the type checker to make use of the type information. For example, cons of [1,2] is translated as:\
_cons(1,_cons(2,_nil())):cons[_]\
This annotation is all that is needed to force the compiler to treat the result as a concrete cons list. Type inference does the rest of the hard work.\
The type expression _ is a special type that denotes an anonymous type: each occurrence of the type expression denotes a different unknown type. It is useful in situations, like this one, where only some of the type information is known.}