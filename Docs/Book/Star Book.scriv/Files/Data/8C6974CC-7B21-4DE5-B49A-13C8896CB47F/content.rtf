{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
Underlying the sequence notation is the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 sequence
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  contract. This contract contains type signatures in it that can be used to construct and to match against sequence values. The sequence notation is realized by the compiler translating sequence terms to a series of calls to those functions.\
The actual sequence contract is\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 contract sequence[t->>e] ::= \{\
  _nil:()=>t.     -- empty sequence\
  _cons:(e,t)=>t. -- add to front\
  _apnd:(t,e)=>e. -- add to back\
  _empty:()<=t.   -- match empty sequence\
  _pair:(e,t)<=t. -- match front\
  _back:(t,e)<=t. -- match back\
\}\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 The first three entries in this contract should be fairly self-evident:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl264\slmult1\pardirnatural\partightenfactor0
\ls1\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}
\f1\fs24 \cf0 <$Scr_Cs::1>
\f2\fs22 _nil
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  is a function that returns an empty {\field{\*\fldinst{HYPERLINK "scrivcmt://846BE6ED-03AC-4078-8467-8FAE32384850"}}{\fldrslt sequence;}}\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}
\f1\fs24 \cf0 <$Scr_Cs::1>
\f2\fs22 _cons
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  is a function that \'91glues\'92 a new element to the front of the collection; and\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}
\f1\fs24 \cf0 <$Scr_Cs::1>
\f2\fs22 _apnd
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  appends elements to the 
\i back
\i0  of the collection.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0
\cf2 The compiler uses these three functions to transform sequence expressions into function calls. \
For example, the sequence expression:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 [1,2,3]\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 is transformed into\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 _cons(1,_cons(2,_cons(3,_nil())))\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 If a sequence expression has an explicit type marker on it, then its translation is slightly different \'97 to allow the type checker to make use of the type information. For example, \
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 cons of [1,2]\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 is translated as:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 _cons(1,_cons(2,_nil())):cons[_]\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 This annotation is all that is needed to force the compiler to treat the result as a concrete cons list. Type inference does the rest of the hard work.\
The type expression _ is a special type that denotes an anonymous type: each occurrence of the type expression denotes a different unknown type. It is useful in situations, like this one, where only some of the type information is known.}