{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
Although better than the original 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 sTest
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  program there is still one major sense in which the test program is not general enough. We can see this by looking at another example: a function that counts elements in the tree:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 count:all t ~~ (tree[t]) => integer.\
count(tEmpty) => 0.\
count(tNode(L,_,R)) => count(L)+count(R)+1\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 This code is very similar, but not identical, to the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 test
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  function.\
The issue is that 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 test
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  is trying to do two things simultaneously: in order to apply its test predicate to a binary tree it has to implement a walk over the tree, and it also encodes the fact that the function we are computing over the tree is a boolean-value function.\
We often need to do all kinds of things to our data structures and writing this kind of recursion over and over again is tedious and error prone. What we would like to do is to write a single 
\i visitor
\i0  function and specialize it appropriately when we want to perform a specific function.\
This principle of separating out the different aspects of a system is one of the core foundations of good software engineering. It usually goes under the label 
\i separation of concerns
\i0 . One of the beautiful things about functional programming is that it directly supports such good architectural practices.\
Since this visitor may be asked to perform any kind of computation on the labels in the tree we will need to slightly generalize the type of function that is passed to the visitor. Specifically, the type of function should look like:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 F : (a,t)=>a\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 where the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 a
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  input represents accumulated state, 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 t
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  represents an element of the tree and the result is another accumulation.\
Using this, we can write a 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 tVisit
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  function that implements tree walking as:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 tVisit:all a,t ~~ (tree[t],(a,t)=>a,a)=>a.\
tVisit(tEmpty,_,A) => A.\
tVisit(tNode(L,Lb,R),F,A) => tVisit(R,F,F(tVisit(L,F,A),Lb)).\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 Just as the accumulating function acquires a new \'91state\'92 parameter, so the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 tVisit
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  function also does. The 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 A
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  parameter in the two equations represents this accumulated state.\
The second rewrite equation for 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 tVisit
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  is a bit dense so let us open it out and look more closely. A more expanded way of writing the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 tVisit
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  function would be:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 tVisit(tEmpty,_,A) => A.\
tVisit(tNode(L,Lb,R),F,A) => let\{\
      A1 = tVisit(L,F,A).\
      A2 = F(A1,Lb).\
    \} in tVisit(R,F,A2)\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 where 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 A1
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  and 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 A2
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  are two local variables that represent the result of visiting the left sub-tree and applying the accumulator function respectively. We have used the let expression form to make the program more obvious, rather than to introduce new functions locally; but this is a legitimate role for let expressions.\
The 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 tVisit
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  function knows almost nothing about the computation being performed, all it knows about is how to walk the tree and it knows to apply functions to labels in the tree.\
Given 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 tVisit
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26 , we can implement our original 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 check
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  and 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 count
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  functions as one-liners:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 check(T,S) => tVisit(T,(A,X)=>(A || X==S),false).\
count(T) => tVisit(T,(A,X)=>A+1,0).\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 The lambda that is embedded in the definition of 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 check
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26  bears a little closer scrutiny:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::0>
\f2\fs22 (A,X)=>(A || X==S)\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 In this lambda, we return 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 A
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26  \'97 if it is true \'97 or we return the result of the test 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 X==S
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26 . This is a common pattern in such programs: the accumulator 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 A
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26  acts as a kind of state parameter that keeps track of whether we have already found the value. \
\pard\tx720\tx1080\tx1440\li720\sl264\slmult1\sb240\sa240\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::1>
\f0 Functional programs are not actually 
\i state-free
\i0 ; often quite the opposite. However, the state in a functional program is never 
\i hidden
\i0 . This is the true distinction between functional and regular procedural programs.\cf2 \expnd0\expndtw0\kerning0
\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1 \cf2 <!$Scr_Ps::1>
\f0\fs26 Notice that we have effectively hidden the recursion in the function definitions of 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 check
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26  and 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 count
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26  \'97\cf2 \expnd0\expndtw0\kerning0
 all the recursion is encapsulated within the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 tVisit
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  function. One of the unofficial mantras of functional programming is 
\i hide the recursion
\i0 .\
The reason we want to hide recursions that this allows the designer of functions to focus on 
\i what
\i0  is being computed rather than focusing on the structure of the data and, furthermore, this allows the implementation of the visitor to be 
\i shared
\i0  by all users of the tree type.\
Notice that, while 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 a
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  and 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 t
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  are type variables, we did not put an explicit quantifier on the type of 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 F
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26 . This is because the quantifier is actually put on the type of 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::2>
\f2\fs22 tVisit
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::2>
\f0\fs26  instead:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 tVisit:all a,t ~~(tree[t],(a,t)=>a,a)=>a\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 Just like regular variables, type variables have scope and points of introduction. Also like regular variables, a type variable may be 
\i free
\i0  in a given type expression; although it must ultimately be 
\i bound
\i0  by a quantifier.}