{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
Although better than the original sTest program there is still one major sense in which the test program is not general enough. We can see by looking at another example: a function that counts elements in the tree:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 count:all t ~~ (tree[t]) => integer.\
count(tEmpty) => 0.\
count(tNode(L,_,R)) => count(L)+count(R)+1\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 This code is very similar, but not identical, to the test function.\
The issue is that test is trying to do two things simultaneously: in order to apply its test predicate to a binary tree it has to implement a walk over the tree, and it also encodes the fact that the function we are computing over the tree is a boolean-value function.\
We often need to do all kinds of things to our data structures and writing this kind of recursion over and over again is tedious and error prone. What we would like to do is to write a single 
\i visitor
\i0  function and specialize it appropriately when we want to perform a specific function.\
This principle of separating out the different aspects of a system is one of the core foundations of good software engineering. It usually goes under the label 
\i separation of concerns
\i0 . One of the beautiful things about functional programming is that it directly supports such good architectural practices.\
Since this visitor may be asked to perform any kind of computation on the labels in the tree we will need to slightly generalize the type of function that is passed to the visitor. Specifically, the type of function should look like:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 F : (a,t)=>a\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 where the a input represents accumulated state, t represents an element of the tree and the result is another accumulation.\
Using this, we can write a tVisit function that implements tree walking as:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 tVisit:all a,t ~~ (tree[t],(a,t)=>a,a)=>a.\
tVisit(tEmpty,_,A) => A.\
tVisit(tNode(L,Lb,R),F,A) => tVisit(R,F,F(tVisit(L,F,A),Lb)).\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 Just as the accumulating function acquires a new \'91state\'92 parameter, so the tVisit function also does. The A parameter in the two equations represents this accumulated state.\
The second rewrite equation for tVisit is a bit dense so let us open it out and look more closely. A more expanded way of writing the tVisit function would be:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 tVisit(tEmpty,_,A) => A.\
tVisit(tNode(L,Lb,R),F,A) => let\{\
      A1 : a.\
      A1 = tVisit(L,F,A).\
      A2 : a.\
      A2 = F(A1,Lb).\
    \} in tVisit(R,F,A2)\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 where A1 and A2 are two local variables that represent the result of visiting the left sub-tree and applying the accumulator function respectively. We have used the let expression form to make the program more obvious, rather than to introduce new functions locally; but this is a legitimate role for let expressions.\
The 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 tVisit
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  function knows almost nothing about the computation being performed, all it knows about is how to walk the tree and it knows to apply functions to labels in the tree.\
Given 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 tVisit
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26 , we can implement our original check and count functions as one-liners:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 check(T,S) => tVisit(T,(A,X)=>(A || X==S),false).\
count(T) => tVisit(T,(A,X)=>A+1,0).\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 Notice that we have effectively hidden the recursion in these function definitions \'97 all the recursion is encapsulated within the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 tVisit
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  function. One of the unofficial mantras of functional programming is 
\i hide the recursion
\i0 .\
The reason we want to hide recursions that this allows the designer of functions to focus on 
\i what
\i0  is being computed rather than focusing on the structure of the data and, furthermore, this allows the implementation of the visitor to be 
\i shared
\i0  by all users of the tree type.\
Notice that, while a and t are type variables, we did not put an explicit quantifier on the type of F. This is because the quantifier is actually put on the type of tVisit instead:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 tVisit:all a,t ~~(tree[t],(a,t)=>a,a)=>a\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 Just like regular variables, type variables have scope and points of introduction. Also like regular variables, a type variable may be 
\i free
\i0  in a given type expression; although it must ultimately be 
\i bound
\i0  by a quantifier.}