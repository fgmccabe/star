{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Before we look at the main sieve, let us see how we construct a generator stream. In the case of the sieve, we need a stream of positive integers (naturals) that will act as the source of potential prime numbers (to be filtered of course).\
The naturals function is set up to return a channel on which will be placed the odd integers greater than 2:\
def naturals is let \{\
  def natChannel is channel()\
  \{ ignore background task \{\
      var counter := 3\
      while true do\{\
        perform wait for sendRv(natChannel,counter)\
        counter := counter+2\
      \}\
    \}\
  \}\
\} in natChannel\
This has a similar structure to the filter function except that the loop does not wait for any input \'97 it keeps on generating odd numbers. This is where the synchronous nature of communication is important: the action:\
perform wait for sendRv(natChannel,counter)\
will only complete if there is a task that is waiting for the message. So this streamer will 
\i not
\i0  gush out numbers unless there is someone listening.}