{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
Most OO languages are embracing some of the simpler features of functional languages. Even Java 8 with its lambda expressions and stream features represents a nod to the power of functional programming.\
However, at the same time, there is a substantial gap in the capabilities of most OO languages compared to modern functional programming languages. This is a problem because the better a language is able to \'91understand\'92 your objectives, the better the tools will be able to support those objectives.\
Fundamentally, OO languages revolve around 
\i \cf2 nouns
\i0 \cf2  rather than 
\i \cf2 verbs
\i0 \cf2 . Verbs (methods) are relegated to being inside the scope of some noun (object): they are not first class. However, this leads to unnatural representations where functions do not naturally fit inside some class. In functional programming languages, like 
\b \cf2 Star
\b0 \cf2 , there is more of an balance between nouns and verbs.\
Functional languages allow a more subtle interplay between data and functions. It is possible to have functions that are about data; it is also quite straightforward to have data structures with functions embedded in them. In fact, a simple definition of a 
\i \cf2 module
\i0 \cf2  is a record that contains functions in it.\
While OO languages like Java provide excellent 
\i \cf2 data abstraction
\i0 \cf2  tools, the same cannot be said for 
\i \cf2 control abstractions
\i0 \cf2 . The result is that OO languages are \'91stuck in the 1970s\'92 when it comes to control abstractions. However, concepts such as map/reduce, computation expressions, and continuations bring a rich suite of new control possibilities that solve important problems in modern programming.\
Similarly, the type systems of languages like Java (or C# or C/C++) make are not as expressive or sensitive as modern type systems in functional languages can be. Professional programmers will recognize the typical response to insufficiently expressive types: lots of casting and dynamic meta-programming. But, while powerful, these techniques amount to giving up on types and their important advantages. Furthermore, contrary to many programmers\'92 expectations, a modern type system is quite capable of dealing with scenarios that require dynamic programming in languages like Java.\
In addition, 
\b \cf2 Star
\b0 \cf2 \'92s extensibility directly addresses a real world requirement: that of supporting a separation of policy from mechanism. Typically OO languages are excellent at describing mechanisms but do not fare so well in describing policies \'96 which are typically declarative in nature. Hence the tendency in software engineering circles to adopt text frameworks such as XML and JSON to express policies. However, these technologies lose one of the major advantages of Java \'96 that of type safety.}