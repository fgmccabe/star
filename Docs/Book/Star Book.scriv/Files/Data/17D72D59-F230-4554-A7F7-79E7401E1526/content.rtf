{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
The simplest operation on a collection is to subset it. The standard function 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 filter
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  allows us to do this with some elegance.\
Using 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 filter
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  is fairly straightforward; for example, to remove all odd numbers from a collection we can use the expression:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 filter((X)=>X%2==0,Nums)\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 For example, if Nums were the list:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 list of [1,2,3,4,5,6,7,8,9]\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 then the value of the filter expression would be\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 list of [2,4,6,8]\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 The first argument to 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 filter
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  is a 
\i predicate
\i0 : a function that returns a boolean value. The filter function (which is part of a standard contract) is required to apply the predicate to every element of its second argument and return a 
\i new
\i0  collection of every element that satisfies the {\field{\*\fldinst{HYPERLINK "scrivcmt://86A09DBB-709D-4764-BF87-3CB56FA40A08"}}{\fldrslt predicate.}}\
Note that the % function is arithmetic remainder, and the expression 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 X%2==0
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  amounts to a test that X is even (its remainder modulo 2 is 0).\
By using a function argument to represent the predicate it is possible to construct many filtering algorithms whilst not making any recursion explicit. However, not all filters are easily handled in this way; for example, a prime number filter 
\i can
\i0  be written\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Ps::0>
\f2\fs22 filter(isPrime,N)\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Ps::0>
\f0\fs26 but such an expression is likely to be very expensive (the 
\f1\fs24 \cf0 \kerning1\expnd0\expndtw0 <$Scr_Cs::1>
\f2\fs22 isPrime
\f1\fs24 \cf2 \expnd0\expndtw0\kerning0
<!$Scr_Cs::1>
\f0\fs26  test is difficult to do well).}