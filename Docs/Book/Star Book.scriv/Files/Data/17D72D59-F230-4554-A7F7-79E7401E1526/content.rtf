{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 The simplest operation on a collection is to subset it. The standard function filter allows us to do this with some elegance.\
Using filter is fairly straightforward; for example, to remove all odd numbers from a collection we can use the expression:\
filter((X)=>X%2==0,Nums)\
For example, if Nums were the list:\
list of [1,2,3,4,5,6,7,8,9]\
then the value of the filter expression would be\
list of [2,4,6,8]\
The first argument to filter is a 
\i predicate
\i0 : a function that returns a boolean value. The filter function (which is part of a standard contract) is required to apply the predicate to every element of its second argument and return a 
\i new
\i0  collection of every element that satisfies the predicate.\{\\SCRV_FN=The original collection is unaffected by the filter.\\END_SCRV_FN\}\
Note that the % function is arithmetic remainder, and the expression X%2==0 amounts to a test that X is even (its remainder modulo 2 is 0).\
By using a function argument to represent the predicate it is possible to construct many filtering algorithms whilst not making any recursion explicit. However, not all filters are easily handled in this way; for example, a prime number filter 
\i can
\i0  be written\
filter(isPrime,N)\
but such an expression is likely to be very expensive (the isPrime test is difficult to do well).}