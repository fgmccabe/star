{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 The complete sequence contract has six signatures in it \'97 the latter three signatures play an analogous role to the first three but for sequence 
\i patterns
\i0  rather than sequence 
\i expressions
\i0 . They also introduce a new form of type expression \'97 the 
\i pattern type
\i0 . For example, the signature for _pair \'97 which is used to decompose sequences into a head and tail \'97 is:\
_pair:(e,t)<=t.\
Notice the direction of the arrow: we have not seen this form of type so far, and relates to a capability that we have not encountered yet in this book \'97 pattern abstractions.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\b \cf2 Pattern Abstraction\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\b0 \cf2 A 
\i pattern abstraction
\i0  is an expression that denotes a pattern.\
Pattern abstractions are exactly analogous to functions \'97 another name for which is 
\i expression abstraction
\i0 . Pattern abstractions allow patterns to be encapsulated and reused in the same way that functions allow expressions to be encapsulated and reused.\
In this case, the pattern abstraction is critical because general sequence notation is independent of the types of the collections involved \'97 and so we have no way of knowing what concrete patterns to apply.\
Pattern abstractions are applied using the same application notation as for function application; for example, the _pair pattern in\
first:all c,e ~~ sequence[c->>e] |: (c)=>e.\
first(_pair(H,T)) => H.\
is a pattern that is applied to the argument of first. What may be a little surprising initially is that the arguments to a pattern application are also patterns! So, here, the variables H and T in the call to _pair will be bound to the first element of the collection and the remainder respectively.\
For example, applying _pair to [1,2] binds H to the value 1 and binds T to the sequence [2]. The value returned by first will be 1. We can combine pattern applications in an exactly analogous manner to the way we combine function calls.\
Obviously, there must also be a way of defining pattern abstractions. We can define a cPair pattern abstraction that applies to cons lists thus:\
cPair:all e ~~ (e,cons[e])<=cons[e].\
cPair(H,T) <= cons(H,T).\
This takes a little careful reading, but is ultimately straightforward: the right hand side is the pattern that is being abstracted, the left hand side is an application template.\
The general form of a pattern abstraction is:\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\i \cf2 name
\i0 (
\i E
\fs20 \dn3 1
\i0\fs26 \up0 ,..,
\i E
\fs20 \dn3 n
\i0\fs26 \up0 ) <= 
\i Pattern
\i0 \
where the various 
\i E
\fs20 \dn3 i
\i0\fs26 \up0  are 
\i expressions
\i0  that represent the values \'91read off\'92 the 
\i Pattern
\i0  \'97 should the pattern be satisfied. This is quite analogous to the situation for rewrite equations \'97 except that the roles of patterns and expressions are reversed.\
Like functions, pattern abstractions may be defined with multiple pattern rules; and the pattern abstraction is satisfiable exactly when one of its pattern rules is.\
Pattern abstractions are not as ubiquitous as functions; however, they certainly play a vital role in the overall design of 
\b Star
\b0 ; and are indispensable in the right circumstances.\
One special use for pattern abstractions is to give higher-level names to particular patterns. This mimics the use of functions naming expressions, and has a similar importance for program design.\
Given that we have seen how sequence expressions are transformed into function calls from the sequence contract, we can now straightforwardly give the equivalent translation for sequence patterns. Syntactically, there is no distinction between sequence expressions and sequence patterns \'97 what distinguishes them is context: sequence patterns show up as patterns in functions and sequence expressions show up in the expression context.\
A sequence pattern, as in the pattern [E,..X] for the non-empty case in concat:\
concat([E,..X],Y) => [E,..concat(X,Y)]\
is transformed into the pattern:\
_pair(E,X)\
and the entire rewrite equation becomes:\
concat(_pair(E,X),Y) => _cons(E,concat(X,Y))\
We can combine multiple pattern abstraction applications; for example, the function:\
single:all c,e ~~ sequence[c->>e] |: (c)=>e.\
single([H]) => H\
which is a function that only matches singleton sequences requires two pattern applications from the sequence contract:\
single(_pair(H,_empty())) => H\
The sequence contract is one of the most important and commonly used contracts in the 
\b Star
\b0  library. As we shall see further, many of the standard functions are built on top of the sequence contract.}