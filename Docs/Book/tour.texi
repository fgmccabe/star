@node A tour of Star
@chapter A tour of Star

Our first task is to introduce you to the @Star{} language. It is
difficult to find the right order in which to present a programming
language like @Star{}; this is because many of the features are highly
inter-related. For example, types depend on values which depend on
functions which depend on types!

Instead, our approach in this book is to take a series of horizontal
slices through the whole language; going progressively deeper as you
become more comfortable with the language. Each layer represents a
reasonably workable subset of the complete language.

Since a layered approach means that any given description may be
incomplete or slightly inaccurate, there is a temptation to use
footnote annotations which declare '@dots{} but there is
also@footnote{Please forgive these pedantic notes when you see them.}
@dots{}'.

@node A first Star program
@section A first Star program

It is traditional to introduce a new programming language with
something like the hello world example. Which we will do in a
moment. However, the factorial function often makes a better first
example for functional programming languages:

@example
sample.factorial@{
  import star.               -- Access standard language features

  public fact : (integer)=>integer.
  fact(0) => 1.              -- base case
  fact(N) where N>0 => N*fact(N-1).
@}
@end example

This is not an executable program per se.; however, it does represent
a more typical source code unit -- most programs are built from many
smaller modules which come together to make the application. This
program is small, but already introduces many of the key elements of
the language.

In this module, we see the name of the module --
@code{sample.factorial} -- an import statement and a function
definition -- of the @code{fact} function.

@node Compiling Factorial
@subsection Compiling Factorial

Source code can be in any form of textual container. There is, for
example, no specific requirement that this @code{sample.factorial}
package be in a file called @code{factorial.star}; although that may
be good advice. Instead, the compiler relies on a @emph{catalog based}
system that maps package names to text entities -- specifically
resources with a URI. The catalog system also serves as an anchor
point in the version management of packages. We will cover this, and
the related repository system for generated artifacts, in @refer{ocean}.

In this case, we can create -- alongside the @code{factorial.star}
file -- the @code{catalog} file which is a JSON-style file containing:

@example
@{
  "content" : @{
    "sample.factorial" : "factorial.star"
   @},
  "default" : "@emph{path to installation}"
@}
@end example

The @Star{} compiler is called @code{sc}, and is invoked @emph{using
the package name} of the file we want to compile:
@example
$ sc sample.factorial
@end example
There are several configurations options for compiling and running
@Star{} programs; the most important is the repository. This is the
directory where compiled code is deposited by the compiler and
accessed by the run-time.

If not explicitly given, the @Star{} compiler and run-time looks for a
directory called @code{.star-repo}@footnote{By convention, the name of
the repository directory is called @code{.star-repo}; but any
directory can be used.}, either in the current directory or in a
parent of the current directory -- all the way up to your home
directory.@footnote{The search terminates at the home directory to
avoid trying to access areas of the file system you do not own.}

As we noted above, @code{sample.factorial} is not a complete
executable package. To use it we need to import it into one that has a
@code{main} function defined, say:

@example
sample.main@{
  import star.
  import star.script.
  import sample.factorial.

  main:(integer)=>action[(),()].
  main(Ix) => do@{
    logMsg("Factorial of $(Ix) is $(fact(Ix))")
  @}
@}
@end example

Once compiled, the program is executed using the @code{star} engine:
@example
$ sc sample.main
$ star sample.main 10
Factorial of 10 is 3628800
$
@end example

If you are used to other programming languages, you might have spotted
something a little unusual here: the type signature for @code{main}
denotes a function that accepts an @code{integer} and returns an
@code{action}. We will explore actions further in @ref{The `M' Word};
but I would like to point something else out here: @code{main} accepts
an @code{integer} whereas the main program in most other programming
languages looks like an array of string values.

@Star{} takes the signature for @code{main} and makes sure that the
command line arguments can be coerced to the appropriate types.



@node Texture
@section Texture

All programming languages can be said to have a particular
@emph{style} or @emph{texture}. This is often so strong that it is
often possible to identify a programming language from a single line
of source code. In our case, this line might be:

@example
public fact : (integer)=>integer.
@end example
which is a @emph{type annotation statement} declaring the type of the
function @code{fact}.

The @code{public} annotation means that the function is exported by
this module and will be available in other modules where the
@code{sample.factorial} module is imported.

@node Lexical style
@subsection Lexical style

It can be difficult for language designers to decide when to use a
keyword and when to use a special operator. We use special operators
for common elements and keywords when either a graphical operator
would be obscure and/or is not common.

For example, in the factorial module, we use braces for grouping; but
we also use the @code{import} and the @code{where} keywords. The
rationale here is that programmers have become used to seeing braces
for grouping statements;@footnote{Those who remember Pascal@footnote{Or Algol 60} will
understand that braces are not the only way of grouping statements.}
whereas the import and where elements are somewhat rarer.

Notice that every statement is terminated with a period. This is one
of those places where a little redundancy can help when building large
programs: the statement terminator is not technically necessary; but
it helps to reduce the scope of error messages.@footnote{We use the
period rather than the commonly used semi-colon because @Star{}
statements are statements, not instructions to perform in sequence.}

@quotation NOTE
The precise rule is slightly more nuanced: a period is required to
terminate a statement; unless the last character of the statement is a
closing brace -- or unless the statement is itself the last statement
in a brace sequence.@footnote{This is one of those somewhat pedantic
notes!}
@end quotation

Another aspect of @Star{}’s texture that may not be visible at this
stage is the reliance on an underlying meta-grammar -- specifically on
an @emph{operator precedence grammar}. OPGs are likely already
familiar to you: it is the almost universally used grammar that
underpins arithmetic expressions. We take the OPG and stretch its use
to include the whole language.

@node Types
@subsection Types
@Star{} is a strongly, statically typed language. This means that all
variables and expressions have a single type; and that all type
constraints are enforceable at compile-time. This is a fairly strong
(sic) statement but we need everything to be well typed and we also
want to guarantee completeness of the type system.

The type annotation statement:
@example
fact : (integer)=>integer.
@end example

is a statement that declares that the type of @code{fact} is a
function of one integer argument and which returns an integer result.

Programmers are encouraged, but not required to, attach explicit type
annotations to most programs. The precise rule is a little subtle:
variables whose type are not quantified @emph{may} have their type
automatically inferred. For top-level functions, that annotation is
often contiguous in the text; but in other cases that may not be the
case.

Other variables -- like the variable @code{N} which is part of the
second recursive equation -- do not need type annotations. This is
possible because underlying the type system is a powerful @emph{type
inference} system that can actually infer all types.

The result is that a lot of the `clutter' that can pervade a strongly
typed language is just not necessary; but the use of explicit type
annotations for top-level definitions provides useful structure and
documentation.

Note that the requirement is that quantified @emph{definitions} have
explicit type annotations. We don’t distinguish functions in any way
here. In particular, functions which are @emph{not} generic -- for
example lambda functions -- do not need type annotations.

@node Rules
@subsection Rules

Most programs are defined using @emph{rules}. In this
case, @code{fact} is defined using @emph{equations}. The equations
that make up a function definition (or any program definition for that
matter) are statements that are written in order.

Rule-based programs support a @emph{case driven} approach to
programming: a program is defined in terms of the different cases or
situations that apply. Using rules to cover different cases allows the
programmer to focus on each case in relative isolation.

In addition, as we shall see later on, the partitioning of programs
into cases like this is very helpful in supporting large-scale issues
such as code annotations, versioning and life-cycle management.

There are various kinds of rules, including function definitions,
grammar definitions, variable definitions and type definitions.

@node Patterns
@subsection Patterns
Patterns are ubiquitous in @Star{}: they form the basis of many rules:
including, most importantly, to define equations. In fact, @emph{all}
variables are introduced by means of patterns.

A pattern can be viewed as a combination of a test --- does a value
match a particular pattern --- and as a way ( @emph{the} way) of
binding a variable to a value.

An equation’s pattern defines when the equation is applicable. The
first equation for @code{fact} above:

@example
fact(0) => 1.
@end example
has a literal pattern on the left hand side of the @code{=>}
operator. This equation only applies when @code{fact} is called with
zero as its argument.

The pattern in the second equation:
@example
fact(N) where N>0 => N*fact(N-1).
@end example

has a guard on it --- after the @code{where} keyword. Guards are
additional conditions that constrain patterns. In this case, the
equation only applies if the argument is greater than zero.

Any pattern may be qualified with a guard; we could have written the
guard @emph{inside} the argument pattern:

@example
fact(N where N>0) => N*fact(N-1).
@end example

We did not because having the guard outside the arguments is neater.

@quotation NOTE
The @code{fact} function’s equations are not fully covering: there are
no cases for @code{fact} for negative numbers. This means that the
function is @emph{partial}; and if called with a negative number will
result in a run-time trap.
@end quotation

@node Packages
@subsection Packages

The normal compilation unit is a @emph{package}. The sample.factorial
package contains just the function fact, but packages can contain
functions, type definitions, import statements and many other elements
that we will encounter.

Package names and references to packages do not refer to file names;
package names are symbolic -- in general a package name consists of a
sequence of identifiers separated by periods.

The @emph{catalog} and @emph{repository} system explored in Chapter 7
that supports the language ensures a proper connection between files
and packages.

@c @node Worksheets
@c @subsection Worksheets

@c The other main kind of compilation unit is the
@c @emph{worksheet}. Worksheets are a modern replacement for the
@c REPL@footnote{Read-Eval-Print-Loop} that you see in many functional
@c programming languages.

@c We say a @emph{modern} replacement for REPLs because worksheets fit
@c much better in the typical environment of an IDE.

@c A worksheet can be used to implement the infamous hello world example
@c in just a few lines:

@c @example
@c worksheet@{
@c   show "hello world".
@c @}
@c @end example

@c We can also use a worksheet to display the results of using and
@c testing our fact function:

@c @example
@c worksheet@{
@c   import sample.factorial.
@c   show "fact(10) is $(fact(10))".
@c   assert fact(5) == 120.
@c @}
@c @end example

@c Worksheets are like a combination of a module and the transcript of a
@c session. In an IDE, the ideal mode of displaying a worksheet is via an
@c interactive editor that responds to edit changes by recomputing the
@c transcript and displaying the results in-line.

@c The key features of a worksheet that we will use are the ability to
@c import packages, define elements, show the results of computations and
@c define assertions.

@node String interpolation
@subsection String interpolation

The expression
@example
"fact(10) is $(fact(10))"
@end example
is an @emph{interpolated string} expression. It means the string
@code{"fact(10) is $(fact(10))"} with the substring @code{(fact(10)}
replaced by the value of the expression embedded within. Interpolated
string expressions are a convenient way of constructing string values;
and, via the use of contracts, are also type safe.

@node Types more types and even more types
@section Types, more types and even more types

In many ways, the defining characteristic of a programming language is
the approach to types. As we shall see, @Star{}’s type system is quite
extensive and powerful; however, simple types are quite
straightforward.

The most basic question to ask about types is

@quotation
What is a type?
@end quotation

There is some surprising variability to the answer to this question;
for example, in many OO languages, types are conflated with
classes. @Star{} types are terms -- i.e., names -- that denote
different kinds of values.

@quotation Type
A type is a term that denotes a collection of values.@footnote{Not a
set of values because not all collections of values are mathematical
sets.}
@end quotation

The type system can be broken down into a number of dimensions:

@itemize
@item
How legal values of various kinds can be identified with a type;
@item
the treatment of type variables and quantifiers; and
@item
constraints on types, particularly type variables
@end itemize

We distinguish two basic styles of type: so-called @emph{structural}
or transparent types and @emph{nominative} or opaque types. A
structural type term echoes the values it models, whereas a nominative
type typically does not.

For example, the standard type @code{integer} is nominative --- its
name gives no hint as to the representation, structure or kinds of
values that are modeled by integer.@footnote{I.e., everything you
thought you knew about integers may or may not apply to the values
denoted by integer.} However, a nominative type often @emph{names} some
actual entity being modeled -- in this case integer values. Two
nominative types which have different names always denote distinct
values, whereas two structural types that look the same are actually
identical.

@node Nominative types
@subsection Nominative types

A nominative type is normally defined using an @emph{algebraic type
definition}. This both introduces a type and defines all the legal
values that belong to the type. For example, we might introduce a
@code{Person} type with the type definition:

@example
Person ::= .noOne
         | someOne@{
             name : string.
             dob : date.
           @}
@end example

This statement tells us that there are two kinds of @code{Person}: a
@code{someOne} who has a @code{name} and date of birth (@code{dob})
associated with them; and a distinguished individual we identify as
@code{.noOne}. The no-one individual @emph{does not} have a name or
date of birth.

@quotation
Note that the @code{.noOne} symbol has a period in front of it. This
is used to distinguish enumerated symbols from other variables.
@end quotation


@quotation
Notice how the type annotation statement we saw for declaring the type
of @code{fact} is also used for defining the types of fields in the
@code{someOne} record.
@end quotation

We can @emph{make} a Person value with a labeled record expression:

@example
S = someOne@{
  name = "fred".
  dob = today()
@}
@end example

The equality symbol is used to introduce a new single-assignment
variable. In this case the variable @code{S} is defined to be a
@code{someOne} record.

Recall that names do not always require an explicit type
annotation. In this case we can infer that @code{S} is a @code{Person}
(because @code{someOne} marks it). Furthermore, we do not need to
explicitly give types to the @code{name} and @code{dob} fields because
their type is constrained by the type declaration for @code{Person}.

@node Reference Type
@subsection Reference Type

@noindent
An important detail about the @code{someOne} record defined above is
that the fields within it are not re-assignable. If we want to make a
variable reassignable, or if we want to make a field of a record
reassignable, we use a special @code{ref} type to denote that. For
example, the type definition

@example
employee ::= employee@{
  dept : ref string.
  name : string
@}
@end example

allows the @code{dept} field within the employee record to be
modifiable -- although the employee's name is still fixed.

Only fields that have a @code{ref} type are modifiable in
records. This is even true when a record is assigned to a reassignable
variable.

A reassignable variable is declared using the @code{:=} operator:

@example
N := employee@{
  dept := "your department".
  name = "Anon. Y. Mouse"
@}
@end example

Since the variable @code{N} is declared as being reassignable, we can
give it a new value:

@example
N := employee@{
  dept := "another".
  name = "some one"
@}
@end example

We can also modify the @code{dept} field of @code{N}:

@example
N.dept := "new department".
@end example
However, we cannot modify the @code{name} field -- because it is not
re-assignable within the @code{Person} type.

Notice that the re-assignability of variables and fields does not
inherit: each field or variable is separate. So, for example, if we
declared a single-assignment variable @code{D} to be an employee:

@example
D = employee@{
  dept := "his department".
  name = "Your Name Here"
@}
@end example

then, even though @code{D} itself cannot be re-assigned to, the
@code{dept} field of @code{D} @emph{can} be altered:

@example
D.dept := "my department"
@end example

@node Accessing Reference Variables
@subsubsection Accessing Reference Variables

The value of a re-assignable variable is accessed using the @code{!}
operator. For example:
@example
D.dept!
@end example
will retrieve the actual department @var{D} is assigned to. The
expression @code{D.dept} actually means something different -- it
denotes the @emph{container} for the department.

@node Structural types
@subsection Structural types

A structural type is, informally, a type that looks like a value. For
example, the type

@example
(integer,string,employee)
@end example
is a @emph{tuple type} -- it denotes the type of a triple of values,
consisting of an @code{integer}, a @code{string} and an
@code{employee} in this case. Values of this tuple type are also
tuples; for example:
@example
(3,"fred",employee@{name="peter". dept:="sales"@})
@end example

There are several forms of structural type, the tuple type is one of
them; others include @emph{record types} and @emph{function types}.

We shall see more of these as we introduce the rest of the
language. However, it is worth pausing to ask the question @emph{Why
do we have both structural and nominative types}?

Briefly, nominative types help the programmer focus on what a value
@emph{denotes}; whereas structural types tend to expose what a value
can @emph{do}.

For example, the @code{employee} type clearly points to what an
employee value is intended to denote (an employee!), but does not help
if we want to know what an employee can do. Nor does it expose what
information we are using to model employees. On the other hand, the
function type in the annotation:

@example
f : (integer)=>string
@end example

clearly indicates what one can use @code{f} for, but it does not
indicate anything about why you would want to (except, perhaps, to
convert an @code{integer} to a @code{string}).

In summary, use nominative types when you are modeling real world
entities and structural types when the focus is on operations and
structure more than on what the intention is. In practice, of course,
you will use both in some combination.

@node Optional values
@subsection Optional values
Notice that we identified a special case of @code{.noOne} in our
@code{Person} type. One reason for including this in a type is to be
able to cope with non-existent people. However, this approach is not
always the most effective one when modeling situations where a
variable or field may not have a value.

Explicit null values, as found in C++ and similar languages, cause a
great number of problems: for example, null must have a special
universal type; there are many scenarios where it is not possible for
a variable to be null but the compiler must discover those for itself;
and there is often a consequent tendency in defensive programming to
test for null.

There is no direct equivalent of a global @emph{null} value. However,
the standard @code{option} type allows the equivalent of selective
nullability. Any variable that might not have a proper value can be
marked with the option type rather than the underlying type. And you
can use @code{.none} in those cases to indicate the equivalent of no
value.

So, for example, suppose that a @code{Person} might have a
@code{spouse} --- who is also a @code{Person} --- but is not
guaranteed to have one. Such a type can be described using:

@example
Person ::= someOne@{
  name : string.
  dob : date.
  spouse : ref option[Person].
@}
@end example

Here we have done two things: we have eliminated the @code{.noOne} case
for @code{Person} and we have marked the @code{spouse} as being both
read-write and @code{option}al.

Someone with no spouse would be written:

@example
freddy = someOne@{
  name = "Freddy".
  dob = today().
  spouse := .none
@}
@end example

whereas someone who has a spouse would be written:

@example
someOne@{
  name = "Lisa".
  dob = lastYear.
  spouse := some(johnny)
@}
@end example

Of course, we can record @code{freddy}’s marriage to @code{lisa} using
an assignment:

@example
freddy.spouse := some(lisa)

lisa.spouse := some(freddy)
@end example
although such circular structures should be avoided where possible.

@node The flavors of equality
@subsection The flavors of equality

Equality in programming languages is typically a very subtle
topic. The issues can range from the approximate nature of floating
point numbers, the difference between integers and long values and the
multiple potential concepts of equality for objects.

Equality is always between values of the @emph{same type} and it is
always @emph{semantic}. So, for example, an equality condition such
as:

@example
3==3.0
@end example
is not considered type safe --- because @code{3} is an @code{integer}
literal and @code{3.0} is a @code{float} literal. If you need to
compare an integer and a floating point number for equality you will
need to first of all decide in which type the comparison will be made
(integer or floating point equality) and then @emph{coerce} the other
value into that type:
@example
3 :: float == 3.0
@end example
is valid@footnote{The expression @code{3::float} is a coercion
expression that converts the integer @code{3} into a float value.}
excepting, of course, that exact comparison between floating point
numbers is not @emph{stable}.

This is an important issue because not all integer values can be
represented in a float value and vice-versa. So, comparing an integer
and a floating point value raises the possibility of spurious accuracy
as a result of losing information. The intended effect of the coercion
is to make explicit the nature of equality being relied on.

The second principle is that equality is semantic. What that means is
that the @code{==} symbol is the name of a @code{boolean}-valued
function. The precise type of @code{==} is quite interesting, we
shall, however, leave it to later when we have covered some of the
core type features around contracts.

In effect, equality is @emph{not} considered to be privileged; and it
is definable by the programmer --- albeit with some important useful
default implementations.

@node A tale of three loops
@section A tale of three loops
Imagine that your task is to add up a list of numbers. Sounds simple
enough: in most procedural or OO languages (such as Java) one would
write a fragment of code that looks like:

@example
int total = 0;

for(Integer ix:L)
  total += ix;
@end example
However, this code is also full of pitfalls. For one thing we have a
lot of extra detail in this code that represents additional
commitments beyond those we might be comfortable with:

@itemize
@item
we have had to fix on the type of the number being totaled;
@item
we had to know about Java’s boxed v.s. unboxed types; and
@item
we had to construct an explicit loop, with the result that we
sequentialized the process of adding up the numbers.
@end itemize

We can also write an equivalent loop in @Star{}:

@example
total = valof action@{
  tot .= ref 0;
  for ix in L do
    tot := tot+ix;
  valis tot
@}
@end example

The valof/valis combination is a neat way of segueing from the `world
of expressions' into the `world of actions'.

Some special features of this notation may not be familiar:

@itemize
@item
A reassignable variable is declared in an action sequence using the form:
@example
tot .= ref 0
@end example
This is doing two separate things: declaring the variable @code{tot}
-- in the context of an action sequence -- and making it re-assignable
-- using the expression @code{ref 0}.

@item
Semi-colons are using to separate actions -- and they are not
optional: they denote a sequence of actions.

@item
The action @code{for ix in L do @dots{}} is an @emph{iterative} action
that performs the action for every element of @code{L} that matches
the pattern @code{ix}. I.e., it is entirely possible to use a more
complex pattern here -- which would have the effect of filtering the
source. For example, we could total up positive numbers in @code{L}
using:

@example
for (ix where ix>0) in L do
  tot := tot+ix
@end example

@item
The value of the @code{action} expression is denoted by the action
@code{valis tot}. This may appear anywhere in an action sequence --
with the proviso that it always denotes the end of the action: no
actions may logically follow the @code{valis}.
@end itemize

This program is essentially equivalent to the Java loop; although
there are some subtleties about the nature of valof/valis that go
beyond Java. As a result, it has similar architectural issues.

While one loop is not going to hurt anyone; real code in languages
like Java typically has many such loops. Especially when nesting loops
to any depth, such code quickly becomes impossible to follow.

@node A functional loop
@section A functional loop

A more idiomatic way of expressing a computation like the totalizer is
to use a function. For example, we can write:

@example
let@{
  total:(cons[integer])=>integer.
  total(nil) => 0.
  total(cons(E,L)) => total(L)+E
@} in total(L)
@end example
while short, this code too has some of the same drawbacks as the for iteration.

The type expression @code{cons[integer]} refers to the standard type
of `cons lists'. Similarly, @code{nil} refers to the empty list and
@code{cons(E,L)} refers to the list obtained by prepending @code{E} to
the list @code{L}. We will explore this in more detail in
@pxref{Functional Programming}.

Even if it is more declarative, there is still a lot of extra detail
and architectural commitments here --- like the commitment to
@code{cons} lists and the commitment to @code{integer}s. These result in a
function that is needlessly restricted.

Like other functional languages, @Star{} has a range of higher-order
operators that may come to the rescue. For example, we can avoid the
explicit recursion altogether by using @code{leftFold}:

@example
total = leftFold((+),0,L)
@end example
where @code{leftFold} means

@quotation
apply a left associative accumulating function to the elements of the
data, assuming that the applied operator is left associative.
@end quotation

This expression is clearly both more concise and higher-level than
either the explicit loop or the explicit recursion; and it begins to
illustrate the productivity gains that are potentially available to
the functional programmer.

Using @code{leftFold} means that we can often abstract away the
machinery of loops and recursion completely --- instead we can solve
the problem at a more holistic level. This is one of the hallmarks of
functional programming -- it is possible to eliminate many instances
of explicit loops and recursions.

@c @node A totalizer query
@c @subsection A totalizer query

@c While concise, expressions involving much use of @code{leftFold} (and
@c the analogous @code{rightFold}) can be difficult to follow. An even
@c clearer way of adding up numbers is to use a @emph{query expression}:

@c @example
@c total = @{fold X with (+) | X in L@}
@c @end example
@c This query expression frees us from most of the commitments we endured
@c before: it can add up the elements of any kind of collection --- not
@c just @code{cons} lists --- and it can add up floating point numbers
@c just as easily as integers. Finally, we have not had to say exactly
@c how the numbers should be added up: the language system is free to use
@c a parallel algorithm for the computation should it be more optimal.

@c The query expression is also very close to the natural specification:

@c @quotation
@c Add up the numbers in L
@c @end quotation

@c Query expressions --- which are similar to but also more expressive
@c than LINQ --- can be used to encapsulate a wide range of such
@c computations.

@c @quotation
@c Of course, SQL programmers have long had access to this kind of
@c conciseness and declarative expressiveness. However, SQL is
@c constrained by the fact that it is intended to represent queries and
@c actions over a very particular form of data --- the relational table.
@c @end quotation

@node The homunculus in the machine
@subsection The homunculus in the machine

@noindent
Programming is often taught in terms of constructing sequences of
steps that must be followed. What does that imply for the programmer?
It means that the programmer has to be able to imagine what it is like
to be a computer following instructions.

It is like imagining a little person --- a homunculus --- in the
machine that is listening to your instructions and following them
literally. You, the programmer, have to imagine yourself in the
position of the homunculus if you want to write effective programs in
most languages today.

Not everyone finds such feats of imagination easy. It is certainly
often tedious to do so. Using query expressions and other higher-order
abstractions significantly reduces the programmer’s burden ---
precisely by being able to take a more declarative approach to
programming.

@node Contracts and constrained types
@section Contracts and constrained types

@noindent
The concepts of interface and contract are foundational in modern
software engineering. This is because explicit interfaces make it
substantially easier to develop and evolve systems. A contract goes
beyond the traditional concept of interface in important ways: we do
not mark the definition of a type with its implemented contracts and
we allow contracts to involve multiple types.

A contract defines a collection of signatures and an implementation
provides specific implementations for those functions for a specific
type (or type combination).

For example, we can imagine a contract for simple four function
calculator arithmetic containing definitions for the basic four
functions of addition, subtraction, multiplication and division:

@example
contract all t ~~ four[t] ::= @{
  plus : (t,t)=>t.
  sub : (t,t)=>t.
  mul : (t,t)=>t.
  div : (t,t)=>t.
@}
@end example

This contract defines --- but does not implement --- the four
calculator functions @code{plus}, @code{sub}, @code{mul} and
@code{div}. All these functions have a similar type, the type for
@code{plus} is:

@example
plus :  all t ~~ four[t] |: (t,t)=>t.
@end example

The clause @code{four[t] |:} is a @emph{type constraint}, specifically
a @emph{contract constraint}. So, these functions are generic
(universally quantified) but the bound type (@code{t}) has the
additional constraint that there must be an implementation for
@code{four} for @code{t}.

The @code{four} contract defines a set of functions that can be used
without necessarily knowing the type(s) that are involved. For
example, we can define the @code{double} function in terms of
@code{plus}:

@example
double(X) => plus(X,X).
@end example

@noindent
The type of @code{double} reflects the fact that we are using elements
from the @code{four} contract:
@example
double : all t ~~ four[t] |: (t)=>t.
@end example
I.e., it inherits the same constraint as the function @code{plus}
has. There are several kinds of type constraint; but the
@emph{contract constraint} is the most significant of them.

@quotation
Notice that we have to give an explicit type annotation for
@code{double}. The reason is that we want to have it have a quantified
type.@footnote{More accurately, there is a restriction/design choice
that type inference can be used to infer @emph{monomorphic} types but
not @emph{polymorphic} types.}
@end quotation

@node Implementing contracts
@subsection Implementing contracts

Defining a contract is a big step, but it is not generally sufficient
to produce working programs. If we had a package containing
only:

@example
some.pkg@{
  import star.
  import star.script.
  
  contract all t ~~ four[t] ::= @{
    plus : (t,t)=>t.
    sub : (t,t)=>t.
    mul : (t,t)=>t.
    div : (t,t)=>t.
  @}

  double : all t ~~ four[t] |: (t)=>t.
  double(X) => plus(X,X).

  main()=> action@{
    show double(2)
  @}
@}
@end example

we would get a compiler error along the lines of:

@example
2:integer
  which is not consistent with
  display[t_12] , four[t_12] |: t_12
  because four[integer] not known to be implemented
@end example

This error message is effectively warning us that we have defined the
@code{four} contract but we have not implemented it. Until we do, the
program is not complete. However, if we do supply an implementation of
four over @code{integer}s:
@example
some.pkg@{
  import star.
  import star.script.
  
  contract all t ~~ four[t] ::= @{
    plus : (t,t)=>t.
    sub : (t,t)=>t.
    mul : (t,t)=>t.
    div : (t,t)=>t.
  @}

  double : all t ~~ four[t] |: (t)=>t.
  double(X) => plus(X,X).

  implementation four[integer] => @{
    plus(x,y) => x+y.
    sub(x,y) => x-y.
    mul(x,y) => x*y.
    div(x,y) => x/y.
  @}

  main()=> action@{
    show double(2)
  @}
@}
@end example

then everything works as expected.

Notice that the error message above shows that type @code{t_12}
actually has two type constraints:

@example
display[t_12] , four[t_12] |: t_12
@end example

This is because the @code{show} action also results in a type
constraint being involved. The @code{display} contract is used to
display values in a number of circumstances; including the string
formatting we saw above.

As may be expected, arithmetic itself is also mediated via the
arithmetic contract. This is how we can support multiple
numeric types using a common set of operators: there are standard
implementations of arithmetic for integers, and floating point
numbers.

@node Coercion not casting
@subsection Coercion, not casting

@Star{} does not support type casting, as found in languages like Java
and C/C++. This is for many reasons, not the least of which is safety
and predictability of code.

Casting in many languages is really two kinds of operations-in-one
which we can refer to as @emph{casting} and @emph{coercion}. Casting
is mapping of a value from one type to another without changing the
value itself; and coercion involves converting a value from one type
to another.

For example, the Java cast expression:
@example
(Person)X
@end example
amounts to a request to verify that @code{X} is actually a
@code{Person} object. In particular, this only checks the value of
@code{X} to see if it is a @code{Person}. On the other hand, casting
an integer to a floating point number involves changing the value to
conform to the floating point representation.

However, coercion in @Star{} is never silent or implicit -- as it can
be in Java and C/C++. An expression of the form:
@example
3+4.5
@end example
will fail to type -- because there is an attempt to add an integer to
a floating point number.

The reason for signaling an error is strongly related to safety and
predictability: automatic conversion of integers to floating point can
be a common source of errors in languages like C -- because such
coercions are not always guaranteed to be semantics preserving (not
all integers can be represented as floating point values). The
implicit coercion of numeric values is easy to miss when reading
arithmetic expressions.

We have a coercion notation that allows programmers to be precise in
their expectations:

@example
(3 :: float)+4.5
@end example
denotes the explicit coercion of the integer @code{3} to a
@code{float} and type checks as expected.

In fact, type coercion is mediated via a contract and this expression
is equivalent to
@example
(_coerce(3):float)+4.5
@end example
where @code{_coerce} is defined in the @code{coercion} contract
involving two types:

@example
contract all s,t ~~ coercion[s,t] ::= @{
  _coerce :: (s)=>t
@}
@end example

The @code{coercion} contract is an interface, but has no analog in
most OO languages: it involves two types -- the source type and the
destination type. Each implementation of coercion specifies both
types. For example, the implementation of coercion between integers
and floating point is explicitly given:
@example
implementation coercion[integer,float] => @{ @dots{} @}
@end example
This statement gives the implementation for coercing integers to
floats. Other implementation statements give the definitions for other
forms of coercion.

Having coercion as a contract makes it straightforward to add new
forms of coercion. This is used quite extensively within @Star{}
itself: for example, parsing JSON can be viewed as coercion from
string values to @code{json} values. Thus the interface to parsers can
be standard across all types and parsers.

@node Actions
@section Actions

@Star{} is primarily intended to be a functional programming
language. The preferred phrase is @emph{functional first}. However,
even in functional programming, sequence can be important.

The way that we handle sequential computation is a little
idiosynctratic: actions are entities that are created separately from
being performed. This is based on the standard @code{execution}
contract@footnote{Which is actually a richer version of the
@code{monad} contract.}

The basic concept is that one uses expressions to build up an action
entity and then evaluates that entity -- and often also extract a
returned value from the computation.

Actions can be constructed from primitive elements, but the normal
method is to use the @code{do} notation. For example, this @code{do}
expression can be used to compute factorial (somewhat laboriously):

@example
AA = do@{
    Cx := 1;
    Fx := 1;
    while Cx!=<Lx do @{
      Fx := Fx! * Cx!;
      Cx := Cx! + 1
    @};
    valis Fx!
  @}
@end example

Not all @code{do} expressions will involve using re-assignable
variables, but nearly all use of re-assignable variables is in the
context of @code{do} expressions.

It is important to note that a @code{do} expression does not directly
compute its value: instead, it is an expression that @emph{denotes} a
computation. So, @code{AA} above is not an @code{integer} but a
computation that will produce an integer.

To run a computation and to get its value we use the @code{valof} operator:

@example
FF = valof AA
@end example

There are actually several variants of computation expressions, all
based on the same fundamental structure; two of the most important are
the @code{action} expression and the @code{task} expression.

@code{action} expressions are used to represent normal sequential
computations and @code{task} expressions are used to represent
concurrent computations; both of which we will explore later on in the
book.

@node There is more
@section There is more

As we have noted, @Star{} is a rich language and it would be
impossible to try to cover it in a short introduction. Later chapters
will look at some of the other features such as a deeper look at
contracts, queries & query rules, actors, concurrency, existential
types, and extending @Star{} with domain specific languages. The next
chapter (@refer{Functional Programming}) starts this process by looking
at functional programming.
