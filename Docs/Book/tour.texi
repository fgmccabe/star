@node A tour of Star
@chapter A tour of Star

Our first task is to introduce you to the @Star{} language. It is
difficult to find the right order in which to present a programming
language like @Star{}; this is because many of the features are highly
inter-related. For example, types depend on values which depend on
functions which depend on types!

Instead, our approach in this book is to take a series of horizontal
slices through the whole language; going progressively deeper as you
become more comfortable with the language. Each layer represents a
reasonably workable subset of the complete language.

Since a layered approach means that any given description may be
incomplete or slightly inaccurate, there is a temptation to use
footnote annotations which declare '@dots{} but there is
also@footnote{Please forgive these pedantic notes when you see them.}
@dots{}'.

@node A first Star program
@section A first Star program

It is traditional to introduce a new programming language with
something like the hello world example. Which we will do in a
moment. However, the factorial function often makes a better first
example for functional programming languages:

@example
sample.factorial@{
  import star.               -- Access standard language features

  public fact : (integer)=>integer.
  fact(0) => 1.              -- base case
  fact(N) where N>0 => N*fact(N-1).
@}
@end example

This is not an executable program per se.; however, it does represent
a more typical source code unit -- most programs are built from many
smaller modules which come together to make the application. This
program is small, but already introduces many of the key elements of
the @Star{} language.

In this module, we see the name of the module --
@code{sample.factorial} -- an import statement and a function
definition -- of the @code{fact} function.

Source code can be in any form of textual container. There is, for
example, no specific requirement that this @code{sample.factorial}
package be in a file called @code{factorial.star}; although that may
be good advice. Instead, the @Star{} system relies on a @emph{catalog
based} system that maps package names to text entities. The catalog
system also serves as an anchor point in the version management of
@Star{} programs. We will cover this, and the related repository
system for generated artifacts, in Chapter 4.

@node Texture
@section Texture

All programming languages can be said to have a particular
@emph{style} or @emph{texture}. This is often so strong that it is
often possible to identify a programming language from a single line
of source code. In the case of @Star{}, this line might be:

@example
public fact : (integer)=>integer.
@end example
which is a @emph{type annotation statement} declaring the type of the
function @code{fact}.

The @code{public} annotation means that the function is exported by
this module and will be available in other modules where the
@code{sample.factorial} module is imported.

@node Lexical style
@subsection Lexical style

@Star{}’s lexical syntax uses a combination of special operators and
keywords.

It can be difficult for language designers to decide when to use a
keyword and when to use a special operator. In the case of @Star{} we
use special operators for common elements and keywords when either a
graphical operator would be obscure and/or is not common.

For example, in the factorial module, we use braces for grouping; but
we also use the @code{import} and the @code{where} keywords. The
rationale here is that programmers have become used to seeing braces
for grouping statements;@footnote{Those who remember Algol 60 will
understand that braces are not the only way of grouping statements.}
whereas the import and where elements are somewhat rarer.

Notice that every statement is terminated with a period. This is one
of those places where a little redundancy can help when building large
programs: the statement terminator is not technically necessary; but
it helps to reduce the scope of error messages.@footnote{We use the
period rather than the commonly used semi-colon because @Star{}
statements are statements, not instructions to perform in sequence.}

@quotation NOTE
The precise rule is slightly more nuanced: a period is required to
terminate a statement; unless the last character of the statement is a
closing brace -- or unless the statement is itself the last statement
in a brace sequence.@footnote{This is one of those somewhat pedantic
notes!}
@end quotation

Another aspect of @Star{}’s texture that may not be visible at this
stage is the reliance on an underlying meta-grammar -- specifically on
an @emph{operator precedence grammar}. OPGs are likely already
familiar to you: it is the almost universally used grammar that
underpins arithmetic expressions. We take the OPG and stretch its use
to include the whole language. The relevance of this will be apparrent
when we look at @emph{extending} @Star{} with new language features.

@node Types
@subsection Types
@Star{} is a strongly, statically typed language. This means that all
variables and expressions have a single type; and that all type
constraints are enforceable at compile-time. This is a fairly strong
(sic) statement but it is a key aspect of @Star{}’s design -- we need
everything to be well typed and we also want to guarantee completeness
of the type system.

The type annotation statement:
@example
fact : (integer)=>integer.
@end example

is a statement that declares that the type of @code{fact} is a
function of one integer argument and which returns an integer result.

@Star{} encourages, but does not require, most programs to have
explicit type annotations. The precise rule is a little subtle:
variables whose type are not quantified @emph{may} have their type
automatically inferred. For top-level functions, that annotation is
often contiguous in the text; but in other cases that may not be the
case.

Other variables -- like the variable @code{N} which is part of the
second recursive equation -- do not need type annotations. This is
possible because underlying the type system is a powerful @emph{type
inference} system that can actually infer all types.

The result is that a lot of the `clutter' that can pervade a strongly
typed language is just not necessary; but the use of explicit type
annotations for top-level definitions provides useful structure and
documentation.

Note that the requirement is that quantified @emph{definitions} have
explicit type annotations. We don’t distinguish functions in any way
here. In particular, functions which are @emph{not} generic -- for
example lambda functions -- do not need type annotations.

@node Rules
@subsection Rules

In @Star{}, most programs are defined using @emph{rules}. In this
case, @code{fact} is defined using @emph{equations}. The equations
that make up a function definition (or any program definition for that
matter) are statements that are written in order.

Rule-based programs support a @emph{case driven} approach to
programming: a program is defined in terms of the different cases or
situations that apply. Using rules to cover different cases allows the
programmer to focus on each case in relative isolation.

In addition, as we shall see later on, the partitioning of programs
into cases like this is very helpful in supporting large-scale issues
such as code annotations, versioning and life-cycle management.

@Star{} has various kinds of rules, including function definitions,
grammar definitions, variable definitions and type definitions.

@node Patterns
@subsection Patterns
Patterns are ubiquitous in @Star{}: they form the basis of many rules:
including, most importantly, to define equations. In fact, @emph{all}
variables are introduced by means of patterns.

A pattern can be viewed as a combination of a test --- does a value
match a particular pattern --- and as a way ( @emph{the} way in
@Star{}) of binding a variable to a value.

An equation’s pattern defines when the equation is applicable. The
first equation for @code{fact} above:

@example
fact(0) => 1.
@end example
has a literal pattern on the left hand side of the @code{=>}
operator. This equation only applies when @code{fact} is called with
zero as its argument.

The pattern in the second equation:
@example
fact(N) where N>0 => N*fact(N-1).
@end example

has a guard on it --- after the @code{where} keyword. Guards are
additional conditions that constrain patterns. In this case, the
equation only applies if the argument is greater than zero.

Any pattern may be qualified with a guard; we could have written the
guard @emph{inside} the argument pattern:

@example
fact(N where N>0) => N*fact(N-1).
@end example

We did not because having the guard outside the arguments is neater.

@quotation NOTE
The fact function’s equations are not fully covering: there are no cases for fact for negative numbers. This means that the function is @emph{partial}; and if called with a negative number will result in a run-time exception.
@end quotation

@node Packages
@subsection Packages

The normal compilation unit is a @emph{package}. The sample.factorial
package contains just the function fact, but packages can contain
functions, type definitions, import statements and many other elements
that we will encounter.

Package names and references to packages do not refer to file names;
package names are symbolic -- in general a package name consists of a
sequence of identifiers separated by periods.

The @emph{catalog} and @emph{repository} system explored in Chapter 7
that supports the language ensures a proper connection between files
and packages.

@node Worksheets
@subsection Worksheets

The other main kind of compilation unit is the
@emph{worksheet}. Worksheets are a modern replacement for the
REPL@footnote{Read-Eval-Print-Loop} that you see in many functional
programming languages.

We say a @emph{modern} replacement for REPLs because worksheets fit
much better in the typical environment of an IDE.

A worksheet can be used to implement the infamous hello world example
in just a few lines:

@example
worksheet@{
  show "hello world".
@}
@end example

We can also use a worksheet to display the results of using and
testing our fact function:

@example
worksheet@{
  import sample.factorial.
  show "fact(10) is $(fact(10))".
  assert fact(5) == 120.
@}
@end example

Worksheets are like a combination of a module and the transcript of a
session. In an IDE, the ideal mode of displaying a worksheet is via an
interactive editor that responds to edit changes by recomputing the
transcript and displaying the results in-line.

The key features of a worksheet that we will use are the ability to
import packages, define elements, show the results of computations and
define assertions.

@node String interpolation
@subsection String interpolation

The expression
@example
"fact(10) is $(fact(10))"
@end example
is an @emph{interpolated string} expression. It means the string
@code{"fact(10) is $(fact(10))"} with the substring @code{(fact(10)}
replaced by the value of the expression embedded within. Interpolated
string expressions are a convenient way of constructing string values;
and, via the use of contracts, are also type safe.

@node Types more types and even more types
@section Types, more types and even more types

In many ways, the defining characteristic of a programming language is
the approach to types. As we shall see, @Star{}’s type system is quite
extensive and powerful; however, simple types are quite
straightforward.

The most basic question to ask about types is

@quotation
What is a type?
@end quotation

There is some surprising variability to the answer to this question;
for example, in many OO languages, types are conflated with
classes. @Star{} types are terms -- i.e., names -- that denote
different kinds of values.

@quotation Type
A type is a term that denotes a collection of values.@footnote{Not a
set of values because not all collections of values are mathematical
sets.}
@end quotation

@Star{}’s type system can be broken down into a number of dimensions:

@itemize
@item
How legal values of various kinds can be identified with a type;
@item
the treatment of type variables and quantifiers; and
@item
constraints on types, particularly type variables
@end itemize

@Star{} distinguishes two basic styles of type: so-called
@emph{structural} or transparent types and @emph{nominative} or opaque
types. A structural type term echoes the values it models, whereas a
nominative type typically does not.

For example, the standard type @code{integer} is nominative --- its
name gives no hint as to the representation, structure or kinds of
values that are modeled by integer.@footnote{I.e., everything you
thought you knew about integers may or may not apply to the values
denoted by integer.} However, a nominative type often indicates some
actual entity being modeled -- in this case integer values. Two
nominative types which have different names always denote distinct
values, whereas two structural types that look the same are actually
identical.

@node Nominative types
@subsection Nominative types

A nominative type is normally defined using an @emph{algebraic type
definition}. This both introduces a type and defines all the legal
values that belong to the type. For example, we might introduce a
Person type with the type definition:

@example
Person ::= noOne
         | someOne@{
             name : string.
             dob : date.
           @}
@end example

This statement tells us that there are two kinds of @code{Person}: a
@code{someOne} who has a @code{name} and date of birth (@code{dob})
associated with them; and a distinguished individual we identify as
@code{noOne}. The no-one individual @emph{does not} have a name or
date of birth.

@quotation
Notice how the type annotation statement we saw for declaring the type
of @code{fact} is also used for defining the types of fields in the
@code{someOne} record.
@end quotation

We can @emph{make} a Person value with a labeled record expression:

@example
S = someOne@{
  name = "fred".
  dob = today()
@}
@end example

The equality symbol is used to introduce a new single-assignment
variable. In this case the variable @code{S} is defined to be a
@code{someOne} record.

Recall that names do not always require an explicit type
annotation. In this case we can infer that @code{S} is a @code{Person}
(because @code{someOne} marks it). Furthermore, we do not need to
explicitly give types to the @code{name} and @code{dob} fields because
their type is constrained by the type declaration for @code{Person}.

@node Reference Type
@subsection Reference Type

@noindent
An important detail about the @code{someOne} record defined above is
that the fields within it are not re-assignable. If we want to make a
variable reassignable, or if we want to make a field of a record
reassignable, we use a special @code{ref} type to denote that. For
example, the type definition

@example
employee ::= employee@{
  dept : ref string.
  name : string
@}
@end example

allows the @code{dept} field within the employee record to be
modifiable -- although the employee's name is still fixed.

Only fields that have a @code{ref} type are modifiable in
records. This is even true when a record is assigned to a reassignable
variable.

A reassignable variable is declared using the @code{:=} operator:

@example
N := employee@{
  dept := "your department".
  name = "Anon. Y. Mouse"
@}
@end example

Since the variable @code{N} is declared as being reassignable, we can
give it a new value:

@example
N := employee@{
  dept := "another".
  name = "some one"
@}
@end example

We can also modify the @code{dept} field of @code{N}:

@example
N.dept := "new department".
@end example
However, we cannot modify the @code{name} field -- because it is not
re-assignable within the @code{Person} type.

Notice that the re-assignability of variables and fields does not
inherit: each field or variable is separate. So, for example, if we
declared a single-assignment variable @code{D} to be an employee:

@example
D = employee@{
  dept := "his department".
  name = "Your Name Here"
@}
@end example

then, even though @code{D} itself cannot be re-assigned to, the
@code{dept} field of @code{D} @emph{can} be altered:

@example
D.dept := "my department"
@end example

@node Accessing Reference Variables
@subsubsection Accessing Reference Variables

The value of a re-assignable variable is accessed using the @code{!}
operator. For example:
@example
D.dept!
@end example
will retrieve the actual department @var{D} is assigned to. The
expression @code{D.dept} actually means something different -- it
denotes the @emph{container} for the department.

@node Structural types
@subsection Structural types

A structural type is, informally, a type that looks like a value. For
example, the type

@example
(integer,string,employee)
@end example
is a @emph{tuple type} -- it denotes the type of a triple of values,
consisting of an @code{integer}, a @code{string} and an
@code{employee} in this case. Values of this tuple type are also
tuples; for example:
@example
(3,"fred",employee@{name="peter". dept:="sales"@})
@end example

@Star{} has several forms of structural type, the tuple type is one of
them; others include @emph{record types} and @emph{function types}.

We shall see more of these as we introduce the rest of the
language. However, it is worth pausing to ask the question @emph{Why}?

Briefly, nominative types help the programmer focus on what a value
@emph{denotes}; whereas structural types tend to expose what a value
can @emph{do}.

For example, the @code{employee} type clearly points to what an
employee value is intended to denote (an employee!), but does not help
if we want to know what an employee can do. On the other hand, the
function type in the annotation:

@example
f : (integer)=>string
@end example

clearly indicates what one can use @code{f} for, but it does not
indicate anything about why you would want to (except, perhaps, to
convert an @code{integer} to a @code{string}).

In summary, use nominative types when you are modeling real world
entities and structural types when the focus is on operations and
structure more than on what the intention is. In practice, of course,
you will use both in some combination.

@node Optional values
@subsection Optional values
Notice that we identified a special case of @code{noOne} in our
@code{Person} type. One reason for including this in a type is to be
able to cope with non-existent people. However, this approach is not
always the most effective one when modeling situations where a
variable or field may not have a value.

Explicit null values, as found in Java and similar languages, cause a
great number of problems: for example, null must have a special
universal type; there are many scenarios where it is not possible for
a variable to be null but the compiler must discover those for itself;
and there is often a consequent tendency in defensive programming to
test for null.

@Star{} has no direct equivalent of a global null value. However, the
standard @code{option} type allows the equivalent of selective
nullability. Any variable that might not have a proper value can be
marked with the option type rather than the underlying type. And you
can use @code{none} in those cases to indicate the equivalent of no
value.

So, for example, suppose that a @code{Person} might have a
@code{spouse} --- who is also a @code{Person} --- but is not
guaranteed to have one. Such a type can be described using:

@example
Person ::= someOne@{
  name : string.
  dob : date.
  spouse : ref option[Person].
@}
@end example

Here we have done two things: we have eliminated the @code{noOne} case
for @code{Person} and we have marked the @code{spouse} as being both
read-write and @code{option}al.

Someone with no spouse would be written:

@example
freddy = someOne@{
  name = "Freddy".
  dob = today().
  spouse := none
@}
@end example

whereas someone who has a spouse would be written:

@example
someOne@{
  name = "Lisa".
  dob = lastYear.
  spouse := some(johnny)
@}
@end example

Of course, we can record @code{freddy}’s marriage to @code{lisa} using
an assignment:

@example
freddy.spouse := some(lisa)

lisa.spouse := some(freddy)
@end example
although such circular structures should be avoided where possible.

@node The flavors of equality
@subsection The flavors of equality

Equality in programming languages is typically a very subtle
topic. The issues can range from the nature of floating point numbers,
the difference between integers and long values and the multiple
potential concepts of equality for objects.

Equality in @Star{} is always between values of the @emph{same type}
and it is always @emph{semantic}. So, for example, an equality
condition such as:

@example
3==3.0
@end example
is not considered type safe --- because @code{3} is an @code{integer}
literal and @code{3.0} is a @code{float} literal. If you need to
compare an integer and a floating point number for equality you will
need to first of all decide in which type the comparison will be made
(integer or floating point equality) and then @emph{coerce} the other
value into that type:
@example
3 :: float == 3.0
@end example
is valid@footnote{The expression @code{3::float} is a coercion
expression that converts the integer @code{3} into a float value.}
excepting, of course, that exact comparison between floating point
numbers is not @emph{stable}.

This is an important issue because not all integer values can be
represented in a float value and vice-versa. So, comparing an integer
and a floating point value raises the possibility of spurious accuracy
as a result of losing information. The intended effect of the coercion
is to make explicit the nature of equality being relied on.

The second principle is that equality is semantic. What that means is
that the @code{==} symbol is the name of a boolean-valued
function. The precise type of @code{==} is quite interesting, we
shall, however, leave it to later when we have covered some of the
core type features around contracts.

In effect, equality is @emph{not} considered to be privileged; and it
is definable by the programmer --- albeit with some important useful
default implementations.

@node A tale of three loops
@section A tale of three loops
Imagine that your task is to add up a list of numbers. Sounds simple
enough: in most procedural or OO languages (such as Java) one would
write a fragment of code that looks like:

@example
int total = 0;

for(Integer ix:L)
  total += ix;
@end example
However, this code is also full of pitfalls. For one thing we have a
lot of extra detail in this code that represents additional
commitments beyond those we might be comfortable with:

@itemize
@item
we have had to fix on the type of the number being totaled;
@item
we had to know about Java’s boxed v.s. unboxed types; and
@item
we had to construct an explicit loop, with the result that we sequentialized the process of adding up the numbers.
@end itemize

We can also write an equivalent loop in @Star{}:

@example
total = valof do@{
  tot := 0;
  for ix in L do
    tot := tot+ix;
  return tot
@}
@end example

The valof/return combination is a neat way of segueing from the `world
of expressions' into the `world of actions'.

This program is essentially equivalent to the Java loop; although
there are some subtleties about the nature of valof/valis that go
beyond Java. As a result, it has similar architectural issues.

While one loop is not going to hurt anyone; real code in languages
like Java typically has many such loops. Especially when nesting loops
to any depth, such code quickly becomes impossible to follow.

@node A functional loop
@section A functional loop

A more idiomatic way of expressing a computation like the totalizer is
to use a function. For example, we can write:

@example
let@{
  total:(cons[integer])=>integer.
  total(nil) => 0.
  total(cons(E,L)) => total(L)+E
@} in total(L)
@end example
while short, this code too has some of the same drawbacks as the for iteration.

The type expression @code{cons[integer]} refers to the standard type
of `cons lists'. Similarly, @code{nil} refers to the empty list and
@code{cons(E,L)} refers to the list obtained by prepending @code{E} to
the list @code{L}. We will explore this in more detail in
@pxref{Functional Programming}.

Even if it is more declarative, there is still a lot of extra detail
and architectural commitments here --- like the commitment to
@code{cons} lists and the commitment to integers. These result in a
function that is needlessly restricted.

Like other functional languages, @Star{} has a range of higher-order
operators that may come to the rescue. For example, we can avoid the
explicit recursion altogether by using @code{leftFold}:

@example
leftFold((+),0,L)
@end example
where @code{leftFold} means

@quotation
apply a left associative accumulating function to the elements of the data, assuming that the applied operator is left associative.
@end quotation

This expression is clearly both more concise and higher-level than
either the explicit loop or the explicit recursion; and it begins to
illustrate the productivity gains that are potentially available to
the functional programmer.

Using @code{leftFold} means that we can often abstract away the
machinery of loops and recursion completely --- instead we can solve
the problem at a more holistic level. This is one of the hallmarks of
functional programming -- it is possible to eliminate many instances
of explicit loops and recursions.

@node A totalizer query
@subsection A totalizer query

While concise, expressions involving much use of @code{leftFold} (and
the analogous @code{rightFold}) can be difficult to follow. An even
clearer way of adding up numbers is to use a @emph{query expression}:

@example
@{fold X with (+) | X in L@}
@end example
This query expression frees us from most of the commitments we endured
before: it can add up the elements of any kind of collection --- not
just @code{cons} lists --- and it can add up floating point numbers
just as easily as integers. Finally, we have not had to say exactly
how the numbers should be added up: the language system is free to use
a parallel algorithm for the computation should it be more optimal.

The query expression is also very close to the natural specification:

@quotation
Add up the numbers in L
@end quotation

@Star{}’s query expressions --- which are similar to but also more
expressive than LINQ --- can be used to encapsulate a wide range of
such computations. We shall look deeper into them when we look at
query rules in @Star{}.

@quotation
Of course, SQL programmers have long had access to this kind of
conciseness and declarative expressiveness. However, SQL is
constrained by the fact that it is intended to represent queries and
actions over a very particular form of data --- the relational table.
@end quotation

@node The homunculus in the machine
@subsection The homunculus in the machine

@noindent
Programming is often taught in terms of constructing sequences of
steps that must be followed. What does that imply for the programmer?
It means that the programmer has to be able to imagine what it is like
to be a computer following instructions.

It is like imagining a little person --- a homunculus --- in the
machine that is listening to your instructions and following them
literally. You, the programmer, have to imagine yourself in the
position of the homunculus if you want to write effective programs in
most languages today.

Not everyone finds such feats of imagination easy. It is certainly
often tedious to do so. Using query expressions and other higher-order
abstractions significantly reduces the programmer’s burden ---
precisely by being able to take a more declarative approach to
programming.

@node Contracts and constrained types
@section Contracts and constrained types

@noindent
The concepts of interface and contract are foundational in modern
software engineering. This is because explicit interfaces make it
substantially easier to develop and evolve systems. A @Star{} contract
goes beyond the traditional concept of interface in important ways: we
do not mark the definition of a type with its implemented contracts
and we allow contracts to involve multiple types.

A contract defines a collection of signatures and an implementation
provides specific implementations for those functions for a specific
type (or type combination).

For example, we can imagine a contract for simple four function
calculator arithmetic containing definitions for the basic four
functions of addition, subtraction, multiplication and division:

@example
contract all t ~~ four[t] ::= @{
  plus : (t,t)=>t.
  sub : (t,t)=>t.
  mul : (t,t)=>t.
  div : (t,t)=>t.
@}
@end example

This contract defines --- but does not implement --- the four
calculator functions @code{plus}, @code{sub}, @code{mul} and
@code{div}. All these functions have a similar type, the type for
@code{plus} is:

@example
plus :  all t ~~ four[t] |: (t,t)=>t.
@end example

The clause @code{four[t] |:} is a @emph{type constraint}, specifically
a @emph{contract constraint}. So, these functions are generic
(universally quantified) but the bound type (@code{t}) has the
additional constraint that there must be an implementation for
@code{four} for @code{t}.

The @code{four} contract defines a set of functions that can be used
without necessarily knowing the type(s) that are involved. For
example, we can define the @code{double} function in terms of
@code{plus}:

@example
double(X) => plus(X,X).
@end example

@noindent
The type of @code{double} reflects the fact that we are using elements
from the @code{four} contract:
@example
double : all t ~~ four[t] |: (t)=>t.
@end example
I.e., it inherits the same constraint as the function @code{plus}
has. There are several kinds of type constraint in @Star{}’s type
system; but the @emph{contract constraint} is the most significant of
them.

@quotation
Notice that we have to give an explicit type annotation for
@code{double}. The reason is that we want to have it have a quantified
type.
@end quotation

@node Implementing contracts
@subsection Implementing contracts

Defining a contract is a big step, but it is not generally sufficient
to produce working programs. If we had a @code{worksheet} containing
only:

@example
worksheet@{
  contract all t ~~ four[t] ::= @{
    plus : (t,t)=>t.
    sub : (t,t)=>t.
    mul : (t,t)=>t.
    div : (t,t)=>t.
  @}

  double : all t ~~ four[t] |: (t)=>t.
  double(X) => plus(X,X).

  show double(2)
@}
@end example

we would get a compiler error along the lines of:

@example
2:integer
  which is not consistent with
  display[t_12] , four[t_12] |: t_12
  because four[integer] not known to be implemented
@end example

This error message is effectively warning us that we have defined the
@code{four} contract but we have not implemented it. Until we do, the
program is not complete. However, if we do supply an implementation of
four over @code{integer}s:
@example
worksheet@{
  contract all t ~~ four[t] ::= @{
    plus : (t,t)=>t.
    sub : (t,t)=>t.
    mul : (t,t)=>t.
    div : (t,t)=>t.
  @}

  double : all t ~~ four[t] |: (t)=>t.
  double(X) => plus(X,X).

  implementation four[integer] => @{
    plus(x,y) => x+y.
    sub(x,y) => x-y.
    mul(x,y) => x*y.
    div(x,y) => x/y.
  @}

  show double(2)
@}
@end example

then everything works as expected.

Notice that the error message above shows that type t_12 actually has
two type constraints:

@example
display[t_12] @var{,} four[t_12] |: t_12
@end example

This is because the @code{show} action also results in a type
constraint being involved. The @code{display} contract is used to
display values in a number of circumstances; including the string
formatting we saw above.

As may be expected, arithmetic itself is also mediated via the
arithmetic contract in @Star{}. This is how we can support multiple
numeric types using a common set of operators: there are standard
implementations of arithmetic for integers, and floating point
numbers.

@node Coercion not casting
@subsection Coercion, not casting

@Star{} does not support automatic type casting, as found in languages
like Java and C/C++. This is for many reasons, not the least of which
is safety and predictability of code.

Casting in many languages is really two kinds of operations-in-one
which we can refer to as @emph{casting} and @emph{coercion}. Casting
is mapping of a value from one type to another without changing the
value itself; and coercion involves converting a value from one type
to another.

For example, the Java cast expression:
@example
(Person)X
@end example
amounts to a request to verify that @code{X} is actually a
@code{Person} object. In particular, this only checks the value of
@code{X} to see if it is a @code{Person}. On the other hand, casting
an integer to a floating point number involves changing the value to
conform to the floating point representation.

@Star{} does not support casting, but does support coercion. However,
coercion in @Star{} is never silent or implicit -- as it can be in
Java and C/C++. An expression of the form:
@example
3+4.5
@end example
will fail to type in @Star{} -- because there is an attempt to add an
integer to a floating point number.

The reason for signaling an error is strongly related to safety and
predictability: automatic conversion of integers to floating point can
be a common source of errors in languages like C -- because such
coercions are not always guaranteed to be semantics preserving (not
all integers can be represented as floating point values). The
implicit coercion of numeric values is easy to miss when reading
arithmetic expressions.

@Star{} provides a coercion notation that allows programmers to be
precise in their expectations:

@example
(3 :: float)+4.5
@end example
denotes the explicit coercion of the integer @code{3} to a
@code{float} and type checks as expected.

In fact, type coercion in @Star{} is mediated via a contract and this
expression is equivalent to
@example
(_coerce(3):float)+4.5
@end example
where @code{_coerce} is defined in the @code{coercion} contract
involving two types:

@example
contract all s,t ~~ coercion[s,t] ::= @{
  _coerce :: (s)=>t
@}
@end example

The @code{coercion} contract is an interface, but has no analog in
most OO languages: it involves two types -- the source type and the
destination type. Each implementation of coercion specifies both
types. For example, the implementation of coercion between integers
and floating point is explicitly given:
@example
implementation coercion[integer,float] => @{ @dots{} @}
@end example
This statement gives the implementation for coercing integers to
floats. Other implementation statements give the definitions for other
forms of coercion.

Having coercion as a contract makes it straightforward to add new
forms of coercion. This is used quite extensively within @Star{}
itself: for example, parsing JSON can be viewed as coercion from
string values to @code{json} values. Thus the interface to parsers can
be standard across all types and parsers.

@node Actions
@section Actions

@Star{} is primarily intended to be a functional programming
language. The preferred phrase is @emph{functional first}. However,
even in functional programming, sequence can be important.

The way that we handle sequential computation is a little
idiosynctratic: actions are entities that are created separately from
being performed. This is based on the standard @code{execution}
contract@footnote{Which is actually a richer version of the
@code{monad} contract.}

The basic concept is that one uses expressions to build up an action
entity and then evaluates that entity -- and often also extract a
returned value from the computation.

Actions can be constructed from primitive elements, but the normal
method is to use the @code{do} notation. For example, this @code{do}
expression can be used to compute factorial (somewhat laboriously):

@example
AA = do@{
    Cx := 1;
    Fx := 1;
    while Cx!=<Lx do @{
      Fx := Fx! * Cx!;
      Cx := Cx! + 1
    @};
    return Fx!
  @}
@end example

Not all @code{do} expressions will involve using re-assignable
variables, but nearly all use of re-assignable variables is in the
context of @code{do} expressions.

It is important to note that a @code{do} expression does not directly
compute its value: instead, it is an expression that @emph{denotes} a
computation. So, @code{AA} above is not an @code{integer} but a
computation that will produce an integer.

To run a computation and to get its value we use the @code{valof} operator:

@example
FF = valof AA
@end example

There are actually several variants of computation expressions, all
based on the same fundamental structure; two of the most important are
the @code{action} expression and the @code{task} expression.

@code{action} expressions are used to represent normal sequential
computations and @code{task} expressions are used to represent
concurrent computations; both of which we will explore later on in the
book.

@node There is more
@section There is more

As we have noted, @Star{} is a rich language and it would be
impossible to try to cover it in a short introduction. Later chapters
will look at some of the other features such as a deeper look at
contracts, queries & query rules, actors, concurrency, existential
types, and extending @Star{} with domain specific languages. The next
chapter (@xref{Functional Programming}) starts this process by looking
at functional programming in @Star{}.
