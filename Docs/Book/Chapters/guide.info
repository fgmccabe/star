This is guide.info, produced by makeinfo version 6.5 from book.texi.

Copyright (C) 2019 and beyond, Francis G. McCabe

   All rights reserved.
INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* star-guide: (star).		Programming in Star
END-INFO-DIR-ENTRY


File: guide.info,  Node: Top,  Next: Why be a Star programmer?,  Up: (dir)

Star Guide
**********

This is the on-line guide for the 'Star' language.

This book gives an introduction into the form and usage of the 'Star'
programming language.  However, it is not a definitive reference on the
language; for which the reader is referred to *Note (star)Top:: by F.G.
McCabe.

* Menu:

* Why be a Star programmer?::
* A tour of Star::
* Functional Programming::

* Concept index::
* Function index::
* List of Syntax Rules::


File: guide.info,  Node: Why be a Star programmer?,  Next: A tour of Star,  Prev: Top,  Up: Top

1 Why be a Star programmer?
***************************

This book is about the programming language called 'Star'.  Why, you may
ask, do you need to learn yet another language?  We hope to answer that
question and more in the course of this book.  We also aim to show you
how to program effectively in 'Star' to solve real world problems.

* Menu:

* Programming has changed::
* Is Star for you?::
* Design goals for Star::
* About this book::


File: guide.info,  Node: Programming has changed,  Next: Is Star for you?,  Up: Why be a Star programmer?

1.1 Programming has changed
===========================

Many of the world's most popular languages are quite old: C/C++ date
back to the 1970's and 1980's; Java dates back to 1995.  Although it
sometimes does not seem like it; quite a lot has changed since those
days.

* Menu:

* Programs are huge::
* Planning for change::
* Programming safely and effectively::
* Real-time is normal time.::
* This train is leaving the station::
* Technology::


File: guide.info,  Node: Programs are huge,  Next: Planning for change,  Up: Programming has changed

1.1.1 Programs are huge
-----------------------

If your program is 100 lines long, it does not actually matter what
programming language you use to write it in - unless you are learning
programming for the first time.

   However, in practice, many software systems are huge.  It is normal
to develop and to encounter programs measured in 100 Klocs (thousands of
lines of code) and it is not uncommon to encounter software systems
measured in the millions of lines of code.

     NOTE: To put these numbers into perspective, 500KLocs is comparable
     to the expected output of a programmer over their entire career.
     So, these systems necessarily involve many people over many years:
     a team of 10 programmers would take 10 years to write 1M lines of
     code.(1)

   Software development at this scale does not share much with
developing small systems.  Large scale software is invariably a team
effort, spread over multiple years.  It often involves large numbers of
components and multiple sub-systems interacting with each other.
Overall, this is a scenario of staggering heterogeneity and complexity.

   If there is one theme that is common in large code bases is that
tooling is critical: powerful IDEs can make a difference in productivity
measured in factors of 2-5.  However, it is our opinion that language
tooling starts with a sound programming language design: the sounder the
foundations, the taller the structure that can be built on it.

   ---------- Footnotes ----------

   (1) Not including code thrown away due to changes of requirements
over that time period.


File: guide.info,  Node: Planning for change,  Next: Programming safely and effectively,  Prev: Programs are huge,  Up: Programming has changed

1.1.2 Planning for change
-------------------------

Furthermore, _change_ is the dominant fact of life for large systems.
Software systems evolve, grow, are repurposed to meet new objectives,
and are re-implemented to take advantage of new technologies.

   Managing change in code is often left to Source Code Control Systems;
but these systems only address part of the problem.  For example, _code
re-use_ is also a requirement and a challenge for large systems.  In
fact, one could imagine a _three Rs_(1) for software engineering: Reuse,
Repurpose, and Refactor.

   When the code base is over 500 Kloc, the theoretical probability of
being able to re-use existing code is high, the actual probability of
re-use may be very low - software engineers may simply not be able to
find the needle in the code haystack, or, typically, the cost of
re-using code may outweigh the cost of developing from scratch.

   The need to repurpose reflects the fact that requirements change and
that software written for one purpose may be used for something
different.  Finally, even if the requirements dont change, the context
almost certainly will: increasing workload can lead to a need to
refactor existing code to enable it to meet changing needs.

   There is another kind of change that we need to consider: the
evolution of our programming languages and other tools.  A successful
programming language is part of an ecosystem.  That ecosystem consists
of the language itself, together with compilers and related tools.  It
also contains libraries, frameworks and packages.  In many cases the
libraries that are associated with a language are far more important
than the language compiler (e.g., Java's package ecosystem is enormous).

   A well designed language is capable of supporting a large variety of
libraries without running into limitations.  Furthermore, a well
designed language is structured in a way that supports its own evolution
- new requirements can lead to new features being added to the language.

     Managing this evolution may be the hardest aspect of designing
     programming languages!

   ---------- Footnotes ----------

   (1) Originally, _R_eading, w_R_iting and a_R_ithmetic.


File: guide.info,  Node: Programming safely and effectively,  Next: Real-time is normal time.,  Prev: Planning for change,  Up: Programming has changed

1.1.3 Programming safely and effectively
----------------------------------------

At the same time, safety and security are also critical: no-one likes to
have their private information exposed to the bad guys.  Most
main-stream programming languages were designed in an era when safety
was not uppermost in programmers’ minds - usually it was performance.
Some seemingly trivial design choices - such as C’s conventions for
laying out strings in memory - turn out to have potentially devastating
security implications.

   In addition, systems that are built assuming a shielded execution
environment, behind closed doors as it were, are often actually expected
to perform in the full glare of the Internet.  Hardening programs so
that they stand up to that glare can often dramatically add to the cost
of development - both in time and in money.


File: guide.info,  Node: Real-time is normal time.,  Next: This train is leaving the station,  Prev: Programming safely and effectively,  Up: Programming has changed

1.1.4 Real-time is normal time.
-------------------------------

Many kinds of business are becoming more and more ‘real-time’: a
small - over the order of milliseconds - slowdown in loading a web page
can mean the loss of 5% or more of revenue for an e-commerce site; an
unrented car, like an unrented hotel room, represents a permanent loss
of business and a competitive disadvantage.

   For the modern programmer, this means that applications must be
engineered from the start to be responsive and multitasking - aspects
that challenge even the most professional of programmers.


File: guide.info,  Node: This train is leaving the station,  Next: Technology,  Prev: Real-time is normal time.,  Up: Programming has changed

1.1.5 This train is leaving the station
---------------------------------------

Perhaps most importantly, we need to be able to do these things _now_ -
time to market is a critical factor in many if not most modern
applications.  Its no good developing the world’s best widget if you
run out of ‘runway’ trying to build it.

   A major bottleneck is the relative poor productivity of most modern
programming languages.  It is simply too hard to produce correct robust
code in languages like C/C++, Python etc.

   Productivity is an issue for individual programmers but is especially
salient for programmer teams.

     Every successful software project involves a team.

   The requirements for team-based development tend to put certain
aspects of programming language design into sharp focus.  For example,
strong types and clear interfaces may be excellent aids for individual
programmers but they are absolutely paramount for team development.

   More generally, in a competitive environment, the only way to
reliably out-perform the competition in reaching the market is to use
radically more productive technology.


File: guide.info,  Node: Technology,  Prev: This train is leaving the station,  Up: Programming has changed

1.1.6 Technology
----------------

The technology platform that programs are written for is also changing.
Just a few decades ago most computers were single-core; nowadays most
computers are multi-core and are capable of significant parallelism.

   Especially spectacular is the parallelism available in modern GPUs;
where a high end graphics processor may have thousands of cores capable
of processing instructions in parallel.  We expect that the days of
personal computers with thousands of cores is not too far in the future.

   Programming parallel machines with conventional languages is an
exercise in frustration.  This is because programming models that worked
in single core computers do not scale well to highly parallel machines.
One of the primary reasons for this is that state - as represented by
the changing values of variables - is _implicit_ in procedural and
object oriented languages.  The implicitness of state is important
because it makes many programs easier to express.  On the other hand,
that implicitness becomes a liability in multi-threaded and parallel
situations where state is no longer so well behaved.

   However, 'Star' has adopted some of the recent innovations in that
make dealing with multi-tasking and parallel execution easier.  These
innovations layer on top of basic features such as threading and provide
simpler models of execution than ‘conventional’ threaded models.
'Star'’s computation expressions combine the best of fork-join queues
and map-reduce frameworks whilst enabling a more normal style of
programming.


File: guide.info,  Node: Is Star for you?,  Next: Design goals for Star,  Prev: Programming has changed,  Up: Why be a Star programmer?

1.2 Is Star for you?
====================

Choosing a programming language - when you actually have a choice - is
highly personal.  Here are some reasons to think about 'Star'.

* Menu:

* If you are already a Java (or C#)::
* If you are already a C++ programmer::
* If you are already a functional programmer::


File: guide.info,  Node: If you are already a Java (or C#),  Next: If you are already a C++ programmer,  Up: Is Star for you?

1.2.1 If you are already a Java (or C#)
---------------------------------------

Most OO languages are embracing some of the simpler features of
functional languages.  Even modern Java with its lambda expressions and
stream features represents a nod to the power of functional programming.
However, at the same time, there is a substantial gap in the
capabilities of most OO languages compared to modern functional
programming languages.

   Fundamentally, OO languages revolve around _nouns_ rather than
_verbs_.  Verbs (methods) are relegated to being inside the scope of
some noun (object): they are not first class.  In functional programming
languages, like 'Star', there is more of an balance between nouns and
verbs.

   It is possible to have functions that are about data; it is also
quite straightforward in functional programming languages to have data
structures with functions embedded in them.  In fact, a simple
definition of a _module_ is a record that contains functions in it.

   While OO languages like Java provide excellent _data abstraction_
tools, the same cannot be said for _control abstractions_.  The result
is that OO languages are ‘stuck in the 1970s’ when it comes to
control abstractions.  However, concepts such as map/reduce, computation
expressions, and continuations bring a rich suite of new control
possibilities that solve important problems in modern programming.

   Similarly, the type systems of languages like Java (or C# or C/C++)
make are not as expressive or sensitive as modern type systems in
functional languages can be.  Professional programmers will recognize a
typical symptom of insufficiently expressive types: lots of casting and
dynamic meta-programming.  But, while powerful, these techniques amount
to giving up on types and their important advantages.  Furthermore,
contrary to many programmers’ expectations, a modern type system is
quite capable of dealing statically with scenarios that require dynamic
programming in languages like Java.


File: guide.info,  Node: If you are already a C++ programmer,  Next: If you are already a functional programmer,  Prev: If you are already a Java (or C#),  Up: Is Star for you?

1.2.2 If you are already a C++ programmer
-----------------------------------------

Moving to a language like 'Star' is a radically different programming
experience for the C++ programmer.  However, most of the differences are
not because 'Star' is a functional programming language.  Rather, it is
because 'Star' does not abide by two of C++'s core principles: zero-cost
abstractions and compatibility with C.

   While 'Star''s compiler does not willfully make programs execute more
slowly, strict CPU performance is not the primary driver for design
features.  This shows up in a desire to avoid the so-called premature
optimization problem: of optimizing the wrong feature.

   In the case of 'Star' vs C++, the most salient of these is likely to
be the different ways that generic programs are compiled: C++ compiles
generic programs by constructing special case implementations for all
used versions of the generic program; whereas 'Star' constructs a single
- type agnostic - implementation of generic functions.

   This affects many aspects of one's day-to-day usage of the language
and its tooling.  One of which is that, for a compiler that has been in
daily use for over 40 years, C++ compilers are still remarkably slow.
C++ binaries can often be very large.

   The compatibility with C requirement has meant that C++ has to
support many programming paradigms (such as pointer arithmetic) that
most modern programming languages - 'Star' included - eschew.

   Pointer arithmetic is known to put applications at risk of severe
security problems; and there are many modern safer alternatives (which
C++ does also support).


File: guide.info,  Node: If you are already a functional programmer,  Prev: If you are already a C++ programmer,  Up: Is Star for you?

1.2.3 If you are already a functional programmer
------------------------------------------------

You have many choices for functional programming languages that are
excellent.  The author considers two languages that are principal
sources of inspiration for many of the functional features of 'Star':
Haskell and Standard ML (SML) - both of which are excellent; but not
perfect.

   For the functional programmer, the principal benefits of 'Star' are
_readability_, _modernity_ and _predictability_.

   One of the major drivers of the design of Haskell and (to a lesser
extent) SML is conciseness.  However, conciseness is not the same as
readability.  In modern software development environments there are many
stakeholders beyond the developer.  Having a language that is easy to
follow by non-technical readers is a major benefit in mixed skill teams.

   Like Haskell, 'Star' has a powerful type system.  'Star'’s type
system has many features in common with Haskell’s type system -
features that typically go beyond the capabilities of many OO languages.
In particular, 'Star'’s contract system is reminiscent of Haskell’s
type classes; and 'Star'’s existential and higher-kinded types give
considerable expressive power to the programmer.

   'Star' does not follow all of Haskell’s type features; and some
type concepts are rephrased into terminology that is more familiar to
main-stream (sic) programmers.

   Like SML, 'Star' has a powerful module system.  However, unlike
SML’s functors, 'Star' modules are first class values.  This means
that there is no artificial separation between ‘ordinary’ programs
and ‘functor’ programs.

   The result is a balanced set of type features that provides
capabilities that scale well from small programs to large systems.

   'Star'’s evaluation is, like that of SML but unlike Haskell,
strict.  We believe that that makes it significantly easier to reason
about the actual behavior and performance of programs.  However, 'Star'
has a rich set of features that support productive concurrent and
parallel programming - based on a combination of system threads and the
features of Concurrent ML.

   Like SML, 'Star' is not a strictly ‘pure’ language.  This was
neither an accident nor an afterthought.  Computer systems are built to
fulfill purposeful activity (although there may be many times when the
actual purpose is hard to discern).  For example, if I deposit a check
into my bank account, I require that the bank’s state is updated to
reflect my new balance: the world has changed as a result of my action.

   However, the converse does not follow: just because the world is
stateful does not mean that all our programs should be needlessly
stateful.  Much, if not most, of a given application program can and
should be crafted in a mathematical style - the merits of functional
programming are very great.

   Overall, the primary rationale in the design of 'Star' is to empower
the programmer in making obviously correct programs.


File: guide.info,  Node: Design goals for Star,  Next: About this book,  Prev: Is Star for you?,  Up: Why be a Star programmer?

1.3 Design goals for Star
=========================

'Star' is a multi-paradigm high-level _symbolic_ language.  It is
designed to be scalable, readable, accurate, high performing and
extensible.

   Paradoxically, scalability in a programming language is always about
large and small chunks of code.  Scalability in 'Star' is fostered by a
range of elements that facilitate composition, change and re-use:

   * The language is strongly statically typed.  This encourages both
     safety and documentation.  The type system is strong enough that
     there is very limited need to escape the type system.  For example,
     modules can be given a first-class type semantics.  This is
     important because it facilitates programmatic manipulation of
     modules in a safe manner.

   * Programs are defined in terms of rules; for example, functions are
     defined in terms of equations.  Apart from being more readable,
     rules are also a natural unit of change in an evolving system.

     A meta-language based on logical annotations makes it possible to
     build meaningfully connected documentation and facilitates
     processes such as code re-use, issue tracking, and code lifetime
     management.
   * The package system is intrinsically versioned and abstracted away
     from any underlying storage system.

   The syntax of 'Star' is oriented towards readability rather than
strict conciseness.  The reason for this is that the programmer is only
one of the stake holders in a given program.  A readable program is one
that is more easily trusted by non-programmers.

   Experience also suggests that readability enhances programmer
productivity also: much of team-based development involves comprehending
and modifying other programmers’ code.

   'Star' is a strongly, statically typed language.  The purpose of a
strong type system is to facilitate the communication of intent of the
programmer.  The purpose of static typing is to ensure that the compiler
can rapidly ‘fail’ incorrect programs without requiring the program
to be run.  Furthermore, static type checking minimizes any run-time
penalty for imposing type constraints.

   Although 'Star' is strongly typed, it uses _type inference_ to
eliminate much of the clutter that some type systems impose on the
programmer - which itself is a productivity sink of course.

   Generally, the _stronger_ the type system, the more the language
system can detect errors before programs are run.  In addition, the more
_expressive_ the type system is, the less the temptation to try to
subvert or bypass the type system.

   However, even though it is technically feasible to completely
eliminate type declarations of functions; doing so is in conflict with
some of the other goals behind 'Star'.  For example, type declarations
act as a form of documentation; and when there is a type error in your
program, having _no_ explicit type declarations can make tracking the
culprit of the error very difficult.  So all top-level variable
definitions (typically functions) are required in 'Star' to have
explicit type _annotations_.(1)

   'Star' has a range of features that make exploiting parallelism
easier to manage.  For example, it has support for _computation
expressions_ and _actors_.  Partitioning an application into different
_agents_ allows programming to follow a more human approach.
Computation expressions allow the programmer to manipulate computations
as easily as they do data values; that in turns greatly eases the
development of parallel and concurrent applications.

   There is no one technology that can solve all problems.  This is as
true for programming as for other domains.  'Star' supports a range of
programming paradigms that allows the developer to ‘use the best tool
for the job’.  However, we go beyond this ‘swiss army knife’
stance and make it straightforward to extend the language.

   Virtually every non-trivial program can be factored into a
combination of general purpose mechanism and specific policy for
applying the mechanism.  'Star' has powerful self-extension features
that allow programmers to design their own policy structures (a.k.a.
domain specific languages).

   Many of 'Star'’s own features - such as its query notation and its
actor notation - are built using these extension mechanisms.

   ---------- Footnotes ----------

   (1) The term _type declaration_ is reserved for defining a new type.
Variable types are defined through _type annotations_.


File: guide.info,  Node: About this book,  Prev: Design goals for Star,  Up: Why be a Star programmer?

1.4 About this book
===================

This book acts as an introduction to the language and to its use.  The
basic features of the language are introduced; however, this is not a
reference manual: it is not intended to be a complete description of the
language.

   That can be found in the 'Star' Language Definition.

   Introducing a programming language like 'Star' can be a challenge in
presentation.  This is because there is a significant amount of mutual
support between elements of the language.

   Our strategy is to take a layered approach - we start with simple
examples, occasionally skipping over certain aspects of the language
without explanation.  Later chapters focus on deeper, more complex
topics.

   For the most part, examples in the text of the book are executable.
You are encouraged to try to get them running on your own system.

* Menu:

* Getting hold of Star::
* Typographical conventions::
* Acknowledgements::


File: guide.info,  Node: Getting hold of Star,  Next: Typographical conventions,  Up: About this book

1.4.1 Getting hold of Star
--------------------------

The 'Star' compiler and run-time is being developed as an open source
project on GitHub.  You can access the source by cloning or downloading
the repository at

     github.com/frankmccabe/star


File: guide.info,  Node: Typographical conventions,  Next: Acknowledgements,  Prev: Getting hold of Star,  Up: About this book

1.4.2 Typographical conventions
-------------------------------

Any text on a programming language often has a significant number of
examples of programs and program fragments.  We show these using a
typewriter-like font, often broken out in a display form:

     P:integer;
     ...

   We use the ... ellipsis to explicitly indicate a fragment of a
program that may not be syntactically correct as it stands.

   As we noted above, 'Star' is a rich language with many features.  As
a result, some parts of the text may require more careful reading, or
represent comments about potential implications of the main text.  These
notes are highlighted the way this note is.


File: guide.info,  Node: Acknowledgements,  Prev: Typographical conventions,  Up: About this book

1.4.3 Acknowledgements
----------------------

No-one is an island, and no project of this scale is one person’s
work.  I have had the great fortune to be able to develop 'Star' in the
context of real world applications solving hard problems.  Individuals
have also played a large role; and it can be hard to ensure that all are
properly acknowledged: please forgive any omissions.

   Of particular significance, I would like to thank Michael Sperber for
our many discussions on the finer topics of language design; and for his
not insignificant contributions to the implementation itself.

   I would also like to thank my old colleagues at Starview inc., in
particular Steve Baunach and Bob Riemenschneider who were the world’s
first 'Star' programmers!  In addition, I would like to thank Michael
Sperber, David Frese and Andreas Bernauer who helped with crucial parts
of the implementation of the concurrency features.  I would also like to
thank Keith Clark, Kevin Cory, Prasenjit Dey, Chris Gray, Mack
Mackenzie, and Kevin Twidle for their help and advice.  I would like to
acknowledge the support of Thomas Sulzbacher who originated the project
and Jerry Meerkatz for keeping the faith.

   Last, but definitely not least, I would like to acknowledge the love
and support of my family; without whom none of this makes sense.


File: guide.info,  Node: A tour of Star,  Next: Functional Programming,  Prev: Why be a Star programmer?,  Up: Top

2 A tour of Star
****************

Our first task is to introduce you to the 'Star' language.  It is
difficult to find the right order in which to present a programming
language like 'Star'; this is because many of the features are highly
inter-related.  For example, types depend on values which depend on
functions which depend on types!

   Instead, our approach in this book is to take a series of horizontal
slices through the whole language; going progressively deeper as you
become more comfortable with the language.  Each layer represents a
reasonably workable subset of the complete language.

   Since a layered approach means that any given description may be
incomplete or slightly inaccurate, there is a temptation to use footnote
annotations which declare '... but there is also(1) ...'.

* Menu:

* A first Star program::
* Texture::
* Types more types and even more types::
* A tale of three loops::
* A functional loop::
* Contracts and constrained types::
* There is more::

   ---------- Footnotes ----------

   (1) Please forgive these pedantic notes when you see them.


File: guide.info,  Node: A first Star program,  Next: Texture,  Up: A tour of Star

2.1 A first Star program
========================

It is traditional to introduce a new programming language with something
like the hello world example.  Which we will do in a moment.  However,
the factorial function often makes a better first example for functional
programming languages:

     sample.factorial{
       import star.               -- Access standard language features

       public fact : (integer)=>integer.
       fact(0) => 1.              -- base case
       fact(N) where N>0 => N*fact(N-1).
     }

   This is not an executable program per se.; however, it does represent
a more typical source code unit - most programs are built from many
smaller modules which come together to make the application.  This
program is small, but already introduces many of the key elements of the
'Star' language.

   In this module, we see the name of the module - 'sample.factorial' -
an import statement and a function definition - of the 'fact' function.

   Source code can be in any form of textual container.  There is, for
example, no specific requirement that this 'sample.factorial' package be
in a file called 'factorial.star'; although that may be good advice.
Instead, the 'Star' system relies on a _catalog based_ system that maps
package names to text entities.  The catalog system also serves as an
anchor point in the version management of 'Star' programs.  We will
cover this, and the related repository system for generated artifacts,
in Chapter 4.


File: guide.info,  Node: Texture,  Next: Types more types and even more types,  Prev: A first Star program,  Up: A tour of Star

2.2 Texture
===========

All programming languages can be said to have a particular _style_ or
_texture_.  This is often so strong that it is often possible to
identify a programming language from a single line of source code.  In
the case of 'Star', this line might be:

     public fact : (integer)=>integer.
   which is a _type annotation statement_ declaring the type of the
function 'fact'.

   The 'public' annotation means that the function is exported by this
module and will be available in other modules where the
'sample.factorial' module is imported.

* Menu:

* Lexical style::
* Types::
* Rules::
* Patterns::
* Packages::
* Worksheets::
* String interpolation::


File: guide.info,  Node: Lexical style,  Next: Types,  Up: Texture

2.2.1 Lexical style
-------------------

'Star'’s lexical syntax uses a combination of special operators and
keywords.

   It can be difficult for language designers to decide when to use a
keyword and when to use a special operator.  In the case of 'Star' we
use special operators for common elements and keywords when either a
graphical operator would be obscure and/or is not common.

   For example, in the factorial module, we use braces for grouping; but
we also use the 'import' and the 'where' keywords.  The rationale here
is that programmers have become used to seeing braces for grouping
statements;(1) whereas the import and where elements are somewhat rarer.

   Notice that every statement is terminated with a period.  This is one
of those places where a little redundancy can help when building large
programs: the statement terminator is not technically necessary; but it
helps to reduce the scope of error messages.(2)

     NOTE: The precise rule is slightly more nuanced: a period is
     required to terminate a statement; unless the last character of the
     statement is a closing brace - or unless the statement is itself
     the last statement in a brace sequence.(3)

   Another aspect of 'Star'’s texture that may not be visible at this
stage is the reliance on an underlying meta-grammar - specifically on an
_operator precedence grammar_.  OPGs are likely already familiar to you:
it is the almost universally used grammar that underpins arithmetic
expressions.  We take the OPG and stretch its use to include the whole
language.  The relevance of this will be apparrent when we look at
_extending_ 'Star' with new language features.

   ---------- Footnotes ----------

   (1) Those who remember Algol 60 will understand that braces are not
the only way of grouping statements.

   (2) We use the period rather than the commonly used semi-colon
because 'Star' statements are statements, not instructions to perform in
sequence.

   (3) This is one of those somewhat pedantic notes!


File: guide.info,  Node: Types,  Next: Rules,  Prev: Lexical style,  Up: Texture

2.2.2 Types
-----------

'Star' is a strongly, statically typed language.  This means that all
variables and expressions have a single type; and that all type
constraints are enforceable at compile-time.  This is a fairly strong
(sic) statement but it is a key aspect of 'Star'’s design - we need
everything to be well typed and we also want to guarantee completeness
of the type system.

   The type annotation statement:
     fact : (integer)=>integer.

   is a statement that declares that the type of 'fact' is a function of
one integer argument and which returns an integer result.

   'Star' encourages, but does not require, most programs to have
explicit type annotations.  The precise rule is a little subtle:
variables whose type are not quantified _may_ have their type
automatically inferred.  For top-level functions, that annotation is
often contiguous in the text; but in other cases that may not be the
case.

   Other variables - like the variable 'N' which is part of the second
recursive equation - do not need type annotations.  This is possible
because underlying the type system is a powerful _type inference_ system
that can actually infer all types.

   The result is that a lot of the ‘clutter’ that can pervade a
strongly typed language is just not necessary; but the use of explicit
type annotations for top-level definitions provides useful structure and
documentation.

   Note that the requirement is that quantified _definitions_ have
explicit type annotations.  We don’t distinguish functions in any way
here.  In particular, functions which are _not_ generic - for example
lambda functions - do not need type annotations.


File: guide.info,  Node: Rules,  Next: Patterns,  Prev: Types,  Up: Texture

2.2.3 Rules
-----------

In 'Star', most programs are defined using _rules_.  In this case,
'fact' is defined using _equations_.  The equations that make up a
function definition (or any program definition for that matter) are
statements that are written in order.

   Rule-based programs support a _case driven_ approach to programming:
a program is defined in terms of the different cases or situations that
apply.  Using rules to cover different cases allows the programmer to
focus on each case in relative isolation.

   In addition, as we shall see later on, the partitioning of programs
into cases like this is very helpful in supporting large-scale issues
such as code annotations, versioning and life-cycle management.

   'Star' has various kinds of rules, including function definitions,
grammar definitions, variable definitions and type definitions.


File: guide.info,  Node: Patterns,  Next: Packages,  Prev: Rules,  Up: Texture

2.2.4 Patterns
--------------

Patterns are ubiquitous in 'Star': they form the basis of many rules:
including, most importantly, to define equations.  In fact, _all_
variables are introduced by means of patterns.

   A pattern can be viewed as a combination of a test -- does a value
match a particular pattern -- and as a way ( _the_ way in 'Star') of
binding a variable to a value.

   An equation’s pattern defines when the equation is applicable.  The
first equation for 'fact' above:

     fact(0) => 1.
   has a literal pattern on the left hand side of the '=>' operator.
This equation only applies when 'fact' is called with zero as its
argument.

   The pattern in the second equation:
     fact(N) where N>0 => N*fact(N-1).

   has a guard on it -- after the 'where' keyword.  Guards are
additional conditions that constrain patterns.  In this case, the
equation only applies if the argument is greater than zero.

   Any pattern may be qualified with a guard; we could have written the
guard _inside_ the argument pattern:

     fact(N where N>0) => N*fact(N-1).

   We did not because having the guard outside the arguments is neater.

     NOTE: The fact function’s equations are not fully covering: there
     are no cases for fact for negative numbers.  This means that the
     function is _partial_; and if called with a negative number will
     result in a run-time exception.


File: guide.info,  Node: Packages,  Next: Worksheets,  Prev: Patterns,  Up: Texture

2.2.5 Packages
--------------

The normal compilation unit is a _package_.  The sample.factorial
package contains just the function fact, but packages can contain
functions, type definitions, import statements and many other elements
that we will encounter.

   Package names and references to packages do not refer to file names;
package names are symbolic - in general a package name consists of a
sequence of identifiers separated by periods.

   The _catalog_ and _repository_ system explored in Chapter 7 that
supports the language ensures a proper connection between files and
packages.


File: guide.info,  Node: Worksheets,  Next: String interpolation,  Prev: Packages,  Up: Texture

2.2.6 Worksheets
----------------

The other main kind of compilation unit is the _worksheet_.  Worksheets
are a modern replacement for the REPL(1) that you see in many functional
programming languages.

   We say a _modern_ replacement for REPLs because worksheets fit much
better in the typical environment of an IDE.

   A worksheet can be used to implement the infamous hello world example
in just a few lines:

     worksheet{
       show "hello world".
     }

   We can also use a worksheet to display the results of using and
testing our fact function:

     worksheet{
       import sample.factorial.
       show "fact(10) is \(fact(10))".
       assert fact(5) == 120.
     }

   Worksheets are like a combination of a module and the transcript of a
session.  In an IDE, the ideal mode of displaying a worksheet is via an
interactive editor that responds to edit changes by recomputing the
transcript and displaying the results in-line.

   The key features of a worksheet that we will use are the ability to
import packages, define elements, show the results of computations and
define assertions.

   ---------- Footnotes ----------

   (1) Read-Eval-Print-Loop


File: guide.info,  Node: String interpolation,  Prev: Worksheets,  Up: Texture

2.2.7 String interpolation
--------------------------

The expression
     "fact(10) is \(fact(10))"
   is an _interpolated string_ expression.  It means the string
'"fact(10) is \(fact(10))"' with the substring '(fact(10)' replaced by
the value of the expression embedded within.  Interpolated string
expressions are a convenient way of constructing string values; and, via
the use of contracts, are also type safe.


File: guide.info,  Node: Types more types and even more types,  Next: A tale of three loops,  Prev: Texture,  Up: A tour of Star

2.3 Types, more types and even more types
=========================================

In many ways, the defining characteristic of a programming language is
the approach to types.  As we shall see, 'Star'’s type system is quite
extensive and powerful; however, simple types are quite straightforward.

   The most basic question to ask about types is

     What is a type?

   There is some surprising variability to the answer to this question;
for example, in many OO languages, types are conflated with classes.
'Star' types are terms - i.e., names - that denote different kinds of
values.

     Type: A type is a term that denotes a collection of values.(1)

   'Star'’s type system can be broken down into a number of
dimensions:

   * How legal values of various kinds can be identified with a type;
   * the treatment of type variables and quantifiers; and
   * constraints on types, particularly type variables

   'Star' distinguishes two basic styles of type: so-called _structural_
or transparent types and _nominative_ or opaque types.  A structural
type term echoes the values it models, whereas a nominative type
typically does not.

   For example, the standard type 'integer' is nominative -- its name
gives no hint as to the representation, structure or kinds of values
that are modeled by integer.(2)  However, a nominative type often
indicates some actual entity being modeled - in this case integer
values.  Two nominative types which have different names always denote
distinct values, whereas two structural types that look the same are
actually identical.

* Menu:

* Nominative types::
* Reference Type::
* Structural types::
* Optional values::
* The flavors of equality::

   ---------- Footnotes ----------

   (1) Not a set of values because not all collections of values are
mathematical sets.

   (2) I.e., everything you thought you knew about integers may or may
not apply to the values denoted by integer.


File: guide.info,  Node: Nominative types,  Next: Reference Type,  Up: Types more types and even more types

2.3.1 Nominative types
----------------------

A nominative type is normally defined using an _algebraic type
definition_.  This both introduces a type and defines all the legal
values that belong to the type.  For example, we might introduce a
Person type with the type definition:

     Person ::= noOne
              | someOne{
                  name : string.
                  dob : date.
                }

   This statement tells us that there are two kinds of 'Person': a
'someOne' who has a 'name' and date of birth ('dob') associated with
them; and a distinguished individual we identify as 'noOne'.  The no-one
individual _does not_ have a name or date of birth.

     Notice how the type annotation statement we saw for declaring the
     type of 'fact' is also used for defining the types of fields in the
     'someOne' record.

   We can _make_ a Person value with a labeled record expression:

     S = someOne{
       name = "fred".
       dob = today()
     }

   The equality symbol is used to introduce a new single-assignment
variable.  In this case the variable 'S' is defined to be a 'someOne'
record.

   Recall that names do not always require an explicit type annotation.
In this case we can infer that 'S' is a 'Person' (because 'someOne'
marks it).  Furthermore, we do not need to explicitly give types to the
'name' and 'dob' fields because their type is constrained by the type
declaration for 'Person'.


File: guide.info,  Node: Reference Type,  Next: Structural types,  Prev: Nominative types,  Up: Types more types and even more types

2.3.2 Reference Type
--------------------

An important detail about the 'someOne' record defined above is that the
fields within it are not re-assignable.  If we want to make a variable
reassignable, or if we want to make a field of a record reassignable, we
use a special 'ref' type to denote that.  For example, the type
definition

     employee ::= employee{
       dept : ref string.
       name : string
     }

   allows the 'dept' field within the employee record to be modifiable -
although the employee's name is still fixed.

   Only fields that have a 'ref' type are modifiable in records.  This
is even true when a record is assigned to a reassignable variable.

   A reassignable variable is declared using the ':=' operator:

     N := employee{
       dept := "your department".
       name = "Anon. Y. Mouse"
     }

   Since the variable 'N' is declared as being reassignable, we can give
it a new value:

     N := employee{
       dept := "another".
       name = "some one"
     }

   We can also modify the 'dept' field of 'N':

     N.dept := "new department".
   However, we cannot modify the 'name' field - because it is not
re-assignable within the 'Person' type.

   Notice that the re-assignability of variables and fields does not
inherit: each field or variable is separate.  So, for example, if we
declared a single-assignment variable 'D' to be an employee:

     D = employee{
       dept := "his department".
       name = "Your Name Here"
     }

   then, even though 'D' itself cannot be re-assigned to, the 'dept'
field of 'D' _can_ be altered:

     D.dept := "my department"


File: guide.info,  Node: Structural types,  Next: Optional values,  Prev: Reference Type,  Up: Types more types and even more types

2.3.3 Structural types
----------------------

A structural type is, informally, a type that looks like a value.  For
example, the type

     (integer,string,employee)
   is a _tuple type_ - it denotes the type of a triple of values,
consisting of an 'integer', a 'string' and an 'employee' in this case.
Values of this tuple type are also tuples; for example:
     (3,"fred",employee{name="peter". dept:="sales"})

   'Star' has several forms of structural type, the tuple type is one of
them; others include _record types_ and _function types_.

   We shall see more of these as we introduce the rest of the language.
However, it is worth pausing to ask the question _Why_?

   Briefly, nominative types help the programmer focus on what a value
_denotes_; whereas structural types tend to expose what a value can
_do_.

   For example, the 'employee' type clearly points to what an employee
value is intended to denote (an employee!), but does not help if we want
to know what an employee can do.  On the other hand, the function type
in the annotation:

     f : (integer)=>string

   clearly indicates what one can use 'f' for, but it does not indicate
anything about why you would want to (except, perhaps, to convert an
'integer' to a 'string').

   In summary, use nominative types when you are modeling real world
entities and structural types when the focus is on operations and
structure more than on what the intention is.  In practice, of course,
you will use both in some combination.


File: guide.info,  Node: Optional values,  Next: The flavors of equality,  Prev: Structural types,  Up: Types more types and even more types

2.3.4 Optional values
---------------------

Notice that we identified a special case of 'noOne' in our 'Person'
type.  One reason for including this in a type is to be able to cope
with non-existent people.  However, this approach is not always the most
effective one when modeling situations where a variable or field may not
have a value.

   Explicit null values, as found in Java and similar languages, cause a
great number of problems: for example, null must have a special
universal type; there are many scenarios where it is not possible for a
variable to be null but the compiler must discover those for itself; and
there is often a consequent tendency in defensive programming to test
for null.

   'Star' has no direct equivalent of a global null value.  However, the
standard 'option' type allows the equivalent of selective nullability.
Any variable that might not have a proper value can be marked with the
option type rather than the underlying type.  And you can use 'none' in
those cases to indicate the equivalent of no value.

   So, for example, suppose that a 'Person' might have a 'spouse' -- who
is also a 'Person' -- but is not guaranteed to have one.  Such a type
can be described using:

     Person ::= someOne{
       name : string.
       dob : date.
       spouse : ref option[Person].
     }

   Here we have done two things: we have eliminated the 'noOne' case for
'Person' and we have marked the 'spouse' as being both read-write and
'option'al.

   Someone with no spouse would be written:

     freddy = someOne{
       name = "Freddy".
       dob = today().
       spouse := none
     }

   whereas someone who has a spouse would be written:

     someOne{
       name = "Lisa".
       dob = lastYear.
       spouse := some(johnny)
     }

   Of course, we can record 'freddy'’s marriage to 'lisa' using an
assignment:

     freddy.spouse := some(lisa)

     lisa.spouse := some(freddy)
   although such circular structures should be avoided where possible.


File: guide.info,  Node: The flavors of equality,  Prev: Optional values,  Up: Types more types and even more types

2.3.5 The flavors of equality
-----------------------------

Equality in programming languages is typically a very subtle topic.  The
issues can range from the nature of floating point numbers, the
difference between integers and long values and the multiple potential
concepts of equality for objects.

   Equality in 'Star' is always between values of the _same type_ and it
is always _semantic_.  So, for example, an equality condition such as:

     3==3.0
   is not considered type safe -- because '3' is an 'integer' literal
and '3.0' is a 'float' literal.  If you need to compare an integer and a
floating point number for equality you will need to first of all decide
in which type the comparison will be made (integer or floating point
equality) and then _coerce_ the other value into that type:
     3 :: float == 3.0
   is valid(1) excepting, of course, that exact comparison between
floating point numbers is not _stable_.

   This is an important issue because not all integer values can be
represented in a float value and vice-versa.  So, comparing an integer
and a floating point value raises the possibility of spurious accuracy
as a result of losing information.  The intended effect of the coercion
is to make explicit the nature of equality being relied on.

   The second principle is that equality is semantic.  What that means
is that the '==' symbol is the name of a boolean-valued function.  The
precise type of '==' is quite interesting, we shall, however, leave it
to later when we have covered some of the core type features around
contracts.

   In effect, equality is _not_ considered to be privileged; and it is
definable by the programmer -- albeit with some important useful default
implementations.

   ---------- Footnotes ----------

   (1) The expression '3::float' is a coercion expression that converts
the integer '3' into a float value.


File: guide.info,  Node: A tale of three loops,  Next: A functional loop,  Prev: Types more types and even more types,  Up: A tour of Star

2.4 A tale of three loops
=========================

Imagine that your task is to add up a list of numbers.  Sounds simple
enough: in most procedural or OO languages (such as Java) one would
write a fragment of code that looks like:

     int total = 0;

     for(Integer ix:L)
       total += ix;
   However, this code is also full of pitfalls.  For one thing we have a
lot of extra detail in this code that represents additional commitments
beyond those we might be comfortable with:

   * we have had to fix on the type of the number being totaled;
   * we had to know about Java’s boxed v.s.  unboxed types; and
   * we had to construct an explicit loop, with the result that we
     sequentialized the process of adding up the numbers.

   We can also write an equivalent loop in 'Star':

     total = valof do{
       tot := 0;
       for ix in L do
         tot := tot+ix;
       return tot
     }

   The valof/return combination is a neat way of segueing from the
‘world of expressions’ into the ‘world of actions’.

   This program is essentially equivalent to the Java loop; although
there are some subtleties about the nature of valof/valis that go beyond
Java.  As a result, it has similar architectural issues.

   While one loop is not going to hurt anyone; real code in languages
like Java typically has many such loops.  Especially when nesting loops
to any depth, such code quickly becomes impossible to follow.


File: guide.info,  Node: A functional loop,  Next: Contracts and constrained types,  Prev: A tale of three loops,  Up: A tour of Star

2.5 A functional loop
=====================

A more idiomatic way of expressing a computation like the totalizer is
to use a function.  For example, we can write:

     let{
       total:(cons[integer])=>integer.
       total(nil) => 0.
       total(cons(E,L)) => total(L)+E
     } in total(L)
   while short, this code too has some of the same drawbacks as the for
iteration.

   The type expression 'cons[integer]' refers to the standard type of
‘cons lists’.  Similarly, 'nil' refers to the empty list and
'cons(E,L)' refers to the list obtained by prepending 'E' to the list
'L'.  We will explore this in more detail in *note Functional
Programming::.

   Even if it is more declarative, there is still a lot of extra detail
and architectural commitments here -- like the commitment to 'cons'
lists and the commitment to integers.  These result in a function that
is needlessly restricted.

   Like other functional languages, 'Star' has a range of higher-order
operators that may come to the rescue.  For example, we can avoid the
explicit recursion altogether by using 'leftFold':

     leftFold((+),0,L)
   where 'leftFold' means

     apply a left associative accumulating function to the elements of
     the data, assuming that the applied operator is left associative.

   This expression is clearly both more concise and higher-level than
either the explicit loop or the explicit recursion; and it begins to
illustrate the productivity gains that are potentially available to the
functional programmer.

   Using 'leftFold' means that we can often abstract away the machinery
of loops and recursion completely -- instead we can solve the problem at
a more holistic level.  This is one of the hallmarks of functional
programming - it is possible to eliminate many instances of explicit
loops and recursions.

* Menu:

* A totalizer query::
* The homunculus in the machine::


File: guide.info,  Node: A totalizer query,  Next: The homunculus in the machine,  Up: A functional loop

2.5.1 A totalizer query
-----------------------

While concise, expressions involving much use of 'leftFold' (and the
analogous 'rightFold') can be difficult to follow.  An even clearer way
of adding up numbers is to use a _query expression_:

     {fold X with (+) | X in L}
   This query expression frees us from most of the commitments we
endured before: it can add up the elements of any kind of collection --
not just 'cons' lists -- and it can add up floating point numbers just
as easily as integers.  Finally, we have not had to say exactly how the
numbers should be added up: the language system is free to use a
parallel algorithm for the computation should it be more optimal.

   The query expression is also very close to the natural specification:

     Add up the numbers in L

   'Star'’s query expressions -- which are similar to but also more
expressive than LINQ -- can be used to encapsulate a wide range of such
computations.  We shall look deeper into them when we look at query
rules in 'Star'.

     Of course, SQL programmers have long had access to this kind of
     conciseness and declarative expressiveness.  However, SQL is
     constrained by the fact that it is intended to represent queries
     and actions over a very particular form of data -- the relational
     table.


File: guide.info,  Node: The homunculus in the machine,  Prev: A totalizer query,  Up: A functional loop

2.5.2 The homunculus in the machine
-----------------------------------

Programming is often taught in terms of constructing sequences of steps
that must be followed.  What does that imply for the programmer?  It
means that the programmer has to be able to imagine what it is like to
be a computer following instructions.

   It is like imagining a little person -- a homunculus -- in the
machine that is listening to your instructions and following them
literally.  You, the programmer, have to imagine yourself in the
position of the homunculus if you want to write effective programs in
most languages today.

   Not everyone finds such feats of imagination easy.  It is certainly
often tedious to do so.  Using query expressions and other higher-order
abstractions significantly reduces the programmer’s burden --
precisely by being able to take a more declarative approach to
programming.


File: guide.info,  Node: Contracts and constrained types,  Next: There is more,  Prev: A functional loop,  Up: A tour of Star

2.6 Contracts and constrained types
===================================

The concepts of interface and contract are foundational in modern
software engineering.  This is because explicit interfaces make it
substantially easier to develop and evolve systems.  A 'Star' contract
goes beyond the traditional concept of interface in important ways: we
do not mark the definition of a type with its implemented contracts and
we allow contracts to involve multiple types.

   A contract defines a collection of signatures and an implementation
provides specific implementations for those functions for a specific
type (or type combination).

   For example, we can imagine a contract for simple four function
calculator arithmetic containing definitions for the basic four
functions of addition, subtraction, multiplication and division:

     contract all t ~~ four[t] ::= {
       plus : (t,t)=>t.
       sub : (t,t)=>t.
       mul : (t,t)=>t.
       div : (t,t)=>t.
     }

   This contract defines -- but does not implement -- the four
calculator functions 'plus', 'sub', 'mul' and 'div'.  All these
functions have a similar type, the type for 'plus' is:

     plus :  all t ~~ four[t] |: (t,t)=>t.

   The clause 'four[t] |:' is a _type constraint_, specifically a
_contract constraint_.  So, these functions are generic (universally
quantified) but the bound type ('t') has the additional constraint that
there must be an implementation for 'four' for 't'.

   The 'four' contract defines a set of functions that can be used
without necessarily knowing the type(s) that are involved.  For example,
we can define the 'double' function in terms of 'plus':

     double(X) => plus(X,X).

The type of 'double' reflects the fact that we are using elements from
the 'four' contract:
     double : all t ~~ four[t] |: (t)=>t.
   I.e., it inherits the same constraint as the function 'plus' has.
There are several kinds of type constraint in 'Star'’s type system;
but the _contract constraint_ is the most significant of them.

     Notice that we have to give an explicit type annotation for
     'double'.  The reason is that we want to have it have a quantified
     type.

* Menu:

* Implementing contracts::
* Coercion not casting::


File: guide.info,  Node: Implementing contracts,  Next: Coercion not casting,  Up: Contracts and constrained types

2.6.1 Implementing contracts
----------------------------

Defining a contract is a big step, but it is not generally sufficient to
produce working programs.  If we had a 'worksheet' containing only:

     worksheet{
       contract all t ~~ four[t] ::= {
         plus : (t,t)=>t.
         sub : (t,t)=>t.
         mul : (t,t)=>t.
         div : (t,t)=>t.
       }

       double : all t ~~ four[t] |: (t)=>t.
       double(X) => plus(X,X).

       show double(2)
     }

   we would get a compiler error along the lines of:

     2:integer
       which is not consistent with
       display[t_12] , four[t_12] |: t_12
       because four[integer] not known to be implemented

   This error message is effectively warning us that we have defined the
'four' contract but we have not implemented it.  Until we do, the
program is not complete.  However, if we do supply an implementation of
four over 'integer's:
     worksheet{
       contract all t ~~ four[t] ::= {
         plus : (t,t)=>t.
         sub : (t,t)=>t.
         mul : (t,t)=>t.
         div : (t,t)=>t.
       }

       double : all t ~~ four[t] |: (t)=>t.
       double(X) => plus(X,X).

       implementation four[integer] => {
         plus(x,y) => x+y.
         sub(x,y) => x-y.
         mul(x,y) => x*y.
         div(x,y) => x/y.
       }

       show double(2)
     }

   then everything works as expected.

   Notice that the error message above shows that type t_12 actually has
two type constraints:

     display[t_12] , four[t_12] |: t_12

   This is because the 'show' action also results in a type constraint
being involved.  The 'display' contract is used to display values in a
number of circumstances; including the string formatting we saw above.

   As may be expected, arithmetic itself is also mediated via the
arithmetic contract in 'Star'.  This is how we can support multiple
numeric types using a common set of operators: there are standard
implementations of arithmetic for integers, and floating point numbers.


File: guide.info,  Node: Coercion not casting,  Prev: Implementing contracts,  Up: Contracts and constrained types

2.6.2 Coercion, not casting
---------------------------

'Star' does not support automatic type casting, as found in languages
like Java and C/C++.  This is for many reasons, not the least of which
is safety and predictability of code.

   Casting in many languages is really two kinds of operations-in-one
which we can refer to as _casting_ and _coercion_.  Casting is mapping
of a value from one type to another without changing the value itself;
and coercion involves converting a value from one type to another.

   For example, the Java cast expression:
     (Person)X
   amounts to a request to verify that 'X' is actually a 'Person'
object.  In particular, this only checks the value of 'X' to see if it
is a 'Person'.  On the other hand, casting an integer to a floating
point number involves changing the value to conform to the floating
point representation.

   'Star' does not support casting, but does support coercion.  However,
coercion in 'Star' is never silent or implicit - as it can be in Java
and C/C++.  An expression of the form:
     3+4.5
   will fail to type in 'Star' - because there is an attempt to add an
integer to a floating point number.

   The reason for signaling an error is strongly related to safety and
predictability: automatic conversion of integers to floating point can
be a common source of errors in languages like C - because such
coercions are not always guaranteed to be semantics preserving (not all
integers can be represented as floating point values).  The implicit
coercion of numeric values is easy to miss when reading arithmetic
expressions.

   'Star' provides a coercion notation that allows programmers to be
precise in their expectations:

     (3 :: float)+4.5
   denotes the explicit coercion of the integer '3' to a 'float' and
type checks as expected.

   In fact, type coercion in 'Star' is mediated via a contract and this
expression is equivalent to
     (_coerce(3):float)+4.5
   where '_coerce' is defined in the 'coercion' contract involving two
types:

     contract all s,t ~~ coercion[s,t] ::= {
       _coerce :: (s)=>t
     }

   The 'coercion' contract is an interface, but has no analog in most OO
languages: it involves two types - the source type and the destination
type.  Each implementation of coercion specifies both types.  For
example, the implementation of coercion between integers and floating
point is explicitly given:
     implementation coercion[integer,float] => { ... }
   This statement gives the implementation for coercing integers to
floats.  Other implementation statements give the definitions for other
forms of coercion.

   Having coercion as a contract makes it straightforward to add new
forms of coercion.  This is used quite extensively within 'Star' itself:
for example, parsing JSON can be viewed as coercion from string values
to 'json' values.  Thus the interface to parsers can be standard across
all types and parsers.


File: guide.info,  Node: There is more,  Prev: Contracts and constrained types,  Up: A tour of Star

2.7 There is more
=================

As we have noted, 'Star' is a rich language and it would be impossible
to try to cover it in a short introduction.  Later chapters will look at
some of the other features such as a deeper look at contracts, queries &
query rules, actors, concurrency, existential types, and extending
'Star' with domain specific languages.  The next chapter (*Note
Functional Programming::) starts this process by looking at functional
programming in 'Star'.


File: guide.info,  Node: Functional Programming,  Next: Concept index,  Prev: A tour of Star,  Up: Top

3 Functional Programming
************************

There is a perception of functional programming that it is _weird_ and
_difficult_.  This is unfortunate for a number of reasons; the most
important being that functional programming is _not_ weirder than
procedural programming and that all programmers can benefit by
programming functionally.

   As for being difficult, a more accurate description would be that
there is a deeper _range of features_ in functional programming than in
most modern programming languages: so a perception of complexity can
arise simply because there is more to say about functional programming
languages.  However, the simplest aspects of functional programming are
very simple and the ramp need not be steep.

   What may be surprising to the reader who is not familiar with
functional programming is that it is _old_: predating the origins of
modern computing itself, that there is a huge amount that can be
expressed functionally, and that functional programming is often at
least as efficient and sometimes more efficient than procedural
programming.

   In this chapter we will show how we can utilize 'Star' as a vehicle
for functional programming.  As a side-goal, we also hope to demystify
some of the language and ideas found in functional programming.

* Menu:

* What is functional programming?::
* Basics::
* Another look at types::
* Functions as values::
* Going further::
* Polymorphic arithmetic::
* A word about type inference::
* Are we there yet?::


File: guide.info,  Node: What is functional programming?,  Next: Basics,  Up: Functional Programming

3.1 What is functional programming?
===================================

The foundations of functional programming rest on two principles:

  1. Programs are expressed in terms of functions, where a somewhat
     mathematical view of functions is taken; i.e., functions always
     produce the same output for the same input.

     This is what people mean when they say that functional programs are
     _declarative_.(1)

  2. Functions are values: they can be passed as arguments to functions,
     returned from functions, and they can be put into and retrieved
     from data structures.

   This last principle is what people mean when they refer to functions
as being _first class_ values.  It is also what is meant when we say
that functional programming languages are _higher order_.

   It is worth asking why these two principles are so important.
Although most early programmers were mathematicians; the extreme
constraints imposed by early machines meant that one might not have seen
much evidence of mathematical thinking in those early programs.
However, almost by accident, programming and mathematics share some
attributes: the importance of _composition_ and the power of
_abstraction_.  Functional programming is almost ideally placed to
exploit both of these to the full.

   'Star' is not actually a _pure_ functional programming language;
i.e., it is possible to write programs that violate the declarative
principle.  However, it is a _functional-first_ programming language: a
declarative style is strongly encouraged.  In this book we shall mostly
focus on writing pure functional programs in 'Star'.

   ---------- Footnotes ----------

   (1) The term declarative has a technical definition.  But this
captures much of the essence of declarativeness (sic).


File: guide.info,  Node: Basics,  Next: Another look at types,  Prev: What is functional programming?,  Up: Functional Programming

3.2 Basics
==========

It is often easier to introduce functional programming using numerical
examples.  Last chapter we saw, for example, the factorial program.
This is mostly because most programmers are already familiar with
numbers.  Continuing that tradition, here is a function that returns the
sign of a number:

     sign(X) where X<0 => -1.
     sign(0) => 0.
     sign(X) where X>0 => 1.

Each of these equations applies to different situations: the first
equation applies when the input argument is negative, the second when it
is exactly zero and the third when it is strictly positive.  These
represent the three possible cases in the definition of the sign
function.

   A 'Star' function may be built from any number of rewrite equations;
however, they must all be contiguous within the same group of
statements.

   Although it is good practice to ensure that equations in a function
definition do not overlap, 'Star' will try the equations in a function
definition in the order they are written in.(1)  We could have relied on
this and written 'sign' using:

     sign(X) where X<0 => -1.
     sign(0) => 0.
     sign(X) => 1.

   Sometimes it is important to mark a particular equation as the
_default_ case: i.e., an equation that should be used if none of the
other cases apply:

     sign(X) where X<0 => -1.
     sign(0) => 0.
     sign(X) default => 1.
   An explicitly marked 'default' equation does not need to be the last
equation; but, wherever it is written, default equations are only
attempted after all other equations have failed to apply.

* Menu:

* Functions::
* Order of evaluation::

   ---------- Footnotes ----------

   (1) The _Church Rosser Theorem_ guarantees some independence on the
order of the rewrite equations provided that the different rewrite
equations that make up function definitions do not overlap.  Usually,
however, it is too fussy to _require_ programmers to ensure that their
equations do not overlap; hence the reliance on ordering of equations.


File: guide.info,  Node: Functions,  Next: Order of evaluation,  Up: Basics

3.2.1 Functions
---------------

A function is defined as a sequence of _rewrite equations_ each of which
consist of a _pattern_ and an _expression_.  There are three general
forms of rewrite equations:

     PATTERN => EXPRESSION

   or
     PATTERN where CONDITION => EXPRESSION

   or
     PATTERN default => EXPRESSION

The left hand side of a rewrite equation consists of a pattern which
determines the applicability of the equation; and the right hand side
represents the value of the function if the pattern matches.

     Pattern: A pattern represents a test or guard on an (implicit)
     value.  Patterns can be said to succeed or fail depending on
     whether the value being tested matches the pattern.

   We also refer to a pattern being _satisfied_ when matching a
value.(1)

   The pattern in a rewrite equation is a guard on the arguments of the
function call.  For example, given a call
     sign(34)
   the patterns in the different equations of the 'sign' function will
be applied to the integer value '34'.

   When the pattern on the left hand side of a rewrite equation succeeds
then the equation _fires_ and the value of the expression on the right
hand side of the equation becomes the value of the function.

   There are many kinds of pattern in 'Star'; here, we look at three of
the most common kinds of pattern, and in later sections, we look at
additional forms of patterns.

_Variable Pattern_
     A variable pattern is denoted by an identifier; specifically by the
     first occurrence of an identifier.

     A variable pattern always succeeds and has the additional effect of
     _binding_ the variable to the value being matched.

   For example, the 'X' in the left hand side of
     double(X) => X+X
   is a variable pattern.  Binding 'X' means that it is available for
use in the right hand side of the equation - here to participate in the
expression 'X+X'.

   The part of the program that a variable has value is called its
_scope_.

   * Variables in rewrite equations always have scope ranging from the
     initial occurrence of the variable through to the whole of the
     right hand side of the equation.
   * Variable patterns are the _only_ way that a variable can get a
     value in 'Star'.

   Subsequent occurrences of variables in a pattern are semantically
equivalent to an equality test; specifically a call to the '=='
predicate.  For example, in the equation:

     same(X,X) => true.
   the second occurrence of 'X' is regarded as an equality test; i.e.,
this equation is equivalent to:

     same(X,X1 where X==X1) => true.

   Sometimes, the earlier occurrence of a variable is not in the pattern
itself but in an outer scope.

_Literal Pattern_
     A literal pattern - such as a numeric literal or a string literal -
     only matches the identical number or string.

   Clearly, a literal match amounts to a comparison of two values: the
pattern match succeeds if they are identical and fails otherwise.

   Equality is based on _semantic equality_ rather than _reference
equality_.  What this means, for example, is that two strings are equal
if they have the same sequence of characters in them, not just if they
are the same object in memory.

     NOTE: However, not all types admit equality: for example, functions
     are not comparable; similarly, implementing equality for circular
     structures is problematic.(2)

   There is no automatic coercion of values to see if they _might_
match.  In particular, an integer pattern will only match an integer
value and will not match a float value - even if the numerical values
are the same.  I.e., there will be no attempt made to coerce either the
pattern or the value to fit.

   This, too, is based on the desire to avoid hard-to-detect bugs from
leaking into a program.

_Guard Pattern_
     Sometimes known as a _semantic guard_, a guard pattern consists of
     a pair of a pattern and a condition:

          PATTERN where CONDITION

   Conditions are boolean-valued and a guard succeeds if both its
pattern matches and if its condition is _satisfied_.

     Note that conditions _may_ bind variables.  This is why we do not
     state that conditions are boolean-valued expressions.

   'Star' has a normal complement of special conditional forms which we
shall explore as we encounter the need.  In the case of the equation:
     sign(X) where X>0
   the guard pattern is equivalent to:
     X where X>0
   We can put guard pattern anywhere that a pattern is valid; and, for
convenience, we can also put them immediately to the left of the rewrite
equation’s is operator.

     Any variables that are bound by the pattern part of a guarded
     pattern are _in scope_ in the condition part of the guard.
     Furthermore, any variables that are bound by the condition part of
     the guarded pattern have the same scope as variables introduced in
     the pattern.

   In the pattern above, the variable 'X' will be bound in the variable
pattern 'X' and will then be tested by evaluating the condition 'X>0'.

   ---------- Footnotes ----------

   (1) This terminology originates from Logic - where a formula can be
satisfied (made true) by observations from the world.

   (2) None of the standard 'Star' data types are circular in nature.


File: guide.info,  Node: Order of evaluation,  Prev: Functions,  Up: Basics

3.2.2 Order of evaluation
-------------------------

'Star' is a so-called _strict_ language.  What that means is that
arguments to functions are evaluated prior to calling the function.

     We do not specify the order of evaluation of the arguments of the
     function; except that:
       1. Arguments are evaluated before entry to the function.
       2. The function is evaluated before entry to the function.

   Most programming languages are strict; for two main reasons:

  1. It is significantly easier for programmers to predict the
     evaluation characteristics of a strict language.
  2. It is also easier to implement a strict language efficiently on
     modern hardware.  Suffice it to say that modern hardware was
     designed for evaluating strict languages, so this argument is
     somewhat circular.

   There many possible styles of evaluation order; one of the great
merits of programming declaratively is that the order of evaluation does
not affect the actual results of the computation.

   It may, however, affect whether you get a result.  Different
strategies for evaluating expressions can easily lead to differences in
which programs terminate and which do not.

   One other kind of evaluation that is often considered is _lazy_
evaluation.  Lazy evaluation means simply that expressions are only
evaluated _when needed_.  Lazy evaluation has many potential benefits:
it certainly enables some very elegant programming techniques.

   Essentially for the reasons noted above, 'Star' does not use lazy
evaluation; however, as we shall see, there are features of 'Star' that
allow us to recover some of the power of lazy evaluation.(1)

   The other dimension in evaluation order relates to the rewrite
equations used to define functions.  Here, 'Star' uses an in-order
evaluation strategy: the equations that make up the definition of a
function are tried in the order that they are written - with the one
exception being any default equation which is always tried last.

   ---------- Footnotes ----------

   (1) Even predominantly lazy languages like Haskell have features
which enforce strict evaluation.  It reduces to a question of which is
the _default_ evaluation style.


File: guide.info,  Node: Another look at types,  Next: Functions as values,  Prev: Basics,  Up: Functional Programming

3.3 Another look at types
=========================

Organizing data is fundamental to any programming language.  'Star'’s
data types are organized around the algebraic data type.  In addition,
'Star'’s supports quantified types of several varieties.

* Menu:

* Quantifier types::
* Contract constrained types::
* Algebraic data types::


File: guide.info,  Node: Quantifier types,  Next: Contract constrained types,  Up: Another look at types

3.3.1 Quantifier types
----------------------

A _generic_ type is one which has one or more type variables in it.  For
example, the type expression:
     (x,x)=>boolean
   is such a generic type (assuming that 'x' is a type variable - see
below).

   All type variables must be bound by a quantifier in some enclosing
scope.  If a type variable is not bound within a particular type
expression, it is considered _free_ in that type expression.

   A _quantified type_ is a type that introduces (i.e., binds) a type
variable.  There are two quantifiers in 'Star': a universal quantifier
and an existential quantifier.

   The most common quantifier is the _universal quantifier_ and
universally quantified types correspond closely to generic types in
other languages.

   Universally quantified types are often used to denote function types
and collection types.  For example, the type
     all x ~~ (x,x)=>boolean
   denotes the type of a generic binary function that returns a boolean
value.  The standard type for the equality predicate '==' is similar to
this type.

   A universally quantified type should be read as ‘for all possible
values’ of the bound variable.  For example, this function type should
be read as denoting functions that:

     for any possible type - 'x' - the function takes two such 'x'’s
     and returns a 'boolean'.

   'Star' also supports _existentially_ quantified types - these are
useful for denoting the types of modules and/or abstract data types.
For example, the type expression:

     exists e ~~ { f1 : e }
   denotes the type of a record with a field - 'f1' - which has a type.
The analogous reading for this type expression would be:

     there is a type - 'x' - such that the record has a field - called
     'f1' - of this type.

   As may be guessed, this is kind of obscure: 'f1' has a type, but we
don't know much else about it!

   However, existential types can be very useful, especially in
combination with record types like this one.  We will leave our more
detailed exploration of existential types for later.


File: guide.info,  Node: Contract constrained types,  Next: Algebraic data types,  Prev: Quantifier types,  Up: Another look at types

3.3.2 Contract constrained types
--------------------------------

We noted above that the type of the standard equality predicate was
almost the same as:
     all x ~~ (x,x)=>boolean
   This type denotes a universally quantified function type that can be
applied to arguments of any given type.  However, equality in a normal
programming language is _not_ universal: not all values admit to being
reliably tested for equality.  A great example of such a limitation are
functions - equality between functions is not well defined.(1)

   To capture this, we need to be able to constrain the scope of the
quantifier; specifically to those argument types that do admit equality.

   We can do this by adding a _contract constraint_ to the type - the
constraint states that equality must be defined for the type.  We do
this by prepending a constraint clause to the type:
     all x ~~ equality[x] |: (x,x)=>boolean
   The 'equality[x] |:' clause states that the type variable 'x' must
satisfy the 'equality' contract.

   What is implied when we state this?  This is captured in the
definition of the contract itself, in this case:
     contract all t ~~ equality[t] ::= {
       (==) : (t,t) => boolean.
     }
   In effect, the 'equality' contract states that there must be a single
function defined - '==' .

   If this seems a little circular, it is not.  The 'equality' contract
is effectively saying that the '==' function must be defined for the
type; and we constrain function (and other) types with the 'equality'
contract constraint when we need to ensure that '==' is defined!

   We provide evidence for contracts through the implementation
statement.  This declares that a given type satisfies a contract by
providing implementations for the functions in the contract.

   For example, we can provide evidence that the 'equality' contract
applies to strings using a built-in primitive to actually implement
equality for strings:
     implementation equality[string] => {
       s1 == s2 => _string_eq(s1,s2).
     }
   We shall explore more fully the power of this form of type constraint
in later sections and chapters.  For now, the core concept is that
quantified types can be constrained to allow very precise formulations
of types.

   ---------- Footnotes ----------

   (1) Strictly, not decidable.


File: guide.info,  Node: Algebraic data types,  Prev: Contract constrained types,  Up: Another look at types

3.3.3 Algebraic data types
--------------------------

An algebraic data type definition achieves several things
simultaneously: it introduces a new type into scope, it gives an
enumeration of the legal values of the new type and it defines both
constructors for the values and it defines patterns for decomposing
values.  This is a lot for a single statement to do!

   For example, we can define a type that denotes a point in a
two-dimensional space:
     point ::= cart(float,float).
   This kind of statement is called a _type definition statement_ and is
legal in the same places that a function definition is legal.

   The new type that is named by this statement is point; so, a variable
may have point type, we can pass point values in functions and so on.

   The constructor cart allows us to have expression that allow new
point structures to be made:
     cart(3.4,2.1)
   'cart' is also the name of a _pattern_ operator that we can use to
take apart point values.  For example, the euclid function computes the
Euclidian distance associated with a point:
     euclid:(point)=>float.
     euclid(cart(X,Y)) => sqrt(X*X+Y*Y).
   Of course, this particular 'point' type is based on the assumption
that point values are represented in a cartesian coordinate system.  One
of the more powerful aspects of algebraic data types is that it is easy
to introduce multiple alternate forms of data.  For example, we might
want to support two forms of point: in cartesian coordinates and in
polar coordinates.  We can do this by introducing another case in the
type definition statement:
     point ::= cart(float,float)
             | polar(float,float).
   Of course, our 'euclid' function also needs updating with the new
case:
     euclid:(point)=>float.
     euclid(cart(X,Y)) => sqrt(X*X+Y*Y).
     euclid(polar(R,T)) => R.
   'cart' and 'polar' are called _constructor functions_.  The term
_constructor_ refers to the common programming concept of constructing
data structures.  They are called functions because, logically, they
_are_ functions.

   For example, we might give a type to 'polar':
     polar : (float,float)=>point
   In fact, constructor functions are one-to-one functions.  Variously
known as _free functions_ (in logic), _bijections_ (in Math), one-to-one
functions are guaranteed to have an inverse.  This is the logical
property that makes constructor functions useful for representing data.

   Of course, we are talking of a _logical_ property of constructor
functions.  Internally, when implementing functional languages like
'Star', the values returned by constructor functions are represented
using data laid out in memory - just like in any other programming
language.

   'Star' actually employs a special type for constructor functions; so
the correct type of 'polar' is given by:
     polar : (float,float)<=>point
   The double arrow representing the fact that constructor functions are
bijections.

   In addition to constructor functions, an algebraic type definition
can introduce two other forms of data: _enumerated symbols_ and _record
functions_.  Enumerated symbols are quite useful in representing
symbolic alternatives.  The classic example of an enumerated type is
'daysOfWeek':
     daysOfWeek ::= monday
                  | tuesday
                  | wednesday
                  | thursday
                  | friday
                  | saturday
                  | sunday.
   Another example is the standard 'boolean' type which is defined:
     boolean ::= true | false.
   Unlike enumerated symbols in some languages, there is no numeric
value associated with an enumeration symbol: an enumerated symbol
‘stands for’ itself only.  The reason for this will become clear in
our next type definition which mixes enumerated symbols with constructor
functions:
     sTree ::= sEmpty | sNode(sTree,string,sTree)
   In addition to mixing the enumerated symbol ('sEmpty') with the
'sNode' constructor, this type is _recursive_: in fact, this is a
classic binary tree type where the labels of the non-empty nodes are
strings.  (We shall see shortly how to generalize this).

   Whenever you have a recursive type, its definition must always
include one or more cases that are not recursive and which can form the
base case(s).  In that sense, an enumerated symbol like 'sEmpty' plays a
similar role in 'Star' as null does in other languages; except that
'sEmpty' is only associated with the sTree type.

   We can use 'sTree' to construct binary trees of string value; for
example:
     sNode(sNode(sEmpty,"alpha",sEmpty),
           "beta",
           sNode(sEmpty,"gamma",sEmpty))
   denotes the tree in:

   ![A Binary string Tree][images/sTree.jpg]

     One of the hallmarks of languages like 'Star' is that _every_ value
     has a legal syntax: it is possible to construct an expression that
     denotes a literal value of any type.

   Just as we can define 'sTree' values, so we can also define functions
over 'sTree's.  For example, the 'check' function returns 'true' if a
given tree contains a particular search term:
     check(sEmpty,_) => false.
     check(sNode(L,Lb,R),S) => Lb==S || check(L,S) || check(R,S).
   Here we see several new aspects of 'Star' syntax:

   * An empty pattern - marked by '_' - matches anything.  It is called
     the _anonymous pattern_ and is used whenever we don’t care about
     the actual content of the data.
   * The '||' disjunction is a _short-circuit_ disjunction; much like
     '||' in languages like Java.  Similarly, conjunction ('&&') is also
     short-circuiting.
   * Functions can be recursive.  'Star' permits _mutual recursion_ just
     as easily: there is no special requirement to order function
     definitions in a program.

   We can use 'sTest' to check for the occurrence of particular strings:
     T = sNode(sNode(sEmpty,"alpha",sEmpty),
               "beta",
               sNode(sEmpty,"gamma",sEmpty)).

     show check(T,"alpha").          -- results in true
     show check(T,"delta").          -- results in false


File: guide.info,  Node: Functions as values,  Next: Going further,  Prev: Another look at types,  Up: Functional Programming

3.4 Functions as values
=======================

The second principle of functional programming is that functions are
first class.  What that means is that we can have functions that are
bound to variables, passed into functions and returned as the values of
functions.  In effect, a function is a legal _expression_ in the
language.  It also means that we can have _function types_ in addition
to having types about data.

   We can see this best by looking at a few examples.  One of the
benefits of passing functions as arguments to other functions is that it
makes certain kinds of parameterization easy.  For example, suppose that
you wanted to generalize 'check' to apply an arbitrary test to each node
- rather than just looking for a particular string.

   We will first of all define our 'fTest' function itself:
     fTest:(sTree,(string)=>boolean)=>boolean.
     fTest(sEmpty,_) => false.
     fTest(sNode(L,Lb,R),F) => F(Lb) || fTest(L,F) || fTest(R,F).
   The substantial change here is that, rather than passing a string to
look for, we pass 'fTest' a boolean-valued function to apply; within
'fTest' we replace the equality test 'Lb==S' with a call 'F(Lb)'.

   Notice that the type annotation for 'fTest' shows that the type of
the second argument is a function type - from 'string' to 'boolean'.

   Given 'fTest', we can redefine our earlier 'check' function with:
     check(T,S) => fTest(T,(X)=>X==S).
   We have a new form of expression here: the _anonymous function_ or
_lambda expression_.  The expression
     (X)=>X==S
   denotes a function of one argument, which returns 'true' if its
argument is the same value as 'S'.

   Interestingly, it would be difficult to define a top-level function
that is equivalent to this lambda because of the occurrence of the
variable 'S' in the body of the lambda.  This is an example of a _free
variable_: a variable that is mentioned in the body of a function but
which is defined outside the function.  Because 'S' is free, because it
is not mentioned in the arguments, one cannot simply have a function
which is equivalent to the lambda as a top-level function.

   Free variables are a powerful feature of functional programming
languages because they have an _encapsulating_ effect: in this case the
lambda encapsulates the free variable so that the 'fTest' function does
not need knowledge of 'S'.

* Menu:

* Functions and closures::
* Let binding::
* Generic types::
* Generic functions::


File: guide.info,  Node: Functions and closures,  Next: Let binding,  Up: Functions as values

3.4.1 Functions and closures
----------------------------

If a function is an expression, what is the value of the function
expression?  The conventional name for this value is _closure_:

_Closure_
     A closure is a structure that is the value of a function expression
     and which may be applied to arguments.

   It is important to note that, as a programmer, you will never
‘see’ a closure in your program.  It is an implementation artifact
in the same way that the representation of floating point numbers is an
implementation artifact that allow computers to represent fractional
numbers but which programmers (almost) never see explicitly in programs.

   Pragmatically, one of the important roles of closures is to capture
any free variables that occur in the function.  Most functional
programming languages implement functions using closure structures.
Most functional programming languages (including 'Star') do not permit
direct manipulation of the closure structure: the only thing that you
can _do_ with a closure structure is to use it as a function.

     In the world of programming languages, there is a lot of confusion
     about closures.  Sometimes you will see a closure referring to a
     function that captures one or more free variables.


File: guide.info,  Node: Let binding,  Next: Generic types,  Prev: Functions and closures,  Up: Functions as values

3.4.2 Let binding
-----------------

We noted that it is difficult to achieve the effect of the '(X)=>X==S'
lambda expression with named functions.  The reason is that the lambda
is _not_ defined in the same way that named functions are defined -
because it occurs as an expression not as a statement.  If we wanted to
define a named function which also captures 'S', we would have to be
able to define functions inside expressions.

   There is an expression that allows us to do this: the 'let'
expression.  A 'let' expression allows us to introduce local definitions
anywhere within an expression.  We can define our lambda as the named
function 'isS' using the 'let' expression:
     let{
       isS(X) => X==S
     } in isS
   The region between the braces is a _definition environment_ and
'Star' allows _any_ definition statement to be in such an environment.
We can define check using a let expression:
     check(T,S) => fTest(T,
         let{
           isS(X) => X==S.
         } in isS)
   This is a somewhat long-winded way of achieving what we did with the
anonymous lambda function - we would not normally recommend this way of
writing the 'check' function as it is significantly more complicated
than our earlier version.  However, there is a strong inter-relationship
between anonymous lambdas, let expressions and variable definitions.  In
particular, these are equivalent:
     let{
       isS = (X) => X==S
     } in isS
   and
     (X)=>X==S
   Apart from being long-winded, the 'let' expression is significantly
more flexible than a simple lambda.  It is much easier within a 'let'
expression to define functions with more than one rewrite equation; or
to define multiple functions.  We can even define types within the let
binding environment.

   Conversely, lambda functions are so compact because they have strong
limitations: you cannot easily define a multi-rewrite equation function
with a lambda and you cannot easily define a recursive function as a
lambda.

   In short, we would use a 'let' expression when the function being
defined is at all complex; and we would use a lambda when the function
being defined is simple and small.

   Assembling functions in this way, either by using anonymous lambdas
or by using 'let' expressions, is one of the hallmarks of functional
programming.


File: guide.info,  Node: Generic types,  Next: Generic functions,  Prev: Let binding,  Up: Functions as values

3.4.3 Generic types
-------------------

What actually makes 'fTest' more constrained than it could be is the
type definition of 'sTree' itself.  It too is unnecessarily restrictive:
why not allow trees of any type?  We can, using the type definition for
'tree':
     all t ~~ tree[t] ::= tEmpty | tNode(tree[t],t,tree[t]).
   Like the original 'sTree' type definition, this statement introduces
a new type: 'tree[t]' which can be read as _tree of something_.  The
name 'tree' is not actually a type identifier - although we often refer
to the tree type - but it is a _type constructor_.

   In an analogous fashion to constructor functions, a type constructor
constructs types from other types.  Type constructors are even
bijections - one-to-one functions from types to types.

     Unlike constructor functions though, type functions play no part in
     the run-time evaluation of programs.

   The identifier 't' in the type definition for 'tree' denotes a _type
variable_.  Again, similarly to regular variables and parameters, a type
variable denotes a single unspecified type.  The role of the type
variable 't' is like a parameter in a function: it identifies the
unknown type and its role.

   The 'tree' type is a universally quantified type.  What that means is
that instead of defining a single type it defines a family of related
types: for example:
     tree[string]
     tree[integer]
     ...

   are 'tree' types.  We can even have trees of trees:
     tree[tree[string]]
   We capture this genericity of the tree type by using a _universal
quantifier_:
     all t ~~ tree[t]
   What this type expression denotes is a set of possible types: for any
type 't', 'tree[t]' is also a type.  There are infinitely many such
types of course.

   The 'all' quantifier is important: as in logic, there are two kinds
of quantifiers in 'Star'’s type system: the _universal_ quantifier all
and the _existential_ quantifier exists.

     'Star' uses context to determine whether any given identifier is a
     type variable or a type name.  Specifically, if an identifier is
     bound by a quantifier then it must refer to a type variable.

   The types of the two constructors introduced in the 'tree' type
definition are similarly quantified:
     tEmpty:all t ~~ tree[t].

     tNode:all t ~~ (tree[t],t,tree[t)]<=>tree[t].
   The type 'tree[t]' on the right hand side of 'tEmpty'’s type
annotation raises a couple of interesting points:

  1. This looks like a type annotation with no associated definition.
     The fact that the 'tEmpty' symbol was originally introduced in a
     type definition is enough of a signal for the compiler to avoid
     looking for a definition for the name.

  2. The type of a literal 'tEmpty' expression - assuming that no
     further information is available - will be of the form 'tree[t34]'
     where 't34' is a ‘new’ type variable not occurring anywhere
     else in the program.  In effect, the type of 'tEmpty' is tree of
     _some type_ 't34' where we don’t know anything more about 't34'.


File: guide.info,  Node: Generic functions,  Prev: Generic types,  Up: Functions as values

3.4.4 Generic functions
-----------------------

Given this definition of the tree type, we can construct a more general
form of the tree test function; which is almost identical to fTest:(1)
     test:all t ~~ (tree[t],(t)=>boolean)=>boolean.
     test(tEmpty,_) => false.
     test(tNode(L,Lb,R),F) => F(Lb) || test(L,F) || test(R,F).
   and our original string check function becomes:
     check(T,S) => test(T,(X) => X==S)
   The type of check is also more generic:
     check:all t ~~ (tree[t],t)=>boolean
   I.e., 'check' can be used to find any type of element in a tree -
providing that the types align of course.

   Actually, this is not the correct the type for check.  This is
because we do not, in general, know that the type can support equality.
The precise type for check should take this into account:
     check:all t ~~ equality[t] |: (tree[t],t) => boolean

   ---------- Footnotes ----------

   (1) This time too, we must use an explicit type annotation.


File: guide.info,  Node: Going further,  Next: Polymorphic arithmetic,  Prev: Functions as values,  Up: Functional Programming

3.5 Going further
=================

Although better than the original 'sTest' program there is still one
major sense in which the test program is not general enough.  We can see
this by looking at another example: a function that counts elements in
the tree:
     count:all t ~~ (tree[t]) => integer.
     count(tEmpty) => 0.
     count(tNode(L,_,R)) => count(L)+count(R)+1
   This code is very similar, but not identical, to the 'test' function.

   The issue is that 'test' is trying to do two things simultaneously:
in order to apply its test predicate to a binary tree it has to
implement a walk over the tree, and it also encodes the fact that the
function we are computing over the tree is a boolean-value function.

   We often need to do all kinds of things to our data structures and
writing this kind of recursion over and over again is tedious and error
prone.  What we would like to do is to write a single _visitor_ function
and specialize it appropriately when we want to perform a specific
function.

   This principle of separating out the different aspects of a system is
one of the core foundations of good software engineering.  It usually
goes under the label _separation of concerns_.  One of the beautiful
things about functional programming is that it directly supports such
good architectural practices.

   Since this visitor may be asked to perform any kind of computation on
the labels in the tree we will need to slightly generalize the type of
function that is passed to the visitor.  Specifically, the type of
function should look like:
     F : (a,t)=>a
   where the 'a' input represents accumulated state, 't' represents an
element of the tree and the result is another accumulation.

   Using this, we can write a 'tVisit' function that implements tree
walking as:
     tVisit:all a,t ~~ (tree[t],(a,t)=>a,a)=>a.
     tVisit(tEmpty,_,A) => A.
     tVisit(tNode(L,Lb,R),F,A) => tVisit(R,F,F(tVisit(L,F,A),Lb)).
   Just as the accumulating function acquires a new ‘state’
parameter, so the 'tVisit' function also does.  The 'A' parameter in the
two equations represents this accumulated state.

   The second rewrite equation for 'tVisit' is a bit dense so let us
open it out and look more closely.  A more expanded way of writing the
'tVisit' function would be:
     tVisit(tEmpty,_,A) => A.
     tVisit(tNode(L,Lb,R),F,A) => let{
       A1 = tVisit(L,F,A).
       A2 = F(A1,Lb).
       } in tVisit(R,F,A2)
   where 'A1' and 'A2' are two local variables that represent the result
of visiting the left sub-tree and applying the accumulator function
respectively.  We have used the let expression form to make the program
more obvious, rather than to introduce new functions locally; but this
is a legitimate role for let expressions.

   The 'tVisit' function knows almost nothing about the computation
being performed, all it knows about is how to walk the tree and it knows
to apply functions to labels in the tree.

   Given 'tVisit', we can implement our original 'check' and 'count'
functions as one-liners:
     check(T,S) => tVisit(T,(A,X)=>(A || X==S),false).
     count(T) => tVisit(T,(A,X)=>A+1,0).
   The lambda that is embedded in the definition of check bears a little
closer scrutiny:
     (A,X)=>(A || X==S)
   In this lambda, we return 'A' - if it is 'true' - or we return the
result of the test 'X==S'.  This is a common pattern in such programs:
the accumulator 'A' acts as a kind of state parameter that keeps track
of whether we have already found the value.

     Functional programs are not actually _state-free_; often quite the
     opposite.  However, the state in a functional program is never
     _hidden_.  This is the true distinction between functional and
     regular procedural programs.

   Notice that we have effectively hidden the recursion in the function
definitions of 'check' and 'count' - all the recursion is encapsulated
within the 'tVisit' function.

     One of the unofficial mantras of functional programming is _hide
     the recursion_.

   The reason we want to hide recursions that this allows the designer
of functions to focus on _what_ is being computed rather than focusing
on the structure of the data and, furthermore, this allows the
implementation of the visitor to be _shared_ by all users of the tree
type.

   Notice that, while 'a' and 't' are type variables, we did not put an
explicit quantifier on the type of 'F'.  This is because the quantifier
is actually put on the type of 'tVisit' instead:
     tVisit:all a,t ~~ (tree[t],(a,t)=>a,a)=>a
   Just like regular variables, type variables have scope and points of
introduction.  Also like regular variables, a type variable may be
_free_ in a given type expression; although it must ultimately be
_bound_ by a quantifier.

* Menu:

* Going even further::


File: guide.info,  Node: Going even further,  Up: Going further

3.5.1 Going even further
------------------------

We have focused so far on generalizing the visitor from the perspective
of the tree type.  But there is another sense in which we are still
_architecturally entangled_: from the perspective of the 'check' and
'count' functions themselves.

   In short, they are both tied to our 'tree' type.  However, there are
many possible collection data types; 'Star' for instance has some 5 or 6
different standard collection types.  We would prefer not to have to
re-implement the 'check' and 'count' functions for each type.

   The good news is that, using contracts, we can write a single
definition of 'check' and 'count' that will work for a range of
collection types.

   Let us start by defining a contract that encapsulates what it means
to visit a collection:
     contract all c,t ~~ visitor[c->>t] ::= {
       visit:all a ~~ (c,(a,t)=>a,a)=>a
     }
   This 'visitor' contract defines a single function that embodies what
it means to _visit_ a collection structure.  There are quite a few
pieces here, and it is worth examining them carefully.

   A contract header has a template that defines a form of _contract
constraint_.  The clause
     visitor[c ->> t]
   is such a constraint.  The sub-clause
     c ->> t
   refers to two types: 'c' and 't'.  The presence of the '->>' term
identifies the fact that 't' _depends_ on 'c'.

   The 'visitor' contract itself is about the collection type 'c'.  But,
within the contract, we need to refer to both the collection type and to
the type of elements in the collection: the 'visit' function is over the
collection, it applies a function to elements of the collection.

   Furthermore, as we design the contract, we _do not know_ the exact
relationship between the collection type and the element type.  For
example, the collection type may be generic in one argument type - in
which case the element type is likely that argument type; conversely, if
the type is _not_ generic (like 'string' say), then we have no direct
handle on the element type.

   We _do know_ that within the contract the element type is
_functionally determined_ by the collection type: if you know the
collection type then you should be able to figure out the element type.

   We express this dependency relationship with the the 'c ->> t' form:
whatever type 'c' is, 't' must be based on it.

   The body of the contract contains a single type annotation:
     visit:all a ~~(c,(a,t)=>a,a)=>a
   This type annotation has three type variables: the types 'c' and 't'
come from the contract header and 'a' is local to the signature.  What
the signature means is

     Given the visitor contract, the 'visit' function is from the
     collection type 'c', a function argument and an initial state and
     returns a new accumulation state.

   It is worth comparing the type of 'visit' with the type of 'tVisit':
     tVisit:all t,a ~~(tree[t],(a,t)=>a,a)=>a
   The most significant difference here is that in 'tVisit' the type of
the first argument is fixed to 'tree[t]' whereas in 'visit' it is left
simply as 'c' (our collection type).

   Given this contract, we can re-implement our two 'check' and 'count'
functions even more succinctly:
     check(T,S) => visit(T, (A,X)=>A || X==S,false)
     count(T) => visit(T, (A,X)=>A+1,0)
   These functions will apply to _any_ type that satisfies - or
implements - the 'visitor' contract.  This is made visible in the
revised type signature for 'count':
     count:all c,t ~~ visitor[c->>t] |: (c)=>integer.
   This type is an example of a _constrained type_.  It is generic in
'c' and 't' but that generality is constrained by the requirement that
the 'visitor' contract is appropriately implemented.  The eagled-eyed
reader will notice that 'count' does not actually depend on the type of
the elements in the collection: this is what we should expect since
'count' does not actually care about the elements themselves.

   The type signature for 'check', however, does care about the types of
the elements:
     check:all c,t ~~
       visitor[c->>t], equality[c] |: (c,t)=>boolean
   This type annotation now has two contract constraints associated with
it: the collection must be something that is visitable and the elements
of the collection must support 'equality'.

   Given the work we have done, we can implement the 'visitor' contract
for our 'tree[t]' type quite straightforwardly:
     implementation all t ~~ visitor[tree[t]->>t] => {
       visit = tVisit
     }
   Notice that header of the implementation statement provides the
connection between the collection type (which is 'tree[t]') with the
element type ('t').  The clause
     visitor[tree[t]->>t]
   is effectively a declaration of that connection.

   Now that we have disconnected 'visit' from 'tree' types, we can
extend our program by implementing it for other types.  In particular,
we could also implement the visitor for the 'sTree' type:
     implementation visitor[sTree ->> string] => {
       visit = sVisit
     }
   however, we leave the definition of 'sVisit' as a simple exercise for
the reader.

   Our final versions of 'count' and 'check' are now quite general: they
rely on a generic implementation of the 'visit' function to hide the
recursion and are effectively independent of the actual collection types
involved.

   If we take a second look at our visitor contract we can see something
quite remarkable: it counts as a definition of the famous _visitor
pattern_.  This is remarkable because, although visitor patterns are a
common design pattern in OO languages, it is often hard in those
languages to be crisp about the semantics of visiting; in fact, they are
called patterns because they represent patterns of use which may be
encoded in Java (say) whilst not necessarily being definable in them.

   The combination of contract and implementation represents a quite
formal way of defining patterns like the visitor pattern.

   There is something else here that is quite important too: we are able
to define and implement the visitor contract _without_ having to modify
in any way the type definition of 'tree' or 'sTree'.  From a software
engineering point of view this is quite important: we are able to gain
all the benefits of interfaces without needing to entangle them with our
types.  This becomes critical in situations where we are not able to
modify types - because they don’t belong to us and/or we don’t have
access to the source.


File: guide.info,  Node: Polymorphic arithmetic,  Next: A word about type inference,  Prev: Going further,  Up: Functional Programming

3.6 Polymorphic arithmetic
==========================

There are other ways in which programs can be polymorphic.  In
particular, let us focus for a while on arithmetic.  One of the issues
in arithmetic functions is that there are many different kinds of
numbers.  Pretty much every programming language distinguishes several
kinds of numbers; for example, Java distinguishes byte, short, int,
long, float, double, BigInteger and BigDecimal - and this does not count
the wrapped versions.  Other languages have even more choice.

   One question that might seem relevant is why?  The basic answer is
that different applications call for different properties of numbers and
no one numeric type seems to fit all needs.  However, that variety comes
at a cost: when we use numbers we tend to have to make too early a
choice for the numeric type.

   For example, consider the 'double' function we saw earlier:
     double(X) => X+X
   What type should 'double' have?  In particular, what should the type
of '+' be?  Most people would be reluctant to use different arithmetic
operators for different types of numbers.(1)  This is resolved in 'Star'
by relying on contracts for the arithmetic operations.

   The result is that the most appropriate type signature for 'double'
is exquisitely tuned:
     double:all t ~~ arith[t] |: (t)=>t
   This type is precisely the most general type that 'double' could
have.  Any further constraints result in making a potentially premature
choice for the numeric type.

   If we take another look at our original 'fact' function:
     fact(0) => 1
     fact(N) => N*fact(N-1)
   this is constrained to be a function from 'integer' to 'integer'
because we introduced the literal integers '0' and '1'.  However, the
'arith' contract contains synonyms for these very common literals.
Using 'zero' and 'one' allow us to be abstract in many arithmetic
functions:
     genFact:all a ~~ arith[a] |: (a)=>a.
     genFact(zero) => one.
     genFact(N) => N*genFact(N-one).
   We call out 'zero' and one for special treatment because they occur
very frequently in numerical functions.  We can introduce other numeric
literals without compromising our type by using _coercion_; although it
is more clumsy:
     factorialC:all t ~~
       arith[t],coercion[integer,t] |: (t)=>t.
     factorialC(N) where N==0::t => 1::t.
     factorialC(N) => N*factorialC(N-1::t).
   The expressions '0::t' and '1::t' are coercions from 'integer' to
't'.

   Of course, coercion is also governed by contract, a fact represented
in the type signature by the coercion contract constraints on the type
of 't'.

   In any case, using these techniques, it is possible to write numeric
functions without unnecessarily committing to specific number types.
That in turn helps to make them more useful.

* Menu:

* Optional computing::
* Special syntax for optional values::

   ---------- Footnotes ----------

   (1) Although some languages - such as SML - do require this.


File: guide.info,  Node: Optional computing,  Next: Special syntax for optional values,  Up: Polymorphic arithmetic

3.6.1 Optional computing
------------------------

There are many situations where it is not possible to guarantee that a
computation will succeed.  The simplest examples of this include
scenarios such as accessing external files; but may also apply to
getting the first element of a list or the label of a 'tree' node.  The
great unknown of accessing elements of a collection is ‘is it
there?’.  Its not guaranteed of course, and we need to be able to
handle failure.

   Many languages employ the concept of a special 'null' value to denote
some of these cases - like a 'someOne' not having a 'spouse'.  However,
the special 'null' value brings its own problems: the type of 'null' is
problematic (it is a legal value for every type) and there are many
situations where 'null' is never possible.

   We address this by handling those situations where failure is
possible differently than where it is not.  Specifically, we do this via
the 'option' type.

   The type definition of 'option' is quite straightforward:
     all t ~~ option[t] ::= none | some(t).
   where 'none' is intended to denote the non-existence of a value and
'some' denotes an actual value.

   The 'option' type is intended to be used in cases where functions are
known to be partial.(1)  An 'option' return type signals that the
function may not always have a value.

   Normal pattern matching can be used to access a value wrapped in a
'some'; for example, to access someone's 'spouse' we can use the
condition:
     isMarriedTo(P,J) where some(JJ).=P.spouse => J==JJ.
     isMarriedTo(_,_) default => false.
   The important detail here is that all access to a 'option' wrapped
value is gated by some form of pattern matching and that, normally, this
takes place in a condition.

     The condition
          some(JJ).=P.spouse
     represents a pattern matching condition: it is satisfied if
     'P.spouse' matches 'some(JJ)' and has the additional effect of
     defining and binding the variable 'JJ' to the matched spouse.

   ---------- Footnotes ----------

   (1) A partial function does not have a value across the whole range
of its arguments.


File: guide.info,  Node: Special syntax for optional values,  Prev: Optional computing,  Up: Polymorphic arithmetic

3.6.2 Special syntax for 'option'al values
------------------------------------------

Of course, the code above _is_ kind of clumsy!  There is a range of
operators in 'Star' to make using 'option' values more pleasant.

   The most important of these is the '^=' operator which combines the
'.=' with the 'some' match.  Using this, the 'isMarriedTo' function
becomes:
     isMarriedTo(P,J) where JJ^=P.spouse => J==JJ.
     isMarriedTo(_,_) default => false.
   The meaning of '^=' is similar to the pattern match condition '.=';
except that the pattern is assumed to be for a 'some' value.

   While the '^=' operator(1) is very useful in unpacking an optional
value, the '^|' operator allows us to handle cases where we always need
to be able to give some kind of value.  For example, normally a 'map'
returns none if an entry is not present.  However, a _cache_ is
structured differently: if a value is not present in a cache then we
must go fetch it:

     cacheValue(K) => cache[K] ^| fetch(K)

   We can also apply a match _in line_ to an 'option'al value.  The '^'
operator allows a pattern to be formed by applying a 'option' valued
function directly in place.  For example, the equation:
     head(first^(1)) => "alpha"
   is equivalent to:
     head(X) where some(1).=first(X) => "alpha"
   We will see more examples of this when we look more closely at
sequences and collections processing.

   Finally, we can promote an optional expression into an enclosing
expression (which is therefore also optional).  For example, in the
expression:

     nameOf(^P.spouse)
   if 'P.spouse' is 'none', then the value returned by the 'nameOf'
expression is also 'none', otherwise it takes the form:
     some("P_spouse_name")
   (assuming that 'nameOf' is defined for 'Person's.)

   Overall, the 'option' type is part of an elegant approach to
nullability that is easily incorporated into 'Star'’s (and similar)
type system.

   ---------- Footnotes ----------

   (1) Read as ‘has a value’.


File: guide.info,  Node: A word about type inference,  Next: Are we there yet?,  Prev: Polymorphic arithmetic,  Up: Functional Programming

3.7 A word about type inference
===============================

We have seen some powerful forms of types in this chapter: recursive
types defined using algebraic type definitions, generic types and even
function types.  Recall also that 'Star' only requires programmers to
explicitly declare the types of quantified variables and functions.  It
is worth pausing a little to see how this might be done.

   Recall our original 'fact' function:
     fact(0) => 1.
     fact(N) => N*fact(N-1).
   The compiler is able to compute the types of the various variables
automatically through a process known as _type inference_.  Type
inference may seem magical, but is actually (mostly) quite simple.  Let
us take a look at the expression:
     N-1
   which is buried within the recursive call in 'fact'.  Although it
looks like a special operator, 'Star' does not treat arithmetic
expressions in a special way; the '-' function is just a function from
numbers to numbers; its type is given by:(1)
     (-) : all t ~~ arith[t] |: (t,t)=>t
   However, we should simplify this type a little in order to make the
explanation of type inference a little simpler.  In what follows, we
assume that the type of ('-') is:
     (-) : (integer,integer)=>integer
   Type inference proceeds by using special _type inference rules_ which
relate expressions to types, in this case the applicable rule is that a
function application is consistent if the function’s parameter types
are consistent with the types of the actual arguments.  If they are
consistent, then the type of the function application is the return type
of the function.

   The type inference process initially gives every variable an unknown
type - represented by a new type variable not appearing anywhere else.
For our tiny 'N-1' example, we will give 'N' the type T_{N}.

   The ('-') function has two arguments whose types can be expressed as
a tuple of types:
     (integer,integer)
   and the types of the actual arguments are also a tuple:
     (T_{N},integer)
   In order for the expression to be type correct, the actual types of
the arguments must be consistent with the expected types of the
function; which we can do by making them _the same_.  There is a
particular process used to do this - called _unification_.

   ![Inferring the Type of N-1][images/minustype]

_Unification_
     An algorithm that replaces variables with values in such a way as
     to make two terms identical.

   Unification matches equals with equals and handles (type) variables
by substitutions - for example, we can make these two type expressions
equal by _binding_ the type variable T_{N} to 'integer'.

   We initially picked the type of 'N' to be an arbitrary type variable,
but the process of checking consistency leads us to refine this and make
the type concrete.  I.e., the use of 'N' in a context where an integer
is expected is enough to allow the compiler to infer that the type of
'N' is indeed 'integer' and not T_{N}.

   Of course, if there are multiple occurrences of 'N' then each of
those occurrences must also be consistent with integer; and if an
occurrence is not consistent then the compiler will report an error - a
given expression may only have one type!

   The bottom line is that 'Star'’s types are based on a combination
of unification for comparing types and a series of type rules that have
the effect of introducing _constraints_ on types based on which language
features are present in the text.  The type checker is really a
constraint solver: if the constraints are not satisfiable (for example
by trying to ‘call’ a variable and add a number to it) then there is
a type error in the program.

   The magic of type inference arises because it turns out that solving
these constraints is sufficient for robustly type checking programs.

   A sharp-eyed reader will notice that 'Star'’s type system is
different in nature to that found (say) in OO languages.  In 'Star'’s
type system, types are considered to be consistent in 'Star' if they are
_equal_.  This is quite different to the notion of consistency in OO
languages where an argument to a function is consistent if its type is a
_sub-type_ of the expected type.

   However, we would note that the apparent restriction to the type
system imposed by type equality is much less severe in practice than in
theory - and that OO languages’ type systems also often incorporate
some of the same restrictions.

* Menu:

* Why is type inference restricted?::

   ---------- Footnotes ----------

   (1) We put the (-) in parentheses to highlight the use of an operator
as a normal symbol.


File: guide.info,  Node: Why is type inference restricted?,  Up: A word about type inference

3.7.1 Why is type inference restricted?
---------------------------------------

We have stated a few times that 'Star''s type system only infers types
of variables that are _not_ quantified.  In fact, it is fairly simple to
build a type inference system that can infer quantified types.  For
example, such a complete type inference system would infer from these
equations:

     conc(nil,x)=>x.
     conc(cons(h,tl),x) => cons(h,conc(tl,x))
   the generalized type for 'conc':
     conc:all t ~~ (cons[t],cons[t])=>cons[t].
   However, several technical and non-technical considerations stay our
hand at building such a type inference system:

   * There are still types that cannot be correctly inferred; and would
     therefore require explicit type annotations to correctly type the
     program.
   * Having explicit type annotations is 'good style' in general and
     definitely aids in debugging type errors.

   On the other hand, requiring type annotations for _every_ variable is
extremely tedious and verbose.  An extreme version of this policy would
require the 'conc' program above to be written:

     conc:all t ~~ (cons[t],cons[t])=>cons[t].
     conc(nil,x:list[t])=>x.
     conc(cons(h:t,tl:list[t]),x:list[t]) => cons(h,conc(t,x))
   The design of 'Star' strikes a balance between useability and rigor:
most variables do not require explicit type annotations.  We require
them only when something 'special' is being indicated; one of those
special circumstances is when defining a generic function.

   Even there, there are many situations where explicit type annotations
are not needed: for example when defining a field in a record, or a
function in the implementation of a contract, there already is a type
that the type system can use to verify the program.

   So, the precise rule for type inference is:

     If the type of a variable is known from context, then use that type
     to verify the type of any value the variable may be bound to.
     Otherwise, use type inference on the value to infer a type for the
     variable but do not attempt to generalize it by adding quantifiers
     to the inferred type.

   We are only able to scratch the surface of the type system here.  It
is certainly true that - like many modern functional languages -
'Star'’s type system is complex and subtle.  The primary motivation
for this complexity is to reduce the burden for the programmer: by being
able to infer types automatically, and by being able to address many
programming subtleties, the type system comes to be seen as the
programmer’s friend rather than as an obstacle to be ‘gotten
around’.


File: guide.info,  Node: Are we there yet?,  Prev: A word about type inference,  Up: Functional Programming

3.8 Are we there yet?
=====================

The straightforward answer to this is no.  There is a great deal more to
functional programming than can be captured in a few pages.  However, we
have covered some of the key features of functional programming -
particularly as it applies to 'Star'.  In subsequent chapters we will
take a closer look at collections, at modular programming, at
concurrency and even take a pot shot at Monads.

   If there is a single idea to take away from this chapter it should be
that functional programming is natural.  If there is a single piece of
advice for the budding functional 'Star' programmer, it should be to
_hide the recursion_.  If there is a single bit of comfort to offer
programmers it should be that _Rome was not built in a day_.

   In the next chapter we look at collections, one of the richest topics
in programming.


File: guide.info,  Node: Concept index,  Next: Function index,  Prev: Functional Programming,  Up: Top

Concept index
*************


File: guide.info,  Node: Function index,  Next: List of Syntax Rules,  Prev: Concept index,  Up: Top

Standard function index
***********************


File: guide.info,  Node: List of Syntax Rules,  Prev: Function index,  Up: Top

List of Syntax Rules
********************



Tag Table:
Node: Top257
Node: Why be a Star programmer?782
Node: Programming has changed1327
Node: Programs are huge1885
Ref: Programs are huge-Footnote-13492
Node: Planning for change3585
Ref: Planning for change-Footnote-15881
Node: Programming safely and effectively5940
Node: Real-time is normal time.6949
Node: This train is leaving the station7706
Node: Technology8982
Node: Is Star for you?10667
Node: If you are already a Java (or C#)11119
Node: If you are already a C++ programmer13257
Node: If you are already a functional programmer15074
Node: Design goals for Star18236
Ref: Design goals for Star-Footnote-122741
Node: About this book22869
Node: Getting hold of Star23922
Node: Typographical conventions24277
Node: Acknowledgements25080
Node: A tour of Star26519
Ref: A tour of Star-Footnote-127667
Node: A first Star program27730
Node: Texture29293
Node: Lexical style30102
Ref: Lexical style-Footnote-131878
Ref: Lexical style-Footnote-231987
Ref: Lexical style-Footnote-332137
Node: Types32191
Node: Rules33939
Node: Patterns34882
Node: Packages36365
Node: Worksheets37046
Ref: Worksheets-Footnote-138291
Node: String interpolation38320
Node: Types more types and even more types38820
Ref: Types more types and even more types-Footnote-140690
Ref: Types more types and even more types-Footnote-240779
Node: Nominative types40895
Node: Reference Type42441
Node: Structural types44193
Node: Optional values45828
Node: The flavors of equality47969
Ref: The flavors of equality-Footnote-149858
Node: A tale of three loops49967
Node: A functional loop51550
Node: A totalizer query53577
Node: The homunculus in the machine54995
Node: Contracts and constrained types56001
Node: Implementing contracts58363
Node: Coercion not casting60483
Node: There is more63534
Node: Functional Programming64117
Node: What is functional programming?65725
Ref: What is functional programming?-Footnote-167492
Node: Basics67614
Ref: Basics-Footnote-169405
Node: Functions69756
Ref: Functions-Footnote-174917
Ref: Functions-Footnote-275043
Node: Order of evaluation75114
Ref: Order of evaluation-Footnote-177237
Node: Another look at types77409
Node: Quantifier types77874
Node: Contract constrained types80055
Ref: Contract constrained types-Footnote-182476
Node: Algebraic data types82509
Node: Functions as values88675
Node: Functions and closures91263
Node: Let binding92635
Node: Generic types95074
Node: Generic functions98243
Ref: Generic functions-Footnote-199251
Node: Going further99315
Node: Going even further104256
Node: Polymorphic arithmetic110795
Ref: Polymorphic arithmetic-Footnote-1113841
Node: Optional computing113906
Ref: Optional computing-Footnote-1116073
Node: Special syntax for optional values116163
Ref: Special syntax for optional values-Footnote-1118248
Node: A word about type inference118283
Ref: A word about type inference-Footnote-1122958
Node: Why is type inference restricted?123052
Node: Are we there yet?125783
Node: Concept index126765
Node: Function index126900
Node: List of Syntax Rules127053

End Tag Table
