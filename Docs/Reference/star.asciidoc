= Star Reference

[[Introduction]]
== Introduction to Star

*Star* is a high-level symbolic programming language oriented to the
needs of large-scale high performance processing in modern parallel and
distributed computing environments.

*Star* is a _functional-first_ language – in that functions and other
programs are first class values. However, it is explicitly not a pure
language: it has support for updatable variables and structures.
However, its bias is definitely in favor of functional programming and
in order to get the best value from programming in *Star*, such
side-effecting features should be used sparingly.

*Star* is strongly, statically, typed. What this means is that all
programs and all values have a single type that is determined by a
combination of type inference and explicit type annotations.

While this definitely increases the initial burden of the programmer; we
believe that correctness of programs is a long-term productivity gain –
especially for large programs developed by teams of programmers.

The type language is very rich; including polymorphic types, type
constraints and higher-rank and higher kinded types. Furthermore, except
in cases where higher-ranked types are required, type inference is used
extensively to reduce the burden of type bureaucracy on programmers.

*Star* is extensible; there are many mechanisms designed to allow
extensions to the language to be designed simply and effectively. Using
such techniques can significantly ease the burden of writing
applications.

[[About-this-reference]]
=== About this Reference

This reference is the language definition of the *Star* language. It is
intended to be thorough and as precise as possible in the features
discussed. However, where appropriate, we give simple examples as
illustrative background to the specification itself.

[[Metagrammar]]
==== Metagrammar

Throughout this document we introduce many syntactic features of the
language. We use a variant of traditional BNF grammars to do this. The
meta-grammar can be described using itself; as shown in see
link:#metaGrammar[metaGrammar].

....
MetaGrammar ::= Production … Production
Production ::= NonTerminal ::= Body
Production ::+= NonTerminal ::+= Body
Body ::= Quoted | NonTerminal | Choice | Optional | Sequence | ( Body )
Quoted ::= ’Characters’
NonTerminal ::= Identifier | Identifier ( Expression )
Choice ::= Body | … | Body
Optional ::= [ Body ]
Sequence ::= Body  op … op Body [+]
....

Some grammar combinations are worth explaining as they occur quite
frequently and may not be standard in BNF-style grammars. For example
the rules for actions contain this rule for block actions:

....
BlockAction ::= ’{’ Action ; … ; Action ’}’
....

This grammar rule defines a link:#BlockAction[BlockAction] as a possibly
empty sequence of Actions separated by semi-colons and enclosed in
braces – the classic definition of a block. There are three language
patterns that fit this rule:

[arabic]
. An empty sequence of actions, which would be denoted by:
+
....
{}
....
. A single action, enclosed by braces with no separating semi-colons.
For example:
+
....
{
  X := 12
}
....
+
is a single action – that is an assignment in this case.
. A sequence of several actions; each of which is separated by
semi-colons. For example:
+
....
{
  A .= 42;
  fooBar();
  valis A
}
....
+
is a link:#BlockAction[BlockAction] that consists of three actions
within it.
+
The rule:
+
....
Decimal ::= Digit .. Digit+
....
+
denotes a definition in which there must be at least one occurrence of a
Digit; in this case there is also no separator between the Digits.

Occasionally, where a non-terminal is not conveniently captured in a
single production, later sections will add to the definition of the
non-terminal. This is signaled with a `::+=` production, as in:

....
Expression ::+= ListLiteral
....

which signals that, in addition to previously defined expressions, a
ListLiteral is also an Expression.

[[Typographical-Conventions]]
==== Typographical Conventions

typographical conventions

Any text on a programming language often has a significant number of
examples of programs and program fragments. In this reference, we show
these using a ‘typewriter‘-like font, often broken out in a display
form:

....
...
P : integer
...
....

We use the `...` ellipsis to explicitly indicate a fragment of a program
that is embedded in a context. ellipsis ...

Occasionally, we have to show a somewhat generic fragment of a program
where you, the programmer, are expected to put your own text in. We
highlight such areas using `this` font:

....
(Args) => Expr
....

This kind of notation is intended to suggest that `Args` and `Expr` are
a kind of _meta-variable_ which are intended to be replaced by specific
text.

[TIP]
====
Some parts of the text require more careful reading, or represent
comments about potential implications of the main text. These notes are
highlighted the way this note is. footnote:[Notes which are not really
part of the main exposition, but still represent nuggets of wisdom are
relegated to footnotes.]
====
[WARNING]
====
Occasionally, there are areas where the programmer may accidentally
‘trip over’ some feature of the language.
====

[[Lexical-Syntax]]
== Lexical Syntax

[[Characters]]
=== Characters

character set

Unicode

*Star* source text is based on the Unicode character set. This means
that identifiers and string values may directly use any Unicode
characters; specifically any _Unicode Scalar Value_.footnote:[In
particular, the so-called _surrogate pairs_ are not legal in *Star*.]

[NOTE]
====
We use the term _CodePoint_ to refer to a Unicode Scalar Value – the
former being easier to say than the latter. However, *Star* does not
support surrogate pairs; hence *Star* code points are technically
Unicode Scalar Values.
====
[NOTE]
====
However, all the standard operators and keywords fall in he ASCII subset
of Unicode.
====
[[Comments-and-White-Space]]
==== Comments and White Space

Input is tokenized according to rules that are similar to most modern
programming languages: contiguous sequences of characters are assumed to
belong to the same token unless the class of character changes – for
example, a punctuation mark separates sequences of letter characters. In
addition, white space and comments serve as token boundaries; otherwise
white space and comments are ignored by the higher-level semantics of
the language.

....
Ignorable ::= LineComment
  | BlockComment
  | WhiteSpace
....

There are two forms of comment: line comment and block comment.

[[Line-Comment]]
===== Line Comment

indexterm:[comment,line]
indexterm:[line comment]

A line comment consists of a `--␣` or a `--\t` followed by all
characters up to the next new-line. Here, `\t` refers to the Horizontal
Tab.

....
LineComment ::= (--␣ | --\t) Char … Char \n
....

[[Block-Comment]]
===== Block Comment

indexterm:[comment,block]

A ((block comment)) consists of the characters `/*` followed by any
characters and terminated by the characters `*/`.

....
BlockComment ::= /* Char … Char */
....

Each form of comment overrides the other: a `/*` sequence in a line
comment is _not_ the start of a block comment, and a `-- ` sequence in a
block comment is similarly not the start of a line comment but the
continuation of the block comment.

[[White-Space]]
===== White Space

indexterm:[white space]

White space characters are used to help delimit other tokens. Except
when they occur in a link:#StringLiteral[StringLiteral] or in a
link:#QuotedIdentifier[QuotedIdentifier] they serve no other purpose.

....
WhiteSpace ::=   | \n |\r | \f |\t
....

[[Number-Literals]]
=== Number Literals

indexterm:[numeric literals]
indexterm:[literal,number]

The numeric values include integer values, floating point values,
decimal values and character codes. The latter are integers that
represent the Unicode code points of particular characters.

....
NumericLiteral ::= Decimal
  | BigInteger
  | Hexadecimal
  | FloatingPoint
  | CharacterCode
....

[TIP]
====
The lexical syntax for numeric values is for positive values only. The
interpretation of negative numeric literals is part of the grammar, not
the lexical notation.
====

[[Integer-Tokens]]
==== Integer Tokens

indexterm:[number,integer]

An ((integer)) is written using the normal decimal notation (see
link:#decimalFig[decimalFig]):

....
1  34 -99
....

[TIP]
====
All integers are represented as at least 62 bit values. So-called
_bigints_ have arbitrary precision.
====
....
Decimal ::=Digit … Digit+
Digit ::= 0|1|2|3|4|5|6|7|8|9
BigInteger ::= 0b Decimal
....

Normal integers have limited (62bit) precision, whereas big integers
have unlimited precision.

[[Hexadecimal-Integers]]
==== Hexadecimal Integers

indexterm:[number,hexadecimal]

A ((hexadecimal number)) is an integer written using hexadecimal
notation. A hexadecimal number consists of a leading `0x` followed by
a sequence of hex digits. For example,

....
0x0 0xff
0x34fe
....

are all hexadecimals.

....
Hexadecimal::= 0x Hex … Hex+
Hex::= 0|1|2|3|4|5|6|7|8|9|a|b|c|d|e|f
....

[[Floating-Point-Numbers]]
==== Floating Point Numbers

indexterm:[number,floating point]

((Floating point)) numbers are written using a notation that is familiar.
For example,

....
234.45  1.0e45
....

The syntax for floating point numbers follows normal conventions:

....
FloatingPoint ::= Digit…Digit+ . Digit…Digit+ [e[-]Digit…Digit+]]
....

[TIP]
====
All floating point number are represented to a precision that is at
least equal to 64-bit double precision. There is no equivalent of
single-precision floating pointer numbers.
====

[[Character-Codes]]
==== Character Codes

indexterm:[number,character code]

The ((character code)) notation allows a number to be based on the coding
value of a character. Any Unicode character scalar value can be entered
in this way:

....
0cX 0c[ 0c\n 0c
....

For example, `0c\n` is the character associated with the new line
character, i.e., its value is `10`.

[TIP]
====
Unicode has the capability to represent up to one million character code
points.
====
....
CharacterCode ::= 0c CharRef
....

A CharacterCode has type `integer`.

[[Characters-and-Strings]]
=== Characters and Strings

indexterm:[character reference]

A `string` consists of a sequence of characters – specifically
link:#CharRef[CharRef]s. There is no specific type for the characters
themselves – instead, there are primitives for accessing individual code
points as `integer`s.

[CAUTION]
====
The reasons for this are due to the fact that Unicode `string` values
cannot be easily represented as a unique sequence of code points.
====
[[Character-Literals]]
==== Character Literals

indexterm:[character literal]

A link:#CharRef[CharRef] is a denotation of a single character.

....
CharRef ::= Char | Escape

Char ::= CodePoint

CharLiteral ::= \`CharRef\`

Escape ::= \b | \d | \e | \f | \n | \r | \t | \v |
   \Char | \u Hex…Hex;
....

For most characters, the character reference for that character is the
character itself. For example, the string `"T"` contains the character
`\`T\``. However, certain standard characters are normally referenced by
escape sequences consisting of a backslash character followed by other
characters; for example, the new-line character is typically written
`\`\n\``. The standard escapes references are shown in see
link:#CharEscape[CharEscape].

[width="100%",cols="41%,59%",options="header",]
|===
|Char |Description
|`\b` |Back space
|`\d` |Delete
|`\e` |Escape
|`\f` |Form Feed
|`\n` |New line
|`\r` |Carriage return
|`\t` |Tab
|`\v` |Vertical Tab
|`\u`Hex..Hex; |Unicode code point
|`\ Char` |The Char itself
|===

Apart from the standard character references, there is a hex encoding
for directly encoding unicode characters that may not be available on a
given keyboard:

....
\u34ff;
....

This notation accommodates the Unicode’s varying width of character
codes – from 8 bits through to 20 bits.

[[String-Literals]]
==== String Literals

indexterm:[string,quoted]

A ((string)) is a sequence of character references (see
link:#CharRef[CharRef]).

There are two forms of _string literal_: a QuotedString and a
BlockString.

....
StringLiteral ::= QuotedString | BlockString

QuotedString ::= " StrChar … StrChar "

StrChar ::= CharRef | Interpolation | Embedding

Interpolation ::= $( Expression ) [ : FormattingSpec ; ] 

FormattingSpec ::= CharRef … CharRef

Embedding ::= #( Expression )
....

[TIP]
====
Strings are _not_ permitted to contain the new-line character – other
than as a character reference.
====
Most string literals take the form of
link:#QuotedString[QuotedString]s. Such string literals support special
notation for control characters and also permit _interpolation_ of
values embedded within them. The supported control characters are mostly
the usual suspects:

....
"This string has a \nnew line in the middle"
....

[[Block-String]]
==== Block String

indexterm:[string,block form of]

In addition to the normal notation for strings, there is a block form of
string that permits raw character data to be processed as a string.

....
BlockString ::= """ Char … Char """
....

The block form of string allows any characters in the text and performs
no interpretation of those characters.

Block strings are written using triple quote characters at either end.
Any new-line characters enclosed by the block quotes are considered to
be part of the strings.

The normal interpretation of `$` and `#` characters as interpolation
markers is suppressed within a block string; as are any escape
characters’ interpretations.

....
"""This is a block string with $ and
uninterpreted \n characters"""
....

[TIP]
====
This form of string literal can be a convenient method for including
block text into a program source.
====
[[identifiers]]
=== Identifiers

((Identifiers)) are used to denote operators, keywords and variables. There
are three main kinds of identifier: regular alpha-numeric identifiers,
graphic identifiers and quoted identifiers. However, semantically, all
these are essentially equivalent: they all identify some variable or
some type.

[[Alphanumeric-Identifiers]]
==== Alphanumeric Identifiers

alpha numeric identifier

Identifiers are based on the Unicode definition of identifier. For the
ASCII subset of characters, the definition corresponds to the common
form of identifier – a letter followed by a sequence of digits and
letters. However, non-ASCII characters are also permitted in an
identifier.

....
Identifier ::= AlphaNumeric
  | GraphicIdentifier
  | QuotedIdentifier

AlphaNumeric ::= LeadChar BodyChar…BodyChar

LeadChar ::= LetterNumber
  | LowerCase
  | UpperCase
  | TitleCase
  | OtherNumber
  | OtherLetter
  | ConnectorPunctuation

BodyChar ::= LeadChar
  | ModifierLetter
  | Digit
....

The terms LetterNumber, ModifierLetter and so on; referred to in
link:#identifierFig[identifierFig] refer to standard character
categories defined in Unicode.

[TIP]
====
This definition of link:#Identifier[Identifier] closely follows the
standard definition of Identifier as contained in the Unicode
specification.
====
[[Graphic-Identifiers]]
==== Graphic Identifiers

indexterm:[indentifier, graphic]

The standard operators often have a graphic form – such as `+`, and
`=<`. link:#standardOperatorsTbl[standardOperatorsTbl] contains a
complete listing of all the standard graphic-form identifiers.

....
GraphicIdentifier ::= SymbolicChar…SymbolicChar

SymbolicChar ::= Char excepting BodyChar
....

The standard GraphicIdentifiers are listed in
link:#tokensTbl[tokensTbl]. I.e, such identifiers are normally also
operators.

[TIP]
====
Apart from their graphic form there is no particular semantic
distinction between a graphic form identifier and a alphanumeric form
identifier.
====

[[Quoted-Identifiers]]
==== Quoted Identifiers

indexterm:[identifier,quoted]

A quoted identifier is denoted by a sequence of charRefs enclosed in
single quotes. Recall that strings are enclosed in double quotes.

....
QuotedIdentifier ::= ' CharRef…CharRef '
....

A quoted identifier suppresses any operator or keyword interpretation
that the identifier might otherwise have.

[TIP]
====
This can be useful for external facing interfaces where, for example,
the name of a field in a structure must have a particular form – even if
that would otherwise be a keyword.
====

[[Standard-Keywords]]
==== Standard Keywords

There are a number of ((keywords)) which are reserved by the language –
these may not be used as identifiers or in any other role.

[TIP]
====
On those occasions where it is important to have an identifier that is a
keyword it is possible to achieve this by enclosing the keyword in
single quotes.

For example, while `type` is a keyword in the language; enclosing the
word in single quotes: `'type'` has the effect of suppressing the keyword
interpretation – even though the printed representations are the same.

Enclosing a name in parentheses also has the effect of suppressing any
operator information about the name.
====
[[Punctuation]]
=== Punctuation

There are relatively few ((punctuation)) symbols; although it has a large
number of graphical identifiers, which are defined in
link:#Graphic-Identifiers[Graphic Identifiers].

[[End-of-Term]]
==== End of Term

With a few exceptions, statements footnote:[A statement in *Star* is not
to be confused with statements in languages like C or Java: statements
in *Star* always declare some fact.] are terminated by the Terminator –
which consists of a period followed by white space character.

....
Terminator ::= . WhiteSpace
....

The exceptions are:

* After a brace. If a statement’s last character is a brace, then it
does not need to be terminated with a Terminator. This mimics C-style
conventions.
* The last definition If a statement is the last in a sequence of
statements that are enclosed in braces, then it does not need
termination.

[[Parentheses]]
==== Parentheses

((Parentheses)) are _active_: they are not simply a means of grouping
expressions and/or overriding precedences of operators. This is because
parentheses have two distinct roles: to group and/or override
precedences, and as a way of enclosing tuples of terms.

[[Square-Brackets]]
==== Square Brackets

Square brackets (`[` and `]`) are used to delimit certain kinds of list
and sequence expressions.

[[Braces]]
==== Braces

indexterm:[puncutation, braces]
((Braces)) are used to delimit groups of statements.

There are two forms of braces: with and without a period character.

....
Brace ::= { | } | {. | .}
....

They must be appropriately paired: a `{` must be paired with a
subsequent `}`; and similarly the `{.` must be paired with `.}`.

[[Special-Brackets]]
==== Special Brackets

There are several _special_ sets of brackets:

....
SpecialBracket ::= (| | |) |
  [| | |] |
  <| | |> |
  {! | !} |
  {? | ?}
....

As with other brackets, these must be appropriately paired. Each one of
these special bracket pairs takes a single term as argument – unlike the
`()` and `[]` brackets which take comma separated sequences.

[[Grammar]]
== Grammar

The grammar of *Star* is based on an _operator precedence grammar_. This
allows us to address the full grammar and semantics of `Star` in a
layered approach. The grammar layer is focused on the _well formed
formedness_ of `Star` programs – which expressions are syntactically
valid even though they may not be type correct.

In effect, the grammar layer represents the second layer (above the
lexical layer) in the ’tower of semantics’ that represents the full
semantics of `Star` programs.

[TIP]
====
This choice gives us two key benefits: it is simple to understand and it
is simple to extend. The latter is particularly important in `Star` as a
significant part of its functionality is derived from _profiles_ which
are similar to macros.
====
However, it also makes certain other aspects more challenging. In
particular, an operator precedence grammar knows less about the program
as it is parsed. This means that syntax errors are liable to less
informative.

[[Operator-Precedence-Grammar]]
=== Operator Precedence Grammar

An operator precedence grammar (OPG) allows us to write expressions
like:

....
X * Y + X / Y
....

and to know that this means the equivalent of:

....
(X * Y) + (X / Y)
....

or more specifically:

....
'+'('*'(X, Y), '/'(X, Y))
....

Operator precedence grammars are often used to capture arithmetic-style
expressions. In `Star` we extend the concept to cover the entire
language.

For example, an equation such as:

....
double(X) => X*X
....

can be interpreted – by treating `=>` as an operator – as:

....
'=>'(double(X),'*'(X,X))
....

Of course, this is merely a _parse_ of the equation. The real task of
the compiler is to interpret this abstract syntax as an equation rather
than as an attempt to apply the `=>` function.footnote:[The entire
operator precedence grammar (not including tokenization) is very
succinct, as can be seen in See link:#srOpPrecGrammar[srOpPrecGrammar].]

....
Term(Priority) ::= Prefix(Priority)
  | Infix(Priority)
  | Postfix(Priority)
  | Term0

Prefix(Priority) ::= Identifier Term(R) where prefix($1,P,R) and P<=Priority

Infix(Priority) ::= Term(L) Identifier Term(R) where infix($2,L,P,R) && P<=Priority

Postfix(Priority) ::= Term(L) Identifier where postfix($2,L,P) && P<=Priority

Term0 ::= 
....

Some notes about link:#srOpPrecGrammar[srOpPrecGrammar]:

* We are somewhat liberal with traditional BNF notation; terms such as
+
....
where infix($2,L,P,R) && P<=Priority
....
+
amount to _constraints_ on the production: this condition must be
satisfied in addition to the normal sequences of terminals and
non-terminals
* A non-terminal of the form:
+
....
Term(Priority)
....
+
amounts to a parameterized non-terminal. Or, equivalently, it stands for
all possible expansions of the non-terminal.
* This grammar is the basis of the actual grammar for `Star`; although
the actual implementation is somewhat more efficient than the ambiguous
grammar would suggest.
* There is an additional constraint not implied by this set of rules: a
given identifier may be an operator of more than one form - prefix,
infix and postfix.

[[Standard-Operators]]
=== Standard Operators

A key input to the grammar is the table of operators. There are a large
number of standard operators; some of which are symbolic and others are
alphanumeric in form.

The standard operators are listed in
link:#standardOperatorsTbl[standardOperatorsTbl]. Operators in this
table are listed in order of priority. Together with a priority,
operators can also be considered to `prefix`, `infix`, `postfix`, or
some combination of the three.

The priority of an operator is the indication of the ‘importance’ of the
operator: the higher the priority the nearer the top of the abstract
syntax tree the corresponding structure will be.

Priorities are numbers in the range 1..2000; by convention, priorities
in the range 1..899 refer to entities that normally take the role of
expressions, priorities in the range 900..1000 refer to predicates and
predicate-level connectives and priorities in the range 1001..2000 refer
to entries that have a statement or program level interpretation.

[width="100%",cols="18%,27%,5%,50%",options="header",]
|===
|Operator |Form |Priority |Description
|`retire` |non-associative prefix |901 |suspend computation

|`retire` |non-associative infix |901 |suspend computation

|`all` |non-associative prefix |1010 |universal quantifier

|`.<.` |non-associative infix |700 |set membership

|`^=` |non-associative infix |900 |optional decomposition match

|`&&` |right associative infix |910 |conjunction

|`^?` |left associative infix |800 |option propagate

|`~=` |non-associative infix |900 |not equals

|`~>` |non-associative infix |1231 |type function

|`throw` |non-associative prefix |930 |raise an exception

|`.|.` |left associative infix |720 |bitwise or

|`do` |non-associative prefix |200 |do {}

|`do` |non-associative infix |1200 |while T do {}

|`import` |non-associative prefix |900 |import module

|`catch` |non-associative infix |1199 |try {...} catch {...}

|`valis` |non-associative prefix |930 |return value from execution

|`,..` |non-associative infix |1000 |list cons

|`for` |non-associative prefix |1175 |for ... do {}

|`••` |left associative infix |450 |binary function composition

|`**` |left associative infix |600 |exponentiation

|`->` |non-associative infix |890 |map entry

|`.+.` |non-associative prefix |700 |count of number of bits

|`<$` |right associative infix |720 |constant replace

|`raise` |non-associative prefix |930 |raise an exception

|`then` |non-associative infix |1180 |if ... then ... else

|`!` |non-associative postfix |100 |pick up value from a ref cell

|`!` |non-associative infix |100 |pick up value from a ref cell

|`->>` |non-associative infix |1200 |dependent type marker

|`?=` |non-associative infix |900 |optional decomposition match

|`default` |non-associative postfix |940 |default value marker

|`#` |non-associative prefix |1750 |Macro statement marker

|`#` |non-associative infix |760 |package separator

|`??` |right associative infix |920 |conditional operator

|`%` |left associative infix |700 |modulo

|`<-` |non-associative infix |905 |variable bind

|`.>>>.` |left associative infix |600 |arithmetic shift right

|`\\+` |left associative infix |700 |add element to set

|`*` |non-associative postfix |700 |multicat

|`*` |left associative infix |700 |multiplication

|`\\-` |left associative infix |700 |remove element from set

|`+` |non-associative postfix |700 |one or more repetitions

|`+` |left associative infix |720 |addition

|`.>>.` |left associative infix |600 |logical shift right

|`resume` |non-associative prefix |890 |suspend computation

|`resume` |non-associative infix |890 |suspend computation

|`*>` |non-associative infix |905 |for all

|`,` |right associative infix |1000 |tupling operator

|`contract` |non-associative prefix |1560 |contract definition

|`\\/` |left associative infix |720 |union

|`-` |non-associative prefix |300 |arithmetic negation

|`-` |left associative infix |720 |subtraction

|`raises` |non-associative infix |1000 |type of values that can raise
exceptions

|`.` |non-associative prefix |10 |identify enumerator

|`.` |left associative infix |100 |object access

|`/` |left associative infix |700 |division

|`<*>` |right associative infix |950 |applicative splat

|`try` |non-associative prefix |1200 |try {...} catch {...}

|`exists` |non-associative prefix |1010 |existential quantifier

|`if` |non-associative prefix |1175 |if ... then ... else

|`:` |non-associative infix |1250 |type annotation

|`;` |non-associative postfix |1251 |sequencing operator

|`;` |right associative infix |1251 |sequencing operator

|`<` |non-associative infix |900 |less than

|`.=` |non-associative infix |900 |pattern match

|`=>>` |right associative infix |950 |continuation arrow

|`=` |non-associative infix |975 |definition

|`|:` |non-associative infix |1235 |constrained type

|`show` |non-associative prefix |1240 |display debug message

|`++` |right associative infix |720 |concatenate

|`>` |non-associative infix |900 |greater than

|`return` |non-associative prefix |930 |wrap value in monad

|`?` |non-associative prefix |820 |mark expression as optionally there

|`@` |non-associative prefix |400 |meta annotation

|`@` |right associative infix |400 |meta annotation

|`|=` |non-associative infix |999 |implicit variable

|`in` |right associative infix |900 |list membership

|`break` |non-associative prefix |10 |break out of an action (loop or
block)

|`suspend` |non-associative prefix |890 |suspend computation

|`suspend` |non-associative infix |890 |suspend computation

|`open` |non-associative prefix |900 |import object

|`trace` |non-associative prefix |140 |display tracing message

|`~~` |right associative infix |1240 |quantifier

|`assert` |non-associative prefix |1240 |assert condition

|`⊕` |left associative infix |720 |addition

|`.^.` |left associative infix |720 |bitwise xor

|`//` |left associative infix |960 |map over

|`public` |non-associative prefix |1700 |public program

|`ref` |non-associative prefix |899 |reference type/cell

|`.~.` |non-associative prefix |650 |bitwise 1’s complement

|`where` |non-associative infix |911 |semantic guard

|`=<` |non-associative infix |900 |less than or equal

|`case` |non-associative prefix |901 |case expression

|`==` |non-associative infix |900 |equality predicate

|`\\` |left associative infix |700 |difference

|`=>` |right associative infix |950 |function arrow

|`^` |non-associative prefix |100 |Optional propagation

|`^` |non-associative infix |100 |Apply optional function and match
result

|`<=>` |non-associative infix |950 |constructor arrow

|`generator` |non-associative prefix |300 |define a generator expression

|`valof` |non-associative prefix |300 |evaluate an action expression

|`yield` |non-associative prefix |300 |yield in a generator expression

|`while` |non-associative prefix |1175 |while ... do {}

|`private` |non-associative prefix |1510 |private program

|`•` |left associative infix |450 |function composition

|`.&.` |left associative infix |700 |bitwise and

|`///` |left associative infix |960 |indexed map over

|`::` |non-associative infix |400 |type coercion

|`+++` |right associative infix |720 |choice

|`:=` |non-associative infix |975 |assignment

|`:?` |non-associative infix |400 |fallable type coercion

|`.<<.` |left associative infix |600 |shift left

|`implementation` |non-associative prefix |1260 |contract implementation

|`>>=` |right associative infix |950 |monadic bind

|`^/` |left associative infix |960 |filter

|`<~` |non-associative infix |999 |type interface rule

|`type` |non-associative prefix |1251 |type marker

|`|` |left associative infix |1548 |type union and abstraction

|`.#.` |left associative infix |600 |test nth bit

|`handle` |non-associative infix |1199 |try {...} handle {...}

|`~` |non-associative prefix |905 |logical negation

|`^//` |left associative infix |800 |filter map

|`||` |right associative infix |920 |disjunction

|`else` |right associative infix |1200 |if ... then ... else

|`::=` |non-associative infix |1550 |algebraic type definition

|`/\\` |left associative infix |700 |intersection

|`>=` |non-associative infix |900 |greater than or equal

|`>>` |right associative infix |950 |monadic bind
|===

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Keyword |Keyword |Keyword
|`retire` |`all` |`throw`
|`do` |`import` |`catch`
|`valis` |`for` |`raise`
|`then` |`default` |`resume`
|`contract` |`raises` |`try`
|`exists` |`if` |`in`
|`break` |`suspend` |`open`
|`public` |`ref` |`where`
|`case` |`generator` |`valof`
|`yield` |`while` |`private`
|`implementation` |`type` |`handle`
|`else` | |
|===

[width="100%",cols="5%,17%,2%,17%,2%,17%,2%,17%,2%,17%,2%",]
|===
|`.<.` |`^=` |`&&` |`^?` |`~=` | | | | | |
|`~>` |`.|.` |`,..` |`••` |`**` | | | | | |
|`->` |`.+.` |`<$` |`!` |`->>` | | | | | |
|`?=` |`#` |`??` |`%` |`<-` | | | | | |
|`.>>>.` |`\\+` |`*` |`\\-` |`+` | | | | | |
|`.>>.` |`*>` |`,` |`\\/` |`-` | | | | | |
|`.` |`/` |`<*>` |`:` |`;` | | | | | |
|`<` |`.=` |`=>>` |`=` |`|:` | | | | | |
|`++` |`>` |`?` |`@` |`|=` | | | | | |
|`~~` |`⊕` |`.^.` |`//` |`.~.` | | | | | |
|`=<` |`==` |`\\` |`=>` |`^` | | | | | |
|`<=>` |`•` |`.&.` |`///` |`::` | | | | | |
|`+++` |`:=` |`:?` |`.<<.` |`>>=` | | | | | |
|`^/` |`<~` |`|` |`.#.` |`~` | | | | | |
|`^//` |`||` |`::=` |`/\\` |`>=` | | | | | |
|`>>` | | | | | | | | | |
|===

[[Programs]]
== Programs

This chapter focuses on the organization of programs using functions,
types and other computational forms. Apart from program values
themselves, a key concept is the
link:#ThetaEnvironment[ThetaEnvironment]. This is where many functions,
types etc. are defined.

[[Package-Structure]]
=== Package Structure

A link:#Package[Package] consists of the package identifier and a set of
link:#Definition[Definition]s enclosed in braces. For example, the text:

....
hello{
  hello() => "hello".
}
....

defines a `package` – called `hello` – that contains a single function –
also called `hello`.

Typically, however, package identifiers take the form of a dotted
sequence of identifiers:

....
hello.example{
  hello() => "hello".
}
....

The body of a link:#Package[Package] may contain
link:#Definition[Definition]s which may also include
link:#ImportStatement[ImportStatement]s.

....
Package ::= PackageName ThetaEnvironment

PackageName ::= Identifier . … . Identifier
....

[[Managing-Exposed-Elements-of-a-Package]]
==== Managing Exposed Elements of a Package

By default, all the elements that are defined in a package are _not_
exported as part of the package. Only those elements that are marked
`public` will be exported.footnote:[An element in a package may be
marked `private` – which will also ensure that it is not visible outside
the package.]

[[Theta-Environment]]
=== Theta Environment

A link:#ThetaEnvironment[ThetaEnvironment] consists of a set of
definitions of types, programs and variables.

....
ThetaEnvironment ::= { Definition Terminator … Terminator Definition }

Definition ::= TypeDefinition
  | Annotation
  | TypeAnnotation
  | VariableDefinition
  | FunctionDefinition
  | ContractDefinition
  | ContractImplementation
  | OpenStatement
  | ImportStatement
....

Many of the definitions in a link:#ThetaEnvironment[ThetaEnvironment]
define entities that may be recursive and mutually recursive.

There are two variants of link:#ThetaEnvironment[ThetaEnvironment]:
recursive and non-recursive. Definitions within a recursive environment
may reference each other as well as definitions from an outer scope.
Conversely, definitions in a non-recursive environment may only access
definitions from the outer scope.

In most cases, a recursive environment is distinguished from a
non-recursive environment by special `{..}` brackets. So, for example:

....
let{.
  f(0)=>1.
  f(N)=>N*f(N-1)
.} in f
....

defines a recursive function `f`. However, in:

....
foo(N) => let{
  g(X) => X*N
} in g(N)
....

the definition of `g` is not permitted to be recursive. A fragment such
as:

....
foo(K) => let{
  f(0)=>1.
  f(N)=>N*f(N-1)
} in f(K)
....

would result in an undefined variable error – because the recursive
reference to `f` would not be recognized.

[NOTE]
====
Although, as noted, most recursive environments are introduced using
`{..}` brackets, the link:#ThetaEnvironment[ThetaEnvironment] that makes
up a package is recursive. This is partly because a non-recursive
package environment is mostly meaningless.
====

[[Type-Annotations]]
=== Type Annotations

indexterm:[type annotation]

In most cases it is not necessary to explicitly declare the type of a
variable – or any expression. However, it is good practice to declare
explicitly the types of programs; especially within ThetaEnvironments,
and it is required if the type of the variable is intended to be
generic.

....
TypeAnnotation ::= Variable : Type
....

For example, a generic function `consLength` that takes a `cons` list
and returns an integer would have the declaration:

....
consLength:all t ~~ (cons[t])=>integer
....

[[Type-Definitions]]
=== Type Definitions

indexterm:[type definition]

There are several ways that a type may be defined in a scope – i.e., a
link:#ThetaEnvironment[ThetaEnvironment].

....
TypeDefinition ::= AlgebraicTypeDefinition
  | TypeExistsStmt
  | TypeAliasStmt
....

[[Algebraic-Type-Definition]]
==== Algebraic Type Definition

An algebraic type definition is a statement that defines a type in terms
of different constructors for the type.

....
AlgebraicTypeDefinition ::= Type ::= AlgebraicConstructor | …  | AlgebraicConstructor

AlgebraicConstructor ::= EnumeratedSymbol
  | PositionalConstructor
  | RecordConstructor

PositionalConstructor ::= . Identifier ( Type ,  …  , Type )

RecordConstructor ::= Identifier { Annotation Terminator …  Terminator Annotation }
....

An algebraic type definition is a statement that introduces a new type;
it also defines the possible values associated with the type.

As illustrated in link:#algebraicTypeDefFig[algebraicTypeDefFig], an
algebraic type definition introduces the new type and defines one or
more link:#AlgebraicConstructor[AlgebraicConstructor]s – separated by
the `|` operator.

An AlgebraicConstructor is a specification of a value of a type; i.e.,
constructors _paint a picture_ of the shape of potential values of the
type.

There are three kinds of Constructor: enumerated symbols, term
constructor constructors and labeled record constructors.

As elaborated below, each _arm_ of an algebraic type definition defines
a value or set of values that belong to the type. There is a slightly
more formal way of expressing this: an algebraic type definition induces
a set of free functions.

indexterm:[constructor,bijection]

Free functions are technically bijections – they are one-to-one – i.e.,
they have inverses. In programming languages, free functions are used as
data structuring tools; but mathematically they are functions.

For example, the type definition:

....
person ::= .noone | .someone(string,integer)
....

induces the constructor function for `someone`:

....
someone : (string,integer) <=> person
....

The enumerated symbol has a simpler type:

....
noone : () <=> person
....

whereas:

....
.noone : person
....

The complete set of constructor functions introduced within an algebraic
type definition is complete: i.e., they define all the possible values
of the type.

[NOTE]
====
A given label, whether it is used as an
link:#EnumeratedSymbol[EnumeratedSymbol], the label of a
link:#PositionalConstructor[PositionalConstructor] or a
link:#RecordConstructor[RecordConstructor] can be defined only once.
I.e., it is not permitted to _share_ constructor labels across different
types. Nor may such a label be used as the name of a variable in the
same scope.
====

[NOTE]
====
Different record constructors within an algebraic type definition may
define fields with the same name. For example, in

....
person ::= student{name:string. course:string} |
  employee{name:string. company:string}
....

the `name` field occurs in both the `student` constructor and the
`employee` constructor.

In the event of defining the same field in multiple constructors, the
types associated with them _must be identical_.
====
[NOTE]
====
An link:#AlgebraicTypeDefinition[AlgebraicTypeDefinition] statement for
a generic type (i.e., a type with type parameters) may omit the explicit
quantifiers. I.e., instead of

....
all e ~~ cons[e] ::= .nil | .cons(e,cons[e])
....

it is permissable to write:

....
cons[e] ::= .nil | .cons(e,cons[e])
....

The reason is that the quantifiers in such a definition may be reliably
inferred without being explicitly identified.
====
[[Type-Exists-Statement]]
==== Type Exists Statement

....
TypeExistsStmt ::= [all BoundType ,…,BoundType ~~] Type <~ FaceType
....

[NOTE]
====
The explicit use of link:#TypeExistsStmt[TypeExistsStmt]s is rare.
However, they are automatically constructed in some situations.
====
The link:#TypeExistsStmt[TypeExistsStmt] declares the existence of a
type – together with its associated algebraic interface (see
link:#typeInterface[typeInterface]). It does so without specifying any
constructors for the type.

[[Type-Alias-Statement]]
==== Type Alias Statement

A type alias is a statement that introduces a new type name by mapping
it to an existing type expression.

....
TypeAliasStmt ::= [all BoundType ,…,BoundType ~~] Type ~> Type
....

Type aliases may be parameterized – in the sense that the type being
defined may be parameterized and that the definiens may also be
parameterized.

Note that the any type variables on the right hand side of a
link:#TypeAliasStmt[TypeAliasStmt] must also have been mentioned on the
left hand side.

For example, the statement:

....
time ~> integer
....

declares a new type that is an alias for `time` – i.e., that it is
actually equivalent to the `integer` type.

[TIP]
====
Type aliases allow the programmer to signal that a particular type is
being used in a special way. In addition, during program development,
type aliases are useful to provide markers for types that will be
elaborated further with a regular algebraic definition.
====
Type aliases have no run-time presence. In fact, they may be viewed
as a simple form of type macro – type expressions that match the left
hand side are replaced by the type expression on the right hand side.
However, type aliases have some definite constraints: a type alias may
not be, directly or indirectly, recursive.

[NOTE]
====
A second role for link:#TypeAliasStmt[TypeAliasStmt]s is to signal the
fulfillment of an link:#ExistentialType[ExistentialType] requirement.
====
[[Variable-Definition]]
=== Variable Definition
indexterm:[variable definition]
indexterm:[declaration, variable]

A link:#VariableDefinition[VariableDefinition] is a
link:#Definition[Definition] or an link:#Action[Action] that explicitly
denotes the declaration of a variable.
link:#VariableDefinition[VariableDefinition]s may appear in
link:#ThetaEnvironment[ThetaEnvironment]s and link:#Action[Action]s.

....
VariableDefinition::=Variable = Expression
 | Variable := Expression
....

A re-assignable variable is declared using the form:

....
Variable := Expression
....

[NOTE]
====
Unlike single assignment variable declarations, the re-assignable
variable declaration is restricted to defining individual variables.
====
[NOTE]
====
It is not possible to declare a variable without also giving it a value.
====

[[Variable-Scope]]
==== Variable Scope

indexterm:[variable, scope]
indexterm:[scope of variable]

In general, the scope of a variable extends to include the entire
context in which it is declared. In the case of a variable declaration
in a link:#ThetaEnvironment[ThetaEnvironment], the scope includes the
entire link:#ThetaEnvironment[ThetaEnvironment] and any associated bound
element. In the case of an link:#BlockAction[BlockAction] the scope
extends from the action following the declaration through to the end of
the enclosing link:#BlockAction[BlockAction].

The precise rules for the scope of a variable are slightly complex but
result in a natural interpretation for the scopes of variables:

* Variables that are defined in patterns are limited to the element that
is naturally associated with that pattern:
** Variables declared in the head pattern of an equation or other rule
are scoped to that equation or rule.
** If a pattern governs a conditional expression or statement, variables
declared in the pattern extend to the then part of the conditional but
not to any else part.
** No variables declared in a negated condition escape that condition
** If a pattern governs a `for` loop, or a `while` loop, then variables
declared in the pattern extend to the body of the loop. (See
link:#ForAction[ForAction] and link:#WhileAction[WhileAction]).
* Variables that are defined in a link:#Condition[Condition] are bound
by the scope of the link:#Condition[Condition].
* Variables that are declared in a
link:#ThetaEnvironment[ThetaEnvironment] extend to all the definitions
in the link:#ThetaEnvironment[ThetaEnvironment] and to any bound
expression or action.
+
[NOTE]
====
In particular, variables defined within a
link:#ThetaEnvironment[ThetaEnvironment] may be mutually recursive.

[NOTE]
====
Note that it is _not_ permissible for a non-program variable to be
involved in a mutually recursive group of variables. I.e., if a group of
mutually recursive of variables occurs in a
link:#ThetaEnvironment[ThetaEnvironment] then all the variables must be
bound to functions or other program elements.
====
====
* Variables that are imported into a package body from another package
extend to the entire body of the importing package.
* Variables that are declared in an link:#BlockAction[BlockAction]
extend from the end of their
link:#VariableDefinition[VariableDefinition] to the end of the block
that they are defined in. The scope of a variable does not include its
link:#VariableDefinition[VariableDefinition].
+
It is not permitted for a variable to be declared more than once in a
given action block.

[[Scope-Hiding]]
===== Scope Hiding

indexterm:[scope, hiding]
indexterm:[variable, hiding]

It is not permitted to define a variable with the same name as another
variable that is already in scope. This applies to variables declared in
patterns as well as variables declared in
link:#ThetaEnvironment[ThetaEnvironment]s.

For example, in the function:

....
hider(X) => let{
  X = 1
} in X
....

the inner declaration of `X` effectively amounts to an equality test
that the the `X` that occurs in the head of the function is equal to
`1`.

[[Reassignable-Variables]]
==== Re-assignable Variables

indexterm:[variable, re-assignable]

Re-assignable variables serve two primary roles within programs: to hold
and represent state and to facilitate several classes of algorithms that
rely on the manipulation of temporary state in order to compute a
result.

In order to facilitate program combinations – including procedural
abstraction involving re-assignable variables – there are additional
differences between re-assignable variables and single-assignment
variables.

In particular, re-assignable variables have a distinguished type
compared to single-valued variables – they must be of
link:#ReferenceType[ReferenceType].

In addition to the different type, there are two operators that are
associated with re-assignable variables: `ref` and `!` (pronounced
_shriek_). The former is used in situations where a variable’s name is
intended to mean the variable itself – rather than its value. The latter
is the converse: where an expression denotes a reference value that must
be ‘dereferenced’.

[[Functions-and-Equations]]
=== Functions and Equations

A ((function)) is a program for computing values; organized as a set of
equations.

....
FunctionDefinition ::= Equation ... Equation

Equation ::= RuleHead [GuardCondition]] => Expression
  | DefltEquation

DefltEquation ::= RuleHead default => Expression

RuleHead ::= Identifier(Pattern,...,Pattern)

GuardCondition ::= where Condition
....

[NOTE]
====
Functions and other program values are first class values; as a result
they may be passed as arguments to other functions as well as being
assigned as attributes of records.

====
Functions can be defined in a
link:#ThetaEnvironment[ThetaEnvironment] – which case they must be
associated with an explicit or implicit
link:#TypeAnnotation[TypeAnnotation] – or they may be _anonymous_ –
i.e., appear as a function literal in an expression.

[[Equations]]
==== Equations

An equation is a rule for deciding how to rewrite an expression into a
simpler expression. Each equation consists of a
link:#TuplePattern[TuplePattern] that is used to match the call to the
function and a replacement expression. The left hand side of the
function may also have a guard associated with it, this guard may use
variables introduced in the pattern.

[NOTE]
====
An equation is said to apply iff the patterns in the left hand side of
the equation (including any `where` clauses) all match the corresponding
actual arguments to the function application.
====theta environment

Functions are defined in the context of a
link:#ThetaEnvironment[ThetaEnvironment] – for example, in the body of a
`let` expression (see link:#LetExpression[LetExpression]), or at the
top-level of a `package`.

It is not necessary for the equations that define a function to be
contiguous within a link:#ThetaEnvironment[ThetaEnvironment]. However,
all the equations for a function must be present in the _same_
link:#ThetaEnvironment[ThetaEnvironment].

===== Type of Functions

The type safety of a function is addressed in stages. In the first
place, we give the rules for individual equations:

....
E |= A:AT /\ E’ |= R:RT => E |= A=>R : AT=>RT
....

This states that the type of an equation is a function type: from the
type of the argument pattern to the type of the result expression.

If the equation has a link:#GuardCondition[GuardCondition], that that
condition must be type satisfiable:

....
E |= A:AT /\ E’ |= sat(C) /\ E” |= R:RT => E |= A=>R : AT=>RT
....

where _E’_ is the original environment _E_ extended with the variable
definitions found in the pattern `A` and _E”_ is _E’_ extended with the
variables found in the condition `C`.

In fact this rule slightly understates the type safety requirement. For
any statement in a theta environment we also have:

[[Evaluation-Order-of-Equations]]
==== Evaluation Order of Equations

equations,evaluation order

Using multiple equations to define a function permits a case-base
approach to function design – each equation relates to a single case in
the function. When such a function is _applied_ to actual arguments then
only one of the equations in the definition may apply.

Equations are applied in the order that they are written – apart from
any equation that is marked `default`. If two equations overlap in their
patterns then the first equation to apply is the one used.

[[Default-Equations]]
==== Default Equations

default equation

default

equation

functions,default

default

equation

It is permitted to assign one of the equations in a function definition
to be the `default` equation. An equation marked as `default` is
guaranteed _not_ to be used if any of the non-default equations apply.
Thus, a `default` equation may be used to capture any remaining cases
not covered by other equations.

patterns,variable pattern

A `default` equation may not have a `where` clause associated with it,
and furthermore, the patterns in the left hand-side should be generally
be variable patterns (see link:#patternVariables[patternVariables]).

[NOTE]
====
In particular, it _should_ be guaranteed that a `default` equation
cannot fail to apply.
====
[[Evaluation-Order-of-Arguments]]
==== Evaluation Order of Arguments

function application,evaluation order

There is _no_ guarantee as to the order of evaluation of arguments to a
function application. In fact, there is no guarantee that a given
expression will, in fact, be evaluated.

[NOTE]
====
The programmer should also _not_ assume that argument expressions will
_not_ be evaluated!
====In general, the programmer should make the fewest possible
assumptions about order of evaluation.

[[Pattern-Coverage]]
==== Pattern Coverage

patternCoverage patterns,coverage of

Any given equation in a function definition need not completely cover
the possible arguments to the function. For example, in

....
F : (integer)=>integer.
F(0) => 1.
F(X) => X*F(X-1).
....

the first equation only applies if the actual argument is the number
`0`; which is certainly not all the `integer`s.

The set of equations that define a function also define a coverage of
the potential values of the actual arguments. In general, the coverage
of a set of equations is smaller than the possible values as determined
by the type of the function.

If a function is _partial_ – i.e., if the coverage implied by the
patterns of the function’s equations is not complete with respect to the
types – then the compiler _may_ issue an incomplete coverage warning.
Furthermore, if a function fails to apply at run-time then this is a
_fatal error_ and evaluation of the program will halt.

[NOTE]
====
The programmer is advised to make functions _total_ by supplying an
appropriate `default` equation. In the case of the `F`actorial function
above, we can make the `default` case explicit as is shown in
link:#factorialFunProg[factorialFunProg].
====
....
fact : (integer)=>integer.
fact(X) where X>0 => X*fact(X-1).
fact(X) default => 1
....

[[Anonymous-Function]]
==== Anonymous Function

anonymous function

expressions,function

Anonymous functions – or lambda expressions – are expressions of the
form:

....
(X) => X+Y
....

Lambda expressions may appear anywhere a function value is permitted.

....
LambdaExpression ::= TuplePattern => Expression
....

[NOTE]
====
If it desired to have a single-argument anonymous function that takes a
tuple pattern then use double parentheses:

....
((X,Y)) => X+Y
....
====For example, a lambda expression to add 1 to its single argument
would be:

....
(X) => X+1
....

Lambda expressions are often used in function-valued functions. For
example in:

....
addX:(integer)=>((integer)=>integer).
addX(X) => ((Y) => X+Y)
....

the value returned by `addX` is another function – a single argument
function that adds a fixed number to its argument.

[NOTE]
====
Note the extra set of parentheses around both the embedded function type
and around the returned function value.
====[NOTE]
====
Lambda expressions functions may reference free variables.
====
[[Contract-Definition]]
=== Contract Definition

type,contracts

A contract definition is a statement that defines the functions and
action procedures associated with a contract. As can be seen in
contractFig, a contract statement associates a contract name – together
with a set of type variables – with a set of TypeAnnotations that define
the elements of the contract. Within the Contract statement, a
TypeAnnotation may varer to the type(s) in the contract head.

....
ContractDefinition ::= contract ContractSpec ::= FaceType

ContractSpec ::= [all BoundType ,…,BoundType ~~] Identifier [ TypeArgSpec [->> TypeArgSpec] ]

TypeArgSpec ::= TypeVariable , … , TypeVariable
....

For example, the contract that underlies
link:#TypeCoercion[TypeCoercion] expressions is:

....
contract all s,t ~~ coercion[s,t] <~ { coerce:(s)=>t }
....

default values,contract

A contract statement may also include _defaults_ for the names defined
in the contract. If a given contract implementation does not give an
implementation for a name that has a default associated for it, then the
default is used.

[NOTE]
====
Default specifications may use variables that are in scope at the point
of the contract specification.footnote:[This is generally not the same
scope as where a contract implementation is given.]
====[TIP]
====
The type quantifier may be omitted from
link:#ContractDefinition[ContractDefinition]s – _except_ for the case
that a higher-kinded type is being quantified.
====[TIP]
====
An important usage pattern for contracts is to represent _abstract
types_. An abstract type is one defined by its contract rather than one
defined by an explicit type definition.

For example, the `arith` contract in
link:#arithContractProg[arithContractProg] defines a set of arithmetic
functions. However, it can also be interpreted as a definition of an
abstract type of arithmetic values – the values that implement the
`arith` contract.
====____
*Under the covers:* If the contract statement looks like a type
definition, that is because it _is_ a kind of type definition.
Specifically, it defines a dictionary of sorts – of the elements defined
within the contract.
____

[[Functional-Dependencies]]
==== Functional Dependencies

type,contracts!functional dependencies

functional dependencies in contracts

For certain forms of contract, it may be that the type parameters may
not all be independent of each other. For example, consider the standard
`stream` contract (defined in
link:#streamContractProg[streamContractProg]) which reads:

....
public contract all S,E ~~ stream[S ->> E] ::= {
  _eof:(S) => boolean.
  _hdtl:(S) => option[(E,S)].
  _back:(S) => option[(S,E)].
}
....

The intention of the `stream` contract is to support processing
collections of elements in a sequential manner. The type parameter `S`
identifies the collection to be iterated over; and the type parameter
`E` identifies the type of each element.

However, the collection’s type uniquely determines the type of each
element: the element type is not independent of the collection. For
example, to iterate over a `cons[t]`, each element will be of type `t`;
and to iterate over a `string` each element will be a `integer` even
though the `string` type does not mention `integer`.

[NOTE]
====
Each `integer` represents a unicode code point in the `string`.
====Using a `->>` clause in a `contract` – and in corresponding contract
`implementation` statements – allows the contract designer to signal
this relationship.

[[Contract-Implementation]]
=== Contract Implementation

type,contracts!implementation

A contract implementation is a specification of how a contract is to be
implemented for a specific type combination.

....
ContractImplementation ::= implementation
ContractSpec => Expression
....

The link:#Type[Type]s mentioned in link:#ContractSpec[ContractSpec] must
be link:#NominalType[NominalType]s.

[NOTE]
====
In particular, it is not permitted to define an `implementation` of a
contract for FunctionTypes.

It is permissible, however, to implement Contracts for TupleTypes.
====The body of a contract `implementation` must be an expression that
gives a definition for each of the elements of the `contract`
specification.

[NOTE]
====
A `contract` implementation often takes the form of a regular
AnonymousRecord or an anonymous ThetaRecord.
====Usually, the implementation of a `contract` is fairly
straightforward. Program~link:#consSizeProg[consSizeProg], for example,
gives the implementation of the standard `sizeable` contract for the
`cons` type.

....
implementation all e ~~ sizeable[cons[e]] => {
  size(nil) => 0
  size(cons(_,T)) => size(T)+1

  isEmpty(nil) => true.
  isEmpty(_) default  => false
}
....

[[Implementing-Contracts-with-Functional-Dependencies]]
==== Implementing Contracts with Functional Dependencies

type,contracts!functional dependencies

Implementing a contract which has a functional dependency is exactly
analogous to implementing a regular contract. The dependent type(s) must
be identified in the `implementation` statement. For example, the
initial part of the implementation of the `stream` contract over `cons`
lists:

....
implementation all e ~~ stream[cons[e]->>e] => {
....

Note that this `implementation` implies that a `stream` over a `cons`
list connects the element type of the `cons[t]` type to the elements of
the `stream` contract.

[[Recursive-Contract-Implementations]]
==== Recursive Contract Implementations

More complex contract implementations may require the use of auxiliary
function definitions; and hence may involve the use of `let`
expressions. This is particularly the case when implementing a contract
that itself depends on other contracts being implemented.

For example, this is an implementation of the `comp` contract for `cons`
values:

....
public implementation all x ~~ comp[x],equality[x] |: comp[cons[x]] => let{.
  consLess(nil,_) => true.
  consLess(cons(H1,T1),cons(H2,T2)) where H1<H2 => true.
  consLess(cons(H1,T1),cons(H2,T2)) where H1==H2 => consLess(T1,T2).
  consLess(_,_) default => false.

  consGe(L1,L2) => ~ consLess(L2,L1).
.} in { (<) = consLess. (>=) = consGe }
....

[NOTE]
====
The implementation of `comp` for `cons` types is based on a requirement
that the individual elements of lists must also be compared. Hence the
clause

....
comp[x],equality[x] |: comp[cons[x]]
....

in the head of the contract `implementation` statement. The primary job
of the `consLess` function is to show how `cons` values may be compared.
However, it depends on `<` being defined for the element of the `cons`
list.
====Our definition of inequality for `cons` values assumes that:

* `nil` lists are less than any non-empty list;
* one non-empty list is less than another if the first element is less
than the first element of the second; and finally
* if the first elements of the two lists are identical then we consider
the tails of each list.

[TIP]
====
The curious reader may wonder why we introduce a new name `consLess` in
order to define `<` (and, by extension `consGe` for `>=`). The reason
for this has to do with limitations on type inference in the context of
recursive programs: within the equations that define a function, any
_use_ of the function symbol must represent a recursive use.
====For example, in the equation:

....
consLess(cons(H1,T1),cons(H2,T2)) where H1<H2 => true.
....

we are relying on a definition of inequality for the elements of the
`cons` list – whilst we are defining inequality for `cons` lists
themselves.

If we had tried to define `<` directly, using, for example:

....
cons(H1,T1)<cons(H2,T2) where H1<H2 => true.
....

then we would have two occurrences of `<` which really represent
different functions.

Normally, outside of the definition of the function, it is permitted to
allow a given function to be used in different uses – always assuming
that the types are consistent. However, within the definition of a
function, all occurrences of the function symbol must varer to the same
function.

In the case of the `<` equation above, the type inference system would
not be able to distinguish a recursive call from a call to a different
overloaded function of the same name; and would assume that both uses of
`<` are intended to be part of the same definition. This, in turn, would
result in a type error being generated.

In summary, when defining an overloaded function like `<`, we often have
to introduce an auxiliary function to _carry_ the recursion.

By using the `let` expression and the auxilliary `consLess` function we
are able to separately define inequality for `cons` lists while
depending on the implementation of `<` for their elements.

[[Importing-Packages]]
=== Importing Packages

import package

package,import

The link:#ImportStatement[ImportStatement] is used to signal that this
package depends on other packages.footnote:[The `import` statement is
only permitted at the top-level of a package.]

A package may use another package by importing it. The
link:#ImportStatement[ImportStatement] denotes a requirement that the
types, programs and other elements of the imported package are made
available to the importing package.

The link:#ImportStatement[ImportStatement] is used to denote that the
exported elements of another package should be made available within
this package. There are two variants of the
link:#ImportStatement[ImportStatement]: the open import and the named
import.

....
ImportStatement ::= OpenImportStatement
  | NamedImportStatement

OpenImportStatement ::= [public] import PackageName

NamedImportStatement ::= Variable import PackageName
....

[[The-open-import-Statement]]
==== The open import statement

import,open

open import

import

An link:#ImportStatement[ImportStatement] of the form:

....
import Pkg
....

imports all the definitions that are located with the Pkg and declares
them as being at the _same_ scope level as other
link:#Definition[Definition]s within the package.

This has two primary implications: all the exported definitions may be
used without qualification as though they had been defined locally.
However, if a given name is declared twice – even if in two separate
packages – then the compiler will show an error.

In addition to the regular functions and types defined in the imported
package, any contracts, and contract implementations that are defined in
the imported package are also in scope.

If the link:#OpenImportStatement[OpenImportStatement] is prefixed by a
`public` keyword then, in addition to importing the definitions, they
are also implicitly _re-exported_ by thhis package.

[NOTE]
====
By using `public` package imports it is possible to construct the
equivalent of a library – consisting of multiple packages internally but
viewed as a single package externally.
====
[[Named-Import]]
==== Named Import

import,named

An link:#ImportStatement[ImportStatement] of the form:

....
P import Pkg
....

is a _named import_ – so-called because it establishes a
link:#Variable[Variable] whose value is the contents of the imported
package and whose name is used to access the imported package.

Definitions that are imported as a named import are not immediately
defined to be in scope. Instead, they must be accessed via the package
variable – using link:#FieldAccess[FieldAccess] expressions.

For example, if `Pkg` exports a type `person` and a function `someone`,
then to use the type and function they are referenced from the `P`
variable – much like accessing link:#Record[Record] fields:

....
Joe : P.person.
Joe = P.someone("Joe")
....

Using named imports in this way is a convenient way to establish
different name spaces. Since all the definitions within the package must
be accessed via the link:#FieldAccess[FieldAccess] operator, the name
used to import the package effectively becomes a local name space for
that package and will not clash with neither other imported packages nor
locally defined functions and types.

[[Open-Statement]]
=== Open Statement

open statement

opening a record

record,opening

The link:#OpenStatement[OpenStatement] takes a
link:#Record[Record]-valued expression and opens its contents in a
link:#ThetaEnvironment[ThetaEnvironment]. It is analogous to an `import`
of the record.

....
OpenStatement ::= open Expression
....

Any fields and types that are declared within the
link:#Expression[Expression]’s type become defined within the enclosing
link:#ThetaEnvironment[ThetaEnvironment].

[NOTE]
====
The existing scope rules continue to apply; in particular, if there is a
name that is duplicated already in scope then a duplicate definition
error will be signaled.
====Normal type inference is not able to infer anything about the type
of the `open`ed link:#Expression[Expression]. Hence, this statement
requires that the type of the expression is already known.

For example, given the definition:

....
R : { type elem. op:(elem,elem)=>elem. zero:elem }
R = {
  integer ~> elem.
  op(X,Y) => X+Y.
  zero = 0.
}
....

then we can `open` `R` in a link:#LetExpression[LetExpression]:

....
let{
  open R.
  Z : elem.
  Z = zero.
} in Z
....

[NOTE]
====
Although the `open` statement makes available the types and fields
embedded in a record; existential abstraction still applies. In
particular, in this case the fact that the `elem` type is manifest as
`integer` within the record expression `R` is hidden.

The `elem` type (and the `zero` and `op` fields) are available within
the `let`; but no information about what `elem` actually is is
available.
====
[[Types]]
== Types

type system

*Star* is a strongly, statically, typed language. That means that all
values and all variables must have a unique well-defined type that is
determinable by inspecting the text of the program – effectively at
_compile time_.

The type system consists of a method for declaring new types, for
annotating expressions (and by extension programs) with their types and
a system of verifying the type consistency of programs.

This chapter focuses on the type language itself and the semantics of
types.

[[What-is-a-Type_003f]]
=== What is a Type?

____
A Type is an expression that denotes a collection of values.
____

[TIP]
====
Although a type is an expression, type expressions should not be
confused with normal expressions. Types generally play no part in
evaluation.
====Viewed as collections, types have some particular properties: no
value may be a member of more than one type collection; all values are
members of exactly one type collection.

A link:#TypeDefinition[TypeDefinition] introduces a new type and defines
what values belong to the type. A link:#TypeAnnotation[TypeAnnotation]
is an assertion that a particular expression – usually a variable – has
a certain type.

For many simple cases, a type is denoted by an identifier. For example,
the type identifier `string` denotes the set of all strings. More
explicitly, a value has type `string` ifffootnote:[The term "iff" means
"if and only if".] it belongs to the set denoted by the symbol `string`.

Many value-sets are effectively infinite in size: the size of the set of
``string``s is essentially unbounded; as is the set of `integer` values.

In addition to sets of values denoted by identifiers; there are other
kinds of value sets that have more complex type expressions. For
example, the set of _function values_ is denoted not by a single type
expression but a _schema_ of type expressions – each taking a form such
as:

....
(t1,…,tn)=>t
....

For example, the type expression

....
(integer)=>string
....

denotes the set of functions that take an `integer` as an argument and
produce a `string` value. Like the set of all integers, this set is also
infinite in size.

The language for denoting types is quite expressive. It is possible to
have types that are parameterized; that is they are composed from other
type expressions. It is also possible to have types that are not
explicitly named but are defined by constraints.

A simple example of a parameterized type is the `cons` type: a `cons`
type expression always involves the mention of another type – the type
of elements of the list. The type expression

....
cons[string]
....

denotes the type expression associated with lists whose elements are all
string values. Other examples of `cons` type include lists of integers:

....
cons[integer]
....

and even lists of lists of string valued functions:

....
cons[cons[(integer)=>string]]
....

[NOTE]
====
Technically, the `cons` symbol in:

....
cons[integer]
....

type function

is a link:#TypeConstructor[TypeConstructor]: it takes a type as an
argument and returns another type as result.
====Often it is convenient to be able to refer to types without being
specific about the type itself; for this purpose we use
link:#TypeVariable[TypeVariable]s.

A type variable a type identifier that is distinguished by being
introduced using an explicit quantifier – either `all` or `exist`. The
type expression:

....
all t ~~ cons[t]
....

denotes a list type of some unspecified element type – identified by the
type variable `t`.

[TIP]
====
The collection of values associated with this type expression is a
little more difficult to visualize than the set of lists of integers
(say). `cons[t]` denotes a set of `cons` values; but without more
information _we cannot say_ what the complete values look like – it is
dependent on the meaning of the type variable `t`.
====In order to properly understand the interpretation of a type
variable one must understand how the type variable is _bound_. In
general, there are three possibilities: the type variable may be
identified with (equal to) another type; the type variable may be bound
by a universal quantifier or by an existential quantifier.

A universally quantified type (see link:#UniversalType[UniversalType])
denotes a type that allows all possible instantiations for the type
variable. For example, function types often involve universal types. A
universally typed function is expected to work _for all values_ of the
type variable – which, in turn, means that the function definition can
make no assumptions about the actual type.

Existentially quantified types (see
link:#ExistentialType[ExistentialType]) are used to denote _abstract
types_; i.e., the existential quantifier signals that there is a type
that should be treated as an opaque _black box_.

[[Types-of-Types]]
==== Types of Types

type expressions

forms of types

link:#typeFig[typeFig] illustrates the top-levels of the different kinds
of type expressions that the programmer will encounter.

There are two main kinds of type expressions – so-called _structural_
type expressions and _named_ type expression. A structural type
expression encodes by convention the permitted _forms_ of values of that
type. By contrast, a named type expression is defined via some form of
link:#TypeDefinition[TypeDefinition].

A classic example of a structural type expression is the function type.
A function type expression defines both the types of the arguments and
result type of the function. But, more importantly, it signals that the
value is a function.

....
Type::=NominalType
  | TypeVariable
  | TupleType
  | FaceType
  | ReferenceType
  | FunctionType
  | ConstructorType
  | RaisesType
  | QuantifiedType
  | TypeConstraint |: Type
  | ( Type )
  | EncapsulatedType

QuantifiedType ::= UniversalType | ExistentialType
....

[[Nominal-Types]]
=== Nominal Types

nomical types

types,nominal

A link:#NominalType[NominalType] is a term that identifies a class of
values by name. The name may or may not have
link:#TypeArgument[TypeArgument]s – in which case, the type is said to
be _parameterized_.

A good example of a named type (or, more formally, nominal type) is the
standard `integer` type. The word `integer` does not signal by itself
that the allowable operations on integer values include arithmetic,
comparison and so on. That information must come from additional
statements and declarations.

One of the other differences between structural and named type
expressions is that the latter may be used to denote _recursive_ types,
whereas the former cannot.

[TIP]
====
A recursive type is one whose values may contain elements that are
themselves of the same type. For example, in a `tree` type: the nodes of
the tree are typically themselves trees.
====
....
NominalType ::= SimpleType | ParameterizedType

SimpleType ::= TypeConstructor

ParameterizedType ::= TypeConstructor [TypeArgument]

TypeConstructor ::= Identifier

TypeArgument ::= Type | Type ,…, Type
....

[[Predefined-Simple-Types]]
==== Predefined Simple Types

simple type

A simple type is a link:#NominalType[NominalType] with no type
arguments. Some simple types are pre-defined,
link:#predefinedTypes[predefinedTypes] gives a table of such types.

`boolean`::
  used for logical values and conditions
`char`::
  used for character values
`float`::
  type of floating point numbers
`integer`::
  type of fixed precision integer values
`bigint`::
  type of arbitrary precision integer values
`string`::
  type of string values

[[Parameterized-Types]]
==== Parameterized Types

type expression

parameterized types

A parameterized link:#Type[Type] consists of a
link:#TypeConstructor[TypeConstructor] applied to one of more
link:#Type[Type] arguments. For example, the standard `cons` type
constructor has one type argument – the type of elements of the `cons`.

A parameterized type has a _type arity_ – the number of type arguments
it expects. This is defined when the type itself is defined. It is an
error to write a type expression involving an incorrect number of type
arguments.

Parameterized types may be defined using a
link:#TypeDefinition[TypeDefinition] statement.

[NOTE]
====
type,variable constructor

type constructor expression

A type expression of the form:

....
c[t1,…,tn]
....

where `c` is a type variable – i.e., bound by a quantifier – denotes a
rather special form of type: a type constructor expression. Like other
parameterized type expressions, this expression does not denote a single
type; but a set of types. For example, the type expression:

....
c[integer]
....

denotes a type _something of `integer`_.

A subsequent constraint on `c` may cause it to be bound to the
link:#TypeConstructor[TypeConstructor] `cons` (say), in which case the
type expression becomes ground to the parameterized type expression
`cons[integer]`.

Such type expressions are of most use in certain forms of
link:#Contract[Contract] where the contract is about a certain form of
parameterized type.
====
[[Type-Interface]]
==== Type Interface

Nominal types are associated with a link:#FaceType[FaceType] that
denotes nthe _interface_ to the type.

This interface contains all the fields that are defined in any of the
link:#RecordConstructor[RecordConstructor]s that are part of the
link:#AlgebraicTypeDefinition[AlgebraicTypeDefinition] that defines the
link:#NominalType[NominalType].

For example, given the type definition:

....
person ::= layPerson{name : string. address:string }
  | student{name:string. study:string }
....

the interface to `person` is determined to be the
link:#FaceType[FaceType]:

....
{
  name : string.
  address : string.
  study : string
}
....

[NOTE]
====
The interface of a link:#NominalType[NominalType] is formed from the
union of all the fields defined in the
link:#RecordConstructor[RecordConstructor]s.

This is one reason why a given field occurring in multiple
link:#RecordConstructor[RecordConstructor]s must have the same type.
====
[[Structural-Types]]
=== Structural Types

types,structural

structural types

A structural type is a type expression that looks like its purpose.
There are three main forms of structural type: tuple types, program
types and record types.

[[Tuple-Types]]
==== Tuple Types

tuple types

type,tuple

A tuple type is a tuple of types; written as a sequence of type
expressions enclosed in parentheses.

....
TupleType ::= ()
  | (( Type ))
  | (Type,…,Type)
....

A tuple type denotes a fixed grouping of elements. Each element of the
tuple may have a different type.

There are two special cases in link:#TupleType[TupleType]s: the empty
tuple and the singleton tuple type.

===== Empty Tuple

tuple,empty tuple type

empty tuple type

The empty tuple type:

....
()
....

refers to the empty tuple. It is useful primarily for writing function
types where the function has no arguments:

....
()=>string
....

When used as the return type of a function, the `()` type denotes a void
result:

....
(integer)=>()
....

[TIP]
====
The `()` type – sometimes referred to as the _unit type_ – is also used
to denote the return type of some actions.
========= Singleton Type Tuple

tuple,singleton tuple type

In some cases, a singleton tuple must be written with two parentheses.
This is to disambiguate such terms from simple expression parentheses. A
type expression of the form:

....
(integer)
....

is equivalent to just the `integer` type; whereas

....
((integer))
....

denotes the single element tuple type whose element type is `integer`.

[NOTE]
====
The double set of parentheses is not needed, for example, in giving the
type signature of a unary function.
====For example, the type

....
(integer)=>integer
....

denotes a unary function of one argument. The similar type expression:

....
((integer))=>integer
....

denotes a unary function type, whose _argument_ is a unary or singleton
tuple.footnote:[This complexity arises because parentheses have a dual
role: to group expressions and as a notation for tuples.]

[[Record-Types]]
==== Record Types

type,record type

record type

A link:#FaceType[FaceType] is a type expression that denotes a named
association of fields and types. A record type is written as a sequence
of type annotations enclosed in braces.

....
FaceType ::= {Annotation … Annotation }

Annotation ::= TypeAnnotation
  | TypeEquality

TypeEquality ::= type Identifier = Type
....

[NOTE]
====
The various annotations in a record type are terminated by a dot-space
terminator.
====Record types are used as the basis of other features of the type
language – including the link:#ConstructorType[ConstructorType] and
link:#Contract[Contract]s.

Two record types are equivalent if their elements are pair-wise
equivalent. Note that the _order_ of elements is not important. For
example, given the types:

....
{a:string. b:integer. }
....

and

....
{b:integer. a:t. }
....

these types unify – assuming that `t` is a bound type variable –
provided that `t` is unifiable with `string`.

[NOTE]
====
All nomimal types have a link:#FaceType[FaceType] interface associated
with them. This, as is detailed in link:#typeInterface[typeInterface],
defines a type for all of the fields in any of the constructors for the
type. In turn, this permits a link:#FieldAccess[FieldAccess] expression
to apply to a user-defined type as well as a link:#FaceType[FaceType].
====
[[Function-Types]]
==== Function Types

function type

type,function

A function type denotes a function value. It takes the form of a
possibly empty sequence of argument types – denoting the types of the
arguments to the function – enclosed in parentheses; followed by the
result type of the function. link:#functionTypeFig[functionTypeFig]
highlights the form of the function type:

....
FunctionType ::= TupleType => Type
....

For example, a function of two arguments – an `integer` and a `string`
that returns a list of `string`s has a type that takes the form:

....
(integer,string) => cons[string]
....

[[Raiseing-Types]]
==== Raiseing Types

raises type

type,raises

The `raises` type is used to indicate a function type that may raise an
exception.

A function type denotes a function value. It takes the form of a
possibly empty sequence of argument types – denoting the types of the
arguments to the function – enclosed in parentheses; followed by the
result type of the function. link:#functionTypeFig[functionTypeFig]
highlights the form of the function type:

....
RaisesType ::= Type raises Type
....

For example, an `integer` function may raise a `string` exception; this
would be signaled using a type of the form:

....
(integer) => integer raises string
....

Functions that raise exceptions may not be inferred: their type must be
explicitly declared; for example, the declaration:

....
foo:(integer) => integer raises string
....

declares that `foo` is a function from `integer` to `integer`, and it
may raise an exception – in the form of a `string`.

If such a function is used in an expression, then it must either be in
the lexical context of a link:#TryCatchAction[TryCatchAction],
link:#TryCatchExpression[TryCatchExpression] expression, or it must be
within the definition of a function that is also declared to raise
`string` exceptions.

[[Constructor-Type]]
===== Constructor Type

constructor type

type,constructor

A constructor is a special function that is introduced in an
link:#AlgebraicTypeDefinition[AlgebraicTypeDefinition].

[NOTE]
====
Constructors are special because they can be viewed simultaneously as a
function and as a pattern. Hence the form of the constructor reflects
that bidirectionality.
====
....
ConstructorType ::= Type <=> Type
....

The left hand side of a constructor type should either be a
link:#TupleType[TupleType] or an link:#FaceType[FaceType] – depending on
whether the denoted constructor is a term constructor constructor or a
record constructor.

[TIP]
====
Explicit link:#ConstructorType[ConstructorType]s are most used in the
context of the signatures of _abstract data types_: where a type and its
constructors are _exported_ from a record.
====
[[Reference-Type]]
==== Reference Type

reference type

type,var

A re-assignable variable is given a `ref`erence type.

....
ReferenceType ::= ref Type
....

Reference types allow the programmer to distinguish re-assignable
variables from other values; in particular they allow one to distinguish
between binding to the _value_ of a re-assignable variable or to its
_name_.

[NOTE]
====
The latter is not as common, but is important to support abstractions
involving re-assignable variables.
====The type of a re-assignable variable takes the form:

....
ref Type
....

For example, given the declaration:

....
var Ix := 0
....

the variable `Ix` has type `ref integer`; whereas the declaration:

....
Jx = 0
....

results in the variable `Jx` having type `integer`.

[[Quantified-Types]]
=== Quantified Types

quantified types

type,quantified

A quantified type expression is form that identifies a collection of
types rather than a single specific type.

There are two forms of quantified type: universal types and existential
types. Universal types correspond approximately to _generic_ types found
in many programming languages; whereas existential types correspond to
_abstract_ types. The latter is somewhat less common in programming
languages.

Associated with any quantified type is the bound type – otherwise known
as a type variable. The permitted uses of a given bound type variable
depend on whether it is universally bound or existentially bound.

[[Universally-Quantified-Types]]
==== Universally Quantified Types

type,universally quantified

universally quantified type

A universally quantified type denotes a type that is valid for all
substitutions of a type variable.

....
UniversalType ::= all BoundType ,…,BoundType ~~ Type

BoundType ::= Identifier | Identifier / Decimal
....

For example, the type expression:

....
all x ~~ (x,x)=>boolean
....

denotes the generic function type of two arguments that returns a
`boolean`.

There are two forms of link:#BoundType[BoundType], a simple type
variable and a second form that includes an arity.

The first form of link:#BoundType[BoundType] introduces a regular type
variable – i.e., a variable which may be bound to any `type`. The second
form is used to introduce a higher-kinded type variable.

For example, the quantification:

....
all c/1 ~~ ...
....

denotes a variable which may only be bound to type constructors that
take one argument – for example `cons`.

[WARNING]
====
A regular type variable only unifies with regular types, and a type
constructor type variable only unifies with type constructors.
====There is also a short hand form of the universally quantified type
where there are multiple quantifiers. I.e., instead of writing

....
all x ~~ all y ~~ (x,y)=>tp
....

we can write

....
all x,y ~~ (x,y)=>tp
....

[TIP]
====
Higher kinded type variables are most commonly used in the context of
link:#ContractDefinition[ContractDefinition]s.
====The compiler will infer the type of expressions; but does _not_
infer any quantified type. Functions that are intended to be generic
must have explicit type annotations associated with them.

For example, the `dblFilter` function in link:#dblFilter[dblFilter]
applies a `map` function in two different situations – one for each
element of each pair in the input list. This requires that `dblFilter`
be given an explicit universally quantified type annotation:

....
dblFilter:all u,v ~~ (all t~~(t)=>t, cons[(u,v)])=>cons[(u,v)].
dblFilter(M,[]) => [].
dblFilter(M,[(A,B),..L]) => [(M(A),M(B)),..dblFilter(M,L)].
....

It is important to note that any actual function argument supplied to
`dblFilter` will itself have to be generic – i.e., its type will also be
universally quantified.

[[Existentially-Quantified-Types]]
==== Existentially Quantified Types

type,existentially quantified

existentially quantified type

exists

exists

An existential type denotes an _abstract_ type. More formally, it
denotes a specific – but unknown – type.

[NOTE]
====
The terms universally quantified and existentially quantified types
reflect the similar concepts in first order predicate logic. However,
the domain is different: in logic, universal quantifiers apply to
formulae that have a truth value; whereas in type language, quantifiers
apply to type expressions.
====
....
ExistentialType ::= exists BoundType ,…,BoundType ~~ Type
....

An existentially quantified type denotes a type within which there is an
_abstract type_: i.e., the type exists but the expression is not
explicit about which type.

Existential types are most often used in the type signatures of abstract
data types. For example, the term in the statement:

....
R = { type el = integer. op(X,Y) => X+Y. }
....

has type:

....
exists el ~~ { op:(el,el)=>el }
....

[NOTE]
====
Note that the fact that within the record the type `el` is identified as
`integer` does not escape the record itself. Externally, the existence
of the type is known but not what it is.

It is permissible to refer to the type within the record by a dot
reference.
====
[[Bound-Type-Variables]]
==== Bound Type Variables

type,variable

A type variable is a variable which may be bound to a type. Like other
variables, type variables have a scope; and they have a context that
determines the permissable values that the variable may be given.

[NOTE]
====
Although type variables have scope, they do not participate in any
computation of values in the program. It is not possible, for example,
for a program to dynamically determine the type of a value.
====
....
TypeVariable ::= Identifier
....

Type variables are associated with an _arity_ – which constrains the
kinds (sic) of types that the type variables may be bound to. A variable
that has arity zero may be bound to any well formed type; a variable
that has an arity greater than zero may only be bound to a type
constructor of appropriate arity.

For example, given:

....
all t ~~ cons[t] ::= .nil | cons(t, cons[t]).
....

The type variable `t` may be bound to a type expression such as
`cons[string]` but not to a higher-kinded type (such as `cons` itself).

On the other hand, given:

....
_iter:all x,m/1,e ~~ execution[m->>e] |: (s,m[x],(t,x)=>m[x]) => m[x]
....

The type variable `m` is specified with the arity `1` – making it a
higher-kinded type that expects one type argument.

===== Scope of Type Variables

type,variable!scope

All type variables have a scope which generally follows the scoping
rules for normal variables.

There are two particular cases that are important: type variables
introduced via link:#TypeDefinition[TypeDefinition]s and those
introduced via explicitly quantified type expressions.

A variable introduced in the head of an
link:#AlgebraicTypeDefinition[AlgebraicTypeDefinition] definition, or in
the head of a link:#ContractDefinition[ContractDefinition] are in scope
throughout the definition or contract respectively.

[[Encapsulated-Types]]
==== Encapsulated Types

encapsulated type

type,encapsulated in record

existential type

heterogenous types

An link:#EncapsulatedType[EncapsulatedType] is a reference to a type
that is embedded within a record.

....
EncapsulatedType ::= Expression.Identifier
....

As noted above, record literals may have types embedded within them.
Such a record type is existentially quantified.

It is possible to access the type embedded within such a record – albeit
with some restrictions:

The form of an link:#EncapsulatedType[EncapsulatedType] reference is
limited to terms of the form:

....
R.t
....

where `R` is a link:#Variable[Variable] whose type interface contains
the type `t`.

More generally, an link:#EncapsulatedType[EncapsulatedType] reference
may involve a sequence of field names where each intermediate field name
varers to a sub-record:

....
R.f1.f2.t
....

The _value_ of an encapsulated type is strictly opaque: it is assumed to
be different to all other types. Which means that effectively _only_ the
other fields of the record variable `R` contain functions and values
that can be used in conjunction.

For example, consider the `group` type defined in:

....
group ::= group{
  type el = quality[el].
  zero : el.
  op : (el,el)=>el.
  inv : (el)=>el.
}
....

[TIP]
====
A `group` literal is analogous to a mathematical group: a set which is
closed under a binary operation and whose elements have an inverse.

The contents of a `group` literal contain the definitions of the
elements, the binary operation, the zero element and the inverse
function.
====

The qualification of the `el` type that it supports `equality`
allows convenient access to equality of group elements. Without such a
qualification, equality would not be possible for programs using `group`
values.

An additional requirement for a group is that its operation is
associative. Such a property cannot be expressed in terms of type
constraints.

A `group` literal that implements the group for `integer`s is shown in:

....
IG = group{
  type el = integer.
  zero = 0.
  op = (+).
  inv(X) => -X.
}
....

The `IG` value contains the elements of a group value. We can, for
example, access the `zero` of `IG` using the statement:

....
IZ : IG.el.
IZ = IG.zero.
....

This asserts that `IZ`’s type is whatever the encapsulated type within
`IG` is – without being explicit about what that type is.

It is possible to construct functions over `group`s that varer to
encapsulated types. For example, the `invertGroup` function below
constructs a new group by _inverting_ the operation.

....
invertGroup : (group)=>group.
invertGroup(G) => group{
  type el = G.el.
  zero = G.zero.
  op(X,Y) => G.op(G.inv(X),G.inv(Y)).
  inv(X) => G.inv(X)
}
....

[[Constrained-Types]]
=== Constrained Types

contrained type

A constrained type is one with additional constraints in the form of
link:#Type-Constraints[Type Constraints].

....
ConstrainedType ::= TypeConstraint|:Type
....

Constrained types are generally either type variables or immediately
enclosed by a quantifier.

For example, a type expression of the form:

....
all t ~~ comp[t], arith[t] |: (t)=>t
....

denotes a generic unary function type for any type that implements both
the `comp` and the `arith` contracts (see
link:#comparisonPredicates[comparisonPredicates] and
link:#arithmeticContract[arithmeticContract]).

See link:#Type-Constraints[Type Constraints] for a description of the
possible forms of type constraint.

[[Type-Constraints]]
=== Type Constraints

type,constraints

A link:#TypeConstraint[TypeConstraint] is a constraint on a
link:#Type[Type]; usually implying a constraint on the possible binding
of a link:#TypeVariable[TypeVariable].

....
TypeConstraint ::= Contract
  | FieldConstraint
  | ImplicitConstraint
  | TypeConstraint ,,, TypeConstraint
....

Generally, a link:#TypeConstraint[TypeConstraint] on a
link:#TypeVariable[TypeVariable] restricts in some sense the possible
bindings for that type variable.

For example, a link:#Contract[Contract] refers to a named collection of
functions and a link:#TypeVariable[TypeVariable] constrained by a
link:#Contract[Contract] means that any concrete instantiation of the
link:#TypeVariable[TypeVariable] must be to a link:#Type[Type] that
implements the link:#Contract[Contract].

Similarly, a link:#FieldConstraint[FieldConstraint] constrains the
link:#TypeVariable[TypeVariable] so that any binding must be to a
link:#Type[Type] that has the named field in its definition.

For example, using `arith` as a constraint allows us to say _the type
can be anything that implements the standard arithmetic functions_. The
type expression:

....
arith[t] |: t
....

denotes this kind of constrained type.

[NOTE]
====
It is possible to view a type variable binding itself as a form of
constraint: if we bind the type variable `t` to the type `integer` then
we are constraining the type `t` to be equal to `integer`.
====[NOTE]
====
In many cases type inference will automatically result in constraints
being added to type expressions.
====It is possible mix different forms of
link:#TypeConstraint[TypeConstraint]; for example, if a
link:#TypeVariable[TypeVariable] must be bound to a type that implements
the `comp` contract as well as having the `integer`-typed `ident`
attribute, the type expression:

....
comp[t], t <~ { ident:integer }
....

captures this.

[NOTE]
====
If a constrained type variable is unified with another type variable,
then the constraints of the two variables are merged. It may be that
such a merging of constraints is not possible; in such a case, the
unification will fail.
====
[[Contract-Constraints]]
==== Constract Constraints

type,constraints!contract

contract constraint

A link:#Contract[Contract] is a requirement on a link:#Type[Type] – or
tuple of link:#Type[Type]s – that whatever type it is, that there must
exist an `implementation` of the link:#Contract[Contract] for the
link:#Type[Type].

For example, the type constraint expression in the constrained type:

....
comp[t] |: t
....

means that the type variable `t` may only unify with concrete types that
implement the `comp` contract.

[NOTE]
====
Since only named types may implement link:#Contract[Contract]s, it is
also not permissible to unify the constrained variable with an
structural type – such as a function type.
====
....
Contract ::= Identifier[TypeArgument]
  | Identifier[TypeArgument ->> TypeArgument]
....

It is possible for link:#Contract[Contract]s to reference more than one
type. For example, the standard `coercion` contract (see
link:#coercionContractProg[coercionContractProg]) references two types.
A `coercion` link:#Contract[Contract] will therefore look like:

....
coercion[T1,T2]
....

where `T1` represents the source type of the coercion and `T2`
represents the destination type.

If the `->>` clause is used, then the link:#Contract[Contract] being
referenced must have a _functional dependency_ functional dependency
associated with it.

[NOTE]
====
Conversely, if a link:#Contract[Contract] has a functional dependency,
then any constraint varerring to it must also have a `\->>` clause.
====The `->>` clause identifies which type(s) are dependent on the type
argument(s) of the link:#Contract[Contract]. (See
link:#ContractFunctionalDependency[ContractFunctionalDependency]).

[[Implicit-Binding-Constraints]]
==== Implicit Binding Constraints

type,constraints!implicit

implicit binding constraint

A link:#ImplicitConstraint[ImplicitConstraint] is a requirement that a
given variable of a specified type exists (i.e., is in scope).

For example, the constraint expression in the constrained type:

....
foo |= t |: (integer) => t
....

means that, for any variable of this type, there must also be a variable
call `foo` in scope, of type `t`. Typically, the constrained type is a
function, and the implicit binding constraint also means that the
implicit variable is in scope within the function.

More specifically, `foo` must be in scope wherever the function is
called, and `foo` is automatically in scope within the definition of
`foo`.

In effect, the implicit constraint denotes an implicitly bound variable;
or, equivalently, a dynamically scoped variable.

....
ImplicitConstraint ::= Identifier|=Type
....

So, for example, in the function `clamp` below, there is an implicitly
defined variable `limit`:

....
clamp : limit |: integer |: (integer)=>integer.
clamp(X) => valof{
  if X>limit then
    valis limit
  else
    valis X
}
....

Any call to `clamp` must occur in a scope where `limit` is defined with
type `integer`:

....
let{
  limit = 1000;
} in clamp(Z)
....

[[Field-Constraints]]
==== Field Constraints

type,field

type,constraints!field

A _FieldConstraint_ is a requirement on a variable that whatever type it
is, it should have particular attributes of particular types defined for
it.

....
FieldConstraint ::= Type <~ { Annotation . …. Annotation }
....

For example, in

....
r <~ { alpha : string. beta : integer }
....

if `r` is unified against a concrete type then that type’s
link:#FaceType[FaceType] interface (see
link:#typeInterface[typeInterface]) must contain both of `alpha` and
`beta`. In addition, the fields must be of the right types.

[NOTE]
====
It is also possible to require that an
link:#EncapsulatedType[EncapsulatedType] exists. For example, the
constraint:

....
s <~ { type elem }
....

requires that any actual binding for type `s` must include the embedded
type `elem`.
====
[[Type-Semantics]]
=== Type Semantics

semantics of types

[[Type-Rules]]
==== Type Rules

type safety

type rules

The connection between the argument type of a `cons` type expression and
the actual elements of lists is denoted by a _type inference rule_. Type
inference rules are rules for relating expressions and statements in the
language to the types associated with that statement. For example, the
rule:

....
E ⊦ El:T
⇒
E ⊦ cons(El,.nil):cons[T]
....

says that if the expression El has type T, then the expression

....
cons(El1,.nil)
....

has type `cons[T]`. This is the formal way of stating that all elements
of a `cons` list must have the same type.

The general form of a type inference rule that is determining a type
(sometimes called a type judgment) is:

....
Condition
⇒
E ⊦ X:T
....

____
If _Condition_ is satisfied, then we can infer from the context E that X
has type T
____

where the symbol ⊦ can be read as _type implication_. In general, the
type of an expression depends on the context that it is found.

The _environment_ part of the type judgement consists of a sequence of
type bindings, type equalities and type constraints:

* A type binding consists of a type annotation:
+
....
var : type
....
* A type equality consists of an equality between a type variable and a
type:
+
....
type = type
....
* A type constraint consists of an instance of a
link:#TypeConstraint[TypeConstraint]s:
+
....
Constraint
....

The environment’s primary purpose is to establish the context of a type
judgement.

[NOTE]
====
The environment is described as an ordered sequence because of scope
hiding: where a local definition of a value may obscure an outer
definition.
====
[[Freshening-and-Skolemization]]
==== Freshening and Skolemization

skolemization

In any logic with quantifiers, reasoning about terms can involves
rewriting quantified expressions. The type system has two related
operations over types: freshening and skolemization.

[[Freshening]]
===== Freshening

Freshening refers to the process of copying a quantified type expression
and replacing the bound type variable with a _new_ type variable;
crucially, one that may be bound in a subsequent inference step.

[NOTE]
====
Freshening is closely connected to the logical inference step of
_standardizing apart_; which involves renaming bound variables so that
they are unique and moving the associated quantifier _all the way
outside_. In effect, the new type variable becomes free in the logical
formula that represents the type of the entire program.
====The most common situation that freshening occurs when inferring the
type of an identifier occurrence: the type ascribed to an identifier
_occurrence_ is the recorded type of the identifier – freshened.
Informally, freshening corresponds to the intuition that a generic type
may be used in many ways; and this is realized in type inference by
freshening the recorded type of an identifier for each occurrence of the
identifier in the program.

[[Skolemization]]
===== Skolemization

Skolemization refers to the process of copying a quantified type
expression and replacing the bound type variable with a _new_ unique
type; crucially, one that is _not_ equal to any other type.

The most common situation that skolemization occurs is when validating
that a variable’s definition is consistent with its declared type.

Informally, skolemization corresponds to the intuition that any
definition of a variable (or function) whose type is generic must obey
certain constraints: specifically the definition may not further
constrain the type by any entanglement with additional constraints.

This is acheived by marking the type variable as effectively read-only
within the definition; or equivalently, by using a new type that does
not appear anywhere and therefore has no knowledge of functions that may
be defined for it.

[[Type-Unification]]
==== Type Unification

type,unification

The type system is based on the concept of type _equality_ –
specifically two types are considered equal iff they are syntactically
identical. Unification is an algorithm that can be used to determine if
two terms can be made to be identical to each other – typically by
replacing variables with values.

[[Unifying-Nominal-Types]]
===== Unifying Nominal Types

Two nominal types unify if they can be made identical:

* Two link:#SimpleType[SimpleType]s unify if they are the same
link:#SimpleType[SimpleType]
+
For example,
+
....
integer = integer
....
+
but,
+
....
integer ≠ string
....
+
[NOTE]
====
*Star* distinguishes between types declared in different scopes. So, two
types in different packages or in different scopes within the same
package will not unify.
====
* Two link:#ParameterizedType[ParameterizedType]s unify if their
link:#TypeConstructor[TypeConstructor]s unify, they have the same number
of link:#TypeArgument[TypeArgument]s, and those arguments pairwise
unify.
+
For example,
+
....
cons[integer] = cons[integer]
....
+
but,
+
....
cons[integer] ≠ cons[string]
....
+
and
+
....
cons[integer] ≠ list[integer]
....
+
and
+
....
cons[integer] ≠ cons[integer,string]
....

[NOTE]
====
In fact, the `cons` example – with two type arguments instead of one –
is not a valid type expression. This is because it is not consistent
with the type definition for `cons`.
====
[[Unifying-Reference-Types]]
===== Unifying Reference Types

Two reference types unify if their argument types unify

For example,

....
ref integer = ref integer
....

but,

....
ref integer ≠ ref string
....

and

....
ref integer ≠ list[integer]
....

[[Unifying-Tuple-Types]]
===== Unifying Tuple Types

Two link:#TupleType[TupleType]s unify if they have the same number of
elements, and those elements unify in a pairwise fashion.

....
() = ()
....

and

....
(integer,string) = (integer,string)
....

and

....
(integer,string) = (integer,t)
....

where `t` is a type variable, with the additional effect that `t` will
be bound to the `string` type.

However,

....
() ≠ (())
....

because the second is actually a unary tuple containing a zero-tuple;
and

....
(string,integer) ≠ (integer,string)
....

because elements must unify in a pairwise way.

[[Unifying-Face-Types]]
===== Unifying Face Types

Fields in a record are not intrinsically ordered, but the spirit of
unification for records is similar to that of tuples:

Two face types unify iff:

* they have the same fields and embedded types
* each field’s type in one face type unifies with the corresponding
field of the other face type
* each embedded type in one record unifies with the corresponding
embedded type of the other record type.

[NOTE]
====
There is no syntax for _partial_ records.
====For example,

....
{} = {}
....

and

....
{ foo:integer. type bar } = { foo:t. type bar }
....

with `t` being bound to `integer`; whereas

....
{ foo:integer. } ≠ {bar:integer}
....

because the second record type does not have a `foo` field, and the
first does not have a `bar` field.

[[Unifying-Function-Types]]
===== Unifying Function Types

Two function types unify iff their arguments unify and the result
unifies. Note that the simple function type does not unify with the
constructor function type.

....
(integer)=>integer = (t)=>t
....

where `t` is a type variable that is subsequently bound to `integer`;
whereas

....
(integer,string)=>integer ≠ (string,integer)=>integer
....

and

....
(integer,string)=>integer ≠ (integer,string)<=>integer
....

[[Unifying-Type-Variables]]
===== Unifying Type Variables

There are two sub-cases for unifying type variables:

[arabic]
. if either the left or the right terms are not type variables, then
_provided that_:
* the type variable does not itself appear in the non-variable type; and
* any type constraints on the type variable are satisfied by the
non-variable type;
+
then the two types are unifiable.
+
[NOTE]
====
The first condition is known as an _occurs check_. Occurrs check
====
+
In addition, the fact of the unification is recorded as a binding for
the variable type. Thereafter, when unifying types, this binding must be
applied to all occurrences of the same type variable.
. if both left and right terms are type variables then the unification
is permitted; and the fact of the unification is recorded as a binding
for the variable that is bound. As for non-variable bindings, the
binding must be applied to all occurrences of the same type variable.
+
In addition, any type constraints on the type variables are _merged_. If
this merging is not possible then the two type variables do not unify.
+
Type constraints are merged as follows, assuming that `ta` is bound to
`tb`:
[arabic]
.. for every contract constraint in `ta`, if a contract contraint exists
for `tb` with the same contract name, then the two contracts must unify,
otherwise it is appended to the contraints for `tb`.
.. if there is a field constraint in `ta`, it is merged with the
corresponding field constraint for `tb`.

[[Unifying-Quantified-Types]]
===== Unifying Quantified Types

Unifying quantified types is slightly more involved than that of other
forms of type. Two quantified types are unifiable iff they can be made
to be identical; however, a quantified type stands for all or some type.
In particular, two quantified types are considered to be identical if
they differ only in the name of the bound variable.

For example,

....
all x ~~ cons[x]
....

is equivalent to

....
all y ~~ cons[y]
....

Our rule for unifying two quantified types reflects this:

Two quantified types are unifiable if

* they are the same form of quantifier (`all` vs `exists`
* for some type name `t` that does not occur in either of them,
+
....
all x~~T1
....
+
is renamed to
+
....
all t~~T1'
....
+
where T1’ is obtained from T1 by systematically replacing all
occurrences of `x` by `t` – except for any further occurrences of `x` as
a bound variable in a quantified type within T1.
+
Similarly,
+
....
all y~~T2
....
+
is rewritten to
+
....
all t~~T2'
....
+
[NOTE]
====
Both T1 and T2 are rewritten using the same target name `t`.
====
+
Finally, the two quantified types unify iff
+
....
T1' = T2'
....

[NOTE]
====
Because both `x` and `y` are bound type variables, they cannot occur in
any outer type terms – should the quantified types be part of larger
type terms that are being unified there cannot be any binding ’side
effect’ by rewriting either of `x` or `y`.
====Some examples:

....
all a~~((cons[a])=>(a)) = all b~~((cons[b])=>(b))
....

are equal because we can rename both `a` and `b` to `c` and unify the
bound types:

....
all c~~((cons[c])=>(c)) = all c~~((cons[c])=>(c))
....

However

....
all a~~(a)=>integer ≠ exists b~~(b)=>integer
....

because of the different quantifiers, and

....
all a~~(a)=>integer ≠ (t)=>integer
....

for any type t because the latter type is not quantified.

[[Patterns]]
== Patterns

patterns

Patterns are templates that are used to match against a value; possibly
binding one or more variables to components of the matched value.
Patterns are used as guards in equations, as filters in query
expressions and in `for` loops. Patterns represent one of the
fundamental mechanisms that can guide the course of a computation.

....
Pattern::=ScalarPattern
  | Variable
  | ConstructorPattern
  | TuplePattern
  | GuardedPattern
  | SequencePattern
....

____
patterns,type of

*Patterns and Types:* Every pattern has a type associated with it. This
is the type of values that the pattern is valid to match against. In the
type safety productions involving patterns, we use the same meta
predicate: E ⊦ P:T as for expressions.
____

[[Variables-in-Patterns]]
=== Variables in Patterns

pattern,variable pattern

variables

Variables in patterns are used to bind variables to elements of the
input being matched against.

[NOTE]
====
A repeated occurrence of a variable in a pattern is equivalent to a call
to the `==` predicate. For example, the pattern:

....
(X,Y,X)
....

is equivalent to the link:#GuardedPattern[GuardedPattern]:

....
(X,Y,X1) where X==X1
....

The `==` predicate is defined in the standard `equality` contract (see
link:#EqualityContract[EqualityContract]); and therefore, the call and
the pattern may not be valid if `equality` is not implemented for the
type of `X`.
====
[[Scope-of-Pattern-Variables]]
==== Scope of Pattern Variables

variables,scope of

A pattern always occurs in the context of a _scope extension_ – a new
potential scope for variables. For example, in the equation:

....
fact(N) => N*fact(N-1)
....

the pattern on the left hand side of the equation:

....
fact(N)
....

introduces variables that are in scope on the right hand side of the
equation:

....
N*fact(N-1)
....

[[Anonymous-Variable-Pattern]]
==== Anonymous Variable Pattern

The special identifier – `_` – is used on those occasions where a filler
of some kind is needed. Every occurrence of `_` refers to a different
variable. A match with `_` is always successful, but the value itself is
ignored.

[[Scalar-Literal-Patterns]]
=== Scalar Literal Patterns

....
ScalarPattern::= StringLiteral
  | NumericLiteral
....

[[Literal-String-Patterns]]
==== Literal String Patterns

string,pattern

patterns,literal string

A literal string as a pattern matches exactly that string; the type of a
string pattern is `string`.

[NOTE]
====
The operators that are used to denoted string interpolation expressions
(see link:#stringInterpolation[stringInterpolation]) must _not_ be used
in string patterns. In particular, the dollar character _must_ be quoted
in a string pattern.
====For example, in the function:

....
hasDollar("has$") => true
....

the string pattern `"has$"` is not legal. You should use:

....
hasDollar("has\$") => true
....

[[Literal-Numbers]]
==== Literal Numbers

number pattern

patterns,literal number

A literal number – `integer`, `bigint` or `float` – as a pattern matches
exactly that number.

The type of the pattern depends on the type of the number literal:
`integer` literals have type `integer`, `float` literals have type
`float`.

[[Constructor-Patterns]]
=== Constructor Patterns

constructor,pattern

patterns,constructor

A constructor pattern denotes an occurrence of a value that has been
declared within an algebraic type definition (see
link:#AlgebraicTypeDefinition[AlgebraicTypeDefinition]).

A constructor pattern mimics the form of the constructor definition
itself: for a
link:#PositionalConstructorLiteral[PositionalConstructorLiteral] it
consists of an identifier followed by a sequence of patterns, enclosed
in parentheses and separated by commas, denoting the arguments to the
link:#PositionalConstructorLiteral[PositionalConstructorLiteral].

....
ConstructorPattern::= EnumeratedSymbolPattern
  | PositionalConstructorPattern
  | RecordConstructorPattern
....

[NOTE]
====
link:#PositionalConstructorPattern[PositionalConstructorPattern]s are
the only way that a constructor value may be inspected and elements of
it extracted. There are no indexing operators over because it is not
possible to give a consistent typing to such operators.
====
[[Enumerated-Symbol-Patterns]]
==== Enumerated Symbol Patterns

patterns,enumerated symbol

enumerated symbol pattern

An enumerated symbol – as a pattern – matches the same symbol only.

....
EnumeratedSymbolPattern::= . Identifier
....

[[Positional-Constructor-Patterns]]
==== Positional Constructor Patterns

patterns,positional constructor

positional constructor patterns

A positional constructor pattern consists of a constructor label
followed by the argument patterns – as introduced in the appropriate
link:#AlgebraicTypeDefinition[AlgebraicTypeDefinition].

....
PositionalConstructorPattern::= .Identifier ( Pattern, …, Pattern)
....

[NOTE]
====
Positional constructors, like link:#EnumeratedSymbol[EnumeratedSymbol]s,
are marked by a leading `.` character. This helps to distinguish such
expressions from normal function calls.
====
[[Record-Patterns]]
==== Record Patterns

patterns,record constructor

record constructor pattern

A record pattern consists of the record label, followed by attribute
patterns enclosed in braces.

Each attribute pattern takes the form:

....
Identifier = Pattern
....

where _Pattern_ is a pattern that the link:#Identifier[Identifier]
attribute must satisfy.

Unlike positional constructor patterns, it is not required for all of
the attributes to be mentioned in a record constructor pattern. At its
limit, a pattern of the form:

....
label{}
....

becomes a test that the `label` record literal is present – with no
constraints on the attributes of the record.

....
RecordConstructorPattern ::= Identifier { AttributePattern. … . AttributePattern}

AttributePattern ::= Identifier = Pattern
....

[[Tuple-Patterns]]
=== Tuple Patterns

patterns,tuple

A tuple pattern consists of a tuple with patterns as the elements of the
tuple.

....
TuplePattern::= ( Pattern, …, Pattern)
....

Such anonymous tuple patterns can be used to extract values from tuple
values (link:#TupleLiteral[TupleLiteral]). For example, the pattern
`(X,Y)` in the query condition:

....
(X,Y) in R
....

matches against the elements of `R` and ‘binds’ the local variables `X`
and `Y` to the first and second tuple member of each successive elements
of `R`.

[NOTE]
====
As noted in link:#TupleType[TupleType], anonymous tuples are essentially
syntactic sugar for automatically defined algebraic types. The above
query is equivalent to:

....
$2(X,Y) in R
....

Noting, of course, that `$2` is not a legal
link:#Identifier[Identifier].
====
[[Guarded-Pattern]]
=== Guarded Pattern

guardPattern patterns,guarded guarded patterns

A guarded pattern attaches a semantic condition on a pattern. It
consists of a pattern, followed by the `where` keyword and a predication
condition – all enclosed in parentheses.

Guarded patterns are useful in enhancing the specificity of patterns –
which apart from guarded patterns are purely syntactic in nature.

....
GuardedPattern ::= Pattern where Condition
....

A guarded pattern has a type assignment based on the type of the left
hand side, and the type safety of the condition.

[[Sequence-Patterns]]
=== Sequence Patterns

A sequence pattern represents a use of the standard `stream` contract
(see link:#streamContractProg[streamContractProg]) to match sequences of
values.

sequence,patterns

patterns,sequence

[[Sequence-Pattern-Notation]]
==== Sequence Pattern Notation

....
SequencePattern ::= [ PtnSequence ]

PtnSequence ::= Pattern, … , Pattern[,..Pattern
....

In a similar way to link:#SequenceExpression[SequenceExpression]s,
link:#SequencePattern[SequencePattern] depend on the `stream` contract,
In fact, a link:#SequencePattern[SequencePattern] is syntactic sugar for
terms involving the `stream` contract – which is defined in
link:#streamContractProg[streamContractProg].

A pattern of the form:

....
[Ptn1, …, Ptnn]
....

is equivalent to the pattern:

....
Str where (Ptn1,X1) ?= _hdtl(Str) &&
    …
    (Ptnn,Xn) ?= _hdtl(Xn-1) &&
    _eof(Xn)
....

[[Expressions]]
== Expressions

An expression is a form that denotes a _value_. Evaluation is the
computational process of realizing the denoted value. Associated with
all expressions is a link:#Type[Type] – which governs the valid
expressions and actions that the expression itself may be part of.

....
Expression::=Variable
  | NumericLiteral
  | StringLiteral
  | AlgebraicLiteral
  | ApplicativeExpression
  | FieldAccess
  | RecordUpdate
  | CaseExpression
  | TryCatchExpression
  | RaiseExpression
  | ConditionalExpression
  | Condition
  | LetExpression
  | ValofExpression
  | LambdaExpression
  | TypedExpression
  | SequenceExpression
  | IndexExpression
  | SliceExpression
....

[[Variables]]
=== Variables

variables

A link:#Variable[Variable] is a placeholder that denotes a value.
Variables may be used to denote many kinds of values – arithmetic
values, complex data structures and programs.

....
Variable::=Identifier
....

[NOTE]
====
Any given variable has a single type associated with it and may only be
bound to values of that type.footnote:[We sometimes informally refer to
a variable being ‘bound’ to a value X (say). This means that the value
associated with the variable is X.]
====Variables have a scope – a syntactic range over which they are
defined. Variables can be said to be free in a given scope – including
functions that they are referenced within.

Variables are _single-assignment_; i.e., once given a value, a variable
may not be reassigned to. Furthermore, all variable introductions are in
contexts where the variable is given a value.

However, it is possible to give a variable a `ref` type; which permits
the variable’s value to be effectively re-assigned.

[NOTE]
====
Technically, assigning to a `ref` variable is not changing the variable
itself, but is changing the contents of the cell that denotes the `ref`
variable’s value.
====
[[Re_002dassignable-Variables-in-Expressions]]
==== Re-assignable Variables in Expressions

referring to re-assignable variables,in expressions

There are two modes of referring to re-assignable variables in
expressions: to access the value of the variable and to access the
variable itself. The primary reason for the latter may be to assign to
the variable, or to permit a later assignment.

An undecorated occurrence of a variable denotes access to the variable
itself, whereas if the access is decorated with a `!` then that refers
to the variable’s value. Thus, given a variable declaration:

....
Cx := 0
....

then the reference to `Cx` in the expression:

....
Cx+3
....

is not legal because `Cx` here does not refer to the variable’s value.
Instead use:

....
Cx!+3
....

[[Modifying-Fields-of-Records]]
==== Modifying Fields of Records

Assignability of variables does _not_ automatically imply that the value
of the variable is itself modifiable. Thus, given a variable declaration
such as:

....
P := someone{ name="fred"; age=23 }
....

the assignment:

....
P.age := 24
....

is not valid – because, while we can assign a new value to `P`, that
does not confer an ability to modify the value that `P` has.

However, by marking a _field_ of a record type as a `ref` type, then we
_can_ change that field of the record. Thus, for example, if the type of
`person` were:

....
person ::= person{
  name : string.
  age : ref integer.
}
....

then the assignment:

....
P.age := 24
....

is valid.

[NOTE]
====
Note that one may change a suitably declared field of a record even when
the variable ’holding’ the record it not itself re-assignable.

....
P is someone{ name="fred". age := 23 }
....

I.e., re-assignability depends only on whether the target is
re-assignable.
====In addition to modifying the contents of a re-assignable variable,
there is a link:#RecordUpdate[RecordUpdate] expression which does not
modify a record but can be used to construct a new record value by
replacing a field in the record.

[[Numeric-Literal-Expressions]]
=== Numeric Literal Expressions

numeric literal

There are three forms of numeric literal expression: integers
(link:#Integer-Literal[Integer Literal]), arbitrary precision integers
(link:#Arbitrary-Precision-Integer[Arbitrary Precision Integer]) and
floating point numbers (link:#FloatingPoint[FloatingPoint]).

[[Integer-Literal]]
==== Integer Literal

integer

The `integer` type is used to denote integral values in the range
-2305843009213693952..2305843009213693951.footnote:[I.e., 62 bit
precision.]

Integers may be written in a variety of styles (see
link:#decimalFig[decimalFig]; the most common form is the simple
link:#Decimal[Decimal] notation.

[[Arbitrary-Precision-Integer]]
==== Arbitrary Precision Integer

integer

arbitrary precision integer

Arbitrary precision integers do not have a fixed upper limit in their
range: in principle, a single number could take the entire memory of the
computer.footnote:[Not recommended.]

Arbitrary precision integers are written as a sequence of decimal digits
prefixed by a `0b`:

....
0b815915283247897734345611269596115894272000000000
....

It is possible to coerce between so-called __bigint__s and regular
integers; although it is not guaranteed to be possible in all cases.

[[Floating-Point-Literals]]
==== Floating Point Literals

float

The `float` type is used to represent fractional values. Floating point
numbers are represented as IEEE double precision – i.e., 64 bit.

[NOTE]
====
In fact, the precision of floating numbers is limited to 62 bits. The
least significant bits are dropped.
====The syntax of floating point numbers is given in
link:#floatingPointFig[floatingPointFig].

[[String-Literal-Expressions]]
=== String Literal Expressions

string literals

The `string` type is used to denote string values. There are two main
forms of `string` literal: the double-quoted string expression and the
triple-quoted or block-quoted `string` literal.

The syntax of `string` literals is given in
link:#quotedStringFig[quotedStringFig]. The simplest form of `string`
literal is a sequence of characters enclosed in double-quotes:

....
"A string literal with 35 characters"
....

[[String-Interpolation]]
==== String Interpolation

string interpolation

String interpolation refers to the embedding of expressions in string
literals. The actual string value of an interpolated `string` literal
requires the evaluation of those expressions.

For example, given a variable `X` with the value 24, then:

....
"this has the value of X: $(X)"
"$(X*X) people saw this"
....

would have values:

....
"this has the value of X: 24"
....

and

....
"576 people saw this"
....

respectively.

There are three forms of interpolation expression: a display
interpolation, a formatted interpolation and an embedded interpolation.

[NOTE]
====
If a `string` interpolation expression itself contains a string, the
various quoting mechanisms for strings apply to that string also. I.e.,
it is not necessary to ‘double-quote’ strings within `string`
interpolation expressions.

For example, the `string` expression in:

....
"The price of cheese is $(priceOf("cheese"))"
....

works as expected: the argument to the `priceOf` function is the string
literal `"cheese"`. An even more nested example is:

....
"The price of $(P) is $(priceOf("SKU$(P)"))"
....

In this example, we have a `string` interpolation expression embedded
within another `string` interpolation expression.
====An link:#Interpolation[Interpolation] expression may be followed by
a link:#FormattingSpec[FormattingSpec]. If present, then this
specification is used to guide how values are formatted.

For example, the value of

....
"--$(120345567):999,999,999,999;--"
....

is the string:

....
"--120,345,567--"
....

Detailed formatting is controlled by the `format` contract – see
link:#formatContractProg[formatContractProg] – in particular the
different implementations of that contract which in turn means that
different types of expression will have type appropriate ways of
specifying the formatting.

[[Semantics-of-String-Interpolation]]
===== Semantics of String Interpolation

String interpolation expressions may refer to variables that are in
scope at the location of the string literal itself.

An expression of the form:

....
"prefix$(Exp)suffix"
....

is interpreted as:

....
_multicat([prefix,disp(Exp),suffix])
....

If a link:#FormattingSpec[FormattingSpec] is present, then the
translation takes that into account also. For example, the expression:

....
"prefix$(Exp):Format;suffix"
....

is equivalent to the expression:

....
_multicat([prefix,frmt(Exp,Format),suffix])
....

where `frmt` is part of the `format` contract – see
link:#formatContract[formatContract].

The standard `_multicat` function takes a list of `string` values and
concatentates them into a single `string` value.

[NOTE]
====
`_multicat` is itself defined via a contract specification: it is part
of the `concat` contract.
====
[[String-Embedding]]
===== String Embedding

string embedding

String embedding is a simpler form of string interpolation where the
contents of the embedded expression are expected to be already
`string`-valued and are simply subistituted in place.

For example, given a variable `F` with the value `"foo"`, then:

....
"#(F) is the complement of bar"
....

would have values:

....
"foo is the complement of bar"
....

[[Block-Strings]]
==== Block Strings

block string

A BlockString is a string literal that consists of a sequence of
characters enclosed in triple quotes; as defined in
link:#blockStringFig[blockStringFig].

The principal difference between a BlockString and a regular
QuotedString is that no interpretation of characters in the text is
made. I.e., there is no equivalent of string interpolation and nor are
any escape characters interpreted.

In addition, BlockStrings can span multiple lines whereas QuotedStrings
are not permitted to include new-line characters.

[[Algebraic-Constructor-Expressions]]
=== Algebraic Constructor Expressions

The link:#AlgebraicConstructor[AlgebraicConstructor] expressions are
those that refer to constructors that are defined in
link:#AlgebraicTypeDefinition[AlgebraicTypeDefinition]s.

There are three primary forms of
link:#AlgebraicConstructor[AlgebraicConstructor]s:

* link:#EnumeratedSymbol[EnumeratedSymbol]s
* link:#PositionalConstructorLiteral[PositionalConstructorLiteral]
terms, and
* link:#RecordLiteral[RecordLiteral] terms.

....
AlgebraicLiteral ::= EnumeratedSymbol
  | PositionalConstructorLiteral
  | RecordLiteral
....

[[Enumerated-Symbols]]
==== Enumerated Symbols

enumerated symbols

Enumerated symbols are written using regular identifiers (see
link:#enumeratedSymbolFig[enumeratedSymbolFig]) – prefixed with a
period. Such a symbol must first have been declared within a type
definition statement which also determines the type of the symbol.

....
EnumeratedSymbol ::= .Identifier
....

For example, the `boolean` type definition has two
link:#EnumeratedSymbol[EnumeratedSymbol]s in its definition: `.true` and
`.false`. Thus

....
.true
....

is an expression consisting of an
link:#EnumeratedSymbol[EnumeratedSymbol] from the type definition:

....
boolean ::= .true | .false.
....

Enumerated symbols have no internal structure; they are often used to
define enumerations or for sentinels. For example, the standard
cons-list type uses `nil` to mark the empty list:

....
all e ~~ cons[e] ::=  .nil | .cons(e,cons[e])
....

[NOTE]
====
The period in front of an enumerated helps to highlight the special role
of enumerated symbols. It also helps to prevent silent errors caused by
mistyping an enumerated symbol.
====
[[Positional-Constructor-Literals]]
==== Positional Constructor Literals

positional constructor

link:#PositionalConstructorLiteral[PositionalConstructorLiteral]
expressions denote data constructor values. In particular, it refers to
positional constructors that are introduced in an algebraic
link:#TypeDefinition[TypeDefinition].

....
PositionalConstructorLiteral ::= .Identifier(Expression, … ,Expression)
....

The valid types of the arguments to a
link:#PositionalConstructorLiteral[PositionalConstructorLiteral] are
determined by its definition within the appropriate type definition.

For example, in the type definition:

....
address ::= .noWhere | .someWhere(string,integer,string)
....

`someWhere` as the identifier of a
link:#PositionalConstructorLiteral[PositionalConstructorLiteral] and any
instance must have exactly three arguments: a `string`, an `integer` and
a `string`.

[NOTE]
====
Positional constructors, like link:#EnumeratedSymbol[EnumeratedSymbol]s,
are marked by a leading `.` character. This helps to distinguish such
expressions from normal function calls.
====
[[Accessing-Elements-of-a-Positional-Constructor-Literal]]
===== Accessing Elements of a Positional Constructor Literal

The only way that elements of a
link:#PositionalConstructorLiteral[PositionalConstructorLiteral] can be
_accessed_ is via a pattern match – see
link:#posConPattern[posConPattern]. For example, given the definition of
`address` above, we can ’unpack’ its argument using a pattern such as in

....
city(someWhere(City,_,_)) => City
....

Unlike positional constructors, records allow their fields to be
addressed individually.

[[Record-Literals]]
==== Record Literals

A record literal is a collection of values identified by name.

Like link:#PositionalConstructorLiteral[PositionalConstructorLiteral]s,
the link:#RecordLiteral[RecordLiteral] must have been defined with a
link:#TypeDefinition[TypeDefinition] statement. This also constrains the
types of the expressions associated with the fields.

....
RecordLiteral::=Record | RecRecord
Record ::= Identifier{ RecordElement Terminator … Terminator RecordElement }
RecordElement ::= Identifier = Expression
| Identifier := Expression
| type Identifier = Type
....

There are two variants of the link:#RecordLiteral[RecordLiteral]: the
link:#Record[Record] form and the link:#RecRecord[RecRecord] form. This
section focuses on the former.

For example, given the type definition:

....
employee ::= emp{
  name : string.
  hireDate : date.
  salary : ref integer.
  dept : ref string.
}
....

A literal `emp` value will look like:

....
E = emp{ name = "Fred Nice".
  hireDate = today().
  salary := 23000.
  dept := "mail"
}
....

[NOTE]
====
Fields whose type is a link:#ReferenceType[ReferenceType] are defined
within the record using the `:=` operator. All other fields are defined
using the `=` operator.
====For any given link:#RecordLiteral[RecordLiteral] _all_ the fields of
the record must be associated with a value. This value is either
explicitly given or can be supplied by a `default` declaration within
the type definition itself.

Fields within a link:#RecordLiteral[RecordLiteral] are identified by
name; and may be written in any order.

[[Accessing-Fields-of-a-Record]]
==== Accessing Fields of a Record

record access

. operator

Record access expressions access the value associated with a field of a
record value.

....
FieldAccess::=Expression . Identifier
....

An expression of the form

....
A.F
....

where `F` is the name of an attribute of the record `A` denotes the
value of that attribute. For example, given the type definition

....
person ::= someone{ name : string. age : integer }
....

and a `person` value bound to `P`:

....
P = someone{ name="fred". age=32 }
....

then the expression `P.name` has value `"fred"`.

[NOTE]
====
The binding of the record access operator (`.`) is very strong. Thus,
expressions such as `A.L[ix]` and `A.F(a,b*3)` are equivalent to

....
(A.L)[ix]
....

and

....
(A.F)(a,b*3)
....

respectively.
====
[[Updating-Fields-of-a-Record]]
==== Updating Fields of a Record

record update

. operator

= operator

A record cannot be updated in the normal sense – unless one or more of
the fields of teh record is marked as being a reference variable.
However, there is a notation for constructing a new literal from an
existing record, replacing one or more of the fields with new values.

....
RecordUpdate::=Expression . Identifier = Expression
....

An expression of the form

....
A.F=B
....

where `F` is the name of an attribute of the record `A` denotes a
version of `A` with the `F` field replaced by `B`.

The type of the overall expression is the same as the type of `A`; since
we are essentially creating a variant of `A`.

....
person ::= someone{ name : string. age : integer }
....

and a `person` value bound to `P`:

....
P = someone{ name="fred". age=32 }
....

then the expression `P.name="peter"` has value

....
someone{ name="peter". age=32 }
....

[NOTE]
====
The old version of the record – `P` – is still available, if it is still
accessible.
====
[[Recursive-Record-Literals]]
==== Recursive Record Literals

theta record

A link:#RecRecord[RecRecord] is a record whose contents is specified by
means of a link:#ThetaEnvironment[ThetaEnvironment].

....
RecRecord ::= Identifier{. DefinitionTerminator … Terminator Definition .}
....

Externally, a link:#RecRecord[RecRecord] is the same as a regular
link:#Record[Record]; internally, however, its fields are defined
differently using link:#Definition[Definition]s.
link:#Definition[Definition]s include link:#RecordElement[RecordElement]
but may also include link:#TypeDefinition[TypeDefinition]s and other
forms of definition.

Furthermore, _within_ a link:#RecRecord[RecRecord], definitions may be
_mutually recursive_.

link:#RecRecord[RecRecord]s are especially convenient when the fields of
the record are program values. For example, assuming a type definition
such as:

....
onewayQ[t] ::= onewayQ{
  add : (t)=>action[(),()].
  take : ()=>t.
}
....

then the literal:

....
onewayQ{.
  private Q := [].
  add(X) => action {
    Q := [Q..,X];
    return ()
  .}
  take() => valof action{
    H = head(Q);
    Q := tail(Q);
    return H
  }
}
....

defines a `onewayQ` record with two exposed values – the functions `add`
and `take`.

[NOTE]
====
If there are extra definitions, they should be marked `private` which
will exclude them from the record’s type signature.
====[NOTE]
====
A link:#RecRecord[RecRecord] has many of the characteristics of an
object in OO languages – except that there is no concept of inheritance;
nor is there a direct equivalence of the `self` or `this` keyword.
====[NOTE]
====
A definition within a link:#RecRecord[RecRecord] that is marked
`private` does _not_ ’contribute’ to the external type of the record;
and neither can such an attribute be accessed via the
link:#FieldAccess[FieldAccess] expression.
====
[[Tuples]]
=== Tuples

tuples

A tuple consists of a sequence of expressions separated by commas and
enclosed in parentheses. In effect, a tuple is a
link:#PositionalConstructorLiteral[PositionalConstructorLiteral] where
the link:#Identifier[Identifier] is omitted.

....
TupleLiteral::= ( Expression, … , Expression )
....

Tuples allow a straightforward and casual grouping of values together
without requiring a specific type definition of a data structure.

[NOTE]
====
Unlike
link:#PositionalConstructorLiteral[PositionalConstructorLiteral]s, the
set of possible tuples _cannot_ be defined using a
link:#TypeDefinition[TypeDefinition]. Instead, the tuple types form a
_type schema_.

[NOTE]
====
Not a single type, because each arity of anonymous tuple type denotes a
different type. However, all tuples are related by their tuple-ness.
====
====In that tuples can be used to group elements together, they are
somewhat similar to arrays. However, unlike arrays, each element of a
tuple may be of a different type, and also unlike arrays, tuple elements
may not be accessed via an indexing operation: tuples can only be
unwrapped by some form of pattern matching.

For example, if the `split` function splits a list into a front half and
back half, it may be used in a statement of the form:

....
(F,B) = split(L)
....

which has the effect of unpacking the result of the `split` function
call and binding the variables `F` and `B` to the front half and back
half of the list `L`.

The tuple notation is unremarkable except for two cases: the single
element tuple and the zero element tuple.

[[Zero_002dary-Tuples]]
==== Zero-ary Tuples

0-ary tuples

Zero-element tuples _are_ permitted. A zero-element tuple, which is
written

....
()
....

is essentially a symbol.

A tuple of no values is effectively the same as void and is used to
signal void or empty arguments.

[[Singleton-Tuples]]
==== Singleton Tuples

Some special handling is required to represent tuples of one element.

The principal issue is the potential ambiguity between a tuple with one
element and a normal operator override expression.

For example,

....
(a+b)*c
....

is such a case: the inner term `(a+b)` is not intended to denote a tuple
but simply the sum of `a` and `b`.

A singleton tuple _may_ be written; by doubly parenthesizing it. An
expression of the form:

....
((34))
....

denotes a singleton tuple with the integer `34` in it.

[NOTE]
====
Fortunately, singleton tuples are not often required in programs.
====
[[Function-Application-Expressions]]
=== Function Application Expressions

expressions,function application

A function application expression applies a function to zero or more
arguments.

....
ApplicativeExpression ::= Expression ( Expression, … , Expression)
....

It is quite normal for the function expression being applied to
arguments itself to be the result of a function application. For
example, given the function `double`:

....
double : all s ~~ (((s)=>s))=>((s)=>s)
double(F) => (X) => F(F(X))
....

we can apply `double` to `inc`:

....
inc : (integer)=>integer.
inc(X) => X+1.
....

to get an expression such as:

....
double(inc)(3)
....

which has value 5.

[NOTE]
====
The link:#PositionalConstructorLiteral[PositionalConstructorLiteral]
expression is actually a form of the
link:#ApplicativeExpression[ApplicativeExpression]; where the function
being applied is the constructor defined in a
link:#TypeDefinition[TypeDefinition].
====
[[Control-Expressions]]
=== Control Expressions

control expression

The so-called control expressions involve and modify the meaning of
other expressions and actions.

[[Case-Expression]]
==== Case Expressions

case expression

....
CaseExpression ::= caseExpression in CaseHandler

CaseHandler ::= { CaseRule. … . CaseRule  }

CaseRule ::= Pattern => Expression |
  Pattern default => Expression
....

The value of a case expression depends on which of the cases match its
governing expression.

For example, the expression:

....
case D in {
  monday => 0.
  tuesday => 1.
  _ => 10
}
....

compares the value of the variable `D` against the symbols `monday` and
`tuesday` and returns 0 or 1 if either of those match. Other values of
`D` return `10`.

[NOTE]
====
The cases of a case expression resemble syntactically the equations of a
function definition. This is deliberate: a function definition expressed
as equations is effectively a `case` expression.
====
[[Try-Catch]]
==== Try Catch

try catch

try

catch

The link:#TryCatchExpression[TryCatchExpression] expression is used to
denote an expression which may need to respond to exception situations.

....
TryCatchExpression ::= try Expression catch CaseHandler
....

The type of any exception thrown within the body of the `try`…`catch`
must be consistent with the handler. For example, in:

....
try{
  raise 10
} catch {
  (E) => {
    E+10
  }
}
....

the type of `E` is `integer`; which is consistent with the expression

....
raise 10
....

The value of this overall expression is `20`.

[[Raise]]
==== Raise

raise

....
RaiseExpression ::= raise Expression
....

When a `raise` expression is evaluated, its expression is evaluated and
that value is raised as an exception. There must either be a
link:#TryCatchExpression[TryCatchExpression] form, a
link:#TryCatchAction[TryCatchAction] form in the enclosing lexical
scope, or the function in which it occurs must have been declared as
raiseing a value of the appropriate type.

[NOTE]
====
The type of a `RaiseExpression` is unconstrained – because its value is
never consumed.
====[NOTE]
====
If evaluating the expression that denotes the exception to raise itself
raises an exception, that is a fatal error and causes overall execution
of the program to stop.
====[NOTE]
====
There is no automatic search for an handling form: every `raise` must be
lexically accounted for.
====
[[Conditional-Expression]]
==== Conditional Expressions

conditional expression

....
ConditionalExpression ::= (Condition ?? Expression || Expression)
....

The value of a conditional expression depends on whether the
link:#Condition[Condition] is satisfiable or not. If the
link:#Condition[Condition] is satisfiable, then the expression is
equivalent to the ’then’ branch of the conditional expression; otherwise
it is equivalent to the ’else’ branch.

For example, the expression:

....
(P in members ?? X>Y || X<Y)
....

is equivalent to one of `X>Y` or `X<Y` depending on whether the
link:#Condition[Condition]:

....
P in members
....

is satisfiable – i.e., has at least one solution.

The condition of a conditional expression may introduce variables,
depending on the form of the condition – for example, if the
link:#Condition[Condition] is a link:#SearchCondition[SearchCondition]
condition like that above. These variables are ’in scope’ within the
’then’ part of the conditional expression but are _not_ in scope for the
’else’ part.

[NOTE]
====
The only guarantees as to evaluation of a conditional expression are
that

[arabic]
. the conditional will be evaluated prior to evaluating either arm of
the conditional
. only one of the arms will be evaluated – depending on the value of the
condition.
====
[[Let-Expressions]]
==== Let Expressions

let expressions

A `let` expression allows an expression to be defined in terms of
auxiliary definitions.

....
LetExpression::=let LetEnvironment in Expression
LetEnvironment ::= { RecordElementTerminator … Terminator RecordElement } |
  {. DefinitionTerminator … Terminator Definition .}
....

A `let` expression consists of a body – which is an
link:#LetEnvironment[LetEnvironment] – and a bound
link:#Expression[Expression]. The type of a `let` expression is the type
of the bound expression.

There are two forms of let expressions, recursive and non-recursive. The
non-recursive form is written using the `{` and `}` brackets, whereas
the recursive environment is written using `{.` and `.}` brackets.

Both environments support value and type definitions; the recursive
environment allows mutually recursive definitions to be constructed.

Within a non-recursive let environment, the elements being defined are
not themselves in scope: only variables and types that are defined
outside the environment are in scope within the environment.

[NOTE]
====
This is different to the rule for some languages that allow a form of
sequential scope within a let environment: i.e., they allow later
definitions to rely on earlier definitions. However, in *Star*, a let
environment is also permitted inside a record expression which would
result in a significantly confusing situation.
====[NOTE]
====
`let` expressions are an important program structuring tool for
programmers. It is worth emphasizing that `let` expressions are
expressions! They can be used in many, perhaps unexpected, places.

For example, a `sort` function may require a comparison predicate in
order to operate. This can be supplied as a named function:

....
pComp : (person,person)=>boolean.
pComp(someone{name=N1},someone{name=N2}) => N1<N2

S = sort(L,myCompare)
....

Or, the same may be achieved where the call to `sort` is not so
conveniently close to a definition environment:

....
sort(L, let{
  pComp(someone{name=N1},someone{name=N2}) => N1<N2
}
in pComp)
....

Of course, in this case, the `sort` expression could equally have been
written using a lambda expression:

....
sort(L, (someone{name=N1},someone{name=N2}) => N1<N2)
....

The `let` expression has major applications when constructing
function-returning functions.
====
[[Optional-Expressions]]
==== Optional Expressions

optional expressions

An `option` expression is used to handle cases where a value is not
always guaranteed. The `option` type is built-in but is defined as
though by the algebraic type definition in:

....
option[t] ::= .none | .some(t)
....

The `option` type is intended to convey one of two possibilities: a
given value exists – in which case the `some` constructor is used – or
no value exists – in which case `none` is used.

For example,

....
some("alpha")
....

signals the definite tring value `"alpha"`; whereas

....
.none
....

signals that there is no value.

The `option` type is used as the return type of functions that must
reliably signal whether or not a value exists.

[NOTE]
====
The `option` type serves as a normal replacement for `null` that one
sees in languages like Java.
====
[[Typed-Expressions]]
=== Typed Expressions

typed expressions

A type annotation expression is an explicit declaration of the type of
an expression. A type coercion expression denotes a conversion of a
value so that it conforms to a particular type.

....
TypedExpression::= TypeCoercion | TypeAnnotationExpression
....

[[Type-Annotation-Expression]]
==== Type Annotation Expression

type annotation expressions

A link:#TypeAnnotationExpression[TypeAnnotationExpression] is an
expression that is annotated with a link:#Type[Type]. The annotation
amounts to an assertion that the link:#Type[Type] of the expression is
as annotated.

....
TypeAnnotationExpression ::= (Expression : Type)
....

[NOTE]
====
The link:#TypeAnnotationExpression[TypeAnnotationExpression] should not
be confused with type casting as is found in some languages. The
link:#TypeAnnotationExpression[TypeAnnotationExpression] is a way for
the programmer to communicate exactly what the expected type of an
expression is; analogously to the link:#TypeAnnotation[TypeAnnotation]s
found in link:#ThetaEnvironment[ThetaEnvironment]s.
====
[[Type-Coercion]]
==== Type Coercion

type coercion

....
TypeCoercion ::= Expression :: Type
  | Expression :? Type 
....

A link:#TypeCoercion[TypeCoercion] expression amounts to a call to
convert a value of one type to that of another. For example, coercing a
`float` value to an `integer` value – which also has the potential to
change the value (stripping any fractional part of the value).

Type coercion is supported by a special `coercion`
link:#ContractDefinition[ContractDefinition] shown in:

....
all s,t ~~ contract coercion[s,t] ::= {
  _coerce:(s) => option[t]
}
....

[NOTE]
====
Specifically, an expression of the form:

....
X :: integer
....

is equivalent to the expression:

....
(_optval(_coerce(X)) : integer)
....

which has the effect of declaring that the expression has type `integer`
and the `_coerce` function is an overloaded function that references a
type-specific implementation – based on the source type of `X` and
`integer`.
====The `:?` form of coercion expression is used in situations where the
coercion may _fail_. If the coercion fails then the value should be
`.none`. For example, the coercions of `string` values to `integer` is
not guaranteed – it depends on whether the string denotes an integer or
not:

....
"fred" :? integer
....

has value `.none`; as does:

....
"34ed" :? integer
....

The latter is `.none` because the coercion from strings to integers
attempts to make the whole string an integer value.

There are many standard coercions available. However, it is also
possible for a programmer to define their own type coercion by
appropriately implementing the `coercion` contract.

[[Sequence-Expressions]]
=== Sequence Expressions

sequence expressions

expression,sequence

Sequence expressions are a syntactic feature that make it
straightforward to represent sequences and other forms of collection
values. Some sequence forms embody a sequential ordering of the
elements. A collection may have an ordering present; but that is not
required by the contract and is not enforced in the notation.

[[Sequence-Expression-Notation]]
==== Sequence Expression Notation

....
SequenceExpression ::= [ ExpSequence ]

ExpSequence ::= Expression, … , Expression[,..Expression
....

I.e., a sequence expression consists of a sequence of
link:#Expression[Expression]s separated by commas. In addition, the tail
of the sequence may be denoted by an expression. Otherwise the sequence
is nil-terminated.

Sequence expressions are interpreted in terms of the `sequence`
contract.

An expression of the form:

....
[E1,…,En]
....

is equivalent to the expression:

....
_cons(E1, … , _cons(En,_nil) … )
....

where `_cons` and `_nil` are elements of the `sequence` contract.

____
There is a corresponding contract for sequence terms as
link:#SequencePattern[SequencePattern]s; which uses the `stream`
contract to signal the underlying semantics.
____

[[Index-Expression]]
==== Index Expression

....
IndexExpression ::= Expression [ Expression ]
 | Expression [ ~ Expression ]
 | Expression [ Expression -> Expression ]
....

Index expressions are used to denote accessing elements of a collection.
There are several variants of the notation – corresponding to element
selection, replacing an element in a collection and removing an element
from a collection.

There is a related similar notation – the link:#Slice-Notation[Slice
Notation] – that is used to denote sub-sequences.

The index notation is based on the `indexed` contract
(link:#The-indexed-Contract[The indexed Contract]).

An expression of the form:

....
C[E]
....

is equivalent to:

....
_index(C,E)
....

[NOTE]
====
The result type of an index expression is `option`al. This reflects the
fact that accessing a collection for an element may not be succesfull.
====The `indexed` contract (and therefore the index notation) is
supported for lists, maps.

Replacing elements in a collection is denoted using a variant of the
index notation where the index takes the form of:

....
C[K -> E]
....

which denotes the collection `C` with the element associated with K
replaced (or set) with `E`. This expression is equivalent to the call:

....
_put(C,K,E)
....

and the returned value is a new collection with the replacement made.

[NOTE]
====
The original collection is generally _not_ updated by the call to
`_put`.
====Removing an element is denoted using the variant:

....
C[~K]
....

which denotes the collection `C` with the element `K` removed.

[NOTE]
====
If the collection did not contain any value associated with the key `K`
then the result is the original collection. Otherwise the value is the
collection with any value associated with `K` removed.
====
[[Slice-Notation]]
==== Slice Notation

....
SliceExpression ::= Expression [ Expression : Expression ]
....

The slice notation is based on the `slice` contract
(link:#The-slice-Contract[The slice Contract]).

An expression of the form:

....
C[F:T]
....

refers to the subset of the collection `C` that starts at element `F`
and continues until element `T` (but does not include it).

The above expression is actually equivalent to a call to the `_slice`
function:

....
_slice(C,F,T)
....

[NOTE]
====
The result type of a slice expression is the same as the collection type
that is being sliced.
====
[[Conditions]]
== Conditions

Conditions are used to express constraints. For example, a `where`
pattern (link:#GuardedPattern[GuardedPattern]) uses a condition to
attach a semantic guard to a pattern. Conditions are also as guards on
link:#Equation[Equation]s and in other forms of rule.

[NOTE]
====
Conditions should not be confused with `boolean`-valued expressions; the
fundamental semantics of conditions is based on _satisfiability_ – not
_evaluation_. However, a `boolean`-valued expression _may_ act as a
degenerate example of a condition.
====
....
Condition::=MatchesCondition
  | HasValueCondition
  | ConjunctionCondition
  | DisjunctionCondition
  | ImpliesCondition
  | NegatedCondition
  | ConditionalCondition
  | ( Condition )
  | Expression
....

[[Matching-Conditions]]
=== Matching Conditions

[[Matches-Condition]]
==== Matches Condition

The `matches` condition is a special condition that applies a pattern to
a value. The condition is satisfied if the pattern matches the
expression.

....
MatchesCondition::=Pattern .= Expression
HasValueCondition ::= Pattern ?= Expression
....

A link:#MatchesCondition[MatchesCondition] is type safe if the types of
the left hand side and right hand side are the same. Recall that the
left hand side is an expression, whereas the right hand side is a
pattern.

The first form succeeds if the link:#Pattern[Pattern] exactly matches
the link:#Expression[Expression]; the
link:#HasValueCondition[HasValueCondition] variant can be used as a
link:#Condition[Condition] to ’unwrap’ an `option`al to access its
contents in a safe way. I.e., a link:#Condition[Condition] of the form:

....
Pattern ?= Expression
....

is equivalent to:

....
.some(Pattern) .= Expression
....

[NOTE]
====
Any variables which are introduced in the link:#Pattern[Pattern] of a
matching condition may form part of the scope extension of the condition
– depending on whether the matching condition is embedded in a deeper
condition that masks the variables.
====One common use of the `?=` condition is to ’bring into scope’ a
variable which represents the wrapped content of the `option`al value.

For example, suppose that `P` has the type given by

....
P : Person
....

then the condition in the equation:

....
nameOf(P) where PP ?= P => PP.name
....

unwraps the optional value of `P` into the non-optional `PP`.

[[Logical-Combinations]]
=== Logical Combinations

[[Conjunction-Condition]]
==== Conjunction Condition

A conjunction – using the `&&` operator – is satisfied iff both the left
and right ‘arms’ of the conjunction are satisfied.

....
ConjunctionCondition::=Condition && Condition
....

A link:#ConjunctionCondition[ConjunctionCondition] is satisfied if both
the left and right arms are satisfied.

[NOTE]
====
link:#ConjunctionCondition[ConjunctionCondition] are _short circuiting_:
if the left arm is not satisfiable then the right arm will not be
attempted.
====[NOTE]
====
Any variables that are introduced into scope as a result of the left arm
of the conjunction are also in scope for the right arm – and for the
extending scope the conjunction itself is part of.
====
[[Disjunction-Condition]]
==== Disjunction Condition

disjunctive condition

||

condition

A disjunction – using the `||` operator – is satisfied if either the
left or the right operands are satisfied.

....
DisjunctionCondition::=Condition || Condition
....

[NOTE]
====
link:#DisjunctionCondition[DisjunctionCondition]s are _short
circuiting_: if the left arm is satisfiable then the right arm may not
be attempted.
====[NOTE]
====
Only those variables which are introduced in _both_ of the left and
right arms of the disjunction will be part of the scope extension of the
condition.
====[[Negated-Condition]]
==== Negated Condition

A negation is satisfied iff the operand is _not_ satisfied.

....
NegatedCondition::= ~ Condition
....

[NOTE]
====
None of any variables that are introduced in the negated
link:#Condition[Condition] are part of the scope extension of the
condition.
====[[Implies-Condition]]
==== Implies Condition

An _implication_ condition – using the `implies` operator – is satisfied
iff there is a solution to the right hand side for every solution to the
left hand side.

....
ImpliesCondition::=Condition *> Condition
....

For example, the state of having only sons can be defined as the
condition that all ones children are male. This can be expressed using
the condition:

....
(P,X) in children *> X in male
....

____
Like negation, an link:#ImpliesCondition[ImpliesCondition] condition can
never result in binding a variable to a value. It can only be used to
verify a condition. Thus, to actually look for people who only have
sons, a separate ‘generator’ condition is needed.

A query expression such as:

....
(P,_) in children && (P,X) in children *> X in male
....

is effectively using the first ‘`(P,_) in children`’ condition to find a
person who has children, where the second implies condition verifies
that `P` only has sons.
____

[[Conditional-Condition]]
==== Conditional Condition

conditional condition

A conditional condition is used when the actual condition to apply
depends on a test.

....
ConditionalCondition::= ( Condition ?? Condition || Condition )
....

For example, if the salary of an employee may be gotten from two
different relations depending on whether the employee was a manager or
not, the salary may be retrieved using a query:

....
{ S | ( isManager(P) ??
            (P,S) in manager_salary ||
            (P,S) in employee_salary )
}
....

As with link:#ConditionalExpression[ConditionalExpression]s, the _test_
part of the link:#ConditionalCondition[ConditionalCondition] is
evaluated and, depending on whether the test is _satisfiable_ or not,
the _then_ branch or the _else_ branch is used in the query constraint.

[NOTE]
====
Only variables that are present in all three of _test_, _then_ and
_else_ parts of the link:#ConditionalCondition[ConditionalCondition]
form part of its scope extension.

However, the scope extension of the _then_ part of the
link:#ConditionalCondition[ConditionalCondition] does extend to the
_then_ part of the condition.
====[NOTE]
====
In the case that the __test__is satisfiable; then only solutions from
the _then_ branch will be considered for the overall query. Conversely,
if the ‘test’ is not satisfiable,footnote:[A normal `boolean`-valued
expression is considered to be satisfiable iff it evaluates to `true`.]
then only solutions from the _else_ branch will be used for the overall
query.
====For example, the link:#ConditionalCondition[ConditionalCondition]
above defines the variable `S` in both the ‘then’ and ‘else’ branch.
Depending on the `isManager` test, the result of the query will either
contain the value of a `manager_salary` or an `employee_salary`.

[[Embedded-where-Conditions]]
=== Embedded `where` Conditions

embedded where conditions

condition, embedded where

Many conditions include within them some form of pattern matching.
Conversely, all patterns are implicitly part of a
link:#Condition[Condition]. One particular form of pattern: the
link:#Guarded-Pattern[Guarded Pattern], which uses a `where` clause to
introduce a link:#Condition[Condition] into the pattern, is worth an
additional note.

Any embedded `where` clauses in a pattern are equivalent to a
conjunction in the innermost enclosing condition.

For example, in:

....
if (X where X>0,Y where Y<X).=Foo then …
....

there are two embedded `where` clauses, governing the matches for `X`
and `Y` inside the tuple pair. This condition is equivalent to the
conjunction:

....
if (X,Y).=Foo && X>0 && Y<X then …
....

Note that the ordering of the conjunction reflects the textual order of
the different `where` clauses.

This can become complex when `where` clauses are nested. For example, in

....
if (X where .mine(U where U>0).=X, Y where Y>U).=Foo then …
....

the inner `where` that tests `U` is inserted just after the condition
that tests `X` and before the condition for `Y`:

....
if (X,Y) .= Foo && .mine(U).=X && U>0 && Y>U then …
....

[[Queries]]
== Queries

queries

A link:#QueryExpression[QueryExpression] is an expression that denotes a
value implicitly – by operations and constraints on other identified
values. Typically, the result of a query is an `list` but it may be of
any link:#Type[Type] – provided that it implements the `sequence`
contract.

There are several flavors of query: comprehensions (see
link:#Comprehensions[Comprehensions]) which compute collections of
values, collections; iota expressions (see link:#IotaQuery[IotaQuery]
which compute a single value and test queries (see
link:#TestQuery[TestQuery]) which check for the existence of a solution.

....
QueryExpression ::= Comprehension
 | IotaQuery
 | TestQuery
....

[[Query-Condition]]
=== Query Condition

All of query expressions depend on the notion of a _query condition_. A
query condition is a predicate that may be _satisfied_ in zero or more
ways.

A predicate is satisfied if there is a binding for variable in the
expression that make the expression evaluate to `.true`. This is a
little different to normal evaluation because of the existence of these
variables.

There are many different kinds of query condition, including normal
conditions, but the canonical query condition is the search condition
(see link:#Search-Condition[Search Condition]).

[[Search-Condition]]
==== Search Condition

search

query, search

Search conditions are the foundational element of many query
expressions.

A search condition takes the form: _Pattern_ `in` _Collection_ where
_Pattern_ may have new variables that have not been defined in an outer
scope and _Collection_ is a collection of the appropriate type – in
particular, the type of the pattern must correspond to the type of an
element of the collection.

A search condition is said to be _satisfied_ when there is an element of
the collection that matches the pattern. In many queries this results in
the binding of variables which are referenced in other parts of the
query condition and/or in the bound expression of the query expression.

....
SearchCondition ::= Pattern in Expression
....

For example, the search condition:

....
(X,"john") in parent
....

is satisfied (potentially multiple times) if there is a pair of the
form:

....
(Val,"john")
....

in the collection identified as `parent`. If `parent` were defined as
the list:

....

[ ("alpha","john"), ("beta","peter"), ("gamma","john") ]
....

then the search condition has two solutions: one corresponding to
`"alpha"` and the other to `"gamma"`.

A search condition is type safe if the type of the pattern corresponds
to an element of the type of the collection; and if the contract `iter`
has been implemented for the collection:

....
public contract all s,t ~~ iter[s->>t] ::= {
  _iter:all x ~~ (s,x,(t,x)=>x) => x
}
....

This implies that one can search any type of data structure so long as
there is an implementation of the `iter` contract available for it.

[[Query-Expressions]]
=== Query Expressions

[[Comprehensions]]
==== Comprehension Expressions

comprehension

query,comprehension

A link:#Comprehension[Comprehension] computes a collection of answers –
all of which satisfy a condition.

The general form of a comprehension is shown in
link:#comprehensionFig[comprehensionFig]: it consists of a _condition_
and a _generator_ expression; all enclosed in braces.

....
Comprehension ::= { Expression | Condition }
....

For example, given a `list` bound to the variable `Tble`:

....
Tble = [
  ("john",23),
  ("sam",19),
  ("peter",21)
]
....

then, the query

....
{ Who | (Who,A) in Tble && A>20 }
....

is a link:#Comprehension[Comprehension] over the `Tble` list defined
above. Its value is the `list`:

....
[
  "john",
  "peter"
]
....

`"john"` and `"peter"` are in the result because both `("john",23)` and
`("peter",21)` are in `Tble` and satisfy the condition that `A` is
greater than 20.

[NOTE]
====
The type of the comprehension above is _not_ necessarily a `list`. The
overall type of a comprehension is governed by the `sequence` contract.
Thus the actual type will depend on the context of the comprehension
expression.

In order to force the result to be a `cons` list, use a type annotation:

....
{ Who | (Who,A) in Tble && A>20 }:cons[integer]
....
====[[Iota-Query]]
==== Iota Query

query,iota

An iota query is similar in form to a comprehension, it consists of a
bound expression and a condition. The difference is that an iota
expression returns a single instance of the bound expression: i.e., the
first time the query condition is satisfied the iota query will return
the bound expression – wrapped as an optional value.

....
IotaQuery ::= {! Expression | Condition !}
....

If the condition has no answers then the iota expression returns
`.none`.

For example, to find a child of `P` one could use the expression:

....
{! X | (P,X) in children !}
....

Assuming that the type of `children` is `cons[(string,string)]`, then
the type of this iota query is `option[string]`.

[[Test-Query]]
==== Test Query

query,test

A test query is a form that allows a query to act as a normal condition.
This is most useful when a condition requires some form of search in
order to be satisfied.

Test queries have a truth value – allowing them to be used as normal
conditions – and they may also bind variables. In this regard, a test
query is analogous to a pattern match condition (see
link:#Matches-Condition[Matches Condition]) that also allows variables
to be bound.

....
TestQuery ::= {? Condition ?}
....

If the condition has no answers then the test query is `.false`.

[[Actions]]
== Actions

An action is performed for the sake of its effect. *Star* has a normal
complement of control flow instructions; although there are a few
departures from some common patterns.

Apart from achieving some effect, actions are associated with a value.
This is the value of the action that is returned when action is
completed.

Actions may also be associated with an exception; in the case that the
action does not complete normally. Unlike many programming languages,
exceptions in *Star* are strictly statically checked.

The link:#ValofExpression[ValofExpression] is used to denote that a
value is to be computed by performing actions. Similarly, many actions
involve the evaluation of expressions.

[[Actions-and-Types]]
=== Actions and Types

action types

action!types

Actions have two types associated with them: their _value_ type and
their _exception_ type. The action’s value type is the type of any
returned value – i.e., the type of the expression associated with any
link:#ValisAction[ValisAction]s within the action. The action’s
exception type is the type of any exception that may be thrown by the
action.

[[Basic-Action-Forms]]
=== Basic Action Forms

basic action expressions

The basic actions include those in link:#doFig[doFig]. There are
additional actions, as explained in link:#Fibers[Fibers].

....
Action::=NullAction
  | BlockAction
  | InvokeAction
  | ValisAction
  | DefnAction
  | AssignmentAction
  | IfThenElseAction
  | WhileAction
  | ForAction
  | CaseAction
  | LetAction
  | TryCatchAction
  | RaiseAction
  | LabeledAction
  | BreakAction
....

[[Nothing]]
==== `nothing`

no operation

nothing

The `{}` action does nothing; and does not return a value.

....
NullAction ::= {}
....

The `{}` does nothing. Useful when you don’t want to do anything.

[[Block-Action]]
==== Block Action

block action

An action block consists of a sequence of actions, enclosed in braces
(`{}`) and separated by semi-colons.

....
BlockAction ::= { Action ; … ; Action }
....

The empty action block – `{}` – is equivalent to the
link:#NullAction[NullAction].

[[Invoke-Action]]
==== Invoke Action

invoke action

The link:#InvokeAction[InvokeAction] denotes the invokation of a
sub-computation. Typically, an link:#InvokeAction[InvokeAction] takes
the form of a call to a function.

....
InvokeAction ::= Expression TupleLiteral
....

Any value that is returned by the function call is discarded; however,
if the function throws an exception then that exception is propagated
within the enclosing action.

[[Valis-Action]]
==== Valis Action

valis action

valis

The link:#ValisAction[ValisAction] denotes that the action should
terminate and return a value.

....
ValisAction ::= valis Expression
....

When a `valis` action is performed, its expression is evaluated and that
value is used as the value of the computation.

A link:#ValisAction[ValisAction] must be lexically enclosed by a
link:#ValofExpression[ValofExpression]. The
link:#ValisAction[ValisAction] terminates that expression and the value
of the link:#ValofExpression[ValofExpression] is the value computed by
the link:#ValisAction[ValisAction].

[NOTE]
====
It is possible that evaluating the expression of a
link:#ValisAction[ValisAction] may cause an exception to be thrown. In
that case, the link:#ValisAction[ValisAction] itself aborts and the
exception is propagated to the designated handler.
====[[Raise-Action]]
==== Raise Action

raise action

raise

The link:#RaiseAction[RaiseAction] denotes that the action should
terminate and raise an exception.

....
RaiseAction ::= raise Expression
....

When a `raise` action is performed, its expression is evaluated and that
value is raised as an exception. The syntactically enclosing action must
either be a link:#TryCatchAction[TryCatchAction] form, or the action
must be the top-level of a function and that function must have been
declared as raising a value of the appropriate type.

[NOTE]
====
If evaluating the expression that denotes the exception to raise itself
raises an exception, that is a fatal error and causes overall execution
of the program to stop.
====[NOTE]
====
There is no automatic search for an handling form: every `raise` must be
lexically accounted for.
====[[Labeled-Action]]
==== Labeled Action

labeled action

The link:#LabeledAction[LabeledAction] associates a _label_ with an
action. Apart from that label, the semantics of the labeled action is
not affected – unless it lexically contains a
link:#BreakAction[BreakAction].

....
LabeledAction ::= Identifier : Action
....

The scope of the label is limited to the text enclosed within the
labeled action.

[[Break-Action]]
==== Break Action

break action

break

The link:#BreakAction[BreakAction] denotes that the labeled action
should terminate. The action that was labeled is terminated, and
computation proceeds with its natural successor.

....
BreakAction ::= break Identifier
....

When a `break` action is performed, it must refer to the label of a
syntactically enclosing action. That action is ended – with no further
actions taking place within it – and the labeled action’s natural
successor is entered.

____
*Example:* Labeled actions and labeled breaks are a straightforward
mechanism for early exiting loops. For example, in the loop:

....
firstMultiple(X,M) => valof{
  L:{
    for ix in range(1,X,1) do{
      if ix%M==0 then
        break L
    };
    valis "not found"
  };
  valis "found"
}
....

The `firstMultiple` function will return `"found"` if a multiple of some
`M` is found in a range; and `"not found"` otherwise.

This is because, when a multiple is found, we exit the composite action
labeled `L`; which proceeds to the next action which returns the
`"found"` value.

If the loop ended normally, that is because no multiple was found, and
the action after the loop signals that.
____

[NOTE]
====
There is no run-time search for an enclosing label; nor are labels first
class entities. A label is an identifier that is used to identify (sic)
a specific action.

Labels can be nested, however. In the case that there are multiple
occurrences of a label in scope, a `break` will always refer to the
lexically innermost labeled action with the same label.
====[[Definition-Action]]
==== Definition Action

definition action

The link:#DefnAction[DefnAction] is used to define variable and to give
them a value – that is available to subsequent actions.

....
DefnAction ::= Identifier = Expression
 | ( Identifier , … , Identifier ) = Expression
....

There are two forms of definition action: defining the value of a single
variable or defining the value of a tuple of variables. Clearly, in the
second case, the right hand side must also evaluate to a tuple of the
same arity.

The scope of any variable declared in a definition actions is from the
declaration itself to the end of the containing _BlockAction_.

[NOTE]
====
It is an error for a variable to be referenced within its own
definition. Recursive definitions are not permitted within actions.
However, it is possible to introduce functions, including recursive
functions, within an action by using the link:#LetAction[LetAction] form
of action.
====[[Assignment-Action]]
==== Assignment Action

assignment action

:=

The link:#AssignmentAction[AssignmentAction] is an link:#Action[Action]
that replaces the value of a re-assignable variable with another value.
The variable being re-assigned must have a `ref` type – there is no
‘implicit’ assignability of a variable or field.

....
AssignmentAction ::= Variable := Expression
....

Reassignable variables are typically introduced with a
link:#DefnAction[DefnAction] of the form:

....
V = ref Initial
....

However, if the variable is not otherwise in scope – i.e., no scope
hiding – then if the first occurrence of the variable is in an
assignment statement then that is interpreted as the definition of the
re-assignable variable.

[[Conditional-Action]]
==== Conditional Action

conditional action

The link:#IfThenElseAction[IfThenElseAction] is used to denote a
conditional computation.

....
IfThenElseAction ::= if Condition then Action else Action
  | if Condition then Action
....

The second form of link:#IfThenElseAction[IfThenElseAction] – which
omits the `else` branch – is equivalent to one in which the else branch
is replaced by the link:#NullAction[NullAction]:

....
if Test then
  A
else
  {}
....

[[While-Action]]
==== While Action

while action

while

The link:#WhileAction[WhileAction] is used to denote an iterative
computation that repeats so long as some condition is satisfied.

....
WhileAction ::= while Condition do Action
....

The enclosed action will be repeated zero or more times, for so long as
the test condition is satisfied.

[[For-Action]]
==== For Action

for action

for

....
ForAction ::= for Pattern in Expression do Action
....

The `for` loop iterates over a collection and matches each element
against _Pattern_; which will typically bind one or more variables that
are in scope for the body of the loop.

The type of the collection must implement the `generate` contract.

For example, the action:

....
for (X,Y) in parent do {
  for (Y,Z) in parent do {
    gps := [(X,Z),..gps!]
  }
}
....

collects grandparents into the re-assignable variable `gps`. This action
is equivalent to the double link:#While-Action[While Action]:

....
{
  gps := [];
  G1 = _generate(parent);
  L1: while .true do {
    G1 resume ._next in {
      _yld((X,Y)) => {
        G2 = _generate(parent);
        L2: while .true do {
          G2 resume ._next in {
            _yld((Y,Z)) => {
              gps := [(X,Z),..gps]
            }
            _yld(_) default => {}
            ._end => {
              break L2
            }
          }
        }
      }
      _yld(_) default => {}
      ._end => {
        break L1
      }
    }
  }
}
....

[[Let-Action]]
==== Let Action

let action

let

The link:#LetAction[LetAction] allows an action to have local
definitions embedded within it. It plays the same role as let
expressions do.

....
LetAction ::= let LetEnvironment in Action
....

As with let expressions, there are two forms: the non-recursive form –
using regular braces `{}` – and the recursive form – using dot-braces
(`{..}`.

[[Case-Action]]
==== Case Action

case action

The `case` action selects one of a set of arms depending on the value of
a governing expression. It is the analog of the
link:#CaseExpression[CaseExpression]; oriented to performing actions.

....
CaseAction ::= case Expression in CaseActionHandler

CaseActionHandler ::={ CaseActionRule . … . CaseActionRule }

CaseActionRule ::= Pattern => Action
  | Pattern default => Action
....

As with function definitions, the `default` case, if present, is
intended to apply if no other case rules match the governing expression.
As such, it should not be possible for the `default` rule’s pattern to
fail to apply.

[[Try-Catch-Action]]
==== Try Catch Action

try catch action

try

catch

The link:#TryCatchAction[TryCatchAction] is used to denote a computation
which may need to respond to exception situations.

....
TryCatchAction ::= try Action catch CaseActionHandler
....

The type of any exception thrown within the body of the `try`…`catch`
must be consistent with the handler. For example, in:

....
try{
  raise 10
} catch {
  (E) => {
    logMsg("We got error $(E)")
  }
}
....

the type of `E` is `integer`; which is consistent with the action

....
raise 10
....

action.

[[Valof-Expression]]
==== Valof Expressions

....
Expression ::+= ValofExpression

ValofExpression ::= valof BlockAction
....

The link:#ValofExpression[ValofExpression] is applied to an
link:#BlockAction[BlockAction]. The effect of this is to perform the
action(s) in the block and return its value as the value of the
link:#ValofExpression[ValofExpression].

If the actions in link:#BlockAction[BlockAction] result in the execution
of a link:#ValisAction[ValisAction] then the expression’s value
associated with that action count as the value of the
link:#ValofExpression[ValofExpression] itself (and execution of the
actions is terminated).

At least one of the actions executed within the
link:#BlockAction[BlockAction] must be a link:#ValisAction[ValisAction].
If link:#BlockAction[BlockAction] exits with no
link:#ValisAction[ValisAction] being executed execution of the entire
program halts.

[[Fibers]]
== Fibers

A fiber is a computation whose execution can be managed. Fibers can be
created, suspended and resumed. Fibers also have identity which allows
correlation of fibers when managing sets of fibers.

[NOTE]
====
The `fiber` concept is a relatively low-level feature of *Star*. Other,
higher-level, features are constructed as a layer on top of fibers;
including:

* A `fiber` expression denotes a computation that can be scheduled
independently of other actions.
+
This is analogous to coroutining in other programming languages.
* A `generator` expression is used to define so-called yield-style
generators.
====[[Fiber-Type]]
=== Fiber Type

type, fiber

fiber type

The `fiber` type is used to characterize the type of fiber expressions.
It takes the form:

....
Type::+=FiberType

FiberType ::= fiber [ Type , Type ]
....

The second type argument refers to values that the fiber may suspend
with (see link:#Suspend[Suspend] and link:#RetireAction[RetireAction])
and the first type argument refers to values that the fiber may be
resumed with (see link:#Resume[Resume]).

[[Fiber-Expression]]
=== Fiber Expression

A `fiber` expression evaluates to a new fiber. It contains a set of
actions to perform as the fiber.

....
Expression::+=FiberExpression

FiberExpression ::= fiber BlockAction
  | fiber Expression
  | SuspendExpression
  | ResumeExpression
....

For example, in the `fiber` expression:

....
fiber{
  let{
    yildFn:((),e)=>().
    yildFn(_,E) => valof{
      case suspend .yild(E) in {
       .next => valis ().
      }
    }
  } in {_iter(L,(),yildFn)};
  retire .end
}
....

we use a link:#LetAction[LetAction] to introduce a local function
definition – `yildFn` – and pass it to the standard contract method –
`_iter` – (which is defined in the `iter` contract).

In addition to the actions, there are two special variables defined
within the body of the `fiber` expression: `this` and `first`:

`this`::
  The `this` keyword is bound to the currently executing `fiber` (and
  has the same type). This is one of the primary ways in which a `fiber`
  is given its own identity.
`first`::
  The `first` keyword is bound to the initial event that is passed to
  the `fiber` when it is first resumed.
  +
  [NOTE]
  ====
  When `fiber`s are created, they are in suspended state: i.e., the code
  within the `fiber` expression is not executed immediately. The `fiber`
  starts executing only when it is resumed – using the
  link:#Resume[Resume]
  ====

[[Suspend]]
==== Suspend

The link:#Suspend[Suspend] is used when a fiber wishes to suspend
itself. There are two arguments to the link:#Suspend[Suspend]: the
identity of the fiber to be suspended, a value that determines the
_suspension event_:

....
SuspendExpression::=
    Expression suspend Expression
  | suspend Expression
....

The types of the fiber, the event and the action case must match up;
i.e., given

....
T suspend E in {P1 => A1. .. Pn => An}
....

then `T` must be of type

....
fiber[R,S]
....

for some `S` and `R`; the type of `E`:

....
E : S
....

and the left hand sides of the response case – `Pi` – must have type
`R`.

In effect, the fiber type determines the legal events that the fiber may
be suspended with (and the legal events that the fiber may be resumed
with).

[NOTE]
====
When used directly within the text of a `fiber` expression, there is a
slightly shorter form of `suspend`:

....
suspend E in {P1 => A1. .. Pn => An}
....

This may be used when a fiber is directly suspending itself within the
`fiber` expression. This action is equivalent to:

....
this suspend E in {P1 => A1. .. Pn => An}
....

The `this` keyword is established within the scope of a `fiber`
expression; it allows fibers to discover their own identity.
====
[[Resume]]
==== Resume

A link:#Resume[Resume] is used when a fiber wishes to resume another
fiber. There are two arguments to the link:#Resume[Resume]: the identity
of the fiber to be resumed, and a value that determines the _resumption
event_:

....
ResumeExpression::= Expression resume Expression
....

As with `Suspend`, the types of the fiber, the event and the action case
must match up; i.e., given

....
T resume E
....

then `T` must be of type

....
fiber[R,S]
....

for some `R` and `S`; the type of `E`:

....
E : R
....

and the left hand sides of the response case – `Pi` – must have type `S`
– which will be used to match against the suspension event.

The link:#Suspend[Suspend] and link:#Resume[Resume] are quite symmetric.

[[Retiring-a-Fiber]]
==== Retiring a Fiber

The link:#RetireAction[RetireAction] is used when a fiber wishes to
retire and no longer continue execution. This is the primary means by
which a fiber designates that it is completed. Whether the fiber is
successful or not is determined by the value of the event it signals.

....
RetireAction::=
  Expression retire Expression
  | retire Expression
....

The types of the fiber and the event must match up; i.e., given

....
T retire E
....

then `T` must be of type

....
fiber[R,S]
....

for some `S` and `R`; the type of `E`:

....
E : S
....

In the case where the link:#RetireAction[RetireAction] is being
performed withing the lexical scope of the `fiber` expression, the
shorter form – which omits the identifier for the fiber being retired –
may be used. As with link:#Suspend[Suspend] this is equivalent to using
the `this` keyword to identify the retiring fiber.

[[Standard-Contracts]]
== Standard Contracts

In this chapter we outline the major standard contracts.

Many of these contracts have multiple implementations, for different
types and type combinations; these are outlined in separate chapters.

[[The-equality-contract]]
=== The `equality` contract

equality contract

Equality is based on the `equality` contract. This defines the
`boolean`-valued function: `==`. The complementary function `=!=` is not
defined as part of the `equality` contract; but is defined in terms of
`==`.

equality

contract

....
contract all t ~~ equality[t] ::= {
  (==) : (t,t)=>boolean
}
....

[[_003d_003d-_002d_002d-equals]]
==== `==` – equals

==

predicate

equality predicate

`==` is part of the standard `equality` contract.

Its type is given by:

....
(==) : all t ~~ equality[t] |: (t,t) => boolean
....

In general, equality is _not_ defined for all values. In particular,
equality is not defined for functions, procedures and other program
values.footnote:[Whether two expressions that denote functions of the
same type denote the same function is, in general, not effectively
decidable.]

[[_003d_007e_003d-_002d_002d-not-equals]]
==== `=~=` – not equals

=~=

predicate

inequality predicate

The type signature for `=~=` is:

....
(=~=) : all t ~~ equality[t] |: (t,t) => boolean
....

The `=~=` predicate has a standard definition that makes it equivalent
to a negated equality:

....
X =~= Y => ~ X==Y
....

[[The-comp-contract]]
=== The `comp` contract

Comparison between values is based on the standard `comp` contract – see
Programlink:#comparableContract[comparableContract].

Comparison is _not_ automatically implemented for all types – the
standard language provides implementations for the arithmetic types
(`integer`s, `float`s etc.) and for the `string` type.

....
contract all t ~~ comp[t] ::= {
  (<) : (t,t)=>boolean.
  (>=) : (t,t)=>boolean.
}
....

[[_003c-_002d_002d-less-than]]
==== `<` – less than

<

predicate

The type signature for `<` is:

....
(<) : all t ~~ comp[t] |: (t,t)=>boolean
....

The `<` predicate is satisfied if the left argument is less than the
right argument. The precise definition of less than depends on the
actual implementation of the `comp` contract for the type being
compared; however, for arithmetic types, less than is defined as being
arithmetic less than. For `string`s, one string is less than another if
it is smaller in the standard lexicographic ordering of strings.

[[_003e_003d-_002d_002d-greater-then-or-equal]]
==== `>=` – greater then or equal

>=

predicate

The type signature for `>=` is:

....
(>=) : all t ~~ comp[t] |: (t,t)=>boolean
....

The `>=` predicate is satisfied if the left argument is greater than or
equal to the right argument; as determined by the particular
implementation of the `comp` contract.

[[_003d_003c-_002d_002d-less-than-or-equal]]
==== `=<` – less than or equal

=<

predicate

The type signature for `=<` is:

....
(=<) : all t ~~ comp[t] |: (t,t)=>boolean
....

The `=<` predicate is satisfied if the left argument is less than or
equals to the right argument.

This predicate is not directly part of the `comp` contract, instead it
is defined in terms of `>=`:

....
X =< Y => Y >= X.
....

[[_003e-_002d_002d-greater-than]]
==== `>` – greater than

>

predicate

The type signature for `>` is:

....
(>) : all t ~~ comp[t] |: (t,t)=>boolean
....

The `>` predicate is satisfied if the left argument is strictly greater
than the right argument.

This predicate is not directly part of the `comp` contract, instead it
is defined in terms of `<`:

....
X > Y => Y< X.
....

[[The-display-contract]]
=== The `display` contract

display

contract

pretty print contract

The standard contract `display`, shown in
Program~link:#displayContractProg[displayContractProg], is at the core
of the standard method for displaying values.

[NOTE]
====
The `display` contract is also used as part of
link:#stringInterpolation[stringInterpolation] expressions.
====
....
public contract all t ~~ display[t] ::= {
  disp:(t)=>string.
}
....

One of the primary purposes of the `display` contract is to support the
standard string link:#Interpolation[Interpolation] form.

[TIP]
====
One of the primary benefits of allowing programmers to define their own
implementation of `display` is to enable higher quality display of
values. By defining `display` for yourself, you can use application
oriented display of your values.
====There are standard implementations of `display` contract for many of
the standard types. However, it is quite possible to define one’s own
implementation, either to support your own types or to override the
standard display. For example, supposing that values of the `tree` type:

....
tree[t] ::= empty | node(tree[t],t,tree[t])
....

were intended to be displayed:

....
{ "alpha" "beta" "gamma" }
....

then the following implementation of `display` would ensure that such
trees were displayed more conveniently:

....
implementation all t ~~ display[t] |: display[tree[t]] => let{
  treeDisplay(empty) => " ".
  treeDisplay(node(L,Lb,R)) => "#(treeDisplay(L)) $(Lb) #(treeDisplay(R))".
} in {
  disp(T) => "{#(treeDisplay(T))}"
}
....

Note how the use of `disp` within the definition of `treeDisplay` will
ensure that the display of tree labels may also be overridden with
user-defined implementations of `display`.

Note also that the `treeDisplay` function also uses the interpolation
expression form to display its left and right subtrees. In particular,
we use the embedded form of interpolation to incorporate the `string`
result of displaying the left and right subtrees.

[[The-format-contract]]
=== The `format` contract

format

contract

The standard contract `format`, shown in
Program~link:#formatContractProg[formatContractProg] is used when
displaying values in a formatted manner – especially within
link:#Interpolation[Interpolation] expressions.

....
public contract all t ~~ format[t] ::= {
  frmt:(t,string)=>ss.
}
....

The second argument to `frmt` is normally a formatting string that is in
a format (sic) that is understood by any specific implementers of the
`format` contract.

____
Normally, like `display`, calls to `frmt` are represented implicitly in
string link:#Interpolation[Interpolation] expressions.
____

[[Formatting-Codes]]
==== Formatting Codes

A formatting code is a description of how a numeric or `string` valued
expression should be displayed. Formatting codes allow more detailed
control of the representation of the format in terms of minimum and
maximum widths of output, the number of decimal places to show and the
style of representing numbers – including how negative numbers are
displayed and the display of currencies.

[NOTE]
====
In link:#stringInterpolation[stringInterpolation] expressions,
formatting codes are introduced with a `:` character immediately after
the `$` form and is terminated by a `;` character. An invalid formatting
code is ignored, and treated as though it were part of the quoted string
proper.
====[[The-reversible-Contract]]
=== The `reversible` Contract

The `reversible` contract defines a single function `reverse` that is
intended to mean reverse.

....
public contract all t ~~ reversible[t] ::= {
  reverse : (t)=>t
}
....

[[The-concat-Contract]]
=== The `concat` Contract

The `concat` contract defines a single function (`++`) that is intended
to mean ‘glue together’ – in a type specific way.

....
public contract all t ~~ concat[t] ::= {
  (++) : (t,t)=>t
}
....

[[The-_002b_002b-Contract-Function]]
==== The `++` Contract Function

++

contract function

The type signature for `++` is:

....
(++) : all t ~~ concat[t] |: (t,t) => t
....

The `++` function concatenates two sequences to form their conjunction.

[[The-slice-Contract]]
=== The `slice` Contract

....
public contract all s,k ~~ slice[s->>k] ::= {
  _slice : (s,k,k)=>s.
  _splice : (s,k,k,s)=>s.
}
....

[[The-_005fslice-Contract-Function]]
==== The `_slice` Contract Function

_slice

contract function

The type signature for `_slice` is:

....
_slice : all s,k ~~ _slice[s->>k] |: (s,k,k) => s
....

The `_slice` function extracts a subsequence from a source sequence. A
call of the form:

....
_slice(S,F,T)
....

extracts a subsequence of `S` starting from (and including) `F` and
ending with (but not including) `T`.

It is not required that `k` is actually `integer`; but it is often more
convenient.

The core property of `_slice` is that it should follow the equality:

....
_slice(S,zero,X)++_slice(S,X,end) == S
....

where zero is the index of the first entry in `S` and end is just beyond
the last entry in the collection.

[[The-_005fsplice-Contract-Function]]
==== The `_splice` Contract Function

_splice

contract function

The type signature for `_splice` is:

....
_splice : all s,k ~~ _slice[s->>k] |: (s,k,k,s) => s
....

The `_splice` function replaces a subsequence from a source sequence. A
call of the form:

....
_splice(S,F,T,N)
....

returns a new sequence consisting of `S` with the subsequence starting
from (and including) `F` and ending with (but not including) `T`
replaced by `N`.

Furthermore, for any valid `K`:

....
_splice(S,K,K,empty) == S
....

where empty is the empty sequence for the type `s`.

[[The-stream-Contract]]
=== The `stream` Contract

stream

contract

....
public contract all S,E ~~ stream[S->>E] ::= {
 _eof:(S) => boolean.
 _hdtl:(S) => option[(E,S)].
 _back:(S) => option[(S,E)].
}
....

[[_005feof-_002d_002d-End-of-Stream]]
==== `_eof` – End of Stream

This function should report `true` if its argument represents the empty
stream.

....
_eof : all s,e ~~ stream[s->>e] |: (s) => boolean.
....

[[_005fhdtl-_002d_002d-Head-of-Stream]]
==== `_hdtl` – Head of Stream

This function removes the head of the stream and returns a pair
consisting of that head and the remainder of the stream.

....
_hdtl : all s,e ~~ stream[s->>e] |: (s) => option[(e,s)].
....

[NOTE]
====
The return value of `_hdtl` is a `option` value – because it may be
applied to empty streams.
====[[_005fback-_002d_002d-Back-of-Stream]]
==== `_back` – Back of Stream

This function removes the last element of the stream and returns a pair
consisting of that element and the front of the stream.

....
_back : all s,e ~~ stream[s->>e] |: (s) => option[(s,e)].
....

[NOTE]
====
The return value of `_back` is a `option` value – because it may be
applied to empty streams.
====[[The-sequence-Contract]]
=== The `sequence` Contract

sequence

contract

A sequence expression represents a use of one of the two standard
contracts: Program~link:#streamContractProg[streamContractProg] and
Program~link:#sequenceContractProg[sequenceContractProg]. The former is
used when parsing a sequence and the latter is used when constructing a
sequence. More formally, the `stream` contract is used for
link:#SequencePattern[SequencePattern]s and the `sequence` contract is
used for link:#SequenceExpression[SequenceExpression]s.

....
public contract all S,E ~~ sequence[S->>E] ::= {
  _cons:(E,S) => S.
  _apnd:(S,E) => S.
  _nil:S.
}
....

[[_005fnil-_002d_002d-Empty-Sequence]]
==== `_nil` – Empty Sequence

This is a constant value that denotes the empty sequence.

....
_nil : all S,E ~~ sequence[S->>E] |: S
....

[[_005fcons-_002d_002d-Add-to-Front-of-Sequence]]
==== `_cons` – Add to Front of Sequence

....
_cons : all S,E ~~ sequence[S->>E] |: (E,S) => S
....

This function puts an element onto the front of the sequence; and
returns the resulting extended sequence.

[[_005fapnd-_002d_002d-Add-to-End-of-Sequence]]
==== `_apnd` – Add to End of Sequence

....
_apnd : all S,E ~~ sequence[S->>E] |: (S,E) => S
....

This function puts an element onto the end of the sequence; and returns
the resulting extended sequence.

[NOTE]
====
Not all implementations of the `sequence` contract will be neutral with
respect to the use of `_cons` and/or `_apnd`. It may be that one is more
expensive than the other – depending on the data types used to represent
the sequence.
====[[The-sizeable-Contract]]
=== The `sizeable` Contract

The `sizeable` contract defines two functions for measuring the size of
an entity.

The standard `sizeable` contract is defined for those collections that
have a concept of size associated with them.

....
contract all t ~~ sizeable[t] ::= {
  size : (t) => integer;
  isEmpty : (t) => boolean;
}
....

[[Size-of-a-sizeable-Entity]]
==== Size of a `sizeable` Entity

size

contract function

....
size : all t ~~ sizeable[t] |: (t)=>integer
....

The `size` function returns the number of elements of a `sizeable`
collection. The precise meaning of the `size` function is likely to be
type-specific; for example, for `string`s, the `size` of a `string` is
the number of characters in the string.

[[Is-a-sizeable-Entity-Empty]]
==== Is a `sizeable` Entity Empty

isEmpty

contract function

....
isEmpty : all t ~~ sizeable[t] |: (t)=>boolean
....

The `isEmpty` function returns `true` if the entity is empty.

[[The-indexed-Contract]]
=== The `indexed` Contract

The `indexed` contract provides functions that define what it means to
access and modify key-value collections.

....
public contract all m,k,v ~~ indexed[m ->> k,v] ::= {
  _index:(m,k) => option[v].
  _put:(m,k,v) => m.
  _remove:(m,k) => m.
  _empty:m.
}
....

[[The-_005findex-Access-Function]]
==== The `_index` Access Function

_index

contract function

The `_index` contract function specifies what it means to access a
key-value collection:

....
_index : all m,k,v ~~ indexed[m ->> k,v] |: (m,k) => option[v].
....

[NOTE]
====
The `_index` function returns an `option`al value since it is not
normally guaranteed that a particular key-value combination is present
in the collection.
====[[The-_005fput-Function]]
==== The `_put` Function

_put

contract function

The `_put` contract function specifies what it means to add a new
key-value pair to a collection (or to modify an existing association):

....
_put : all m,k,v ~~ indexed[m ->> k,v] |: (m,k,v) => m.
....

[NOTE]
====
The `_put` function returns a new collection with the modified
information in it. This supports but does not require that the
implementation of `indexed` is _applicative_ in nature.
====The standard implementations of `indexed` for the standard `map`
type is applicative.

[[The-_005fremove-Function]]
==== The `_remove` Function

_remove

contract function

The `_remove` contract function specifies what it means to remove a new
key-value pair from a collection.

....
_remove : all m,k,v ~~ indexed[m ->> k,v] |: (m,k) => m.
....

[NOTE]
====
Like the `_put` function, `_remove` returns a new collection with the
modified information in it.
====[[The-_005fempty-Value]]
==== The `_empty` Value

_empty

contract variable

The `_empty` value denotes an empty key-value collection of the
appropriate sort.

....
_empty : all m,k,v ~~ indexed[m ->> k,v] |: m.
....

[NOTE]
====
The `_empty` value is often used as the starting point for building up a
key-value collection.
====[[The-iter-Contract]]
=== The `iter` Contract

The `iter` contract is an abstraction that represents iteration over
collections.

....
public contract all s,t ~~ iter[s->>t] ::= {
  _iter:all x,e ~~ (s,x,(t,x)=>x) => x
}
....

[[The-_005fiter-Iteration-Function]]
==== The `_iter` Iteration Function

_iter

contract function

The `_iter` function specifies a key part of iteration over collections:
how individual elements of the collection should be handled.

[[The-indexed_005fiter-Contract]]
=== The `indexed_iter` Contract

The `indexed_iter` is analogous to the `_iter` contract, oriented to
iteration over key-value collections.

....
public contract all s,k,v ~~ indexed_iter[s->>k,v] ::= {
  _ix_iter:all x,e ~~ (s,x,(k,v,x)=>x) => x
}
....

[[The-_005fix_005fiter-Iteration-Function]]
==== The `_ix_iter` Iteration Function

_ix_iter

contract function

The `_ix_iter` function specifies a key part of iteration over key-value
collections: how individual elements of the collection should be
handled.

[[The-arith-Contract]]
=== The `arith` Contract

The `arith` contract encodes the basic – so-called calculator –
functions.

....
public contract all x ~~ arith[x] ::= {
  (+): (x,x)=>x.
  (-): (x,x)=>x.
  __minus: (x)=>x.
  zero: x.
  (*): (x,x)=>x.
  (/): (x,x)=>x.
  (%): (x,x)=>x.
  one:x.
}.
....

[[The-_002b-Function]]
==== The `+` Function

+

contract function

The `+` function defines the addition of two elements:

....
(+) : all t ~~ arith[t] |: (t,t) => t.
....

[NOTE]
====
The `(+)` function takes two arguments of the same type and returns a
value of the same type as its arguments.

In fact, it is _this_ specification that ensures that there is no
implicit coercion between different kinds of numeric value.
====[[The-_002d-Function]]
==== The `-` Function

-

contract function

The `-` function defines the subtraction of one element from another.

....
(-) : all t ~~ arith[t] |: (t,t) => t.
....

[NOTE]
====
The `(-)` is a binary function. A separate function – `_uminus` – is
used to denote unary negation.
====[[The-_005fuminus-Function]]
==== The `_uminus` Function

_uminus

contract function

The `_uminus` function defines the unary negation of a number.

....
_uminus : all t ~~ arith[t] |: (t) => t.
....

[NOTE]
====
The `_uminus` function is automatically substituted for occurrences of
unary minus in source programs. There is rarely a need to explicitly
refer to this function.
====[[The-zero-Value]]
==== The `zero` Value

zero

contract variable

The `zero` value denotes the 0 value of the arithmetic type.

....
zero : all t ~~ arith[t] |: t. 
....

[NOTE]
====
The `zero` value is particularly useful when defining arithmetic
functions that should be neutral with respect to the actual type of
numeric value. Literal decimal numbers have a fixed type – `integer`.
====[[The-_002a-Function]]
==== The `*` Function

*

contract function

The `*` function defines the multiplication of one element by another.

....
(*) : all t ~~ arith[t] |: (t,t) => t.
....

[[The-_002f-Function]]
==== The `/` Function

/

contract function

The `/` function defines the division of one element by another.

....
(/) : all t ~~ arith[t] |: (t,t) => t.
....

[[The-_0025-Function]]
==== The `%` Function

%

contract function

The `%` function defines the modulus of one element with respect to
another.

....
(%) : all t ~~ arith[t] |: (t,t) => t.
....

[[The-one-Value]]
==== The `one` Value

one

contract variable

The `one` value denotes the 1 value of the arithmetic type; i.e., the
_unit_ of multiplication.

....
one : all t ~~ arith[t] |: t. 
....

[NOTE]
====
Like the `zero`, the `one` value is particularly useful when defining
arithmetic functions that should be neutral with respect to the actual
type of numeric value.
====[[The-coercion-Contract]]
=== The `coercion` Contract

The `coercion` contract embodies what it means to convert a value of one
type to another.

....
public contract all s,d ~~ coercion[s,d] ::= {
  _coerce:(s)=>d
}.
....

[[The-_005fcoerce-Function]]
==== The `_coerce` Function

_coerce

contract function

The `_coerce` function defines a function that converts a value of one
type to another.

....
_coerce : all s,d ~~ coercion[s,d] |: (s) => d.
....

[NOTE]
====
This is the basis of all coercion; expressions of the form:

....
foo :: type
....

amount to calls to the appropriate implementation of the `_coerce`
function.
====[[Numbers]]
== Numbers

expressions,arithmetic

The basis of arithmetic expressions are several contracts: the `arith`
contract which provides definitions of the familiar _calculator_
functions of `+`, `-`, `*` and `/`.

In addition, there is an extended set of mathematical functions for
trigonometry, bit string manipulation and so on.

[[Numeric-Types]]
=== Numeric Types

There are three standard numeric types: `integer`, `bigint` and `float`.

[[Integer-Type]]
==== Integer Type

Integers are 62 bits in precision. However, there are also arbitrary
precision integers if needed.

[NOTE]
====
The restriction to 62 bits facilitates improved space representation in
the engine. If more precision is required, arbitrary precision
arithmetic is a good choice.
====[[Arbitrary-Precision-Integers]]
==== Arbitrary Precision Integers

As the name suggests, `bigint` numbers have no fixed precision. They can
be used to represent large values – up to the limits of available
memory.

[NOTE]
====
Operations on `bigint` numbers may be significantly more expensive than
operations on fixed size integers.
====In addition, the range of operators supported for `bigint` numbers
is smaller than that for `integer` values.

[[Float-Type]]
==== Float Type

Floating point numbers are the equivalent of IEEE 754 double values.

[[Implemented-Arithmetic-Contracts]]
=== Implemented Arithmetic Contracts

contract, implemented for

integer

and

float

[[Arithmetic-for-Integers]]
==== Arithmetic for Integers

The `arith` contract is implemented for `integer` values. See
link:#arithContractProg[arithContractProg].

[[Arithmetic-for-Floating-Points]]
==== Arithmetic for Floating Points

[[Display-for-integer]]
==== Display for `integer`

[[Format-for-integer]]
==== Format for `integer`

The format string for `integer` values determines how the number is
formatted. For example, the result of

....
"--$(-15):-   0;--"
....

is

....
"--  -15--"
....

The grammar for legal formatting codes for integral values may be given
in the regular expression:

....
[P+-]?([09 ,.])+[P+-]
....

I.e., a sign specification, followed by digit specifications optionally
mixed with thousands markers and periods, terminated by an optional sign
specification.

The complete list[formatting] codes for formatting numeric values is:

`9`::
  A digit is displayed if it is significant. I.e., if it is non-zero or
  there is a non-zero digit to the left of the digit.
`0`::
  A zero character is used for numeric values. It always results in a
  digit being displayed. For example, the value of
  +
....
"--$(5):00;--"
....
  +
  is the string
  +
....
"--05--"
....
`space`::
  A space character is similar to the `0` code; except that a leading
  space is displayed instead of a leading zero.
  +
  For example, the value of
  +
....
"--$(5): 0;--"
....
  +
  is the string
  +
....
"-- 5--"
....
  +
  [NOTE]
  ====
  Signs are treated specially with the space code: any produced sign
  character is migrated past leading spaces – with the result that the
  sign character is always abutted to the digits. For example, the
  result of

....
"--$(-15):-   0;--"
....

  is

....
"--  -15--"
....

  The space code is especially useful for lining up columns of figures
  where a leading space is preferred over leading zeroes.
  ====
`.`::
  A period is displayed if there is a digit to the left.
  +
  This is used for showing currency values – when they are represented
  internally as pennies but should be displayed as dollar values – and
  for floating point numbers.
`,`::
  A comma is displayed if there is a digit to the left.
  +
  This is used for displaying values in the _thousands_ notation. For
  example, the value of
  +
....
"--$(120345567):999,999,999,999;--"
....
  +
  is the string:
  +
....
"--120,345,567--"
....
`-`::
  Is used to control how signed values are presented. If the value is
  negative then a `-` character is displayed; if the value is positive
  then a space is displayed.
  +
  [NOTE]
  ====
  The `-` format code may appear at either end of the display. A leading
  `-` results in the sign being displayed at the beginning – before any
  digits – and a trailing `-` results in the sign appended to the end.
  ====
  +
  [WARNING]
  ====
  If no _sign_ code is present in the format specification then nothing
  is displayed if the value is positive or negative.
  ====
`+`::
  Always results in a sign being displayed. If the value is negative
  then a `-` character is displayed; otherwise a `+` character is
  displayed.
  +
  Like the `-` code, the `+` may appear at either end of the display
  format.
`P`::
  The `P` code uses parentheses on either end of the value to indicate a
  negative value. If the value is positive then spaces are appended to
  either end; otherwise the number is enclosed in `()`s.
  +
  [NOTE]
  ====
  The `P` code should be placed at _both_ ends of the format
  specification. For example, the expression:

....
"Balance: $(Amnt):P999900.00P; remaining"
....

  where `Amnt` had value -563 would result in

....
"Balance: (05.63) remaining"
....
  ====
`X`::
  Causes the integer to be formatted as a hexadecimal number; and a
  hexadecimal digit is displayed if it is significant. I.e., if it is
  non-zero or there is a non-zero digit to the left of the digit.
  +
  For example, this can be used to display the Unicode equivalent of a
  character:
  +
....
"Unicode: $(C)/$(C::integer):XXXXX;"
....

[[Display-for-float]]
==== Display for `float`

[[Format-for-float]]
==== Format for `float`

The grammar for legal formatting codes for `float` values is a little
more complex:

....
[P+-]?[09 ,.]+([eE][+-]?[09 ]+)?[P+-]?
....

I.e., the format string for `float` values permits the exponent to be
printed as well as the mantissa. If the exponent part is missing and if
the `float` value cannot be represented in the available precision
without an exponent then an exception will be `raised`.

[[Arithmetic-Functions]]
=== Arithmetic Functions

[[abs-_002d_002d-absolute-value]]
==== `abs` – absolute value

abs

function.

....
abs : all t ~~ arith[t],comp[t] |: (t)=>t.
....

The `abs` function returns the absolute value of its argument. It
depends on both teh `arith` and the `comp` contracts, hence is
implemented for both `integer` and `float` values.

[[Bit-Manipulation-Functions]]
=== Bit Manipulation Functions

The bit manipulation functions treat `integer` values as 62-bit bit
strings.

[[_002e_0026_002e-Bit_002dwise-Conjunction]]
==== `.&.` Bit-wise Conjunction

.&.

function

....
(.&.) : (integer,integer)=>integer.
....

The `.&.` operator returns the bit-wise conjunction of two `integer`
values.

[[_002e_007c_002e-Bit_002dwise-Disjunction]]
==== `.|.` Bit-wise Disjunction

.|.

function

....
(.|.)  : (integer,integer)=>integer.
....

The `.|.` operator returns the bit-wise disjunction of two `integer`
values.

[[_002e_005e_002e-Bit_002dwise-Exclusive_002dor]]
==== `.^.` Bit-wise Exclusive-or

.^.

function

....
(.^.)  : (integer,integer)=>integer.
....

The `.^.` operator returns the bit-wise exclusive of two `integer`
values.

[[_002e_003c_003c_002e-Bit_002dwise-Left-Shift]]
==== `.<<.` Bit-wise Left Shift

.<<<.

function

....
(.<<.) : (integer,integer)=>integer.
....

The `.<<.` operator left-shifts the left hand argument by the number of
bits indicated in the right argument. It is effectively multiplication
by a power of 2.

[[_002e_003e_003e_002e-Bit_002dwise-Arithmetic-Right-Shift]]
==== `.>>.` Bit-wise Arithmetic Right Shift

.>>.

function

....
(.>>.) : (integer,integer)=>integer.
....

The `.>>.` operator right-shifts the left hand argument by the number of
bits indicated in the right argument. The most significant bit is
replicated in the shift. It is effectively division by a power of 2.

[[_002e_003e_003e_003e_002e-Bit_002dwise-Logical-Right-Shift]]
==== `.>>>.` Bit-wise Logical Right Shift

.>>>.

function

....
(.>>>.) : (integer,integer)=>integer.
....

The `.>>>.` operator right-shifts the left hand argument by the number
of bits indicated in the right argument. The most significant bits of
the result are replaced by zero. This operator is sometimes known as
logical right shift.

[[_002e_007e_002e-Bit_002dwise-Logical-Complement]]
==== `.~.` Bit-wise Logical Complement

.~.

function

{empty}[[bitComplement]]

....
(.~.) : (integer)=>integer.
....

The `.~.` operator forms the logical or 1s complement of its argument.

[[_002e_0023_002e-Bit-Count]]
==== `.#.` Bit Count

.#.

function

....
(.#.) : (integer)=>integer.
....

The `.#.` operator computes the number of non-zero bits in its argument.

[[Trigonometry-Functions]]
=== Trigonometry Functions

____
All the trig functions assume that the angles that they accept (or
return) are expressed in radians.
____

[[sin-_002d_002d-Sine-Function]]
==== `sin` – Sine Function

....
sin : (float) => float.
....

The `sin` function returns the Sine of its argument – expressed in
radians.

[[asin-_002d_002d-Arc-Sine-Function]]
==== `asin` – Arc Sine Function

....
asin : (float) => float.
....

The `asin` function returns the Arc Sine of its argument – expressed in
radians.

[[cos-_002d_002d-Cosine-Function]]
==== `cos` – Cosine Function

....
cos : (float) => float.
....

The `cos` function returns the cosine of its argument – expressed in
radians.

[[acos-_002d_002d-Arc-Cosine-Function]]
==== `acos` – Arc Cosine Function

....
acos : (float) => float.
....

The `acos` function returns the arc cosine of its argument – expressed
in radians.

[[tan-_002d_002d-Tangent-Function]]
==== `tan` – Tangent Function

....
tan : (float) => float.
....

The `tan` function returns the tangent of its argument – expressed in
radians.

[[atan-_002d_002d-Arc-Tangent-Function]]
==== `atan` – Arc Tangent Function

....
atan : (float) => float.
....

The `atan` function returns the Arc Tangent of its argument – expressed
in radians.

[[min-_002d_002d-minimum-value]]
==== `min` – minimum value

min

function

....
min: all t ~~ comp[t] |: (t,t)=>t.
....

The `min` function returns the smaller of its two arguments. It is
defined on top of the `comp` contract.

[[max-_002d_002d-maximum-value]]
==== `max` – maximum value

....
max: all t ~~ comp[t] |: (t,t)=>t.
....

The `max` function returns the larger of its two arguments.

[[sqrt-_002d_002d-square-root]]
==== `sqrt` – square root

....
sqrt : (float)=>float
....

The `sqrt` function returns the square root of its argument. If the
argument is negative, the returned value is undefined.

[[ceil-_002d_002d-ceiling]]
==== `ceil` – ceiling

....
ceil : (float)=>float
....

The `ceil` function returns the nearest integral value that is equal to
or larger than X.

[NOTE]
====
For integral types,

....
ceil(X)=X
....
====[[floor-_002d_002d-floor]]
==== `floor` – floor

....
floor : (float)=>float
....

The `floor` function returns the nearest integral value that is equal to
or smaller than X.

[NOTE]
====
For integral types,

....
floor(X)=X
....
====[[trunc-_002d_002d-round-to-closest-integral]]
==== `trunc` – round to closest integral

....
trunc : (float)=>float
....

The `trunc` function returns the nearest integral value to its argument.

[[log-_002d_002d-Natural-Logarithm]]
==== `log` – Natural Logarithm

....
log : (float)=>float
....

The `log` function returns the natural logarithm of its argument.

[[log10-_002d_002d-Logarithm-Base-10]]
==== `log10` – Logarithm Base 10

....
log10 : (float)=>float
....

The `log10` function returns the base 10 logarithm of its argument.

[[exp-_002d_002d-Natural-Exponentiation]]
==== `exp` – Natural Exponentiation

....
exp has type for all t such that (t)=>t where math over t
....

The `exp` function returns the value $e^X$.

[[random-_002d_002d-random-number-generation]]
==== `random` – random number generation

random number generation

....
random : (float)=>float
....

The `random` function returns a number in the half-open range [0,X)
where X is the argument of the function.

____
The argument of the `random` function must be a positive number.
However, it can be any _normal_ kind of arithmetic value.
____

The number generated is the next in a sequence of numbers that is
typically pseudo-random: i.e., not actually random but statistically
indistinguishable from random.

[[_002a_002a-_002d_002d-exponentiation]]
==== `**` – exponentiation

....
(**) : (float,float) => float
....

The `**` function raises the first argument to the power of the second.

For example, the expression

....
X**3.0
....

denotes the cube of `X`.

[[Strings]]
== Strings

strings

A string is a sequence of Unicode characters that denotes a fragment of
text. This chapter focuses on the built-in functions that are based on
the `string` type.

[[The-Character-Type]]
=== The Character Type

type,char

The `char` type is the standard type that is used to denote character
literals.

[[The-String-Type]]
=== The String Type

The `string` type is the standard type that is used to denote string
literals. A string literal is defined to be a sequence of characters.

____
For most applications, the relationship between character literals and
string literals remains implicit. Most applications manipulate strings
by concatenating them or by splitting them. One common way is to use
string interpolation expressions.

However, there are coercions available between string values and lists
of characters.
____

[[Implemented-Contracts]]
=== Implemented Contracts

contract, implemented for string

string contracts

[[Sizeable-for-String]]
==== Sizeable for String

See link:#sizeableContractProg[sizeableContractProg] for a specification
of the `sizeable` contract.

The `isEmpty` function returns true if its argument is the empty string.
It’s definition is equivalent to:

....
isEmpty(X) => X=="";
....

The `size` function returns the number of Unicode characters in the
`string`.

[NOTE]
====
this is not generally the same as the number of bytes in the string.
====[[Display-for-String]]
==== Display for String

[[Format-for-String]]
==== Format for String

The format specification for `string` values is given in the regular
expression:

....
[LCR][0-9]+
....

where each control code is defined:

`L`::
  The value is shown left-aligned in the text.
  +
  The decimal value immediately after the `L` character is the size of
  the field.
  +
  If the displayed length of the number or string is less than that
  permitted; then the value is shown left-aligned. If the length of the
  value is greater than the size of the field then the text is truncated
  – i.e., the first N characters of the value are used.
`R`::
  The value is shown right-aligned in the text – if the length of the
  value is less than the size of the field.
  +
  If the length of the value is greater than the size of the field then
  the text is truncated.
`C`::
  The value is shown centered in the field.

[[Equality-for-String]]
==== Equality for String

[[Comp-for-String]]
==== Comp for string

String comparison is based on a lexicographic comparison: one `string`
is less than another if its first character is less than the first
character of the second – irrespective of the actual lengths of the
strings. Thus

....
Abbbbbbb < B
....

because `A` is less than `B`. Characters are compared based on their
_code point_ within the Unicode encoding.

[[Concat-for-String]]
==== Concat for String

The implementation of `++` for strings is realized as string
concatenation.

[[Reversible-for-String]]
==== Reversible for String

The `reverse` function – which is part of the `reversible` contract – is
implemented in terms of the code points in the string.

[[Index-for-String]]
==== Index for String

The `_index` function returns a CodePoint from a `string` value at a
particular position.

One can use the the normal indexing notation to access CodePoints from a
`string` – as with other kinds of indexable types:

....
S[ix]
....

instead of

....
_index(S,ix)
....

[[Slice-for-String]]
==== Slice for String

The `_slice` function extracts a substring from its first argument. The
first character of the extracted substring is identified by the second
argument; and the end point of the substring is identified by the third
argument. An expression of the form:

....
_slice("this is a string",5,7)
....

returns the substring `"is"` – corresponding to the two characters
located at positions 5 and 6 in the source string.

There is a special notation for this functionality: the slice notation
(see link:#sliceFunction[sliceFunction]. For example, if the variable
`S` is bound to the string `"this is a string"`, then the above
expression may be written:

....
S[5:7]
....

[[Splice-for-String]]
==== Splice for String

the `_splice` function replaces a substring within its first argument.
For example, the expression:

....
_splice("this is a string",5,7,"was")
....

has, as its value:

....
"this was a string"
....

Like the slice notation, there is special syntax for this function –
when used as an action. The action:

....
S[ix:tx] := U
....

is equivalent to the assignment:

....
S := _splice(S!,ix,cx,U)
....

[[Standard-String-Functions]]
=== Standard String Functions

In addition to certain specific string functions – such as string
concatenation – the `string` type implements the `comp`arable contract
which enables string values to be compared. The `indexable` contract –
see Program~link:#indexedContract[indexedContract] – is also implemented
for strings, which means that the normal `[]` notation may be used to
access the characters of a string.

[[findstring-_002d_002d-string-search]]
==== `findstring` – string search

[[findStringFunction]] `findstring` is used to determine the (next)
location of a search token within a `string`.

....
findstring : (string,string,integer)=>integer;
....

string,search within

finding substrings

The `findstring` function searches a string for an occurrence of another
string. The first argument is the string to search, the second is the
search token, and the third is the integer offset where to start the
search.

For example, the result of the expression:

....
findstring("the lazy dog jumped over the quick brown fox","the",5)
....

is `25`.

If the search token is not present then `findstring` returns -1;

[[gensym-_002d_002d-Generate-Unique-String]]
==== `gensym` – Generate Unique String

gensym

function

....
gensym : (string)=>string
....

The `gensym` function is used to generate unique strings that have an
arbitrarily high probability of being unique.

The generated string has a prefix consisting of the single argument, a
middle which is a unique string generated based on a globally unique
identifier identifying the current process and a counter.

The result is a string that has a high probability of being unique. It
is guaranteed to be unique within the current processor.

[[spaces-_002d_002d-Generate-a-string-of-spaces]]
==== `spaces` – Generate a string of spaces

spaces

standard function

....
spaces : (integer)=>string
....

The `spaces` function generates a `string` containing only the space
character. For example, the value of

....
spaces(3)
....

is the string

....
"   "
....

[[Collections]]
== Collections

This chapter defines the standard collection types. Note that all the
functions that are implemented over collection types are exposed via
contract implementations.

[[Collection-Types]]
=== Collection Types

There are four basic collection types supported: `cons` lists, an
array-like `list` type, `map` type and the `set` type.

[[The-Cons-List]]
==== The Cons List

cons list

The `cons` type is defined as though by the type definition:

....
all e ~~ cons[e] ::= .nil | .cons(e,cons[e]).
....

[[The-Map-Type]]
==== The Map Type

The `map` type denotes a set of key/value pairs. Its type is only
partially exposed:

....
all k,v ~~ equality[k], hash[k] |: map[k,v] <~ {}
....

All uses of the `map` type require that the key type supports both
`equality` and `hash`.footnote:[This is because the underlying
implementation requires it.]

[NOTE]
====
The underlying implementation of `map` is based on ’Ideal Hash Trees’;
which offer effectively constant time performance for accessing and
modifying the `map`.
====[[The-Set-Type]]
==== The Set Type

The `set` type supports set membership style functions. Its type is
partially exposed:

....
all e ~~ equality[e], hash[e] |: set[e] <~ {}
....

Like the `map` type, using the `set` requires that element type supports
`equality` and `hash`.

[[Implemented-Collection-Contracts]]
=== Implemented Collection Contracts

For the vast majority of cases, the built-in functions that are
implemented for collections are mediated through contracts.

[[Equality-Contract-For-Collections]]
==== Equality Contract For Collections

The `equality` contract (link:#equalityContract[equalityContract]) is
defined for all the collection types; usually with requirement that the
element types also implement `equality`.

[[Source-Catalogs]]
== Source Catalogs

Star source code is managed by means of _catalogs_. A catalog is a
document that gives the mapping from a package name to the file that
contains the source of that package.

[NOTE]
====
This separation is intended to avoid questions such as file name
extensions, directory structures and so on. A catalog is able to collect
together all the sources that are relevant to a project while not
requiring that they all be physically co-located.

Indeed, it would be fairly straightforward to extend the catalog system
to allow compilation of non file-based source units.
====[[Catalogs-and-Sources]]
=== Catalogs and Sources

When a package imports another package the source merely contains a
statement that indicated which package is required:

....
import star.json.
....

In order to determine what actual package this refers to there are two
systems that play a role: the _catalog_ system and the _repository_
system. The former identifies where the source is – by URI – and the
latter identifies where the compiled code can be found. The compiler
potentially needs both in order to properly import the package.

The primary purpose of the catalog is to map package identifiers to
package URIs; which in turn identifies the actual resource.

[[Catalogs]]
==== Catalogs

A catalog is a mapping from logical names to URIs. The *Star* language
system uses this mapping to locate source files and compiled code when
the corresponding resource is `import`ed by name.

Catalogs offer an additional level of indirection between a name and the
named entity. This indirection can be used, for example, to implement
versioned access to resources. In addition, catalogs serve the role of
pulling together the resources that a program or application needs into
a coherent set.

[[Structure-of-a-Catalog]]
==== Structure of a Catalog

Catalogs are contained in json filesfootnote:[Subject to change]. The
general structure of a catalog json file looks like:

....
{
  "content" : {
    PkgName : FileName,
    …
    PkgName : FileName
  },
  "version" : Semantic Version String,
  "subcatalogs" : [CatalogPath, … CatalogPath]
}
....

where _PkgName_ is a valid Star package name – written as a string
because it’s JSON.

__FileName__s and __CatalogPath__s are relative file names – or URLs.

Catalogs may actually be in any of a number of formats – depending on
whether there is a way of coercing the format to the standard catalog
type – as shown in link:#catalogType[catalogType].

....
public catalog ::= catalog{
  base : uri.
  parent:option[catalog].
  version : option[version].
  subcats : option[cons[catalog]].
  content : map[string,uri].
}
....

The elements of the `catalog` link:#RecordConstructor[RecordConstructor]
are:

* `base` This is the base uri of the catalog: if not overridden, all
URIs referenced in the catalog should be interpreted as being _relative_
to the base URI.
* `version` This is the default version of all the entries in the
catalog.
* `content` This is a mapping from package names to URIs. Each entry
shows how to obtain the source of a given package.
* `subcatalogs` If specified, the list of catalogs in `subcatalogs` form
additional places to locate the source of a package. If a package could
not be located within this catalog, the compiler will search in the list
of subcatalogs, in order.

For example, a fragment of the catalog for the standard core library is:

....
{
  "content": {
    "star": "star.star",
    "star.arith": "arith.star",
    "star.action": "action.star",
    "star.boot": "boot.star",
    "star.cmdOpts": "cmdOpts.star",
    …
  },
  "version": "1.0.0",
}
....

[[Accessing-Packages-Using-Catalogs]]
==== Accessing Packages Using Catalogs

accessing packages with catalogs

catalog,accessing packages with

The purpose of the catalog is to resolve package names to URIs. The
process for doing this can be summarized as:

[arabic]
. If the package is identified by name, the URI of the package is looked
up within the _current_ catalog.
[arabic]
.. If the name is not present in the catalog, the parent catalog is
searched if available. The location of the parent catalog is identified
by name in the current catalog.
.. If the name is not present, and there is no fall-back, exit with an
error.
. The located URI is resolved against the base URI of the current
catalog. This allows catalogs themselves to contain relative URIs where
possible. This is the so-called target URI.
. The target URI is dereferenced – using a transducer – and accessed. If
the resource does not exist, or is not valid, exit with an error.
. The catalog uri:
+
....
"../catalog"
....
+
is resolved against the URI of the package containing the reference.
[arabic]
.. If a catalog exists in this location then that catalog is used to
resolve references within the target resource.
.. If there is no catalog, then a catalog _may_ be synthesized by
_exploring_ the space around the target URI.

[[Multiple-Versions-of-a-Package]]
==== Multiple Versions of a Package

A source and/or code repository may contain multiple versions of a
package. However, only one version of a given package may be imported by
a given package.

As a result, it is sufficient for the catalog to refer to a
version-specific URI for each package in its catalog.

However specified, the versions that a package is compiled against are
fixed during the compilation of the package. I.e., when a package is
compiled, it is compiled against specific versions of imported packages.
When the package is later executed, the specific versions that were
accessed at compile time are also used at run-time.

[NOTE]
====
Source catalogs and code repositories are responses to two related but
distinct problems: how to organize and access sources of programs and
how to organize access to executable code.

[Index]
== Concept index


[[List-of-Syntax-Rules]]
== List of Syntax Rules

[[List-of-Programs]]
== List of Programs
