@node Tasks
@chapter Tasks

A task is a computation whose execution can be managed. Tasks can be
created, suspended and resumed. Tasks also have identity which allows
correlation of tasks when managing sets of tasks.


@itemize @bullet
@item
A @code{task} expression denotes a computation that can be scheduled
independently of other actions.

This is analogous to coroutining in other programming languages.
@item
A @code{generator} expression is used to define so-called yield-style generators.
@end itemize

@node Task Type
@section Task Type
@cindex type, task
@cindex task type

The @code{task} type is used to characterize the type of task expressions. It takes the form:
@float BNF,taskTypeFig
@caption{Task Type Syntax}
@display
@refer{Type}::+=@refer{TaskType}

@anchored{TaskType} ::= @code{task} @code{[} @refer{Type} @code{,} @refer{Type} @code{]}
@end display
@end float

The second type argument refers to values that the task may suspend
with (see @refer{SuspendAction} and @refer{RetireAction}) and the
first type argument refers to values that the task may be resumed
with (see @refer{ResumeAction}).

@node Task Expression
@section Task Expression

A @code{task} expression evaluates to a new task. It contains a set of
actions to perform as the task.

@float BNF,taskFig
@caption{Task Expression Syntax}
@display
@refer{Expression}::+=@refer{TaskExpression}

@anchored{TaskExpression} ::= @code{task} @refer{BlockAction}
  | @code{task} @refer{Expression}
@end display
@end float

For example, in the @code{task} expression:
@example
task@{
  let@{
    yildFn:((),e)=>().
    yildFn(_,E) => valof@{
      suspend yild(E) in @{
       .next => valis ().
      @}
    @}
  @} in @{_iter(L,(),yildFn)@};
  retire .end
@}
@end example
we use a @refer{LetAction} to introduce a local function definition --
@code{yildFn} -- and pass it to the standard contract method --
@code{_iter} -- (which is defined in the @code{iter} contract).

In addition to the actions, there are two special variables defined
within the body of the @code{task} expression: @code{this} and
@code{first}:

@table @code
@item this
The @code{this} keyword is bound to the currently executing
@code{task} (and has the same type). This is one of the primary ways in which a @code{task} is given its own identity.
@item first
The @code{first} keyword is bound to the initial event that is passed
to the @code{task} when it is first resumed.

@quotation Note
When @code{task}s are created, they are in suspended state: i.e., the
code within the @code{task} expression is not executed
immediately. The @code{task} starts executing only when it is resumed
-- using the @refer{ResumeAction}
@end quotation
@end table


@node Task Actions
@section Task Actions

The primary actions associated with tasks are suspend, resume and retire.

@float BNF,taskActionFig
@caption{Task Action Syntax}
@display
@refer{Action}::+=@refer{TaskAction}

@anchored{TaskAction}::= @refer{SuspendAction}
  | @refer{ResumeAction}
  | @refer{RetireAction}
@c  | @refer{YieldAction}
@end display
@end float

@node Suspend Action
@subsection Suspend Action

The @refer{SuspendAction} is used when a task wishes to suspend
itself. There are three arguments to the @refer{SuspendAction}: the
identity of the task to be suspended, a value that determines the
@emph{suspension event} and a @refer{CaseActionHandler} to respond to
the incoming event when the task is resumed again:

@float BNF,suspendActionFig
@caption{Suspend Action Syntax}
@display
@anchored{SuspendAction}::=
    @refer{Expression} @code{suspend} @refer{Expression} @code{in} @refer{CaseActionHandler}
  | @code{suspend} @refer{Expression} @code{in} @refer{CaseActionHandler}
@end display
@end float

The types of the task, the event and the action case must match up; i.e., given
@example
@var{T} suspend @var{E} in @{@var{P@sub{1}} => @var{A@sub{1}}. .. @var{P@sub{n}} => @var{A@sub{n}}@}
@end example
then @code{@var{T}} must be of type
@example
task[@var{R},@var{S}]
@end example
for some @code{@var{S}} and @code{@var{R}}; the type of @code{@var{E}}:
@example
@code{@var{E}} : @code{@var{S}}
@end example
and the left hand sides of the response case -- @code{@var{P@sub{i}}} -- must have type @code{@var{R}}.

In effect, the task type determines the legal events that the task may
be suspended with (and the legal events that the task may be resumed
with).

@quotation Note
When used directly within the text of a @code{task} expression, there
is a slightly shorter form of @code{suspend}:
@example
suspend @var{E} in @{@var{P@sub{1}} => @var{A@sub{1}}. .. @var{P@sub{n}} => @var{A@sub{n}}@}
@end example
This may be used when a task is directly suspending itself within the
@code{task} expression. This action is equivalent to:
@example
@code{this} @code{suspend} @var{E} @code{in} @{@var{P@sub{1}} => @var{A@sub{1}}. .. @var{P@sub{n}} => @var{A@sub{n}}@}
@end example

The @code{this} keyword is established within the scope of a
@code{task} expression; it allows tasks to discover their own
identity.
@end quotation

@node Resume Action
@subsection Resume Action

The @refer{ResumeAction} is used when a task wishes to resume another task.
There are three arguments to the @refer{ResumeAction}: the
identity of the task to be resumed, a value that determines the
@emph{resumption event} and a @refer{CaseActionHandler} to respond to
the incoming event when the resumed task is suspended again:

@float BNF,resumeActionFig
@caption{Resume Action Syntax}
@display
@anchored{ResumeAction}::=
  @refer{Expression} @code{resume} @refer{Expression} @code{in} @refer{CaseActionHandler}
@end display
@end float

As with the @code{SuspendAction}, the types of the task, the event and
the action case must match up; i.e., given
@example
@var{T} @code{resume} @var{E} @code{in} @{@var{P@sub{1}} => @var{A@sub{1}}. .. @var{P@sub{n}} => @var{A@sub{n}}@}
@end example
then @code{@var{T}} must be of type
@example
task[@var{R},@var{S}]
@end example
for some @code{@var{R}} and @code{@var{S}}; the type of @code{@var{E}}:
@example
@code{@var{E}} : @code{@var{R}}
@end example
and the left hand sides of the response case -- @code{@var{P@sub{i}}}
-- must have type @code{@var{S}} -- which will be used to match
against the suspension event.

The @refer{SuspendAction} and @refer{ResumeAction} are quite symmetric.

@node Retire Action
@subsection Retire Action

The @refer{RetireAction} is used when a task wishes to retire and no
longer continue execution. This is the primary means by which a task
designates that it is completed. Whether the task is successful or not
is determined by the value of the event it signals.

@float BNF,retireActionFig
@caption{Retire Action Syntax}
@display
@anchored{RetireAction}::=
  @refer{Expression} @code{retire} @refer{Expression}
  | @code{retire} @refer{Expression}
@end display
@end float

Note that there is no @refer{CaseActionHandler} specified with this
action; this is because a task that performs the retire action will
not be resumed: it is ended.

The types of the task and the event must match up; i.e., given
@example
@var{T} retire @var{E}
@end example
then @code{@var{T}} must be of type
@example
task[@var{R},@var{S}]
@end example
for some @code{@var{S}} and @code{@var{R}}; the type of @code{@var{E}}:
@example
@code{@var{E}} : @code{@var{S}}
@end example

In the case where the @refer{RetireAction} is being performed withing
the lexical scope of the @code{task} expression, the shorter form --
which omits the identifier for the task being retired -- may be
used. As with the @refer{SuspendAction} this is equivalent to using
the @code{this} keyword to identify the retiring task.

