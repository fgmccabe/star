@node Types
@chapter Types
@cindex type system

@Star{} is a strongly, statically, typed language. That means that all
values and all variables must have a unique well-defined type that is
determinable by inspecting the text of the program -- effectively at
@emph{compile time}.

The type system of @Star{} consists of a method for declaring new
types, for annotating variables (and by extension programs) with their
types and a system of verifying the type consistency of programs.

This chapter focuses on the type language itself and the semantics of
types.

@node What is a Type?
@section What is a Type?

@quotation
A Type is an expression that denotes a set of values.
@end quotation

@quotation TIP
Although a type is an expression, type expressions should not be
confused with normal expressions. Types generally play no part in
evaluation.
@end quotation

Viewed as sets, types have some particular properties: no value may be
a member of more than one type set; all values are members of exactly
one type set.

A @var{TypeDefinition} introduces a new type and defines what values
belong to the type. A @var{TypeAnnotation} is an assertion that a
particular expression -- usually a variable -- has a certain type.

For many simple cases, a type is denoted by an identifier. For
example, the type identifier @code{string} denotes the set of all
strings. More explicitly, a value has type @code{string}
iff@footnote{The term "iff" means "if and only if".} it belongs to the
set denoted by the symbol @code{string}.

Many value-sets are effectively infinite in size: the size of the set
of @code{}string@code{}s is essentially unbounded; as is the set of
@code{integer} values.

In addition to sets of values denoted by identifiers; there are other
kinds of value sets that have more complex type expressions. For
example, the set of @emph{function values} is denoted not by a single type
expression but a @emph{schema} of type expressions -- each taking a form
such as:

@example
(t@sub{1},@dots{},t@sub{n})=>t
@end example

For example, the type expression
@example
(integer)=>string
@end example

denotes the set of functions that take an @code{integer} as an
argument and produce a @code{string} value. Like the set of all
integers, this set is also infinite in size.

The language for denoting types is quite expressive. It is possible to
have types that are parameterized; that is they are composed from
other type expressions. It is also possible to have types that are not
explicitly named but are defined by constraints.

A simple example of a parameterized type is the @code{cons} type: a
@code{cons} type expression always involves the mention of another
type -- the type of elements of the list. The type expression
@example
cons[string]
@end example

denotes the type expression associated with lists whose elements are
all string values. Other examples of @code{cons} type include lists of
integers:
@example
cons[integer]
@end example

and even lists of lists of string valued functions:
@example
cons[cons[(integer)=>string]]
@end example

@quotation NOTE
Technically, the @code{cons} symbol in:
@example
cons[integer]
@end example
@cindex type function
is a @var{Type Constructor}: it takes a type as an argument and
returns another type as result.
@end quotation

Often it is convenient to be able to @emph{talk} about types without
being specific about the type itself; for this purpose we use
@var{TypeVariable}s.

A type variable a type identifier that is distinguished by being
introduced using an explicit quantifier -- either a
@ref{universalType} or a @ref{existentialType} . The type expression:
@example
all t ~~ cons[t]
@end example

denotes a list type of some unspecified element type -- identified by
the type variable @code{t}.

@quotation TIP
The value set associated with this type expression is a little more
difficult to visualize than the set of lists of integers
(say). @code{cons[t]} denotes a set of cons values; but without more
information @emph{we cannot say} what the complete values look like --
it is dependent on the meaning of the type variable @code{t}.
@end quotation

In order to properly understand the interpretation of a type variable
one must understand how the type variable is @emph{bound}. In general,
there are three possibilities: the type variable may be identified
with (equal to) another type; the type variable may be bound by a
universal quantifier or by an existential quantifier.

A universally quantified type (see @ref{universalType}) denotes a type
that allows all possible instantiations for the type variable. For
example, function types often involve universal types. A universally
typed function is expected to work @emph{for all values} of the type
variable -- which, in turn, means that the function definition can
make no assumptions about the actual type.

Existentially quantified types (see @ref{existentialType}) are used to
denote @emph{abstract types}; i.e., the existential quantifier signals
that there is a type that should be treated as an opaque @emph{black
box}.


@node Type Annotations
@subsection Type Annotations
@cindex type annotation
In most cases it is not necessary to explicitly declare the type of a
variable -- or any expression. However, it is good practice to declare
explicitly the types of programs; especially within
@var{thetaEnvironment}s, and it is required if the type of the
variable is intended to be generic.

For example, a generic function @code{consLength} that takes a
@code{cons} list and returns an integer would have the declaration:
@example
consLength:all t ~~ (cons[t])=>integer
@end example

@node Types of Types
@subsection Types of Types
@cindex type expressions
@cindex forms of types

@ref{typeFig} illustrates the top-levels of the different kinds of
type expressions that the @Star{} programmer will encounter.

There are two main kinds of type expressions -- so-called
@emph{structural} type expressions and @emph{named} type expression. A
structural type expression encodes by convention the permitted
@emph{forms} of values of that type. By contrast, a named type
expression is defined via some form of @var{TypeDefinition}.

A classic example of a structural type expression is the function
type. A function type expression defines both the types of the
arguments and result type of the function. But, more importantly, it
signals that the value is a function.

@float BNF,typeFig
@caption{Types of Types}
@display
@anchored{Type}::=@var{TypeExpression}
  | @var{TypeVariable}
  | @var{TupleType}
  | @var{RecordType}
  | @var{FunctionType} | @var{ConstructorType}
  | @var{TypeQuantifier} @code{~~} @var{Type}
  | @var{TypeConstraint} @code{|:} @var{Type}
  | @code{(} @var{Type} @code{)}
  | @var{EncapsulatedType}

@anchored{TypeQuantifier} ::= @var{UniversalQuantifier} | @var{ExistentialQuantifier}
@end display
@end float

@node Nominal Types
@section Nominal Types
@cindex nomical types
@cindex types,nominal

A @var{NamedType} is a term that identifies a class of values by
name. The name may or may not have @ref{TypeArgument}s -- in which
case, the type is said to be @emph{parameterized}.

A good example of a named type (or, more formally, nominal type) is
the standard @code{integer} type. The word @code{integer} does not
signal by itself that the allowable operations on integer values
include arithmetic, comparison and so on. That information must come
from additional statements and declarations.

One of the other differences between structural and named type
expressions is that the latter may be used to denote @emph{recursive}
types, whereas the former cannot.

@quotation TIP
A recursive type is one whose values may contain elements that are
themselves of the same type. For example, in a @code{tree} type: the
nodes of the tree are typically themselves trees.
@end quotation

@float BNF,typeExpressionFig
@caption{Type Expressions}
@display
@anchored{NominalType} ::= @var{SimpleType} | @var{ParameterizedType}

@anchored{SimpleType} ::= @var{TypeConstructor}

@anchored{ParameterizedType} ::= @var{TypeConstructor} @code{[}@var{TypeArgument}@code{]}

@anchored{TypeConstructor} ::= @var{Identifier}

@anchored{TypeArgument} ::= @var{Type} | @var{Type} ,@dots{}, @var{Type}

@end display
@end float

@node Simple Types
@subsection Simple Types
@cindex simple type

A simple type is a @ref{NominalType} with no type arguments. Some
simple types are pre-defined, @ref{predefinedTypes} gives a table of
such types.

@float tbl,predefinedTypes
@caption{Standard Pre-defined Types}
@table @code
@item boolean
used for logical values and conditions
@item float
type of floating point numbers
@item integer
type of integer values
@item string
type of string values
@end table
@end float

@node Parameterized Types
@subsection Parameterized Types
@cindex type expression
@cindex parameterized types
A parameterized @var{TypeExpression} consists of a
@var{TypeConstructor} applied to one of more @var{Type} arguments. For
example, the standard @code{cons} type constructor has one type
argument -- the type of elements of the @code{cons}.

A parameterized type has a @emph{type arity} -- the number of type
arguments it expects. This is defined when the type itself is
defined. It is an error to write a type expression involving an
incorrect number of type arguments.

Parameterized types may be defined using a @var{TypeDefinition}
statement.

@quotation NOTE
@cindex type,variable constructor
@cindex type constructor expression

A type expression of the form:
@example
c[t1,...,tn]
@end example

where @code{c} is a type variable -- i.e., bound by a quantifier --
denotes a rather special form of type: a type constructor
expression. Like other parameterized type expressions, this expression
does not denote a single type; but a set of types. For example, the
type expression:
@example
c[integer]
@end example

denotes a type @emph{something of @code{integer}}.

A subsequent constraint on @code{c} may cause it to be bound to the
@var{TypeConstructor} @code{cons} (say), in which case the type
expression becomes ground to the parameterized type expression
@code{cons[integer]}.

Such type expressions are of most use in certain forms of
@var{Contract} where the contract is about a certain form of
parameterized type.
@end quotation

@node Structural Types
@section Structural Types
@cindex types,structural
@cindex structural types

A structural type is a type expression that looks like its
purpose. @Star{} has three main forms of structural type: tuple types,
program types and record types.

@node Tuple Types
@subsection Tuple Types
@cindex tuple types
@cindex type,tuple

A tuple type is a tuple of types; written as a sequence of type
expressions enclosed in parentheses.

@float BNF,tupleTypeFig
@caption{Tuple Type}
@display
@anchored{TupleType} ::= @code{()}
  | @code{((} @var{Type} @code{))}
  | @code{(}@var{Type} ,@dots{},@var{Type}@code{)}
@end display
@end float

A tuple type denotes a fixed grouping of elements. Each element of the
tuple may have a different type.

There are two special cases in @var{TupleType}s: the empty tuple and
the singleton tuple type.

@subsubsection Empty Tuple
@cindex tuple,empty tuple type
@cindex empty tuple type

The empty tuple type:
@example
()
@end example

refers to the empty tuple. It is useful primarily for writing function
types where the function has no arguments:
@example
()=>string
@end example

When used as the return type of a function, the @code{()} type denotes
a void result:
@example
(integer)=>()
@end example

@quotation TIP
The @code{()} type -- sometimes referred to as the @emph{unit type} --
is also used to denote the return type of some actions.
@end quotation

@subsubsection Singleton Type Tuple
@cindex tuple,singleton tuple type

@noindent
In some cases, a singleton tuple must be written with two
parentheses. This is to disambiguate such terms from simple expression
parentheses. A type expression of the form:
@example
(integer)
@end example

is equivalent to just the @code{integer} type; whereas
@example
((integer))
@end example

denotes the single element tuple type whose element type is
@code{integer}.

@quotation NOTE
The double set of parentheses is not needed, for example, in giving
the type signature of a unary function.
@end quotation
For example, the type
@example
(integer)=>integer
@end example
denotes a unary function of one argument. The similar type expression:
@example
((integer))=>integer
@end example
denotes a unary function type, whose @emph{argument} is a unary or
singleton tuple.@footnote{This complexity arises because parentheses
have a dual role: to group expressions and as a notation for tuples.}

@node Record Types
@subsection Record Types
@cindex type,record type
@cindex record type
@noindent
A @var{RecordType} is a type expression that denotes a named
association of fields and types. A record type is written as a
sequence of type annotations enclosed in braces.

@float BNF,recordTypeFig
@caption{Record Type}
@display
@anchored{RecordType} ::= @code{@{}@var{Annotation} @dots{} @var{Annotation} @code{@}}

@anchored{Annotation} ::= @var{TypeAnnotation}
  | @var{TypeEquality}

@anchored{TypeEquality} ::= @code{type} @var{Identifier} @code{=} @var{Type}
@end display
@end float
@quotation NOTE
The various annotations in a record type are terminated by a dot-space
terminator.
@end quotation

Record types are used as the type of anonymous records (see
@var{anonRecord}). They are also the basis of other features of the
type language -- including the @var{ConstructorType} and
@var{Contract}s.

Two record types are equivalent if their elements are pair-wise
equivalent. Note that the @emph{order} of elements is not
important. For example, given the types:
@example
@{a:string. b:integer. @}
@end example

and
@example
@{b:integer. a:t. @}
@end example

these types unify -- assuming that @code{t} is a bound type variable --
provided that @code{t} is unifiable with @code{string}.

@quotation NOTE
All nomimal types have a @var{RecordType} interface associated with
them. This, as is detailed in @var{algebraicInterface}, defines a type
for all of the fields in any of the constructors for the type. In
turn, this permits a @var{RecordAccess} expression to apply to a
user-defined type as well as a @var{RecordType}.
@end quotation

@node Function Types
@subsection Function Types
@cindex function type
@cindex type,function

@noindent
A function type denotes a function value. It takes the form of a
possibly empty sequence of argument types -- denoting the types of the
arguments to the function -- enclosed in parentheses; followed by the
result type of the function. @var{functionTypeFig} highlights the form
of the function type:

@float BNT,functionTypeFig
@caption{Function Type}
@display
@anchored{FunctionType} ::= @var{TupleType} @code{=>} @var{Type}
@end display
@end float

For example, a function of two arguments -- an @code{integer} and a
@code{string} that returns a list of @code{string}s has a type that
takes the form:
@example
(integer,string) => cons[string]
@end example

@node Constructor Type
@subsubsection Constructor Type
@cindex constructor type
@cindex type,constructor

A constructor is a special function that is introduced in an
@var{AlgebraicType} definition.

@quotation NOTE
Constructors are special because they can be viewed simultaneously as
a function and as a pattern. Hence the form of the constructor
reflects that bidirectionality.
@end quotation

@float BNF,constructorTypeFig
@caption{Constructor Type}
@display
@anchored{ConstructorType} ::= @var{Type} @code{<=>} @var{Type}
@end display
@end float

The left hand side of a constructor type should either be a
@var{TupleType} or an @var{RecordType} -- depending on whether the
denoted constructor is a term constructor constructor or a record
constructor.

@quotation TIP
Explicit @var{ConstructorType}s are most used in the context of the signatures
of @emph{abstract data types}: where a type and its constructors are
@emph{exported} from a record.
@end quotation

@node Reference Type
@subsection Reference Type
@cindex reference type
@cindex type,var

A re-assignable variable is given a @code{ref}erence type.

@float BNF,referenceTypeFig
@caption{Reference Type}
@display
@anchored{ReferenceType} ::= @code{ref} @var{Type}
@end display
@end float

@noindent
Reference types allow the programmer to distinguish re-assignable
variables from other values; in particular they allow one to
distinguish between binding to the @emph{value} of a re-assignable
variable or to its @emph{name}.

@quotation NOTE
The latter is not as common, but is important to support abstractions
involving re-assignable variables.
@end quotation

@node Quantified Types
@section Quantified Types
@cindex quantified types
@cindex type,quantified

A quantified type expression is form that identifies a collection of
types rather than a single specific type.

There are two forms of quantified type: universal types and
existential types. Universal types correspond approximately to
@emph{generic} types found in many programming languages; whereas
existential types correspond to @emph{abstract} types. The latter is
somewhat less common in programming languages.

Associated with any quantified type is the bound type -- otherwise
known as a type variable. The permitted uses of a given bound type
variable depend on whether it is universally bound or existentially
bound.

@node Universally Quantified Types
@subsection Universally Quantified Types
@cindex type,universally quantified
@cindex universally quantified type

A universally quantified type denotes a type that is valid for all
substitutions of a type variable.

@float BNF,universalTypeFig
@caption{Universal Type Expression}
@display
@anchored{universalType} ::= @code{all} @var{BoundType} @comma{}@dots{}@comma{}@var{BoundType} @code{~~} @var{Type}

@anchored{BoundType} ::= @var{Identifier}
  | @var{Identifier}@code{/}@var{Decimal}
@end display
@end float

For example, the type expression:
@example
all x ~~ (x,x)=>boolean
@end example
denotes the generic function type of two arguments that returns a
@code{boolean}.

There are two forms of @var{BoundType}, a simple type variable and a
second form that includes an arity.

The first form of @var{BoundType} introduces a regular type variable
-- i.e., a variable which may be bound to any @code{type}. The second
form is used to introduce a higher-kinded type variable.

For example, the quantification:

@example
all c/1 ~~ ...
@end example
denotes a variable which may only be bound to type constructors that
take one argument -- for example @code{cons}.

@quotation WARNING
It is a type error to bind @code{c} to a regular (complete) type
expression; or to a type constructor that takes more than one type
argument.
@end quotation

The @Star{} compiler also accepts a short hand form of the universally
quantified type where there are multiple quantifiers. I.e., instead of
writing
@example
all x ~~ all y ~~ (x,y)=>tp
@end example
we can write
@example
all x,y ~~ (x,y)=>tp
@end example

@quotation TIP
Higher kinded type variables are most commonly used in the context of
@var{Contract} definitions.
@end quotation

@Star{} will infer the type of expressions; but does @emph{not} infer
any quantified type. That the compiler may not infer an appropriate
type for your functions if you intend them to be generic.

For example, the @code{dblFilter} function in @ref{dblFilter} applies
a @code{map} function in two different situations -- one for each
element of each pair in the input list. This requires that
@code{dblFilter} be given an explicit universally quantified type
annotation:

@float Program,dblFilter
@caption{A @code{double} filter}
@example
dblFilter:all u,v ~~ (all t~~(t)=>t, cons[(u,v)])=>cons[(u,v)].
dblFilter(M,[]) => [].
dblFilter(M,[(A,B),..L]) => [(M(A),M(B)),..dblFilter(M,L)].
@end example
@end float     
It is important to note that any actual function argument supplied to
@code{dblFilter} will itself have to be generic -- i.e., its type will
also be universally quantified.

@node Existentially Quantified Types
@subsection Existentially Quantified Types
@cindex type,existentially quantified
@cindex existentially quantified type
@cindex exists@code{exists}

An existential type denotes an @emph{abstract} type. More formally, it
denotes a specific -- but unknown -- type.

@quotation NOTE
The terms universally quantified and existentially quantified types
reflect the similar concepts in first order predicate logic. However,
the domain is different: in logic, universal quantifiers apply to
formulae that have a truth value; whereas in type language,
quantifiers apply to type expressions.
@end quotation

@float BNF,existentialTypeFig
@caption{Existential Type Expression}
@display
@anchored{existentialType} ::= @code{exists} @var{BoundType},..,@var{BoundType} @code{~~} @var{Type}
@end display
@end float

An existentially quantified type denotes a type within which there is
an @emph{abstract type}: i.e., the type exists but the expression is
not explicit about which type.

Existential types are most often used in the type signatures of
abstract data types. For example, the term in the statement:
@example
R = @{ type el = integer. op(X,Y) => X+Y. @}
@end example

has type:
@example
exists el ~~ @{ op:(el,el)=>el @}
@end example

@quotation NOTE
Note that the fact that within the record the type @code{el} is
identified as @code{integer} does not escape the record
itself. Externally, the existence of the type is known but not what it
is.

It is permissible to refer to the type within the record by a dot
reference.
@end quotation

@node Bound Type Variables
@subsection Bound Type Variables
@cindex type,variable

@noindent
A type variable is a variable which may be bound to a type. Like other
variables, type variables have a scope; and they have a context that
determines the permissable values that the variable may be given.

@quotation NOTE
Although type variables have scope, they do not participate in any
computation of values in the program. It is not possible, for example,
for a program to dynamically determine the type of a value.
@end quotation

@float BNF,typeVariableFig
@caption{Type Variables}
@display
@anchored{TypeVariable} ::= @var{Identifier}
@end display
@end float

Type variables are associated with an @emph{arity} -- which constrains
the kinds (sic) of types that the type variables may be bound to. A
variable that has arity zero may be bound to any well formed type; a
variable that has an arity greater than zero may only be bound to a
type constructor of appropriate arity.

For example, given:
@example
all t ~~ cons[t] ::= nil | cons(t, cons[t]).
@end example

The type variable @code{t} may be bound to a type expression such as
@code{cons[string]} but not to a higher-kinded type (such as
@code{cons} itself).

@subsubsection Scope of Type Variables
@cindex type,variable!scope

All type variables have a scope which generally follows the scoping
rules for normal variables.

There are two particular cases that are important: type variables
introduced via @var{TypeDefinition}s and those introduced via
explicitly quantified type expressions.

A variable introduced in the head of an @var{AlgebraicType}
definition, or in the head of a @var{Contract} definition are in scope
throughout the definition or contract respectively.

@node Encapsulated Types
@subsection Encapsulated Types
@cindex encapsulated type
@cindex type,encapsulated in record
@cindex existential type
@cindex heterogenous types

An @var{EncapsulatedType} is a reference to a type that is embedded
within a record.

@float BNF,encapsulatedTypeFig
@caption{Encapsulated Type}
@display
@anchored{EncapsulatedType} ::= @var{Expression}@code{.}@var{Identifier}
@end display
@end float

As noted above, record literals may have types embedded within
them. Such a record type is existentially quantified.

It is possible to access the type embedded within such a record --
albeit with some restrictions:

The form of an @var{EncapsulatedType} reference is limited to terms of
the form:
@example
R.t
@end example

where @code{R} is a @var{Variable} whose type interface contains the
type @code{t}.

More generally, an @var{EncapsulatedType} reference may involve a
sequence of field names where each intermediate field name varers to a
sub-record:
@example
R.f1.f2.t
@end example

The @emph{value} of an encapsulated type is strictly opaque: it is
assumed to be different to all other types. Which means that
effectively @emph{only} the other fields of the record variable
@code{R} contain functions and values that can be used in conjunction.

For example, consider the @code{group} type defined in:

@example
group ::= group@{
  type el = quality[el].
  zero : el.
  op : (el,el)=>el.
  inv : (el)=>el.
@}
@end example

@quotation TIP
A @code{group} literal is analogous to a mathematical group: a
set which is closed under a binary operation and whose elements have
an inverse.

The contents of a @code{group} literal contain the definitions of the
elements, the binary operation, the zero element and the inverse
function.
@end quotation

The qualification of the @code{el} type that it supports
@code{equality} allows convenient access to equality of group
elements. Without such a qualification, equality would not be possible
for programs using @code{group} values.

An additional requirement for a group is that its operation is
associative. Such a property cannot be expressed in terms of type
constraints.

A @code{group} literal that implements the group for @code{integer}s
is shown in:

@float Program,groupTypeProg
@caption{The @code{group} Type}
@example
IG = group@{
  type el = integer.
  zero = 0.
  op = (+).
  inv(X) => -X.
@}
@end example
@end float

The @code{IG} value contains the elements of a group value. We can,
for example, access the @code{zero} of @code{IG} using the statement:
@example
IZ : IG.el.
IZ = IG.zero.
@end example

This asserts that @code{IZ}'s type is whatever the encapsulated type
within @code{IG} is -- without being explicit about what that type is.

It is possible to construct functions over @code{group}s that varer to
encapsulated types. For example, the @code{invertGroup} function below
constructs a new group by @emph{inverting} the operation.

@float Program,invertGroupProgram
@caption{A @code{group} Inverting Function}
@example
invertGroup : (group)=>group.
invertGroup(G) => group@{
  type el = G.el.
  zero = G.zero.
  op(X,Y) => G.op(G.inv(X),G.inv(Y)).
  inv(X) => G.inv(X)
@}
@end example
@end float

@node Constrained Types
@section Constrained Types
@cindex contrained type

A constrained type is one with additional constraints in the form of
@ref{Type Constraints}.

@float BNF,constrainedTypeFig
@caption{Constrained Type}
@display
@anchored{ConstrainedType} ::= @var{TypeConstraint}@code{|:}@var{Type}
@end display
@end float

Constrained types are generally either type variables or immediately
enclosed by a quantifier.

For example, a type expression of the form:
@example
all t ~~ comparable[t], arith[t] |: (t)=>t
@end example

denotes a generic unary function type for any type that implements
both the @code{comparable} and the @code{arith} contracts (see
@var{comparisonPredicates} and @var{arithmeticContract}).

@xref{Type Constraints} for a description of the possible forms of
type constraint.

@node Type Constraints
@section Type Constraints
@cindex type,constraints

@noindent
A @var{TypeConstraint} is a constraint on a @var{Type}; usually
implying a constraint on the possible binding of a @var{TypeVariable}.

@float BNF,typeConstraintFig
@caption{Type Constraints}
@display
@anchored{TypeConstraint} ::= @var{ContractConstraint}
  | @var{FieldConstraint}
  | @var{TypeConstraint} ,@comma{}, @var{TypeConstraint}
@end display
@end float

Generally, a @var{TypeConstraint} on a @var{TypeVariable} restricts in
some sense the possible bindings for that type variable. For example,
a @var{Contract} refers to a named collection of functions and a
@var{TypeVariable} constrained by a @var{ContractConstraint} means
that any concrete instantiation of the @var{TypeVariable} must be to a
@var{Type} that @code{implement}s the
@var{Contract}.

Similarly, a @var{FieldConstraint} constrains the @var{TypeVariable}
so that any binding must be to a @var{Type} that has the named field
in its definition.

For example, using @code{arith} as a constraint allows us to say
@emph{the type can be anything that implements the standard arithmetic
functions}. The type expression:
@example
arith[t] |: t
@end example
denotes this kind of constrained type.

@quotation NOTE
It is possible to view a type variable binding itself as a form of
constraint: if we bind the type variable @code{t} to the type
@code{integer} then we are constraining the type @code{t} to be equal
to @code{integer}.
@end quotation

@quotation NOTE
In many cases type inference will automatically result in constraints
being added to type expressions.
@end quotation

It is possible mix different forms of @var{TypeConstraint}; for
example, if a @var{TypeVariable} must be bound to a type that
implements the @code{comparable} contract as well as having the
@code{integer}-typed @code{ident} attribute, the type expression:
@example
comparable[t], t <~ @{ ident:integer @}
@end example
captures this.

@quotation NOTE
If a constrained type variable is unified with another type variable,
then the constraints of the two variables are merged. It may be that
such a merging of constraints is not possible; in such a case, the
unification will fail.
@end quotation

@node Contract Constraints
@subsection Constract Constraints
@cindex type,constraints!contract
@cindex contract constraint

@noindent
A @var{ContractConstraint} is a requirement on a @var{Type} -- or
tuple of @var{Type}s -- that whatever type it is, that there must
exist an @code{implementation} of the @var{Contract} for the
@var{Type} (see @var{contracts}).

For example, the type constraint expression in the constrained type:
@example
comparable[t] |: t
@end example
means that the type variable @code{t} may only unify with concrete
types that implement the @code{comparable} contract.

@quotation NOTE
Since only named types may implement @var{Contract}s, it is also not
permissible to unify the constrained variable with an structural type
-- such as a function type.
@end quotation

@float BNF,contractConstraintFig
@caption{Contract Constraint}
@display
@anchored{ContractConstraint} ::= @var{Identifier}@code{[}@var{TypeArgument}@code{]}
  | @var{Identifier}@code{[}@var{TypeArgument} ->> @var{TypeArgument}@code{]}
@end display
@end float

It is possible for @var{ContractConstraint}s to reference more than
one type. For example, the standard @code{coercion} contract (see
@var{typeCoercionContractFig}) references two types. A @code{coercion}
@var{ContractConstraint} will therefore look like:
@example
coercion[T1,T2]
@end example

where @code{T1} represents the source type of the coercion and
@code{T2} represents the destination type.

If the @code{->>} clause is used, then the @var{Contract} being
referenced must have a @emph{functional dependency}
@cindex functional dependency
associated with it.

@quotation NOTE
Conversely, if a @var{Contract} has a functional dependency, then any
constraint varerring to it must also have a @code{\->>} clause.
@end quotation

The @code{->>} clause identifies which type(s) are dependent on the
type argument(s) of the @var{Contract}. (See
@var{ContractFunctionalDependency}).

@node Field Constraints
@subsection Field Constraints
@cindex type,field
@cindex type,constraints!field

A @emph{FieldConstraint} is a requirement on a variable that whatever
type it is, it should have particular attributes of particular types
defined for it.

@float BNF,attributeConstraintFig
@caption{Field Constraint}
@display
@anchored{FieldConstraint} ::= @var{Type} @code{<~} @{ @var{Annotation} . @dots{}. @var{Annotation} @}
@end display
@end float

For example, in
@example
r <~ @{ alpha : string. beta : integer @}
@end example

if @code{r} is unified against a concrete type then that type's
@var{RecordType} interface (see @var{algebraicInterface}) must contain
both of @code{alpha} and @code{beta}. In addition, the fields must be
of the right types.

@quotation NOTE
It is also possible to require that an @var{EncapsulatedType}
exists. For example, the constraint:
@example
s <~ @{ type elem @}
@end example
requires that any actual binding for type
@code{s} must include the embedded type @code{elem}.
@end quotation

@node Type Semantics
@section Type Semantics
@cindex semantics of types


@node Type Rules
@subsection Type Rules
@cindex type safety
@cindex type rules

The connection between the argument type of a @code{cons} type
expression and the actual elements of lists is denoted by a @emph{type
inference rule}. Type inference rules are rules for relating
expressions and statements in the language to the types associated
with that statement. For example, the rule:

@display
@typeprod{E,@var{El}@sub{1},@var{T}},@dots{},@typeprod{E,El@sub{n},@var{T}}
@result{}
@typeprod{E,@code{cons of[@var{El}@sub{1}@comma{}@dots{}@comma{}@var{El}@sub{n}]},@code{cons[@var{T}]}}
@end display
says that if the expressions @var{El@sub{1}} through @var{El@sub{n}}
all have type @var{T}, then the list expression
@example
cons of [@emph{El@sub{1}}@comma{}@dots{}@comma{}@emph{El@sub{n}}]
@end example
has type @code{cons[@var{T}]}. This is the formal way of stating that
all elements of a list must have the same type -- in this case because all the elements of the list have the same type:

@display
@typeprod{E,@var{El}@sub{i},@var{T}}
@end display

The general form of a type inference rule that is determining a type
(sometimes called a type judgment) is:
@display
@var{Condition}
@result{}
@typeprod{E,@var{X},@var{T}}
@end display
@quotation
If @emph{Condition} is satisfied, then we can infer from the context
@var{E} that @var{X} has type @var{T}
@end quotation
where the symbol @turnstile{} can be read as @emph{type
implication}. In general, the type of an expression depends on the
context that it is found.

The @emph{environment} part of the type judgement consists of a sequence of
type bindings, type equalities and type constraints:
@itemize
@item
A type binding consists of a type annotation:
@example
@var{var} : @var{type}
@end example
@item
A type equality consists of an equality between a type variable and a type:
@example
@var{type} = @var{type}
@end example
@item
A type constraint consists of an instance of a @ref{TypeConstraint}s:
@example
@var{Constraint}
@end example
@end itemize
The environment's primary purpose is to establish the context of a
type judgement.

@quotation NOTE
The environment is described as an ordered sequence because @Star{}
permits scope hiding: where a local definition of a value may obscure
an outer definition.
@end quotation

@node Freshening and Skolemization
@subsection Freshening and Skolemization
@cindex skolemization

In any logic with quantifiers, reasoning about terms can involves
rewriting quantified expressions. The type system of @Star{} has two
related operations over types: freshening and skolemization.

@node Freshening
@subsubsection Freshening

Freshening refers to the process of copying a quantified type
expression and replacing the bound type variable with a @emph{new}
type variable; crucially, one that may be bound in a subsequent
inference step.

@quotation NOTE
Freshening is closely connected to the logical inference step of
@emph{standardizing apart}; which involves renaming bound variables so
that they are unique and moving the associated quantifier @emph{all
the way outside}. In effect, the new type variable becomes free in the
logical formula.
@end quotation

The most common situation that freshening occurs in @Star{}'s type
system is when inferring the type of an identifier
occurrence. Informally, freshening corresponds to the intuition that a
generic type may be used in many ways; and this is realized in type
inference by freshening the recorded type of an identifier for each
occurrence of the identifier in the program.

@node Skolemization
@subsubsection Skolemization

Skolemization refers to the process of copying a quantified type
expression and replacing the bound type variable with a @emph{new}
type; crucially, one that is @emph{not} equal to any existing type.

The most common situation that skolemization occurs in @Star{}'s type
system is when validating that a variable's definition is consistent
with its declared type.

Informally, skolemization corresponds to the intuition that any
definition of a variable (or function) whose type is generic must obey
certain constraints: specifically the definition may not further
constrain the type by any entanglement with additional
constraints.

This is acheived by marking the type variable as
effectively read-only within the definition; or equivalently, by using
a new type that does not appear anywhere and therefore has no
knowledge of functions that may be defined for it.

@node Type Unification
@subsection Type Unification
@cindex type,unification

@noindent
The type system is based on the concept of type
@emph{equality}. Unification is an algorithm that can be used to
determine if two terms can be made to be identical to each other --
typically by replacing variables with values.

@node Unifying Nominal Types
@subsubsection  Unifying Nominal Types

Two nominal types unify if they can be made identical:
@itemize @bullet
@item
Two @ref{SimpleType}s unify if they are the same @ref{SimpleType}

For example,
@example
integer = integer
@end example
but,
@example
integer @noteq{} string
@end example

@item
Two @ref{ParameterizedType}s unify if their @var{TypeConstructor}s
unify, they have the same number of @ref{TypeArgument}s, and those
arguments pairwise unify.

For example,
@example
cons[integer] = cons[integer]
@end example
and
@example
action[string,()] = action[string,()]
@end example
but,
@example
cons[integer] @noteq cons[string]
@end example
and
@example
cons[integer] @noteq list[integer]
@end example
and
@example
cons[integer] @noteq cons[integer,string]
@end example
@end itemize


@node Unifying Reference Types
@subsubsection  Unifying Reference Types

Two reference types unify if their argument types unify

For example,
@example
ref integer = ref integer
@end example
but,
@example
ref integer @noteq ref string
@end example
and
@example
ref integer @noteq list[integer]
@end example

@node Unifying Tuple Types
@subsubsection Unifying Tuple Types

Two @ref{TupleType}s unify if they have the same number of elements,
and those elements unify in a pairwise fashion.

@example
() = ()
@end example
and
@example
(integer,string) = (integer,string)
@end example
and
@example
(integer,string) = (integer,t)
@end example
where @code{t} is an arity-0 type variable, with the additional effect
that @code{t} will be bound to the @code{string} type.

However,
@example
() @noteq{} (())
@end example
because the second is actually a unary tuple containing a zero-tuple; and
@example
(string,integer) @noteq{} (integer,string)
@end example
because elements must unify in a pairwise way.

@node Unifying Record Types
@subsubsection Unifying Record Types

Fields in a record are not intrinsically ordered, but the spirit of
unification for records is similar to that of tuples:

Two record types unify iff:
@itemize @bullet
@item
they have the same fields and embedded types
@item
each field's type in one record type unifies with the corresponding
field of the other record type
@item
each embedded type in one record unifies with the corresponding
embedded type of the other record type.
@end itemize

@quotation NOTE
There is no syntax in @Star{} for @emph{partial} records.
@end quotation

For example,
@example
@{@} = @{@}
@end example
and
@example
@{ foo:integer. type bar @} = @{ foo:t. type bar @}
@end example
with @code{t} being bound to @code{integer}; whereas
@example
@{ foo:integer. @} @noteq{} @{bar:integer@}
@end example
because the second record type does not have a @code{foo} field, and
the first does not have a @code{bar} field.

@node Unifying Function Types
@subsubsection Unifying Function Types

Two function types unify iff their arguments unify and the result
unifies. Note that the simple function type does not unify with the
constructor function type.

@example
(integer)=>integer = (t)=>t
@end example
where @code{t} is a type variable that is subsequently bound to
@code{integer}; whereas
@example
(integer,string)=>integer @noteq{} (string,integer)=>integer
@end example
and
@example
(integer,string)=>integer @noteq{} (integer,string)<=>integer
@end example

@node Unifying Type Variables
@subsubsection Unifying Type Variables

There are two sub-cases for unifying type variables:
@enumerate
@item
if either the left or the right terms are not type variables, then
@emph{provided that}:
@itemize @bullet
@item
the type variable does not itself appear in the non-variable type; and
@item
any type constraints on the type variable are satisfied by the
non-variable type;
@end itemize
then the two
types are unifiable.

@quotation NOTE
The first condition is known as an @emph{occurs check}.
@cindex Occurrs check
@end quotation

@noindent
In addition, the fact of the unification is recorded as a binding for
the variable type. Thereafter, when unifying types, this binding must
be applied to all occurrences of the same type variable.
@item
if both left and right terms are type variables then the unification
is permitted; and the fact of the unification is recorded as a binding
for the variable that is bound. As for non-variable bindings, the
binding must be applied to all occurrences of the same type variable.

In addition, any type constraints on the type variables are
@emph{merged}. If this merging is not possible then the two type
variables do not unify.

Type constraints are merged as follows, assuming that @code{t@sub{a}}
is bound to @code{t@sub{b}}:
@enumerate
@item
for every contract constraint in @code{t@sub{a}}, if a contract
contraint exists for @code{t@sub{b}} with the same contract name, then
the two contracts must unify, otherwise it is appended to the
contraints for @code{t@sub{b}}.
@item
if there is a field constraint in @code{t@sub{a}}, it is merged with
the corresponding field constraint for @code{t@sub{b}}.
@end enumerate
@end enumerate


@node Unifying Quantified Types
@subsubsection Unifying Quantified Types

@noindent
Unifying quantified types is slightly more involved than that of other
forms of type. Two quantified types are unifiable iff they can be made
to be identical; however, a quantified type stands for all or some
type. In particular, two quantified types are considered to be
identical if they differ only in the name of the bound variable.

For example,
@example
all x ~~ cons[x]
@end example
is equivalent to
@example
all y ~~ cons[y]
@end example

Our rule for unifying two quantified types reflects this:

Two quantified types are unifiable if
@itemize @bullet
@item
they are the same form of quantifier (@code{all} vs @code{exists}
@item
for some type name @code{t} that does not occur in either of them,
@example
all x~~@var{T1}
@end example
is renamed to
@example
all t~~@var{T1'}
@end example
where @var{T1'} is obtained from @var{T1} by systematically replacing
all occurrences of @code{x} by @code{t} -- except for any further
occurrences of @code{x} as a bound variable in a quantified type
within @var{T1}.

Similarly,
@example
all y~~@var{T2}
@end example
is rewritten to
@example
all t~~@var{T2'}
@end example

@quotation NOTE
Both @var{T1} and @var{T2} are rewritten using the same target name @code{t}.
@end quotation

Finally, the two quantified types unify iff
@example
@var{T1'} = @var{T2'}
@end example
@end itemize

@quotation NOTE
Because both @code{x} and @code{y} are bound type variables, they
cannot occur in any outer type terms -- should the quantified types be
part of larger type terms that are being unified there cannot be any
binding 'side effect' by rewriting either of @code{x} or @code{y}.
@end quotation

Some examples:
@smallexample
all a~~((cons[a])=>(a)) = all b~~((cons[b])=>(b))
@end smallexample
are equal because we can rename both @code{a} and @code{b} to @code{c}
and unify the bound types:
@example
all c~~((cons[c])=>(c)) = all c~~((cons[c])=>(c))
@end example

However
@example
all a~~(a)=>integer @noteq{} exists b~~(b)=>integer
@end example
because of the different quantifiers, and
@example
all a~~(a)=>integer @noteq{} (@var{t})=>integer
@end example
for any type @var{t} because the latter type is not quantified.
