= Types
[#type]

(((type system)))
Star is a strongly, statically, typed language. That means that all
values and all variables must have a unique well-defined type that is
determinable by inspecting the text of the program -- effectively at
_compile time_.

The type system consists of a method for declaring new types, for
annotating expressions (and by extension programs) with their types and
a system of verifying the type consistency of programs.

This chapter focuses on the type language itself and the semantics of
types.

[sidebar]
A Type is a term that denotes a collection of
values.footnote:[Not a set of values: some collections are not sets.]

Viewed as collections, types have a particular property: all values are members
of exactly one type collection. This is the foundation of type checking.

There are two kinds of type terms: nominal types and structural types. Nominal,
or named, types have names but do not otherwise expose the nature of their
values. Structural types do not have word-like names, but they do 'look like'
the values associated with them.

In addition, type expressions are combinations of types and type constructors.

[#typeFig]
.Types of Types
[source,star]
----
type --> nominal.
type --> typeVariable.
type --> tupleType.
type --> recordType.
type --> referenceType.
type --> functionType.
type --> constructorType.
type --> constrainedType.
type --> encapsulatedType.
----

== Nominal Types

[#simpleType]
For many simple cases, a type is denoted by an identifier. For example, the type
identifier `string` denotes the set of all strings. More explicitly, a value has
type `string` iff footnote:[The term "iff" means "if and only if".] it belongs
to the set denoted by the symbol `string`.

In addition to simple types, there are also parameterized types that allow the
characterization of generic types. For example, the `map` type has two
parameters: the type of the key and the type of the value of elements in
the map.

[source,star]
----
nominalType --> identifier.
nominalType --> identifier, ["[", type * [","], ["]"].
----

[#parameterizedType]
A simple example of a parameterized nominal type is the `cons` type: a `cons` type
expression always involves the mention of another type -- the type of elements
of the list. The type expression:

[source,star]
----
cons[string]
----

denotes the type expression associated with lists whose elements are
all string values. Other examples of `cons` type include lists of
integers:
[source,star]
----
cons[integer]
----

and even lists of lists of string valued functions:
[source,star]
----
cons[cons[(integer)=>string]]
----

[NOTE]
****
Technically, the `cons` symbol in:
[source,star]
----
cons[integer]
----
(((type function)))
is a type constructor: it takes a type as an argument and
returns another type as result.
****

[#structuralTypes]
== Structural Types

Formally, a structural type term is an instance of a predefined schema of type
terms. However, informally, structural type terms are terms that mirror
syntactically the values that they represent.

There are three main forms of structural type: tuple types,
program types and record types.

NOTE: Structural types are inherently _non-recursive_: only nominal types can
have definitions that imply a recursive type.

[#tupleType]
=== Tuple Type

(((tuple types)))
(((type,tuple)))
A tuple type is a tuple of types; written as a sequence of type
expressions enclosed in parentheses.

[#tupleTypeFig]
.Tuple Type
[source,star]
----
tupleType --> ["()"].
tupleType --> ["(("],type,["))"].
tupleType --> ["("], type * [","], [")"].
----

A tuple type denotes a fixed grouping of elements. Each element of the
tuple may have a different type.

There are two special cases in <<tupleTypeFig>>: the empty tuple and
the singleton tuple type.

==== Empty Tuple

(((tuple,empty tuple type)))
(((empty tuple type)))
The empty tuple type:
[source,star]
----
()
----

refers to the empty tuple. It is useful primarily for writing function
types where the function has no arguments:
[source,star]
----
()=>string
----

When used as the return type of a function, the `()` type denotes
a void result:
[source,star]
----
(integer)=>()
----

TIP: The `()` type -- sometimes referred to as the _unit type_ --
is also used to denote the return type of some actions.

==== Singleton Type Tuple

(((tuple,singleton tuple type)))
In some cases, a singleton tuple must be written with two
parentheses. This is to disambiguate such terms from simple expression
parentheses. A type expression of the form:
[source,star]
----
(integer)
----

is equivalent to just the `integer` type; whereas
[source,star]
----
((integer))
----

denotes the single element tuple type whose element type is
`integer`.

NOTE: The double set of parentheses is not needed, for example, in giving
the type signature of a unary function.

For example, the type
[source,star]
----
(integer)=>integer
----
denotes a unary function of one argument. The similar type expression:
[source,star]
----
((integer))=>integer
----
denotes a unary function type, whose _argument_ is a unary or
singleton tuple.footnote:[This complexity arises because parentheses
have a dual role: to group expressions and as a notation for tuples.]

[#recordType]
=== Record Type

(((type,record type)))
(((record type)))
A record typed is a type expression that denotes a named
association of fields and types. A record type is written as a
sequence of type annotations enclosed in braces.

[#recordTypeFig]
.Record Type
[source,star]
----
recordType --> ["{"], annotation * [dotSpace], ["}"].

annotation --> typeAnnotation.
annotation --> typeRule.

typeRule --> typeAliasDefinition.
----

NOTE: The various annotations in a record type are separated by a dot-space
terminator.

Record types are used as the basis of other features of the
type language -- including record constructors and <<contract>>s.

Two record types are equivalent if their elements are pair-wise by name
equivalent. Note that the _order_ of elements is not
important. For example, given the types:
[source,star]
----
{a:string. b:integer. }
----

and
[source,star]
----
{b:integer. a:t. }
----

these types unify -- assuming that `t` is a type variable --
provided that `t` is unifiable with `string`.



[#referenceType]
==== Reference Type

(((reference type)))
(((type,var)))
A re-assignable variable is given a `ref`erence type.

[#referenceTypeFig]
.Reference Type
[source,star]
----
referenceType --> ["ref"], type.
----

Reference types allow the programmer to distinguish re-assignable
variables from other values; in particular they allow one to
distinguish between binding to the _value_ of a re-assignable
variable or to its _name_.

NOTE: The latter is not as common, but is important to support abstractions
involving re-assignable variables.

For example, given the declaration for `ix` in the action:
[source,star]
----
valof{
  Ix := 0;
  valis Ix!
}
----

the variable `Ix` has type `ref integer`; whereas the
declaration:
[source,star]
----
Jx = 0
----
results in the variable `Jx` having type `integer`.

==== Function Types

(((function type)))
(((type,function)))
A function type denotes a function value. There are two forms of
function type: a normal, non-throwing, form and a throwing form. The
latter signals that the function may throw an exception, whereas the
non-throwing form is not permitted to throw an exception.

It takes the form of a
possibly empty sequence of argument types -- denoting the types of the
arguments to the function -- enclosed in parentheses; followed by the
result type of the function. <<functionTypeFig>> highlights the form
of the function type:

[#functionTypeFig]
.Function Type
[source,star]
----
functionType --> tupleType, ["=>"], type.
functionType --> tupleType, ["=>"], type, ["throws"], type.
----

For example, a function of two arguments -- an `integer` and a
`string` that returns a list of ``string``s has a type that
takes the form:
[source,star]
----
(integer,string) => cons[string]
----

[#throwingFunctionType]
A throwing function type, such as:
[source,star]
----
(integer,string) => cons[string] throws string
----

signals that the function can throw an exception -- of type `string`
in this case -- when called. It is possible for the exception type to
be quantified, as in:

[source,star]
----
all x,e ~~ (x) => integer throws e
----

This is a generic function type that takes an `x` and either
returns an `integer` or throws `e`.

Exceptions and exception handling are further described in <<tryCatch>>.

[#constructorType]
==== Constructor Type

(((constructor type)))
(((type,constructor)))
A constructor is a special function that is introduced in an
<<algebraicTypeDefinition>>.

NOTE: Constructors are special because they can be viewed
simultaneously as a function and as a pattern. Hence the form of the
constructor reflects that bidirectionality.

[#constructorTypeFig]
.Constructor Type
[source,star]
----
constructorType --> type, ["<=>"], type.
----

The left hand side of a constructor type should either be a
<<tupleType>> or a <<recordType>> -- depending on whether the
denoted constructor is a term constructor constructor or a record
constructor.

TIP: Explicit <<constructorType>>s are most used in the context of the
signatures of _abstract data types_: where a type and its constructors
are _exported_ from a record.


[#constrainedType]
=== Constrained Types

(((contrained type)))
A constrained type is one with additional constraints in the form of
`typeConstraint`s.

[#constrainedTypeFig]
.Constrained Type
[source,star]
----
constrainedType --> typeConstraints, ["|:"], type.

typeConstraints --> typeConstraint.
typeConstraints --> typeConstraint, [","], typeConstraints.
----

For example, a type expression of the form:
[source,star]
----
all t ~~ comp[t], arith[t] |: (t)=>t
----

denotes a generic unary function type for any type that implements
both the `comp` and the `arith` contracts (see
<<compContract>> and <<arithContract>>).

[#typeConstraint]
==== Type Constraints

(((type,constraints)))
There are three kinds of type constraint: contract constraints, field constraints and binding constraints.

.Type Constraints
[source,star]
----
typeConstraint --> contractConstraint.
typeConstraint --> fieldConstraint.
typeConstraint --> implicitConstraint.
----

Type constraints can be applied to any type, however, one of the more
interesting uses of type constraints results from applying constraints to type
variables: the type constraint has the effect of constraining the potential
types to which the tye variable may be unified with.

For example, a <<contract>> refers to a named collection of functions and a type
variable constrained by a <<contract>> constraint means that any concrete
instantiation of the type variable must be to a <<type>> that has an
implementation of the contract in scope.

For example, using `arith` as a constraint allows us to say
_the type can be anything that implements the standard arithmetic
functions_. The type expression:
[source,star]
----
arith[t] |: t
----
denotes this kind of constrained type.

Similarly, a <<fieldConstraint>> constrains the type variable
so that any binding must be to a record type that has the named field within it.

NOTE: It is possible to view a type variable binding itself as a form of
constraint: if we bind the type variable `t` to the type
`integer` then we are constraining the type `t` to be equal
to `integer`.

NOTE: In many cases type inference will automatically result in constraints
being added to type expressions.

It is possible combine different type constraints; for
example, a type variable could be constrained to implement multiple contracts, and even be combined with a field constraint.

[#contractConstraint]
===== Contract Constraint

(((type,constraints!contract))) (((contract constraint)))
A <<contract>> constraint is a requirement on a type -- or a tuple of types --
that whatever type it is, that there must exist an `implementation` in scope of
the contract for the type combination.

For example, the type constraint expression in the constrained type:
[source,star]
----
comp[t] |: t
----
means that the type variable `t` may only unify with 
types where an implementation of the `comp` for that type is in scope.

[#contractConstraintFig]
.Contract Constraint
[source,star]
----
contractConstraint --> identifier ["["], types, ["]"].
contractConstraint --> identifier ["["], types, ["->>"], types, ["]"].
----

It is possible for contract constraints to reference more than
one type. For example, the standard `coercion` contract (see
<<coercionContract>>) references two types. A `coercion`
`contract` constraint will therefore look like:
[source,star]
----
coercion[T1,T2] |: Tp
----

where `T1` represents the source type of the coercion and
`T2` represents the destination type.

If the `-{zwsp}>>` clause is used, then the contract being
referenced must have a _functional dependency_
(((functional dependency)))
associated with it.

NOTE: Conversely, if a contract has a functional dependency, then any
constraint referring to it must also have a `-{zwsp}>>` clause.

The `-{zwsp}>>` clause identifies which type(s) are dependent on the
type argument(s) of the <<contract>>. (See
<<ContractFunctionalDependency>>).

[#implicitBindingConstraint]
===== Implicit Binding Constraints

(((type,constraints!implicit)))
(((implicit binding constraint)))
An implicit binding constraint is a requirement that a given variable of
a specified type exists (i.e., is in scope).

For example, the constraint expression in the constrained type:
[source,star]
----
(foo : t) |: (integer) => t
----
means that, for any variable of this type, there must also be a
variable called `foo` in scope, of type `t`. Typically, the
constrained type is a function, and the implicit binding constraint
also means that the implicitly bound variable is in scope within the function.

More specifically, `foo` must be in scope wherever the function
is called, and `foo` is automatically in scope within the
definition of `foo`.

[#implicitConstraintFig]
.Implicit Binding Constraint
[source,star]
----
implicitConstraint --> typeVariable, ["|="], type.
implicitConstraint --> ["("], typeVariable, [":"], type, [")"].
----

So, for example, in the function `clamp` below, there is an
implicitly defined variable `limit`:

[source,star]
----
clamp : (limit : integer) |: (integer)=>integer.
clamp(X) => valof{
  if X>limit then
    valis limit
  else
    valis X
}
----
Any call to `clamp` must occur in a scope where `limit` is
defined with type `integer`:

[source,star]
----
let{
  limit = 1000;
} in clamp(Z)
----

[#fieldConstraint]
===== Field Constraint

(((type,field)))
(((type,constraints!field)))
A _field constraint_ is a requirement on a variable that if it is bound, it is bound to a record type with an identified attribute.

[#attributeConstraintFig]
.Field Constraint
[source,star]
----
fieldConstraint --> type, ["<~"], ["{"], annotation * [dotSpace], ["}"].
----

For example, in
[source,star]
----
r <~ { alpha : string. beta : integer }
----

if `r` is unified against a concrete type then that tye must be a record type
containg both of `alpha` and `beta`. In addition, the fields must be of the
right types.

[NOTE]
****
It is also possible to require that an <<encapsulatedType>>
exists. For example, the constraint:
[source,star]
----
s <~ { elem ~> _ }
----
requires that any actual binding for type
`s` must include the embedded type `elem`.
****

[#quantifiedType]
=== Quantified Types

A quantified type associates identifies a type as a set of types with a
collection. The members of the set are derived from a template by instantiating
a variable -- the bound variable.

There are two forms of quantified type: the universally quantified type and the
existentially quantified type.

NOTE: The terms universally quantified and existentially quantified types
reflect the similar concepts in first order predicate logic. However,
the domain is different: in logic, universal quantifiers refer to
terms (values) and apply to formulae that have a truth value; whereas
in type language, quantifiers apply to type expressions.

The compiler will infer the type of expressions; but does _not_
infer any quantified type. Functions that are intended to be generic
must have explicit type annotations associated with them.

[#universalType]
==== Universally Quantified Types

(((type,universally quantified)))
(((universally quantified type)))
A universally quantified type denotes a type that is valid for all
substitutions of a type variable.

.Universal Type Expression
[source,star]
----
universalType --> ["all"], boundTypes, ["~~"], type.
----

For example, the type expression:
[source,star]
----
all x ~~ (x,x)=>boolean
----
denotes the generic function type of two arguments that returns a
`boolean`.

The compiler will infer the type of expressions; but does _not_
infer any quantified type. Functions that are intended to be generic
must have explicit type annotations associated with them.

[#existentialType]
==== Existentially Quantified Types

(((type,existentially quantified)))
(((existentially quantified type)))
(((exists`exists`)))
An existential type denotes an _abstract_ type. More formally, it
denotes a specific -- but unknown -- type.


[#existentialTypeFig]
.Existential Type Expression
[source,star]
----
existentialType --> ["exists"], boundTypes, ["~~"], type.
----

An existentially quantified type indicates an _abstract type_:
i.e., the type exists but the expression is not explicit about which
type.

Existential types are most often used in the type signatures of
abstract data types. For example, the term in the statement:
[source,star]
----
R = { e ~> integer. op(X,Y) => X+Y. }
----

is consistent with the type:
[source,star]
----
exists el ~~ { e ~> el. op:(e,e)=>e }
----

The fact that within the record the type `el` is identified as
`integer` does not escape the record itself. Externally, the existence
of the `el` type is known but not what it
is.

It is permissible to refer to the type within the record by a dot
reference.

[#encapsulatedType]
===== Encapsulated Type

(((encapsulated type)))
(((type,encapsulated in record)))
(((existential type)))
(((heterogenous types)))
An `encapsulatedType` is a reference to a type that is embedded
within a record.

[#encapsulatedTypeFig]
.Encapsulated Type
[source,star]
----
encapsulatedType --> field-reference, ["."], identifier.
----

As noted above, record literals may have types embedded within
them. Such a record type is existentially quantified.

It is possible to access the type embedded within such a record --
albeit with some restrictions.

NOTE: To be more precise, types are not values. So, it is technically
meaningless to discuss a type being embedded in a record value.

However, we can use the encapsulated type notation to _identify_
a type from a record value -- provided the reference is well formed.

More generally, an `encapsulatedType` reference may involve a
sequence of field names where each intermediate field name varers to a
sub-record:
[source,star]
----
R.f1.f2.t
----

The actual type identified with an encapsulated type expression
is strictly opaque: it is assumed to be different to all other
types. Which means that effectively _only_ the other fields of
the record variable `R` contain functions and values that can be
used in conjunction.

[#boundType]
==== Bound Type Variables

(((type,variable)))
A bound type variable is a variable which may be bound to a type. Like other
variables, type variables have a scope; and they have a context that
determines the permissible values that the variable may be given.

.Bound Type Variables
[source,star]
----
boundTypes --> boundType * [","].

boundType --> identifier | identifier, ["/"], decimal.
----

There are two forms of `boundType`, a simple type variable and a
second form that includes an arity.

The first form of `boundType` introduces a regular type variable --
i.e., a variable which may be bound to any type. The second form is
used to introduce a higher-kinded type variable.

For example, the quantification:

[source,star]
----
all c/1 ~~ ...
----
denotes a variable which may only be bound to type constructors that
take one argument -- for example `cons`.

WARNING: A regular type variable only unifies with regular types, and a type
constructor type variable only unifies with type constructors.

TIP: Higher kinded type variables are most commonly used in the
context of `contractDefinition`s. In particular, there are no values
directly associated with higher kinded types.

For example, given:
[source,star]
----
all t ~~ cons[t] ::= .nil | cons(t, cons[t]).
----

The type variable `t` may be bound to a type expression such as
`cons[string]` but not to a higher-kinded type (such as
`cons` itself).

On the other hand, given:
[source,star]
----
_iter:all x,m/1,e ~~ execution[m->>e] |: (s,m[x],(t,x)=>m[x]) => m[x]
----
The type variable `m` is specified with the arity `1` --
making it a higher-kinded type that expects one type argument.

TIP: Higher kinded type variables are most commonly used in the
context of `contractDefinition`s. In particular, there are no values
directly associated with higher kinded types.

==== Anonymous Type

The _anonymous_ type -- written with a simple `_` -- denotes
a type variable where every occurrance is unique. The anonymous
variable is used in situations where we don't care what the type is.

== Type Definitions

(((type definition)))
There are several ways that a type may be defined in a scope.

[#typeDefinition]
.Type Definition
[source,star]
----
typeDefinition --> algebraicTypeDefinition.
typeDefinition --> recordTypeDefinition.
typeDefinition --> typeAliasDefinition.
typeDefinition --> typeExistsDefinition.
----

NOTE: Structural types do not need to be defined: they are already part of the
type language.

=== Algebraic Type Definition
[#algebraicTypeDefinition]
An algebraic type definition is a statement that
defines a type in terms of different constructors for the type. There are two
kinds of constructors definable within an algebraic type definition: enumerated
symbols and positional constructor functions:

[#algebraicTypeDefFig]
.Algebraic Type Definition
[source,star]
----
algebraicTypeDefinition --> typeTemplate ["::="], constructor, (["|"], constructor)*.
algebraicTypeDefinition --> quantifier*, algebraicTypeDefinition.

typeTemplate --> identifier.
typeTemplate --> identifier, ["["], identifier * [","], ["]"].

constructor --> ["."], identifier.
constructor --> ["."], identifier, tupleType.
----

An algebraic type definition is a statement that introduces a new
type; it also defines the possible values associated with the type.

As illustrated in <<algebraicTypeDefFig>>, an algebraic type definition
introduces the new type and defines one or more constructors -- separated by the
`|` operator.

A constructor is a specification of a value of a type;
i.e., constructors _paint a picture_ of the shape of potential
values of the type.

There are two kinds of constructor: enumerated symbols and positional 
constructor constructors.footnote:[The related
record constructor must specified in a <<recordTypeDefinition>>.]

For example, the type definition:
[source,star]
----
tree ::= .empty | .node(tree,integer)
----
induces the constructor function for `node`:
[source,star]
----
node : (tree,integer) <=> true
----
The enumerated symbol `empty` has a simpler type:
[source,star]
----
empty : () <=> tree
----

The set of constructor functions introduced within an algebraic type definition
is complete: i.e., they define all the possible values of the type.

NOTE: A given label, whether it is used as an enumerated symbol or the
label of a positional constructor, can be defined only once. I.e., it is not
permitted to _share_ constructor labels across different
types. Nor may such a label be used as the name of a variable in the
same scope.

[NOTE]
****
An <<algebraicTypeDefinition>> statement for a generic type (i.e.,
a type with type parameters) may omit the explicit quantifiers. I.e., instead of

[source,star]
----
all e ~~ cons[e] ::= .nil | .cons(e,cons[e])
----
it is permissible to write:
[source,star]
----
cons[e] ::= .nil | .cons(e,cons[e])
----

The reason is that the quantifiers in such a definition may be
reliably inferred without being explicitly identified.
****

=== Record Type Definition
[#recordTypeDefinition]
A record type definition is a statement that defines a type associated with a
named record with named fields:

.Record Type Definition
[source,star]
----
recordTypeDefinition --> identifier, recordType.
recordTypeDefinition --> quantifiers, identifier, recordType.
----

For example, the type definition:
[source,star]
----
person ::= person{ name:string }.
----
induces the record constructor function for `person`:
[source,star]
----
person : { name:string } <=> person
----

NOTE: A given label, whether it is used as an enumerated symbol, the label of a
positional constructor or a record constructor can be defined only
once. I.e., it is not permitted to _share_ constructor labels across different
types. Nor may such a label be used as the name of a variable in the same scope.

NOTE: As with algebraicTypeDefinition statements, a record type definition may
be quantified. In addition, we may omit the explicit quantifiers. I.e., instead
of

[source,star]
----
all e ~~ person[e] ::= person{ name:string. interest: a }
----
it is permissible to write:
[source,star]
----
person[e] ::= person{ name:string. interest: a }
----

=== Type Alias Statement
[#typeAliasDefinition]
A type alias is a statement that introduces a new type name by mapping
it to an existing type expression.

[#typeAliasFig]
.Type Alias Statement
[source,star]
----
typeAliasDefinition --> typeTemplate, ["~>"], type.
typeAliasDefinition --> quantifier*, typeTemplate, ["~>"], type.
----

Type aliases may be parameterized -- in the sense that the type
being defined may be parameterized and that the definiens may also be
parameterized.

Note that the any type variables on the right hand side of a typeAliasDefinition
must also have been mentioned on the left hand side.

For example, the statement:
[source,star]
----
time ~> integer.
----

declares a new type `time` that is actually equivalent to the `integer` type.

TIP: Type aliases allow the programmer to signal that a particular type is being
used in a special way. In addition, during program development, type aliases are
useful to provide markers for types that will be elaborated further with a
regular algebraic definition.

Type aliases have no run-time presence. In fact, they may be viewed as a simple
form of type macro -- type expressions that match the left hand side are
replaced by the type expression on the right hand side. However, type aliases
have some definite constraints: a type alias may not be, directly or indirectly,
recursive.

NOTE: Type aliases may be parameterized -- in the sense that the type
being defined may be parameterized and that the definiens may also be
parameterized.

For example, the statement:

[source,star]
----
all x,y ~~ pair[x,y] ~> (x,y)
----

defines the `pair` type -- which has two type arguments -- as an alias of a tuple type.

Note that any type variables on the right hand side of a
type alias statement must also have been mentioned on the left
hand side.

=== Type Exists Statement
[#typeExistsDefinition]

A type exists statement is a declaration of a type --
without committing to the nature of teh type itself.

[#typeExitsFig]
.Type Exists Statement
[source,star]
----
typeExistsDefinition --> typeTemplate, ["<~"], type.
typeExistsDefinition --> quantifier*, typeExistsDefinition.
----

There are several scenarios where it is useful to declare the existence of a
type without overly committing to its form:

For example, the statement:
[source,star]
----
time ~> integer.
----

[#typeSemantics]
== Type Semantics

=== Type Rules

(((type safety)))
(((type rules)))
(((semantics of types)))
The connection between the argument type of a `cons` type
expression and the actual elements of lists is denoted by a _type
inference rule_. Type inference rules are rules for relating
expressions and statements in the language to the types associated
with that statement. For example, the rule:

[source,subs="quotes"]
----
E ⊢ E~1~ : T ⇒ E ⊢ .cons(E~1~,.nil) : cons[T]
----
says that if the expression `E~1~`
has type `T`, then the expression
[source,star,subs="quotes"]
----
.cons(_E~1~.nil)
----
has type `cons[T]`. This is the formal way of stating that
all elements of a `cons` list must have the same type.

The general form of a type inference rule that is determining a type
(sometimes called a type judgment) is:
[source,subs="quotes"]
----
_Condition_ ⇒ E ⊢ X : T
----
Which states that if _Condition_ is satisfied, then we can infer from the context
`E` that `X` has type `T`.

where the symbol ⊢ can be read as _type implication_ and ⇒ can be read as
`implies`. In general, the type of an expression depends on the context that it
is found.

The _environment_ part of the type judgement consists of a sequence of
type bindings, type equalities and type constraints:

* A type binding consists of a type annotation:
[source,subs="quotes"]
----
var : type
----
* A type alias consists of a rule that maps a type expression to another type:
[source,subs="quotes"]
----
type ~> type
----
* A type constraint consists of an instance of a <<typeConstraint>>s:
[source,subs="quotes"]
----
Constraint
----

The environment's primary purpose is to establish the context of a
type judgement.

NOTE: The environment is described as an ordered sequence because of scope
hiding: where a local definition of a value may obscure an outer
definition.

=== Freshening and Skolemization

(((skolemization)))
In any logic with quantifiers, reasoning about terms can involves
rewriting quantified expressions. The type system has two related
operations over types: freshening and skolemization.

==== Freshening

(((freshening)))
(((type,freshening)))
Freshening refers to the process of copying a quantified type
expression and replacing the bound type variable with a _new_
type variable; crucially, one that may be bound in a subsequent
inference step.

NOTE: Freshening is closely connected to the logical inference step of
_standardizing apart_; which involves renaming bound variables so
that they are unique and moving the associated quantifier _all
the way outside_. In effect, the new type variable becomes free in the
logical formula that represents the type of the entire program.

The most common situation that freshening occurs when inferring the
type of an identifier occurrence: the type ascribed to an identifier
_occurrence_ is the recorded type of the identifier --
freshened. Informally, freshening corresponds to the intuition that a
generic type may be used in many ways; and this is realized in type
inference by freshening the recorded type of an identifier for each
occurrence of the identifier in the program.

==== Skolemization

(((skolemization)))
(((type,skolemization)))
Skolemization refers to the process of copying a quantified type
expression and replacing the bound type variable with a _new_
unique type; crucially, one that is _not_ equal to any other
type.

The most common situation that skolemization occurs is when validating
that a variable's definition is consistent with its declared type.

Informally, skolemization corresponds to the intuition that any
definition of a variable (or function) whose type is generic must obey
certain constraints: specifically the definition may not further
constrain the type by any entanglement with additional
constraints.

This is acheived by marking the type variable as effectively read-only
within the definition; or equivalently, by using a new type that does
not appear anywhere and therefore has no knowledge of functions that
may be defined for it.

[#typeUnification]
=== Type Unification

(((type,unification)))
The type system is based on the concept of type _equality_ --
specifically two types are considered equal iff they are syntactically
identical. Unification is an algorithm that can be used to determine
if two terms can be made to be identical to each other -- typically by
replacing variables with values.

==== Unifying Nominal Types

(((type,unification,nominal)))
Two nominal types unify if they can be made identical:

* Two <<simpleType>>s unify if they are the same <<simpleType>>
+
For example,
[source,star]
----
integer = integer
----
but,
[source,star]
----
integer ≠ string
----
+
NOTE: Star distinguishes between types declared in different scopes. So,
two types in different packages or in different scopes within the same
package will not unify.
* Two <<parameterizedType>>s unify if their type constructors unify, they have
the same number of type arguments, and those arguments pairwise unify.
+
For example,
[source,star]
----
cons[integer] = cons[integer]
----
but,
[source,star]
----
cons[integer] ≠ cons[string]
----
and
[source,star]
----
cons[integer] ≠ cons[integer]
----
and
[source,star]
----
cons[integer] ≠ cons[integer,string]
----


NOTE: In fact, the `cons` example -- with two type arguments instead of
one -- is not a valid type expression. This is because it is not
consistent with the type definition for `cons`.

==== Unifying Reference Types

Two `ref` types unify if their argument types unify

For example,
[source,star]
----
ref integer = ref integer
----
but,
[source,star,subs="quotes"]
----
ref integer ≠ ref string
----
and
[source,star]
----
ref integer ≠ cons[integer]
----

==== Unifying Tuple Types

Two <<tupleType>>s unify if they have the same number of elements,
and those elements unify in a pairwise fashion.

[source,star]
----
() = ()
----
and
[source,star]
----
(integer,string) = (integer,string)
----
and
[source,star]
----
(integer,string) = (integer,t)
----
where `t` is a type variable, with the additional effect
that `t` will be bound to the `string` type.

However,
[source,star]
----
() ≠ (())
----
because the second is actually a unary tuple containing a zero-tuple; and
[source,star]
----
(string,integer) ≠ (integer,string)
----
because elements must unify in a pairwise way.

==== Unifying Record Types

Fields in a record are not intrinsically ordered, but the spirit of
unification for records is similar to that of tuples:

Two record types unify iff:
* they have the same fields and embedded types
* each field's type in one record type unifies with the corresponding
field of the other record type
* each embedded type in one record unifies with the corresponding
embedded type of the other record type.

For example,
[source,star]
----
{} = {}
----
and
[source,star]
----
{ foo:integer. type bar } = { foo:t. type bar }
----
with `t` being bound to `integer`; whereas
[source,star]
----
{ foo:integer. } ≠ {bar:integer}
----
because the second record type does not have a `foo` field, and
the first does not have a `bar` field.

==== Unifying Function Types

Two function types unify iff their arguments unify and the result
unifies. Note that the simple function type does not unify with the
constructor function type.

[source,star]
----
(integer)=>integer = (t)=>t
----
where `t` is a type variable that is subsequently bound to
`integer`; whereas
[source,star]
----
(integer,string)=>integer ≠ (string,integer)=>integer
----
and
[source,star]
----
(integer,string)=>integer ≠ (integer,string)<=>integer
----

The throwing variant of function type only unifies with a throwing
function type:
[source,star]
----
(integer)=>integer throws string = (t)=>t throws e
----
where `t` is a type variable that is subsequently bound to
`integer` and `e` is bound to `string`; whereas
[source,star]
----
(integer,string)=>integer throws string ≠ (integer,string)=>integer
----
because non-throwing function types do not unify with throwing function types.

==== Unifying Type Variables

There are two sub-cases for unifying type variables:
. if either the left or the right terms are not type variables, then
_provided that_:
* the type variable does not itself appear in the non-variable type; and
* any type constraints on the type variable are satisfied by the
non-variable type;
then the two
types are unifiable.
+
NOTE: The first condition is known as an _occurs check_.
(((Occurs check)))
+
In addition, the fact of the unification is recorded as a binding for
the variable type. Thereafter, when unifying types, this binding must
be applied to all occurrences of the same type variable.
. if both left and right terms are type variables then the unification
is permitted; and the fact of the unification is recorded as a binding
for the variable that is bound. As for non-variable bindings, the
binding must be applied to all occurrences of the same type variable.
+
In addition, any type constraints on the type variables are
_merged_. If this merging is not possible then the two type
variables do not unify.
+
Type constraints are merged as follows, assuming that `t~a~`
is bound to `t~b~`:
.. for every contract constraint in `t~a~`, if a contract
contraint exists for `t~b~` with the same contract name, then
the two contracts must unify, otherwise it is appended to the
contraints for `t~b~`.
.. if there is a field constraint in `t~a~`, it is merged with
the corresponding field constraint for `t~b~`.

==== Unifying Quantified Types

Unifying quantified types is slightly more involved than that of other
forms of type. Two quantified types are unifiable iff they can be made
to be identical; however, a uantified type stands for all or some
type. In particular, two quantified types are considered to be
identical if they differ only in the name of the bound variable.

For example,
[source,star]
----
all x ~~ cons[x]
----
is equivalent to
[source,star]
----
all y ~~ cons[y]
----

Our rule for unifying two quantified types reflects this:

Two quantified types are unifiable if
* they are the same form of quantifier (`all` vs `exists`
* for some type name `t` that does not occur in either of them,
[source,star,subs="quotes"]
----
all x~~_T1_
----
is renamed to
[source,star]
----
all t~~_T1'_
----
where `_T1'_` is obtained from `_T1_` by systematically replacing
all occurrences of `x` by `t` -- except for any further
occurrences of `x` as a bound variable in a quantified type
within `_T1_`.

Similarly,
[source,star,subs="quotes"]
----
all y~~_T2_
----
is rewritten to
[source,star,subs="quotes"]
----
all t~~_T2'_
----
+
NOTE: Both `_T1_` and `_T2_` are rewritten using the same target name `t`.

Finally, the two quantified types unify iff
[source,star,subs="quotes"]
----
_T1'_ = _T2'_
----

NOTE: Because both `x` and `y` are bound type variables, they
cannot occur in any outer type terms -- should the quantified types be
part of larger type terms that are being unified there cannot be any
binding 'side effect' by rewriting either of `x` or `y`.

Some examples:
[source,star]
----
all a~~((cons[a])=>(a)) = all b~~((cons[b])=>(b))
----
these are equal because we can rename both `a` and `b` to `c`
and unify the bound types:
[source,star]
----
all c~~((cons[c])=>(c)) = all c~~((cons[c])=>(c))
----

However
[source,star]
----
all a~~(a)=>integer ≠ exists b~~(b)=>integer
----
because of the different quantifiers, and
[source,star,subs="quotes"]
----
all a~~(a)=>integer ≠ (_t_)=>integer
----
for any type _t_ because the latter type is not quantified.

=== Resolving Constraints

Expressions involving constrained types must be _resolved_ in order to be type
valid. Different constraints have different algorithms associated with their
resolution. However, in all cases, resolving a constraint typically involves a
combination of unifying two or more types and creating a value expression that
embodies the resolved constraint.

==== Resolving Contract Constraints

Contract constraints are resolved by looking for implementations in
scope.


For example, in the expression:

[source,star]
----
X+34
----

the arithmetic `+` operator is actually the name of a function, whose type from
the `arith` contract:

[source,star]
----
public contract all x ~~ arith[x] ::= {
  (+): (x,x)=>x.
  ...
}
----

which means that the type of `+` takes the form:

[source,star]
----
all x ~~ arith[x] |: (x,x) => x
----

For a given occurrance of ``+``, the identifier will have a type associated with
it of the form:

[source,star,subs="quotes"]
----
arith[_N~t~_] |: (_N~t~_,_N~t~_)=>_N~t~_
----

although in many cases, the type `_N~t~_` will be non-variable.

Resolving a contract constraint involves examining the effective environment and
looking for an appropriate implementation in that environment.

Arithmetic is implemented for a wide variety of types, including
potentially user defined types. Resolving the `arith` contract
constraint amounts to identifying the correct implementation that is
defined in the scope that the expression occurs in.

Each implementation of the `arith` contract takes the form

[source,star,subs="quotes"]
----
implementation arith[_type_] => _record_.
----

To resolve the `arith` constraint in the context of a use of ``+`` we perform
the following steps:

. Assuming that the type associated with the occurrence is as above: `_N~t~_`,
 * Let `NT` be the name of the type constructor of `_N~t~_`;
 * If there is no such type constructor (e.g., if the type is not bound to a non-type variable), then this algorithm stops.
. Let `A_N~t~_` be the type associated with an `implementation` of `arith` that is in the effective environment that has the same type constructor: `NT`.
 * If there is no such `implementation` then a type error results, and the algorithm stops.
. If `A_N~t~_` unifies with `_N~t~_` then the contract may be resolved, and the occurrence of the `+` identifier is rewritten to:
[source,star,subs="quotes"]
----
V_N~t~_.(+)
----
where `V_N~t~_` is the expression that is on the right hand side of the `implementation` statement.

To type check a whole program, the checker must systematically attempt to
resolve all the contract constraints discovered. If the checker cannot make
progress, i.e., if one or more of the constraints is insufficiently instantiated
to be able to identify a potential `implementation`, then the checker fails with
a type error.

Implementations can be viewed as functions whose value is a record of
all the elements of the defined contract. For example, the
implementation function of `arith` over `integer` has a
definition that is similar to:
[source,star]
----
arith#integer() => arith{ X+Y => _int_plus(X,Y) ...  }
----

Resolving the expression `X+43` is achieved by replacing the
abstract function `(+)` with an actual function:
[source,star]
----
arith#integer().'+'(X,43)
----

There are several special considerations when identifying
implementations of contracts: when an implementation refers to a
generic type; when a contract has one or more _dependent_ types;
and when a contract constraint appears in a generic function.

When a contract is implemented for a generic type, only the generic
type name itself is used to identify potential implementations. Thus,
it would not be possible, for example, to have two or more
implementations of `arith` for `cons[integer]` and
`cons[float]` in scope.

Where a contract has dependent type arguments, as in the `stream`
contract for example:

[source,star]
----
public contract all S,E ~~ stream[S->>E] ::= {
 _eof:(S) => boolean.
 ...
----

only the type name for the non-dependent type arguments are used to
identify the implementation of the contract.

Finally, for contract constraints appearing in generic functions, the
generic function must itself be appropriately constrained. For example, in

[source,star]
----
addSq : all t ~~ arith[t] |: (t,t)=>t.
addSq(X,Y)=>X+X*Y
----

we have explicitly annotated the type of `addSq` to be constrained by
the `arith` contract. This allows the contract constraints associated
with `X+X*Y` to be resolved by the function constraints rather than
looking for an explicit implementation of `arith`.

Note that annotating a function to be constrained in this way may result
in new requirements for any uses of the function -- whenever `addSq`
is used the `arith` constraint must be resolved in that context.
 
It is an error for the top-level of a program -- i.e., package-level
-- to contain unresolved references to contracts.

==== Resolving Implicit Constraints

Implicit constraints are resolved by looking for an associated
variable to be in scope.  For example, in the expression:

==== Resolving Field Constraints


A <<typeDefinition>> introduces a new type and defines what values
belong to the type.

A <<typeAnnotation>> is an assertion that a particular expression -- usually a
variable -- has a certain type.

