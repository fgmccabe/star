@node Expressions
@chapter Expressions


An expression is a form that denotes a @emph{value}. Evaluation is the
computational process of realizing the denoted value.

@float BNF,expressionFig
@caption{Expression}
@display
@anchored{Expression}::=@refer{Variable}
  | @refer{ScalarLiteral}
  | @refer{AlgebraicConstructor}
  | @refer{ApplicativeExpression}
  | @refer{ConditionalExpression}
  | @refer{CaseExpression}
  | @refer{Condition}
  | @refer{LetExpression}
  | @refer{ValueExpression}
  | @refer{AnonymousFunction}
  | @refer{MemoFunction}
  | @refer{TypedExpression}
  | @refer{QuotedExpression}
@end display
@end float

@quotation Note
This chapter does not cover all forms of expression. Other chapters
that address particular forms of expression include @refer{variables}
(variables), @refer{lists} (list expressions), @refer{strings} (string
expressions) and @refer{actors} (actors).
@end quotation

== Variables in Expressions [[varExpression]] (((variable))) A
variable as an expression is simply an occurrence of the variable's
identifier (see @refer{variableFig}).

==== Type Safety The type associated with a variable expression is
derived from the type recorded for the variable in the environment.
\begin{prooftree} \AxiomC{`( v`,T\sub{v}\ `)`$\in\ $E}
\UnaryInfC{\typeprd{E}{`v`}{T\sub{v}'}} \end{prooftree} where
`T\sub{v`'} is derived from `T\sub{v`} by means of
@emph{refreshing}. I.e., if `T\sub{v`} takes the form:
[listing][mathescape=true] for all t$\subi{}$ such that T

then `T\sub{v`'} is `T` with all occurrences of type variable `t\subi`
replaced with new type variables.


== Scalar Literal Expressions [[scalarExpression]]

There are three forms of scalar literal expression: numeric literals,
string literals and enumerated symbols.

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{ScalarLiteral}::=@refer{Integer}\\ | @refer{Long}\\ |
@refer{Float}\\ | @refer{Decimal}\\ | @refer{String}\\ |
@refer{EnumeratedSymbol} \end{eqnarray*} .Scalar Literals
[[scalarExpressionFig]] \end{figure}

=== 32-bit Integer Literals [[integerType]]
(((type,integer@`integer`)))

The `integer` type is used to denote integral values in the range
-2147483648..2147483647. In addition to the `normal' integers, there
is a special denoted value -- `nonInteger` -- that denotes an invalid
integer.

Integers may be written in a variety of styles (see
@refer{numericLiteral}; the most common form is the simple
@refer{Decimal} notation.

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{Integer}::=@refer{IntegerLiteral}\\ | @refer{Hexadecimal}\\
| @refer{CharacterCode} \end{eqnarray*} .Integer Literals
[[integerExpressionFig]] \end{figure}

\noindent The `integer` type is a so-called boxed type. Underlying the
`integer` type is the raw type that denotes numeric value itself.
(((type,integer@`integer`!raw)))

The `integer` type can be defined using: [listing] type integer is
integer(integer_)

where `integer\_` type is the raw type used internally to denote the
machine representation of a 32-bit integer.  [[rawInteger]]
@quotation Note
A raw `integer\_` is written with a trailing underscore: [listing] 34_

In general, for an integer literal: [listing] 34

is equivalent to the expression: [listing] integer(34_)

@end quotation

==== Largest and Smallest `integer`s The `largeSmall` contract is
implemented for `integer`s. This contract (see @refer{largeSmall})
defines the largest and the smallest `integer`s; its implementation is
equivalent to [listing] implementation largeSmall over integer is {
def largest is integer(0x7fffffff_); def smallest is
integer(0x80000000_); }


=== 64 bit Integer Literals [[longType]] (((type,long@`long`)))

The `long` type is used to denote integral values in the range
$-2^{63} \mbox{ to } 2^{63}-1$ footnote:[I.e.,
-9223372036854775808..{}9223372036854775807].

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{Long}::=@refer{Decimal}`L`\\ | @refer{Hexadecimal}`L`
\end{eqnarray*} .Long Literals [[longExpressionFig]] \end{figure}

As with `integer`s, the `long` type is a boxed type; is is defined
equivalently to: [listing] type long is long(long_)

The `long\_` type is a raw type used internally that denotes the
machine representation of a 64-bit integer. Raw `long\_` literals may
be written using the underscore suffix (after the long indicator):
[listing] 45l_


@quotation Note
There is no automatic conversion between `integer` values and `long`
values. The @refer{TypeCoercion} expression may be used to convert
between them. If `X` is an `integer` variable, then [listing] X as
long

may be used to convert its value to `long`.
@quotation Note
Where converting from `integer` to `long` does not lose any precision,
the same cannot be said for other conversions.
@end quotation
@end quotation

==== Largest and Smallest `long`s The `largeSmall` contract is
implemented for `long`s. This contract (see @refer{largeSmall})
defines the largest and the smallest `long` integers; its
implementation is equivalent to [listing] implementation largeSmall
over long is { def largest is long(0x7fffffffffffffffL_) def smallest
is long(0x8000000000000000L_) }



=== Floating Point Literals [[floatType]] (((type,float@`float`)))

The `float` type is used to represent fractional values. Floating
point numbers are represented as IEEE double precision -- i.e., 64
bit.

\begin{figure}[H] \begin{eqnarray*}
@anchored{Float}::=@refer{FloatingPoint} \end{eqnarray*} .Floating
Point Literals [[floatExpressionFig]] \end{figure}

==== Largest and Smallest `float`s The `largeSmall` contract is
implemented for `float`ing point numbers. Its implementation is
equivalent to [listing] implementation largeSmall over float is { def
largest is __bits_float(0x7fefffffffffffffL_) def smallest is
__bits_float(0x1L_) }


where `\_\_bits\_float` is a special function that allows a 64 bit bit
string to represent a floating point number (the bit string @emph{is}
the bit representation of the floating point number).

=== Decimal Number Literals [[decimalype]]
(((type,decimal@`decimal`)))

The `decimal` point type is used to denote arbitrary precision decimal
fractional values.

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{DecimalNumber}::=@refer{Decimal} \end{eqnarray*} .Decimal
Literals [[decimalExpressionFig]] \end{figure}

The `decimal` type is defined equivalently to: [listing] type decimal
is decimal(decimal_)

where `nonDecimal` is used to denote non-legal decimal values.

@quotation Note
`decimal` numbers are based on a decimal representation. This means
that `decimal` numbers can represent certain fractional values exactly
which `float` numbers cannot.

However, `decimal` computation is often substantially more expensive
than `float`ing point computation.
@end quotation

=== String Literals [[stringType]] (((type,string@`string`)))

The `string` type is used to denote string values.

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{String}::=@refer{StringLiteral} \end{eqnarray*} .String
Expression[[stringInterpolationFig]] \end{figure}

The `string` type is defined equivalently to: [listing] type string is
string(string_)

The simplest form of `string` literal is a sequence of characters
enclosed in double-quotes -- see @refer{string}.

In addition, quoted strings may include @emph{interpolation}
expressions -- which are embedded expressions whose values are
interpolated into the actual string value.

=== String Interpolation [[StringInterpolation]]
(((string,interpolation))) String interpolation refers to the
embedding of variables and expressions in string literals. The actual
string value of an interpolated `string` literal requires the
evaluation of those variables and expressions.

For example, given a variable `X` with the value 24, then: [listing]
"this has the value of X: $X" "$(X*X) people saw this"

would have values: [listing][mathescape=true] "this has the value of
X: 24" ${\rm and}$ "576 people saw this"

respectively.

There are two modes of string interpolation: the dollar form
corresponds to `display`ing a value and the hash form corresponds to
@emph{coercing} a value to a `string` value (see
@refer{typeCoercionExpression}). The former produces a string which is
intended to be parseable as the original value. It is also the form
that is universally supported by all non-programmatic types.

@quotation Note
If a `string` interpolation expression itself contains a string, the
various quoting mechanisms for strings apply to that string
also. I.e., it is not necessary to `double-quote' strings within
`string` interpolation expressions.

For example, the `string` expression in: [listing] logMsg(info,"The
price of cheese is $(priceOf("cheese"))");

works as expected: the argument to the `priceOf` function is the
string literal `"cheese"`. An even more nested example is: [listing]
logMsg(info,"The price of $P is $(priceOf("SKU$P"))");

In this example, we have a `string` interpolation expression embedded
within another `string` interpolation expression.
@end quotation

An @refer{Interpolation} expression may be followed by a
@refer{FormattingSpec}. If present, then this specification is used to
guide how values are formatted.

For example, the value of [listing]
"--\$(120345567):999,999,999,999;--"

is the string: [listing] "--120,345,567--"

Detailed formatting is controlled by the `format` contract -- see
@refer{formatContract} -- which in turn means that different types of
expression will have type appropriate ways of specifying the
formatting.

==== Semantics of String Interpolation

String variable interpolation expressions may refer to variables that
are in scope at the location of the string literal itself.

The meaning of a string interpolation is slightly different for the
two forms of interpolation. An expression of the form:
[listing][escapechar=|] "|_prefix_|$(|_Exp_|)|_suffix_|"

is interpreted as: [listing][mathescape=true]
"$_prefix_$"++display($_Exp_$)++"$_suffix_$"

whereas the expression: [listing][mathescape=true]
"$_prefix_$\#($_Exp_$)$_suffix_$"

is interpreted as being equivalent to: [listing][mathescape=true]
"$_prefix_$"++($_Exp_$ as string)++"$_suffix_$"


@quotation Note
The difference between `display` and `as` becomes most obviously
apparent with `string`s themselves. Assuming that the variable `L` is
bound to the `string` `"hello"`, the value of [listing]
"alpha#(L)beta"

is the string [listing] "alphahellobeta"

whereas the value of [listing] "alpha$(L)beta"

is [listing] "alpha\"hello\"beta"

But in general, there may be many differences between the two forms of
displayed value.
@end quotation

If a @refer{FormattingSpec} is present, then the translation takes
that into account also. For example, the expression:
[listing][escapechar=|] "|_prefix_|$(|_Exp_|):|_Format_|;|_suffix_|"

is equivalent to the expression: [listing][mathescape=true]
"$_prefix_$"++_format($_Exp_$,$_Format_$)++"$_suffix_$"

where `\_format` is part of the `format` contract -- see
@refer{formatContract}.

@quotation Note
Note that this translation is the same for either the `\$` or `\#`
interpolation form.
@end quotation


=== Enumerated Symbols [[enumeratedSymbol]] (((expression,enumerated
symbol))) (((enumerated symbol))) Enumerated symbols are written using
regular identifiers (see @refer{enumSymbolFig}). Such a symbol must
first have been declared within a type definition statement -- see
@refer{enumSymbol} -- which also determines the type of the symbol.

For example, the `boolean` type definition has two
@refer{EnumeratedSymbol}s in its definition: `true` and `false`. Thus
[listing] true

is an expression consisting of an @refer{EnumeratedSymbol} from the
definition: [listing] type boolean is true or false;


== Algebraic Constructor Expressions [[algebraicConstructors]]

The @refer{AlgebraicConstructor} expressions are those that refer to
constructors that are defined in @refer{AlgebraicType} definitions --
_or those that arise from standard type schemas such as tuples and
anonymous records_.

There are two primary forms of @refer{AlgebraicConstructor}s:
positional @refer{ConstructorLiteral} terms and @refer{RecordLiteral}
terms.

Records allow their fields to be addressed individually.

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{AlgebraicConstructor}::=@refer{EnumeratedSymbol}\\ |
@refer{ConstructorLiteral}\\ | @refer{TupleLiteral}\\ |
@refer{RecordLiteral}\\ | @refer{AnonymousRecord}\\ |
@refer{RecordAccess}\\ | @refer{SequenceExpression} \end{eqnarray*}
.Algebraic Constructor Expressions [[algebraicExpressionFig]]
\end{figure}


=== Enumerated Symbol [[enumeratedSymbol]] (((expression,enumerated
symbol))) (((enumerated symbol literal))) @refer{EnumeratedSymbol}s
denote symbolic values. In particular, it refers to symbols that are
introduced in an algebraic @refer{TypeDefinition}.
\begin{figure}[htbp] \begin{eqnarray*}
@anchored{EnumeratedSymbol}::=@refer{Identifier} \end{eqnarray*}
.Enumerated Symbol Expression [[enumeratedSymbolFig]] \end{figure}
Enumerated symbols have no internal structure; they are often used to
define enumerations or for sentinels. For example, the @refer{Boolean}
standard type can be defined [listing] type boolean is false or true

and the standard cons-list type uses `nil` to mark the empty list:
[listing] type cons[t] is cons(t,cons[t]) or nil


=== Constructor Literals [[positionalConstructor]]
(((expression,positional constructor))) (((positional constructor
literal))) @refer{ConstructorLiteral} expressions denote data
constructor values. In particular, it refers to constructors that are
introduced in an algebraic @refer{TypeDefinition}.
\begin{figure}[htbp] \begin{eqnarray*}
@anchored{ConstructorLiteral}::=@refer{Identifier}`(`@refer{Expression}`,`...`,`@refer{Expression}`)`
\end{eqnarray*} .Constructor Literal Expression
[[positionalConstructorFig]] \end{figure} This definition also
determines the valid types of the arguments to the constructor. For
example, the type definition: [listing] type address is noWhere or
someWhere(string,integer,string)

defines `someWhere` as the identifier of a @refer{ConstructorLiteral}
and any instance must have exactly three arguments: a `string`, an
`integer` and a `string`.

\paragraph{Accessing Elements of a Constructor Literal} (((positional
constructor literal,accessing elements))) The only way that elements
of a @refer{ConstructorLiteral} can be @emph{accessed} is via a
pattern match -- see @refer{posConPattern}. For example, given the
definition of `address` above, we can `unpack' its argument using a
pattern such as in [listing] city(someWhere(City,_,_)) is City


=== Tuples [[TupleTerms]] (((expressions,tuple))) (((tuples)))
(((informal combinations of elements))) A tuple consists of a sequence
of expressions separated by commas and enclosed in parentheses. In
effect, a tuple is a @refer{ConstructorLiteral} where the
@refer{Identifier} is omitted -- and is automatically generated.

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{TupleLiteral}::=`()`\\ | `((`@refer{Expression}`))`\\ |
`(`@refer{Expression}\sequence{,}@refer{Expression}`)`\plustwo
\end{eqnarray*} .Tuple Literal Expression [[tupleLiteralFig]]
\end{figure}

Tuples allow a straightforward of the `casual' grouping of values
together without requiring a specific type definition of a data
structure.
@quotation Note
Unlike @refer{ConstructorLiteral}s, tuples @emph{cannot} be defined
using a @refer{TypeDefinition}. Instead, the tuple types form a _type
schema_.
@quotation Note
Not a single type, because each arity of anonymous tuple type denotes
a different type. However, all tuples are related by their tuple-ness.
@end quotation
@end quotation

In that tuples can be used to group elements together, they are
somewhat similar to arrays. However, unlike arrays, each element of a
tuple may be of a different type, and also unlike arrays, tuple
elements may not be accessed via an indexing operation: tuples can
only be `unwrapped' by some form of pattern matching.

For example, if the `split` function splits a list into a front half
and back half, it may be used in a statement of the form: [listing]
def (F,B) is split(L)

which has the effect of unpacking the result of the `split` function
call and binding the variables `F` and `B` to the front half and back
half of the list `L`.


The tuple notation is unremarkable except for two cases: the single
element tuple and the zero element tuple.


==== Zero-ary Tuples [[zeroTuple]] (((tuple,zero-ary))) Zero-element
tuples @emph{are} permitted. A zero-element tuple, which is written
[listing] ()

is essentially a symbol.

==== Singleton Tuples (((single element tuples))) (((tuples,single
element))) Some special handling is required to represent tuples of
one element.

The principal issue is the potential ambiguity between a tuple with
one element and a normal operator override expression.

For example, [listing] (a+b)*c

is such a case: the inner term `(a+b)` is not intended to denote a
tuple but simply the sum of `a` and `b`.

A singleton tuple @emph{may} be written; by doubly parenthesizing
it. An expression of the form: [listing] ((34))

denotes a singleton tuple with the integer 34 in it.

@quotation Note
Fortunately, singleton tuples are not often required in programs.
@end quotation

=== Record Literals [[recordLiteral]] (((expressions,record literal)))
(((record literal))) A record literal is a collection of values
identified by name.

Like @refer{ConstructorLiteral}s, the @refer{RecordLiteral} must have
been defined with a @refer{TypeDefinition} statement. This also
constrains the types of the expressions associated with the fields.


\begin{figure}[H] \begin{eqnarray*}
@anchored{RecordLiteral}::=@refer{Record}\ |@refer{ThetaRecord}\\
@anchored{Record}::=@refer{Expression}`\{`@refer{RecordElement}\sequence{;}@refer{RecordElement}`\`}\\
@anchored{RecordElement}::=@refer{Identifier}\ `=`\
@refer{Expression}\\ | @refer{Identifier}\ `:=`\ @refer{Expression}\\
| `type`\ @refer{Identifier}\ `=`\ @refer{Type} \end{eqnarray*}
.Record Literal Expression[[recordLiteralFig]] \end{figure}


There are two variants of the @refer{RecordLiteral}: the
@refer{Record} form and the @refer{ThetaRecord} form. This section
focuses on the former.

For example, given the type definition: [listing] type employee is
emp{ name has type string; hireDate has type date; salary has type ref
integer; dept has type ref string; }

A literal `emp` value will look like: [listing] def E is emp{ name =
"Fred Nice"; hireDate = today(); salary := 23000; dept := "mail" }

@quotation Note
Fields whose type is a `ref`erence type -- see @refer{referenceType}
-- are defined within the record using the `:=` operator. All other
fields are defined using the `=` operator.
@end quotation

For any given @refer{RecordLiteral} @emph{all} the fields of the
record must be associated with a value. This value is either
explicitly given or can be supplied by a `default` declaration within
the type definition itself.

Fields within a @refer{RecordLiteral} are identified by name; and may
be written in any order.

=== Anonymous Records [[anonRecord]] (((expression,anonymous
records))) (((anonymous records)))

An anonymous record is one which does not have an explicit label.
\begin{figure}[htbp] \begin{eqnarray*}
@anchored{AnonymousRecord}::=`\{`@refer{RecordElement}`;`...`;`@refer{RecordElement}`\`}\\
| `\{`@refer{Definition}\sequence{;}@refer{Definition}`\`}
\end{eqnarray*} .Anonymous Record Literal
Expression[[anonRecordLiteralFig]] \end{figure}

For example, an anonymous record consisting of a `name` and an
`address` may be written: [listing] {name="Fred; address="1 Main St"}

Anonymous records have, as their type, a @refer{RecordType} (see
@refer{recordType}). The type of this record would be represented by:
[listing] { name has type string; address has type string}


=== Accessing Fields of a Record [[dotAccess]] (((record
literal,accessing))) (((expressions,accessing record fields)))

Record access expressions access the value associated with a field of
a record value. The result may either be the field value, or a new
record with a replaced field value.

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{RecordAccess}::=@refer{Expression}\ `.`\ @refer{Identifier}
\end{eqnarray*} .Record Access Expression[[recordAccessFig]]
\end{figure}

An expression of the form [listing] A.F

where `F` is the name of an attribute of the record `A` denotes the
value of that attribute. For example, given the type definition
[listing] type person is someone{ name has type string; age has type
integer; }

and a `person` value bound to `P`: [listing] def P is someone{
name="fred"; age=32 }

then the expression `P.name` has value `"fred"`.

The (`.`) access operator is also used in cases where an anonymous
record is used; for example given the record: [listing] def R is {
alpha = "a"; beta=4}

then `R.alpha` has value `"a"`
@quotation Note
The binding of the record access operator (`.`) is very strong. Thus,
expressions such as `A.L[ix]` and `A.F(a,b*3)` are equivalent to
[listing][mathescape=true] (A.L)[ix] ${\rm and}$ (A.F)(a,b*3)

respectively.
@end quotation

==== Type Safety The type safety of a record access expression is
couched in terms of @refer{AttributeConstraint}s: i.e., a record
access expression implies that a value satisfies the appropriate
@refer{AttributeConstraint}.

\begin{prooftree} \AxiomC{\typeprd{E}{R}{T\ `where`\ T\ `implements`\
`\{F has type `T\sub{f}`\`}}} \UnaryInfC{\typeprd{E}{R.F}{T\sub{f}}}
\end{prooftree}
@quotation Note
This formulation of the type safety of record access expressions
allows for some quite powerful usages. For example, the function:
[listing] getName(R) is R.name

has type: [listing] getName has type for all r,f such that (r)=>f
where r implements {name has type f}

In effect, we can define programs that depend on particular attributes
without having to be concrete about the actual types of the records
being accessed.
@end quotation

=== Theta Records [[thetaRecords]] (((record literal,theta))) (((theta
record)))

A @refer{ThetaRecord} is a record whose contents is specified by means
of a @refer{thetaEnvironment}. There are variants corresponding to
labeled and anonymous records.  \begin{figure}[htbp] \begin{eqnarray*}
[[ThetaRecord]ThetaRecord::=[@refer{Expression}]]`\{`@refer{Definition}\sequence{;}@refer{Definition}`\`}
\end{eqnarray*} .Theta Record Literal
Expression[[thetaRecordLiteralFig]] \end{figure}

Externally, a @refer{ThetaRecord} is the same as a regular
@refer{Record}; internally, however, its fields are defined very
differently using @refer{Definition}s rather than attribute
assignments.

If the record is labeled, then, as with all labeled records, the
definitions within the @refer{thetaEnvironment} must correspond
exactly to the type definition.

@refer{ThetaRecord}s are especially convenient when the fields of the
record are program values. For example, assuming a type definition
such as: [listing] type onewayQ of t is onewayQ{ add has type (t)=>();
take has type ()=>t; }

the literal: [listing] onewayQ{ private var Q := list of []; prc
add(X) do { Q := list of [Q..,X] } take() is valof{ def H is head(Q);
Q := tail(Q); valis H } }

defines a `onewayQ` record with two exposed program values -- `add`
and `take`.

@quotation Note
If there are `extra' definitions, they should be marked `private`
which will exclude them from the record's type signature.
@end quotation

@quotation Note
A @refer{ThetaRecord} has many of the characteristics of an object in
OO languages -- except that there is no concept of inheritance; nor is
there a direct equivalence of the `self` or `this` keyword.
@end quotation

==== `private` fields [[privateField]] (((private fields@`private`
fields))) (((fields,private@`private`))) A definition within a
@refer{ThetaRecord} that is marked `private` does @emph{not}
`contribute' to the external type of the record; and neither can such
an attribute be accessed via the @refer{RecordAccess} expression.

=== Record Substitution Expression [[recordOverride]] (((replacing
values in a record))) (((expressions,substitute@`substitute`)))
(((record values,replacing fields))) An expression of the form:
[listing][mathescape=true] A substitute
{att$\sub1$=$@refer{Expression}\sub1\sequence{;}$att$\subn$=$@refer{Expression}\subn$}

denotes the value obtained by replacing the attributes `att`\subi{} in
`A` with the expressions @refer{Expression}\subi.

\begin{figure}[htbp] \begin{eqnarray*}
_Expression_&\arrowplus&@refer{Expression}\ `substitute`\
@refer{AnonymousRecord} \end{eqnarray*} .Record Override
Expression[[recordOverrideFig]] \end{figure}

For example, the expression [listing] P substitute {age=33}

has value [listing] someone{name="fred"; age=33}

@quotation Note
This expression has a separate value to that of `P` itself; evaluating
the `substitute` does not side-effect `P`.
@end quotation

\noindent The semantics of `substitute` is based on the notion of a
`shallow copy'. The value of the expression: [listing] P substitute {
age=33 }

is a new term whose fields consist of all the fields of `P` -- with
the exception of the `age` field. The `substitute` expression does not
imply a `deep' or complete copy of its left hand side.
@quotation Note
(((expressions,substitute@`substitute`!ref fields@`ref` fields)))
(((record values,replacing ref fields@replacing `ref` fields))) (((ref
field@`ref` field))) This only has significance if the record contains
any `ref` fields. In particular, the resulting expression
@emph{contains} the same `ref` fields as the original; and a
subsequent assignment to a `ref` field will affect both the original
and the substituted term.

For example, given this type definition: [listing] type account is
account{ name has type string; balance has type ref float; }

and given the variable bindings: [listing] def A is account{ name =
"fred"; balance := 0.0 }; def B is A substitute { name = "peter" }

then `A` and `B` both share the @emph{same} `ref` field. An assignment
to one: [listing] A.balance := 5.9

is an assignment to the other. In this case, the value of `B.balance`
is also `5.9`
@end quotation
@quotation Note
Note that if the _right hand side_ of a `substitute` contains a `ref`
field, then the result will have the `ref` field from the right hand
side, not the original.

For example, if we have: [listing] def C is A substitute { balance :=
4.5 }

then `C` _does not_ share a `ref` with `A` and updating either will
not affect the other.
@end quotation

==== Type Safety The type safety of an attribute substitute expression
is couched in terms of @refer{AttributeConstraint}s.
\begin{prooftree} \AxiomC{\typeprd{E}{R}{T\sub{R}\ `where`\ T\sub{R}\
`implements`\ T\sub{S}}} \AxiomC{\typeprd{E}{S}{S\sub{S}\ `where`\
S\sub{S}\ `implements`\ T\sub{S}}} \BinaryInfC{\typeprd{E}{R\
`substitute`\ S}{T\sub{R}}} \end{prooftree} The implication is that
the `substitution' record `S` only contains attributes that are also
present in the `substitute' expression `R`.

== Optional Expressions [[optionExpression]] (((option
expression@`option` expression)))

An `option` expression is used to handle cases where a value is not
always guaranteed. The `option` type is built-in but is defined as
though by the algebraic type definition in
Program~\vref{optionTypeProg}.

\begin{program} [listing] type option of t is none or some(t)

.The `option` Type [[optionTypeProg]] \end{program}

The `option` type is intended to convey one of two possibilities: a
given value exists -- in which case the `some` constructor is used --
or no value exists -- in which case `none` is used.

For example, [listing] some("alpha")

signals the definite `string` value `"alpha"`; whereas [listing] none

signals that there is no value.

The `option` type can be used as the return type of functions that
must reliably signal whether or not a value exists.
@quotation Note
The `option` type serves as a normal `replacement' for `null` that one
sees in languages like Java.
@end quotation

In addition to the `someValue` and `?.` operators -- described below
in @refer{someValue} and @refer{optionChaining} -- two conditions are
defined specifically for `option` expressions: `present` (see
@refer{presentCond}) and `has value` (see @refer{hasValueCond}).

=== Unwrap Option Value -- `someValue` [[someValue]] (((unwrap option
value)))

The `someValue` unwraps a `some` value and returns its contents. It is
defined by the equation:

[listing] someValue(some(X)) is X


@quotation Note
@quotation Note
The `someValue` function is partial. It is not defined in the case
that its argument is not a `some` value. If `someValue` is invoked
with q{none} then the program will terminate.

For this reason, the programmer should consider whether the `has
value` condition (see @refer{hasValueCond}) is a better fit.
@end quotation
@end quotation

=== Option Field Access -- `?.` [[optionChaining]] (((?. operator@`?.`
operator))) (((accessing an optional value))) (((option chaining)))

The `?.` operator can be used similarly to a normal record field
access (see \vref{dotAccess}) except that it takes an `option`al
argument and returns an `option` value.

\begin{figure}[htbp] \begin{eqnarray*}
@refer{RecordAccess}&\arrowplus&@refer{Expression}\ `?.`\
@refer{Identifier} \end{eqnarray*} .Optional Record Access
Expression[[optionAccessFig]] \end{figure}

The form of a optional field access is also similar to the field
access; an expression of the form: [listing] A?.F

will access the `F` field from the wrapped record value in `A`. The
result type of a option field access is also an `option`al.

For example, suppose that `R` has the type given by [listing] R has
type option of Person


Its type can be approximated by (the difference is that field labels
are not themselves functions): [listing] (?.) has type for all r,s
such that (option of r,(r=>s))=>option of s

I.e., it has a similar type to the `map` function (see
\vref{mapFunction}) in the `mappable` contract.

However, it is actually best understood as a macro form. The macro
definition of `?.` can be given in a single line macro: [listing] #?R
?. ?F ==> map((RR)=>RR.F,R)

where `map` is the implementation of the `mappable` contract for the
`option` type.

=== Default Option Expression -- `or else` [[optionDefltChain]] (((or
else operator@`or else` operator))) (((accessing an optional value
with default))) (((option chaining)))

The `or else` operator can be used to unwrap an `option`al value --
giving a default in the case that it is actually `none`

\begin{figure}[htbp] \begin{eqnarray*}
@refer{Expression}&\arrowplus&@refer{Expression}\ `or else`\
@refer{Expression} \end{eqnarray*} .Optional Chaining with
Default[[optionIndexAccessFig]] \end{figure}

The form of a optional access is: [listing] O or else D

where `O` has type `option of t` and `D` has type `t`. If `O` has
value `some(X)` then the value is `X`, otherwise it is `D`.

Like `?.`, `or else` can be best understood as a macro: [listing] # ?O
or else ?D ==> _optionDeflt(O,()=>D) _optionDeflt(some(X),_) is X |
_optionDeflt(none,D) is D()

Notice that the default expression is not evaluated unless the value
of `O` is `none`.

The `or else` operator is right associative. This means that they can
be chained together if more than one default is possible: [listing] A
or else B or else C


== Collection and Sequence Expressions [[sequenceExpression]]
(((sequence,expressions))) (((expressions,sequence)))
(((of@`of`,expression)))

Collection expressions and sequence expressions are a syntactic
feature that make it straightforward to represent collective
values. The difference between a `collection` and a `sequence` is that
the latter embodies a sequential ordering of the elements. A
`collection` may have an ordering present; but that is not required by
the contract and is not enforced in the notation.


A sequence expression represents a use of the standard `sequence`
contract (see Program~\vref{sequenceContractDef}) to construct
sequences of values.

@quotation Note
There is a similar form to @refer{SequenceExpression} which is used to
denote @emph{queries} -- the programmer's analog of set
abstractions. @refer{Query} expressions are defined in
Chapter~\ref{queries}.
@end quotation

\begin{figure}[htbp] \begin{eqnarray*}
_Expression_&\arrowplus&@refer{SequenceExp}\\
[[SequenceExp]SequenceExp::=@refer{SequenceType}\
`of``[`@refer{ExpSequence}`]]`\\ | `[`@refer{ExpSequence}`]`\\
[[ExpSequence]ExpSequence::=[@refer{Expression}`..,`]@refer{Expression}\sequence{,}@refer{Expression}[`,..`@refer{Expression}]]\\
@anchored{SequenceType}::=@refer{Identifier} \end{eqnarray*} .Sequence
Expression [[sequenceExpressionFig]] \end{figure} I.e., a sequence
expression consists of a sequence of @refer{Expression}s separated by
commas. In addition, either -- but not both -- the tail or the front
of the sequence may be denoted by an expression. Otherwise the
sequence is nil-terminated.

An expression of the form: [listing][escapechar=|] |_Label_| of
[|_E\sub1_\sequence{,}_E\subn_|]

is equivalent to the expression: [listing][escapechar=|]
_cons(|_E\sub1_\sequence{,}|_cons(|_E\subn_|,_nil())|\sequence{}|) has
type |_Label_| of %t|\sub{new}|

_provided that \emph{Label_ is the label of a @refer{Type} that
implements the `sequence` contract} -- see @refer{sequenceContract}
and where `\%t\sub{new`} is a new type variable not occurring
elsewhere. Included in that contract are two functions -- denoting the
empty sequence (`\_nil()`) and a non-empty sequence (`\_cons()`) --
that are used to build the true value of a sequence expression.

A sequence can be built up from other sequences by prepending to
them. An expression of the form: [listing][escapechar=|] |_Label_| of
[|_E\sub1_\sequence{,}_E\sub{n-1_}`,..`_E\subn_|]

is equivalent to the expression: [listing][escapechar=|]
_cons(|_E\sub1_\sequence{,}|_cons(|_E\sub{n-1_}|,|_E\subn_|)|\sequence{}|)


Conversely, a sequence may be `front' loaded and be defined by
appending elements to a `front' expression: [listing][escapechar=|]
|_Label_| of [|_F_`..,`_E\sub1_\sequence{,}_E\subn_|]

is equivalent to the expression: [listing][escapechar=|]
_apnd(|\sequence{}|_apnd(|_F_|,|_E\sub1_|)|\sequence{}_E\subn_|)


@quotation Note
It is also possible to have a sequence expression is that is _both_
front-loaded and back-loaded: [listing][escapechar=|] |_Label_| of
[|_F_|..,|_M_|,..|_T_|]

is equivalent to: [listing][escapechar=|]
_apnd(_cons(|_F_|,|_M_|),|_T_|)

which, in turn, is equivalent to: [listing][escapechar=|]
_cons(|_F_|,_apnd(|_M_|,|_T_|))

@end quotation

==== Type Safety Since a sequence expression is essentially a macro
for the use of the `sequence` contract, its type safety determined by
the `sequence` contract in Program~\vref{sequenceContractDef}.

== Index and Slice Notation [[indexNotation]] (((index notation)))
(((notation for indexed access)))

In a similar vein to the @refer{Sequence} notation, the
@refer{IndexExp} notation provides a high-level notation for accessing
elements and subsets of collections.

\begin{figure}[htbp] \begin{eqnarray*}
_Expression_&\arrowplus&@refer{IndexExp}\\
@anchored{IndexExp}::=@refer{Index}\ |\ @refer{IndexWith}\ |\
@refer{Slice}\\ [[Index]Index::=@refer{Expression}\
`[`@refer{Expression}`]]`\\
[[IndexWith]IndexWith::=@refer{Expression}\ `[``with`\
@refer{Expression}`->`@refer{Expression}`]]`\\ | @refer{Expression}\
`[``without`\ @refer{Expression}`]`\\
[[Slice]Slice::=@refer{Expression}\
`[`@refer{Expression}`:`@refer{Expression}`]]`\\ | @refer{Expression}\
`[`@refer{Expression}`:``]` \end{eqnarray*} .Index and Slice
Expressions [[indexExpressionFig]] \end{figure}

@quotation Note
There is some subtlety in the interpretation of index expressions;
depending on whether the @refer{IndexExp} is an expression, or whether
it is the left hand side of an assignment: [listing] L[Ix] := E


In the sections that follow, and in @refer{sequenceUpdate}, we show
the different interpretations of an index expression.
@end quotation

=== Accessing Elements of a Collection [[indexedAccess]] (((indexed
access to collection))) (((access list with index))) An expression of
the form: [listing] C[ix]

is equivalent to the expression [listing] _index(C,ix)

@quotation Note
The type of the resulting value from an indexed access is `option`al
-- see @refer{optionExpression}. I.e., since it cannot be guaranteed
-- in general -- that the element exists, the resulting type expresses
that uncertainty.

You can extract the underlying value by using the `someValue` function
-- see @refer{someValue} -- but a safer way is to use a `has value`
condition (see @refer{hasValueCond}.
@end quotation

The presence of an element can be tested in one of two ways: by using
the `present` predicate -- see @refer{presentCond}: [listing] present
C[Ix]

which tests whether `C` has an element at index `Ix` or using the
special condition: [listing] C[Ix] has value V

which are equivalent to [listing] _index(C,Ix) matches some(_)

and [listing] _index(C,Ix) matches some(V)

respectively.

=== Substitutions in a Collection It is possible to denote the
collection obtained by @emph{substituting} an element -- or deleting
an element -- with expressions such as: [listing] C[with Kx->Vx]

and [listing] C[without Kx]

which represent [listing] _set_indexed(Cx,Kx,Vx)

and [listing] _delete_indexed(Cx,Kx)

respectively.

=== Slicing Collections A more powerful form of accessing single
elements from a collection is the @emph{slice} notation. A slice
expression takes the form: [listing][escapechar=|]
|_C_|[|_From_|:|_To_|]

which denotes the subset of elements `starting' at `@emph{From}` and
`ending' (but _not_ including) with `_To_`.

The special variant: [listing][escapechar=|] |_C_|[|_From_|:]

denotes all the remaining elements of the collection after `From`.

@quotation Note
Related to the indexing and slicing expressions are the indexed
assignments -- as can be seen in @refer{sequenceUpdate}.
@end quotation

== Function Application Expressions [[functionApplication]]
(((expressions,function application))) (((function application
expression)))

A function application expression `applies' a function to zero or more
arguments.

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{ApplicativeExpression}::=@refer{Expression}`(`@refer{Expression}\sequence{,}@refer{Expression}`)`
\end{eqnarray*} .Function Application Expression
[[applicativeExpressionFig]] \end{figure}

It is quite normal for the function expression being applied to
arguments itself to be the result of a function application. For
example, given the function `double`: [listing] double has type for
all s such that (((s)=>s))=>((s)=>s) double(F) is (X) => is F(F(X))

we can apply `double` to `inc`: [listing] inc has type
(integer)=>integer inc(X) is X+1;

to get an expression such as: [listing] double(inc)(3)

which has value 5.

==== Type Safety [[functionApplyType]] (((type,function application)))
The primary type safety rule for function application is that the
types of the arguments of the application match the argument types of
the function. The type of the resulting expression is the return type
associated with the function.

\begin{prooftree}
\AxiomC{\typeprd{E}{`F`}{`(`t\sub1\sequence{,}t\subn`)=>`t}}
\AxiomC{\typeprd{E}{`e\sub1`}{t\sub1}\sequence{\
}\typeprd{E}{`e\subn`}{t\subn}}
\BinaryInfC{\typeprd{E}{`F(e\sub1`\sequence{,}`e\subn)`}{t}}
\end{prooftree}

== Control Expressions [[controlExpression]] The so-called control
expressions involve and modify the meaning of other expressions and
actions.

=== Conditional Expressions [[conditionalExpression]]
(((expressions,conditional))) (((conditional expression)))

A conditional expression applies a predicate @refer{Condition} to
decide whether or not to `take' the `then' branch or the `else'
branch.

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{ConditionalExpression}::=`(`@refer{Condition}`?`@refer{Expression}`:`@refer{Expression}`)`
\end{eqnarray*} .Conditional Expression [[conditionalExpressionFig]]
\end{figure}

The value of a conditional expression depends on whether the
@refer{Condition} is satisfiable or not. If the @refer{Condition} is
satisfiable, then the expression is equivalent to the `then' branch of
the conditional expression; otherwise it is equivalent to the `else'
branch.

For example, the expression: [listing] (P in members ? X>Y : X<Y)

is equivalent to one of `X>Y` or `X<Y` depending on whether the
@refer{Condition}: [listing] P in members

is satisfiable -- i.e., has at least one solution.

The condition of a conditional expression may introduce variables,
depending on the form of the condition -- for example, if the
@refer{Condition} is a @refer{SearchCondition} condition like that
above. These variables are `in scope' within the `then' part of the
conditional expression but are @emph{not} in scope for the `else'
part.

\paragraph{Evaluation Order} The only guarantees as to evaluation of a
conditional expression are that \begin{enumerate} \item the
conditional will be evaluated prior to evaluating either arm of the
conditional \item only one of the arms will be evaluated -- depending
on the value of the condition.  \end{enumerate}

==== Type Safety The type safety requirements of a conditional
expression are that the types of the two arms of the conditional are
the same, and that the condition itself is \safeinf{}:

\begin{prooftree} \AxiomC{\typesat{E}{C}} \AxiomC{\typeprd{E}{Th}{t}}
\AxiomC{\typeprd{E}{El}{t}}
\TrinaryInfC{\typeprd{E}{`(`C`?`Th`:`El`)`}{t}} \end{prooftree}


=== Switch Expressions [[caseExpression]]
(((expressions,case@`case`))) (((case expression@`case` expression)))

A `switch` expression uses a selector expression and a set of
equations to determine which value to return.
@quotation Note

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{CaseExpression}::=`switch`\ @refer{Expression}\ `in`\
@refer{CaseBody}\\
@anchored{CaseBody}::=`\{`@refer{CaseArm}\sequence{`;`}@refer{CaseArm}`\`}\\
@anchored{CaseArm}::=`case`\ @refer{Pattern}\ `is`\
@refer{Expression}\\ | `case`\ @refer{Pattern}\ `default`\ `is`\
@refer{Expression} \end{eqnarray*} .Case Expression
[[caseExpressionFig]] \end{figure}

The `selector' expression is evaluated, and then, at most one of the
@refer{CaseArm}s is selected based on whether the @refer{Pattern}
matches or not. If one of these does match, then the corresponding
@refer{Expression} on the right hand side is evaluated as the value of
the `switch`.

Program~\vref{dogCaseProg} shows a simple example of a `switch`
expression, in this mapping `string`s to `integer`s.  \begin{program}
[listing] switch Alpha in { case "dog" is 1; case "pup" is 2; case _
default is -1 }

.A `case` of Dogs Program[[dogCaseProg]] \end{program}


Each @refer{CaseArm}'s pattern may introduce variables; these
variables are `in scope' only for the corresponding right hand side
expression.

Optionally, a `switch` expression may have a `default` clause. This
clause determines the value of the expression if none of the other
@refer{CaseArm}s match.

@quotation Note
The @refer{Pattern} associated with a `default` should always
apply. If the `default` clause does not match then an exception will
be raised.
@end quotation

\paragraph{Evaluation Order} Other than handling of the `default`
case, the different @refer{CaseArm}s are attempted in the order of
appearance in the text.

I.e., the `default` @refer{CaseArm} is tried only if all other
@refer{CaseArm}s do not apply.

==== Type Safety The type safety requirements of a `case` expression
are that the types of the patterns of each @refer{CaseArm} are the
same, and are the same as the selector expression. In addition, the
right hand sides of the @refer{CaseArm}s should also be consistently
typed.

\begin{prooftree} \AxiomC{\typeprd{E}{S}{T}}
\AxiomC{\typeprd{E}{P\subi}{T}}
\AxiomC{\typeprd{E$\cup{}$varsIn(P\subi)}{E\subi}{T\sub{e}}}
\TrinaryInfC{\typeprd{E}{`switch`\ S\ `in\{`\sequence{}`;``case`\
P\subi\ `is`\ E\subi`;`\sequence{}`\`}}{T\sub{e}}} \end{prooftree}

In the case that there is a `default` clause, then that too must
agree: \begin{prooftree} \AxiomC{\typeprd{E}{S}{T}}
\AxiomC{\typeprd{E}{P\subi}{T}}
\AxiomC{\typeprd{E$\cup{}$varsIn(P\subi)}{E\subi}{T\sub{e}}}
\TrinaryInfC{\typeprd{E}{`switch`\ S\ `in\{`\sequence{}`;``case`\
P\subi\ `is`\ E\subi`;`\sequence{}`case`\ P\subn\ `default`\ `is`\
E\subn`\`}}{T\sub{e}}} \end{prooftree}

`switch` expressions may not be used that often explicitly. However,
the compiler will often construct them during the process of compiling
functions.
@end quotation

=== Let Expressions [[letExpression]] (((expressions,let
expression@`let` expression))) (((let expression@`let` expression)))

A `let` expression allows an expression to be defined in terms of
auxiliary definitions. There are two forms of the
@refer{LetExpression} -- allowing the programmer to choose whether the
auxiliary definitions should precede the bound expression or follow
it.

In addition, it is possible to use a record-valued expression in place
of the set of definitions.

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{LetExpression}::=`let`\ @refer{thetaEnvironment}\ `in`\
@refer{Expression}\\ | @refer{Expression}\ `using`\
@refer{thetaEnvironment} \end{eqnarray*} .Let Expression
[[letExpressionFig]] \end{figure}

(((theta environment))) A `let` expression consists of a body -- which
is a @refer{thetaEnvironment} -- and a bound
@refer{Expression}. Within the @refer{thetaEnvironment} may occur any
of the permitted forms of definition: function definitions, variable
definitions, type definitions, and so on. The scope of these
definitions includes the bound expression.

@quotation Note
`let` expressions are an important program structuring tool for
programmers. It is worth emphasizing that `let` expressions are
expressions! They can be used in many, perhaps unexpected, places.

For example, a `sort` function may require a comparison predicate in
order to operate. This can be supplied as a named function: [listing]
pComp has type (person,person)=>boolean
pComp(someone{name=N1},someone{name=N2}) is N1<N2

def S is sort(L,myCompare)

Or, the same may be achieved where the call to `sort` is not so
conveniently close to a theta environment: [listing] sort(L, let{
pComp has type (person,person)=>boolean |
pComp(someone{name=N1},someone{name=N2}) is N1<N2 } in pComp)

The `let` expression has major applications when constructing
function-returning functions.
@end quotation

==== Type Safety The primary safety requirement for a `let` expression
is that the statements that are defined within the body are type
consistent. This is the same requirement for any theta environment.

The type of a `let` expression is the type of the bound expression.


=== Memo Function [[memoFunction]] (((memo function)))
(((expressions,memo)))

A `memo` function encapsulates a single expression as a zero arity
function that is guaranteed to be evaluated only once.

A `memo` function is a function that `remembers' the value it first
returned. Subsequent invocations of the function simply return that
first value.

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{MemoFunction}::=`memo`\ @refer{Expression} \end{eqnarray*}
.Memo Function [[memoFunctionFig]] \end{figure}

Memo functions have an important role in cases where a group of
variables is mutually recursive; a situation that is not normally
permitted. For example, consider the pair: [listing] def Jack is
someone{ def name is "jack"; spouse() is Jill } def Jill is someone{
def name is "jill"; spouse() is Jack }

assuming this type definition: [listing] type Person is someone{ name
has type string; spouse has type ()=>Person; }


This pair of definitions is not permitted because the value of `Jack`
depends on the variable `Jill`, which in turn depends on `Jack`.
@quotation Note
The reason it is not permitted is that partially constructed values
are not permitted. In fact, any attempt to actually compute this pair
of values would simply result in an infinite loop.
@end quotation

However, the very similar pair of definitions: [listing] JackF() is
someone{ def name is "jack"; spouse() is JillF() } JillF() is someone{
def name is "jill"; spouse() is JackF() }

is permitted -- because mutually recursive functions are
permitted. However, in some cases, especially those involving internal
state, a call to normal zero-arity function is not equivalent to the
result of the function. In this example, each invocation of `spouse`
results in a new value; whose state is independent of other instances.

To permit this, the `memo` function is semantically a function; but
since each time it is called it is guaranteed to return the identical
result it has the same semantics as a shared variable: [listing] def
JackM is memo someone{ def name is "jack"; spouse() is JillM() } def
JillM is memo someone{ def name is "jill"; spouse() is JackM() }


==== Evaluation Semantics As noted above, the primary guarantee that a
`memo` function offers is that it's expression is only evaluated once.

An expression of the form: [listing][escapechar=|] memo
|@refer{Expression}|

denotes a function value. Each time the `memo` expression is evaluated
a new function value is `created'. In this regard, a `memo` function
is no different to an `ordinary' anonymous function.

@quotation Note
The only sense in which it makes a material difference how `memo`
functions are computed is through the binding of free variables within
the`memo`'d expression.

In general, each evaluation of a `memo` function -- or a `function`
expression -- may result in different bindings for free variables
within the @refer{Expression}.

If the function has no free variables then the compiler @emph{may}
simply construct a static entity for the function.
@end quotation

When a `memo` function is entered then one of three possibilities may
occur: either the `memo` function has never been entered, the `memo`
function has already returned a value or there is a concurrent
activity that is computing `within' the function.

\begin{itemize} \item If the `memo` function has never been entered
before then its expression is evaluated, recorded internally within
the function, and the computed value is returned as the value.  \item
If the `memo` function has previously returned then the recorded value
is returned.  \item If the `memo` function is currently being computed
then the call is blocked until the ongoing computation is
completed. At which point the call is handled in the same way as a
subsequent call to the `memo` function.  \end{itemize}

==== Type Safety The type of a `memo` function is determined by the
type of the memo'd expression:

\begin{prooftree} \AxiomC{\typeprd{E}{M}{T\sub{M}}}
\UnaryInfC{\typeprd{E}{`memo`\ M}{`()=>`T\sub{M}}} \end{prooftree}

=== Value Expressions [[valueExpression]] (((valof expression@`valof`
expression))) (((expressions,valof@`valof`)))

The `valof` expression computes a result based on the execution of a
sequence of actions; the last (executed) action being a `valis`
action.

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{ValueExpression}::=`valof`\ @refer{ActionBlock}\\ | `valof`\
@refer{Expression} \end{eqnarray*} .Valof Expressions
[[valueExpressionFig]] \end{figure}

There may be a number of actions within the `valof` action; however,
when a `valis` action is executed the `valof` is terminated and the
value of the `valof` expression is the value associated with the
`valis` action.

@quotation Note
Each `valof` expression must contain at least one `valis` action. The
execution of any of the `valis` actions terminates the `valof` itself;
it acts much like a `return` in other programming languages.
@end quotation

The `valof` expression is useful for those occasions where it is
necessary to side-effect some variable as part of evaluation of an
expression. The classic example of this is the counter, as illustrated
in Program~\vref{counterProg}.  \begin{program} [listing] var Count :=
0; counter has type ()=>integer; counter() is valof{ Count := Count+1;
valis Count };

.A Counting Program[[counterProg]] \end{program}
@quotation Note
Although the `valof` expression form @emph{allows} functions to be
written in a procedural style, their use should be minimized to those
cases where it is essential. In general, procedural programs are
harder to debug and maintain and, furthermore, limit the potential for
highly parallel execution.
@end quotation

==== Type Safety A `valof` expression is type safe if each of the
actions contained within it are type consistent, and its type is the
type of the expression referenced in the `valis` actions within the
body of the `valor`.

The type of a `valof` expression is the type of the expression
associated with the `valis` actions embedded within it.

\begin{prooftree} \AxiomC{\typesafe{E}{A}} \AxiomC{\typeprd{E}{V}{T}}
\AxiomC{$`valis`\ E\in A$} \TrinaryInfC{\typeprd{E}{`valof`\ A}{T}}
\end{prooftree}
@quotation Note
The \safeinf{} meta-predicate is used of actions; and is true iff the
action is consistent in its use of variables and types. See
@refer{actionTypeSafety}.
@end quotation

== Quoted Expressions [[quotedText]]

The `quote` expression is used to `convert' a fragment of *Star*
source text into a form that can be processed by *Star* programs.

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{QuotedExpression}::=`quote(`@refer{QExpression}`)`\\ |
`<|`@refer{QExpression}`|>`\\
@anchored{QExpression}::=`unquote(`@refer{Expression}`)`\\ |
`?`@refer{Expression}\\ | @refer{Expression} \end{eqnarray*} .Quoted
Expressions [[quotedExpressionFig]] \end{figure}


(((quoted expression notation))) There are two forms of quoted forms:
using the `quote` keyword -- together with the `unquote` keyword --
and special `<| |>` brackets -- with embedded `?` marks. Semantically
they are identical; except that the latter is potentially a little
easier to use.

The `quote` expression takes the form: [listing][escapechar=$]
quote($_SyntacticForm_$)

Alternately, the special `<|` brackets `|>` may be used:
[listing][mathescape=true] <|$_SyntacticForm_$|>

The type of a `quote` expression is `quoted` -- whose description is
shown in Program~\vref{quotedProg}.

_SyntacticForm_ may be any valid *Star* term; it is @emph{not} checked
apart from correct use of operators. It does not have to be
syntactically valid -- again, with the exception that operators must
balance appropriately.
@quotation Note
One of the salient differences between the `quote` form of a quoted
expression and the `<|` bracketed `|>` form is that the maximum
priority of operators in the latter form is 2000 whereas it is 1000
within the `quote` form.
@end quotation

For example, the expression: [listing] <|A+45|>

is equivalent to the expression: [listing][mathescape=true]
applyAst(L$\sub1$,nameAst(L$\sub2$,"+"),[nameAst(L$\sub3$,"A"),
integerAst(L$\sub4$,45)])

Note that the various `L\subi` refer to `astLocation` terms and that
no check is made whether the `variable' `A` is defined or of the right
type.


=== Unquoting Within a `quote`d expression, the `unquote` term -- or,
equivalently, the `?` term, can be used to escape the quoting
mechanism and insert variable text.

For example, in the expression: [listing] <| ?A + 45 |>

the identifier `A` now does refer to a normal variable -- whose type
must be `quoted`. If, say, `A` had the value: [listing] <| "fred" |>

then the above expression is equivalent to: [listing] <| "fred" + 45
|>


=== Automatic Quoting It is possible to mark a type definition in such
a way as to automatically construct coercion between the type and
`quoted`. This is done by adding an `implementing` clause to the
@refer{TypeDefinition}. For example [listing] type person is some{
name has type string; } or noOne implementing quotable

results in an implementation for coercion between `person` values and
`quoted` representations of `person`. I.e., [listing] some{name =
"who"} as quoted

is enabled by the `implementing quotable` clause.

=== The Type of Abstract Syntax Terms The foundation of this is the
standard `quoted` type which defines the structure of quoted
fragments. The `quoted` type is defined in Program~\vref{quotedProg}
and the ancillary type `astLocation` is defined in
Program~\vref{locationProg}.  \begin{program} [listing] type quoted is
nameAst(astLocation,string) or boolAst(astLocation,boolean) or
stringAst(astLocation,string) or integerAst(astLocation,integer) or
longAst(astLocation,long) or floatAst(astLocation,float) or
decimalAst(astLocation,decimal) or
applyAst(astLocation,quoted,list[quoted])

.The `quoted` Type[[quotedProg]] \end{program}

=== Locations The `quoted` forms include an `astLocation` field that
indicates where the `quoted` term first appeared in a program. This
type is defined in Program~\vref{locationProg}.  \begin{program}[htb]
[listing] type astLocation is _someWhere{ source has type uri;
charCount has type integer; lineCount has type integer; lineOffset has
type integer; length has type integer; } or noWhere;

.The `astLocation` Type[[locationProg]] \end{program}

==== The `current' location [[locationVar]] (((Accessing source
locations)))

The standard keyword `\_\_location\_\_` denotes the source location of
each of its occurrences. It is a pseudo-variable: it has a type and
value; but its value is based on the text of the program that it is
embedded in: [listing] __location__ has type astLocation;

@quotation Note
The related expression -- `\hash{`\_\_location\_\_} -- is used within
macro rules to denote the location the term that is reduced by a given
macro rule.
@end quotation

== Typed Expressions [[typeExpression]] (((expressions,type))) (((type
expressions))) A type annotation expression is an explicit declaration
of the type of an expression. A type coercion expression denotes a
conversion of a value so that it conforms to a particular type.

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{TypedExpression}::=@refer{TypeCoercion}\\ % |
@refer{TypeCastExpression}\\ | @refer{TypeAnnotationExpression}
\end{eqnarray*} .Type Expression [[typedExpressionFig]] \end{figure}


=== Type Annotation Expression [[typeAnnotationExpression]] A
@refer{TypeAnnotationExpression} is an expression that is annotated
with a @refer{Type}. The annotation amounts to an assertion that the
@refer{Type} of the expression is as annotated.

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{TypeAnnotationExpression}::=`(`@refer{Expression}\ `has
type`\ @refer{Type}`)` \end{eqnarray*} .Type Annotation Expression
[[typeAnnotatedExpressionFig]] \end{figure}

@quotation Note
The @refer{TypeAnnotationExpression} should not be confused with _type
casting_ as is found in some languages. The
@refer{TypeAnnotationExpression} is a way for the programmer to
communicate exactly what the expected type of an expression is;
analogously to the @refer{TypeAnnotation}s found in
@refer{thetaEnvironment}s.
@end quotation

%=== Type Cast Expression [[typeCastExpression]] (((expressions,type
%cast))) (((type cast,expression))) (((as@`as`,expression))) A
%@refer{TypeCastExpression} expression marks an explicit declaration
%of the type of an expression. It also delays actual type checking of
%the castee to runtime.  \begin{figure}[htbp] \begin{eqnarray*}
%@anchored{TypeCastExpression}::=@refer{Expression}\ `cast`\
%@refer{Type} \end{eqnarray*} .Type Cast Expression
%[[typeCastExpressionFig]] \end{figure} ==== Type Safety A type cast
%is an inherently dynamic operation; as far as type consistency is
%concerned the only constraint on the type of the left hand side is
%that its value is consistent with the declared type.  In effect, the
%type consistency check may be delayed until the expression is
%actually evaluated.  However, the declared type may be assumed to be
%the type of the cast expression -- a fact that may be used by the
%type checker.  \begin{prooftree} \AxiomC{\typeprd{E}{Ex}{T\sub{Ex}}}
%\AxiomC{\entail{E,\theta\sub0}{T\subsume
%T\sub{Ex}\leadsto\theta\sub{o}}} \BinaryInfC{\typeprd{E}{Ex` cast
%`T}{T}} \end{prooftree} @quotation Note A type cast expression only
%`makes sense' in a few situations: for example, if either the cast
%type is type `any` or the type of the castee expression is of type
%`any`.  This is because type consistency is based on type equality
%and the only legitimate form of type casting is where the value
%already has the correct type.  However, using type casting with type
%`any` allows so-called @emph{heterogenous} structures where they
%would not ordinarily be permitted.  For example, the `list`
%expression: [listing] list of [1, "alpha", list of []] is not valid
%because the types of the elements of the type are not
%consistent. But, the expression: [listing] list of [1 cast any,
%"alpha" cast any, list of [] cast any] @emph{is} valid, is actually
%of type `list[any]`. However, in order to `unwrap' elements of the
%list it will generally be required to `cast` the elements back out of
%the `any` type.  @end quotation === Type Coercion Expression
%[[typeCoercionExpression]] [[typeCoercionContract]]
%(((expressions,type coercion))) (((type coercion expression))) A
%@refer{TypeCoercion} expression denotes a conversion of a value from
%one type to another.

\begin{figure}[htbp] \begin{eqnarray*}
@anchored{TypeCoercion}::=`(`@refer{Expression}\ `as`\ @refer{Type}`)`
\end{eqnarray*} .Type Coercion Expression
[[typeCoercionExpressionFig]] \end{figure}

The primary difference between _type casting_ and _type coercion_ is
that the former can never result in any change in the value under
consideration. For example, coercing a `float` value to an `integer`
value has the potential to change the value (stripping any fractional
part of the value).

Type coercion is supported by a special `coercion` @refer{Contract}
shown in Program~\vref{typeCoercionContractFig}.

\begin{program} [listing] contract coercion over (s,t) is { coerce has
type (s)=>t };

[[typeCoercionContractFig]] .Coercion Contract `coercion`
\end{program}

@quotation Note
Specifically, an expression of the form: [listing] X as integer

is equivalent to the expression: [listing] (coerce(X) has type
integer)

where the `... has type integer` has the effect of declaring that the
expression has type `integer` and the `coerce` function is an
overloaded function that references a type-specific implementation --
based on the source type of `X` and `integer`.
@end quotation

There are many standard coercions available, as listed in @refer{standardCoercions}. However, it is also possible for a programmer to define their own type coercion by appropriately implementing the `coercion` contract.


\begin{table}
.Standard Type Coercions[[standardCoercions]]
\begin{center}
\begin{tabular}{|ll|ll|ll|}
\hline
Source Type&Target Type&Source&Target&Source&Target\\
\hline
`string`&`integer`&
`integer`&`string`&
`string`&`long`\\
`long`&`string`&
`string`&`fixed`&
`fixed`&`string`\\
`string`&`float`&
`float`&`string`&
`string`&`decimal`\\
`decimal`&`string`&
`integer`&`long`&
`integer`&`fixed`\\
`integer`&`float`&
`integer`&`decimal`&
`long`&`integer`\\
`long`&`fixed`&
`long`&`float`&
`long`&`decimal`\\
`float`&`integer`&
`float`&`long`&
`float`&`fixed`\\
`float`&`decimal`&
`decimal`&`integer`&
`decimal`&`long`\\
`decimal`&`fixed`&
`decimal`&`float`&&\\
\hline
\end{tabular}
\end{center}
\end{table}
