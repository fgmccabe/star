= Standard Contracts

In this chapter we outline the major standard contracts.

Many of these contracts have multiple implementations, for different
types and type combinations; these are outlined in separate chapters.

[#equalityContract]
== The `equality` contract

(((equality contract)))
Equality in Star is based on the `equality` contract. This defines the
`boolean`-valued function: `==`. The complementary function
`~=` is not defined as part of the `equality` contract; but
is defined in terms of `==`.

.The Standard `equality` Contract
[source,star]
----
contract all t ~~ equality[t] ::= {
  (==) : (t,t)=>boolean
}
----

[#equalsPredicate]
===  `==` -- equals

(((equality predicate)))
`==` is part of the standard `equality` contract.

Its type is given by:
[source,star]
----
(==) : all t ~~ equality[t] |= (t,t) => boolean
----

In general, equality is _not_ defined for all values. In particular, equality is
not defined for functions, procedures and other program values.footnote:[Whether
two expressions that denote functions of the same type denote the same function
is, in general, not effectively decidable.]

[#notEqualsPredicate]
===  `~=` -- not equals
(((inequality predicate)))

The type signature for `~=` is:
[source,star]
----
(~=) : all t ~~ equality[t] |= (t,t) => boolean
----

The `~=` predicate has a standard definition that makes it
equivalent to a negated equality:
[source,star]
----
X ~= Y => ~ X==Y
----

[#compContract]
== The `comp` contract

Comparison between values is based on the standard `comp` contract.

Comparison is _not_ automatically implemented for all types --
the standard language provides implementations for the arithmetic
types (`integer`'s, `float`'s etc.) and for the `string`
type.

[#comparableContract]
.The Standard `comp` Contract
[source,star]
----
contract all t ~~ comp[t] ::= {
  (<) : (t,t)=>boolean.
  (>=) : (t,t)=>boolean.
}
----

===  `<` -- less than
The type signature for `<` is:
[source,star]
----
(<) : all t ~~ comp[t] |= (t,t)=>boolean
----

The `<` predicate is satisfied if the left argument is less than
the right argument. The precise definition of less than depends on the
actual implementation of the `comp` contract for the type
being compared; however, for arithmetic types, less than is defined as
being arithmetic less than. For `string`s, one string is less
than another if it is smaller in the standard lexicographic ordering
of strings.

===  `>=` -- greater then or equal
The type signature for `>=` is:
[source,star]
----
(>=) : all t ~~ comp[t] |= (t,t)=>boolean
----

The `>=` predicate is true if the left argument is greater
than or equal to the right argument; as determined by the particular
implementation of the `comp` contract.

=== `=<` -- less than or equal
The type signature for `=<` is:
[source,star]
----
(=<) : all t ~~ comp[t] |= (t,t)=>boolean
----

The `=<` predicate is satisfied if the left argument is less than or equals to
the right argument.

This predicate is not directly part of the `comp` contract, instead it is
defined in terms of `>=`:

[source,star]
----
X =< Y => Y >= X.
----

=== `>` -- greater than
The type signature for `>` is:
[source,star]
----
(>) : all t ~~ comp[t] |= (t,t)=>boolean
----

The `>` predicate is satisfied if the left argument is strictly greater than the
right argument.

This predicate is not directly part of the `comp` contract, instead it is defined in terms of `<`:

[source,star]
----
X > Y => Y < X.
----

[#hashableContract]
== The `hashable` contract

(((hashable contract))) The `hashable` contract defines a standard `hash`
function. It is often used for collections -- such as `map` -- that need a
better way to index values.

.The Standard `hashable` Contract
[source,star]
----
contract all t ~~ hashable[t] ::= {
  hash : (t)=>integer
}
----

[#hashFunction]
===  `hash` -- hash

The `hash` function defines a function that maps values into ``integer``s,
hopefully with minimal collisions.

Its type is given by:
[source,star]
----
hash : all t ~~ hashable[t] |= (t) => integer
----

The `hashable` contract is implemented for `char`, `integer`, `bigint`, `float`,
`string`, `cons` lists, `option`, `either`, and various length tuple types.

[#displayContract]
== The `display` contract
(((pretty print contract)))

The standard contract `display`, shown below, is at the core of the standard
method for displaying values.

NOTE: The `display` contract is also used as part of
<<stringInterpolation>> expressions.

[#displayContractProg]
.The Standard `display` Contract
[source,star]
----
public contract all t ~~ display[t] ::= {
  disp:(t)=>string.
}
----

TIP: One of the primary benefits of allowing programmers to define their own
implementation of `display` is to enable higher quality display of values. By
defining `display` for yourself, you can use application oriented display of
your values.

There are standard implementations of `display` contract for many
of the standard types. However, it is quite possible to define one's
own implementation, either to support your own types or to override
the standard display. For example, supposing that values of the
`tree` type:
[source,star]
----
all t ~~ tree[t] ::= empty | node(tree[t],t,tree[t])
----

were intended to be displayed:
[source,star]
----
{ "alpha" "beta" "gamma" }
----
then the following implementation of `display` would ensure that
such trees were displayed more conveniently:
[source,star]
----
implementation all t ~~ display[t] |= display[tree[t]] => let{.
  treeDisp(empty) => " ".
  treeDisp(node(L,Lb,R)) => "#(treeDisp(L)) $(Lb) #(treeDisp(R))".
.} in {
  disp(T) => "{#(treeDisp(T))}"
}
----

Note how the use of `disp` within the definition of `treeDisplay` will ensure
that the display of tree labels may also be overridden with user-defined
implementations of `display`.

Note also that the `treeDisplay` function also uses the interpolation expression
form to display its left and right subtrees. In particular, we use the embedded
form of interpolation to incorporate the `string` result of displaying the left
and right subtrees.

[#formatContract]
== The `format` contract

The standard contract `format`, shown below, is used when displaying values in a
 formatted manner.

[#formatContractProg]
.The Standard `format` Contract
[source,star]
----
public contract all t ~~ format[t] ::= {
  frmt:(t,string)=>string.
}
----

The second argument to `frmt` is normally a formatting string that is in a
format (sic) that is understood by any specific implementers of the `format`
contract.

Normally, like `display`, calls to `frmt` are represented implicitly in
<<stringInterpolation>> expressions.

=== Formatting Codes

A formatting code is a description of how a numeric or `string`
valued expression should be displayed. Formatting codes allow more
detailed control of the representation of the format in terms of
minimum and maximum widths of output, the number of decimal places to
show and the style of representing numbers -- including how negative
numbers are displayed and the display of currencies.

In <<stringInterpolation>> expressions, formatting codes are
introduced with a `:` character immediately after the `$`
form and is terminated by a `;` character. An invalid formatting
code is ignored, and treated as though it were part of the quoted
string proper.

NOTE: In the standard implementations of the `format` contract the emphasis is
on a so-called _picture_ style format string. For example, the format string for formatting integers as dollars and cents is

[source,star]
----
"${Price}:$99,999.99c;"
----

[#reversibleContract]
== The `reversible` Contract

The `reversible` contract defines a single function `reverse` that is intended to mean reverse.

[#reverseContractProg]
.The Standard `reversible` Contract
[source,star]
----
public contract all t ~~ reversible[t] ::= {
  reverse : (t)=>t
}
----

[#concatContract]
== The `concat` Contract

The `concat` contract defines a single function (`++`) that is intended to mean
`glue together' -- in a type specific way.

[#concatContractProg]
.The Standard `concat` Contract
[source,star]
----
public contract all t ~~ concat[t] ::= {
  (++) : (t,t)=>t
}
----

=== The `++` Concat Function
[#plusPlusFunction]

The type signature for `++` is:
[source,star]
----
(++) : all t ~~ concat[t] |= (t,t) => t
----

The `++` function concatenates two sequences to form their conjunction.


[#glueContract]
== The `glue` Contract

The `glue` contract is analgous to the `concat` contract, except that it allows
the concatenation of elements to sequences.

[#glueContractProg]
.The Standard `gloue` Contract
[source,star]
----
public contract all c,e ~~ glue[c->>e] ::= {
  prepend:(e,c) => c.
  append:(c,e) => c.
}
----

There are two functions: one to add to the beginning of a term and one to add to the end.

The `glue` contract is implemented for the `multi`, `q` and `string` types.

=== The `prepend` Function
[#prependFunction]

The type signature for `prepend` is:
[source,star]
----
prepend : all t,e ~~ glue[t->>e] |= (e,t) => t
----

The `prepend` function prepends an element to the front of a sequence.

=== The `append` Function
[#appendFunction]

The type signature for `append` is:
[source,star]
----
append : all t,e ~~ glue[t->>e] |= (t,e) => t
----

The `append` function appends an element to the end of a sequence.

[#sliceContract]
== The `slice` Contract

[#sliceContractProg]
.The `slice` contract
[source,star]
----
public contract all s,k ~~ slice[s->>k] ::= {
  _slice : (s,k,k)=>s.
  _splice : (s,k,k,s)=>s.
}
----

=== The `_slice`  Function
[#sliceFunction]

The type signature for `_slice` is:
[source,star]
----
_slice : all s,k ~~ _slice[s->>k] |= (s,k,k) => s
----

The `_slice` function extracts a subsequence from a source
sequence. A call of the form:
[source,star]
----
_slice(S,F,T)
----
extracts a subsequence of `S` starting from (and including)
`F` and ending with (but not including) `T`.

It is not required that `k` is actually `integer`; but it is
often more convenient.

In order to ensure proper composability, any implementation of `_slice` and `\+\+` should follow the equality:
[source,star,subs="quotes"]
----
_slice(S,zero,X)++_slice(S,X,end) == S
----
where `zero` is the index of the first entry in `S` and `end` is just beyond the
last entry in the collection.

== The `_splice` Contract Function
[#spliceFunction]

The type signature for `_splice` is:
[source,star]
----
_splice : all s,k ~~ _slice[s->>k] |= (s,k,k,s) => s
----

The `_splice` function replaces a subsequence from a source
sequence. A call of the form:

[source,star]
----
_splice(S,F,T,N)
----

returns a new sequence consisting of `S` with the subsequence
starting from (and including) `F` and ending with (but not
including) `T` replaced by `N`.

Furthermore, for any valid `K`:
[source,star,subs="quotes"]
----
_splice(S,K,K,_empty_) == S
----
where `_empty_` is the empty sequence for the type `s`.

[#streamContract]
== The `stream` Contract

[#streamContractProg]
.The `stream` contract
[source,star]
----
public contract all S,E ~~ stream[S->>E] ::= {
 _eof:(S) => boolean.
 _hdtl:(S) => option[(E,S)].
}
----

=== _eof -- End of Stream


This function should report `true` if its argument represents the
empty stream.

[#endOfStreamProg]
.The `_eof` Function
[source,star]
----
_eof : all s,e ~~ stream[s->>e] |= (s) => boolean.
----

===  `_hdtl` -- Head of Stream

This function removes the head of the stream and returns a pair
consisting of that head and the remainder of the stream.

[#headOfStreamProg]
.The `_hdtl` Function
[source,star]
----
_hdtl : all s,e ~~ stream[s->>e] |= (s) => option[(e,s)].
----

NOTE: The return value of `_hdtl` is a `option` value -- because
it may be applied to empty streams.

[#sequenceContract]
== The `sequence` Contract

A sequence term represents a use of one of the two standard contracts:
<<streamContract>> or <<sequenceContract>>, depending on whether the sequence
term is a pattern or expression.

[#sequenceContractProg]
.The `sequence` contract
[source,star]
----
public contract all S,E ~~ sequence[S->>E] ::= {
  _cons:(E,S) => S.
  _nil:S.
}
----

=== `_nil` -- Empty Sequence

This is a constant value that denotes the empty sequence.

[#nilSequenceProg]
.The `_nil` sequence
[source,star]
----
_nil : all S,E ~~ sequence[S->>E] |= S
----

===  `_cons` -- Add to Front of Sequence

[#consToStreamProg]
.The `_cons` Function
[source,star]
----
_cons : all S,E ~~ sequence[S->>E] |= (E,S) => S
----

This function puts an element onto the front of the sequence; and
returns the resulting extended sequence.


[#buildContract]
== The `build` Contract

The `build` contract is used to build collections, specifically for
comprehension expressions (see <<comprehension>>) and `collect` expressions (see
<<collectExpression>>).

.The `build` contract
[source,star]
----
public contract all S,E ~~ build[S->>E] ::= {
  _push:(E,S) => S.
  _null:S
}
----

The `build` contract has a similar type signature to the `sequence` contract;
however, it is intended that calls to `push` elements would do so at the _end_
of the collection -- in the case that the collection is ordered.

=== `_null` -- Empty collection

This is a constant value that denotes the empty collection.

.The `_null` collection
[source,star]
----
_null : all S,E ~~ build[S->>E] |= S
----

===  `_push` -- Add to end of collection

.The `_push` Function
[source,star]
----
_push : all S,E ~~ build[S->>E] |= (E,S) => S
----

This function puts an element onto the end of the collection; and
returns the resulting extended collection.

[#sizeableContract]
== The `sizeable` Contract

The `sizeable` contract defines two functions for measuring the
size of an entity.

The standard `sizeable` contract is defined for those collections
that have a concept of size associated with them.

[#sizeableContractProg]
.The Standard `sizeable` Contract
[source,star]
----
contract all t ~~ sizeable[t] ::= {
  size : (t) => integer.
  isEmpty : (t) => boolean.
}
----

=== Size of a `sizeable` Entity

[source,star]
----
size : all t ~~ sizeable[t] |= (t)=>integer
----

The `size` function returns the number of elements of a
`sizeable` collection. The precise meaning of the `size`
function is likely to be type-specific; for example, for
`string`s, the `size` of a `string` is the number of
characters in the string.

=== Is a `sizeable` Entity Empty

[source,star]
----
isEmpty : all t ~~ sizeable[t] |= (t)=>boolean
----

The `isEmpty` function returns `true` if the entity is empty, i.e., has size zero.

[#indexedContract]
== The `indexed` Contract

The `indexed` contract provides functions that define what it
means to access and modify key-value collections.

[#indexedContractProg]
.The Standard `indexed` Contract
[source,star]
----
public contract all m,k,v ~~ indexed[m ->> k,v] ::= {
  _index:(m,k) => option[v].
  _put:(m,k,v) => m.
  _remove:(m,k) => m.
  _empty:m.
}
----

=== The `_index` Access Function

The `_index` contract function specifies what it means to access
a key-value collection:

[#indexFunctionProg]
.The `_index` Function
[source,star]
----
_index : all m,k,v ~~ indexed[m ->> k,v] |= (m,k) => option[v].
----

NOTE: The `_index` function returns an `option`al value since it
is not normally guaranteed that a particular key-value combination is
present in the collection.

===  The `_put` Function

The `_put` contract function specifies what it means to add a
new key-value pair to a collection (or to modify an existing
association):

[#insertFunctionProg]
.The `_put` Function
[source,star]
----
_put : all m,k,v ~~ indexed[m ->> k,v] |= (m,k,v) => m.
----

NOTE: The `_put` function returns a new collection with the modified
information in it. This supports but does not require that the
implementation of `indexed` is _applicative_ in nature.

The standard implementations of `indexed` for the standard
`map` type is applicative.

=== The `_remove` Function

The `_remove` contract function specifies what it means to remove a
new key-value pair from a collection.

[#removeFunctionProg]
.The `_remove` Function
[source,star]
----
_remove : all m,k,v ~~ indexed[m ->> k,v] |= (m,k) => m.
----

NOTE: Like the `_put` function, `_remove` returns a new
collection with the modified information in it.

=== The `_empty` Value

The `_empty` value denotes an empty key-value collection of the
appropriate sort.

[#emptyValueProg]
.The `_empty` Value
[source,star]
----
_empty : all m,k,v ~~ indexed[m ->> k,v] |= m.
----

NOTE: The `_empty` value is often used as the starting point for
building up a key-value collection.



[#membershipContract]
== The `membership` Contract

The `membership` contract provides functions that define what it
means to be a member of a collection.

[#membershipContractProg]
.The Standard `membership` Contract
[source,star]
----
public contract all c,e ~~ membership[c->>e] ::= {
  (\+):(c,e)=>c.
  (\-):(c,e)=>c.
  (.<.):(e,c)=>boolean.
}
----

=== The `.<.` Member Function

The `.<.` contract function specifies what it means to be a member of a collection:

[#memberFunctionProg]
.The `.<.` Function
[source,star]
----
(.<.) : all c,e ~~ membership[s ->> e] |= (c,e) => boolean.
----

NOTE: The `.<.` symbol is an infix operator.

For example, given a `cons` list `L` such as `[1,2,10]`, then

[source,star]
----
2 .<. L
----

evaluates to `.true`.

=== The `\+` Add Member Function

`\+` is used to denote a set with an additional element.

[#addmemberFunctionProg]
.The `\+` Function
[source,star]
----
(\+) : all c,e ~~ membership[s ->> e] |= (c,e) => c.
----

NOTE: The `\+` symbol is an infix operator.

The `\+` function returns a new collection with an element added.

For example, given a `set` `L` such as `{1,2,10}`, then

[source,star]
----
L \+ 5
----

has value `{1,2,5,10}`.

NOTE: Implementations should honor the condition that duplicates are
eliminated in collections.

=== The `\-` Remove Member Function

`\-` is used to denote a set where an element is dropped.

[#dropmemberFunctionProg]
.The `\-` Function
[source,star]
----
(\-) : all c,e ~~ membership[s ->> e] |= (c,e) => c.
----

NOTE: The `\-` symbol is an infix operator.

For example, given a `set` `L` such as `{1,2,10}`, then

[source,star]
----
L \- 2
----

has value `{1,10}`.

NOTE: Implementations should honor the condition that duplicates are
eliminated in collections.

[#setOperationsContract]
== The `setops` Contract

The `setops` contract provides functions that define what it
means to combine set valued collections.

[#setopsContractProg]
.The Standard `setops` Contract
[source,star]
----
public contract all k ~~ setops[k] ::= {
  (\/) : (k,k)=>k.
  (/\) : (k,k)=>k.
  (\) : (k,k)=>k.
}
----

=== The `\/` Set Union Function

The `\/` contract function specifies a set union over collections:

[#unionFunctionProg]
.The `\/` Function
[source,star]
----
(\/) : all k ~~ setops[k] |= (k,k) => k.
----

NOTE: The `\/` symbol is an infix operator.

For example, given `cons` lists such as `[1,2,10]` and `[2,5]`, then

[source,star]
----
[1,2,10] \/ [2,5]
----

evaluates to `[1,2,5,10]` -- not necessarily in that precise order.


=== The `/\` Set Intersection Function

The `/\` contract function specifies a set intersection over collections:

[#intersectionFunctionProg]
.The `/\` Function
[source,star]
----
(/\) : all k ~~ setops[k] |= (k,k) => k.
----

NOTE: The `/\` symbol is an infix operator.

For example, given `cons` lists such as `[1,2,10]` and `[2,5]`, then

[source,star]
----
[1,2,10] /\ [2,5]
----

evaluates to `[2]`.


=== The `\` Set Difference Function

The `\` contract function specifies a set difference over collections:

[#differenceFunctionProg]
.The `\` Function
[source,star]
----
(\) : all k ~~ setops[k] |= (k,k) => k.
----

NOTE: The `\` symbol is an infix operator.

For example, given `cons` lists such as `[1,2,10]` and `[2,5]`, then

[source,star]
----
[1,2,10] \ [2,5]
----

evaluates to `[1,10]`.

[#pullContract]
== The `pull` Contract

The `pull` contract provides a function that can be used to extract an
element from a wrapped value.

[#pullContractProg]
.The Standard `pull` Contract
[source,star]
----
public contract all x->>y,e ~~ pull[x->>y,e] ::= {
  pull_:(x)=>y throws e
}
----

=== The `pull_` Function

The `pull_` contract function is used to 'unwrap' a value

[#pullFunctionProg]
.The `pull_` Function
[source,star]
----
pull_ : all x,y,e ~~ pull[x ->> y,e] |= (x) => y throws e
----

NOTE: The `?` unary operator is mapped to a call to the `pull_` function.

Since it is not always guaranteed that it is possible to extract a
wrapped value, the `pull_` function can throw an exception. However,
the type of the exception is determined by the implementation of the
contract.

The `pull` contract is defined for the `either` type and the `option`
type. For example, the implementation for `either` looks like:

[#eitherPullProg]
.The `pull` implementation for `either`
[source,star]
----
public implementation all e,o ~~ pull[either[e,o]->>e,o] => {
  pull_(.either(A)) => A.
  pull_(.other(B)) => throw B
}
----

NOTE: In this case the `other` arm of the `either` value is used when
`pull_` fails to unwrap an `either` value.

[#mappingContract]
== The `mapping` Contract

The `mapping` contract represents a map over collections:

[#mappingContractProg]
.The Standard `mapping` Contract
[source,star]
----
public contract all m/1,e,f ~~ mapping[m->>e,f] ::= {
  (//):(m[e],(e)=>f)=>m[f]
}
----

=== The `//` Map Function

The `//` function specifies a map over a collection: it creates a
new collection based on a function being applied to each element.

[#filterContract]
== The `filter` Contract

The `filter` contract represents a filter over collections:

[#filterContractProg]
.The Standard `filter` Contract
[source,star]
----
public contract all c,e ~~ filter[c->>e] ::= {
  (^/):(c,(e)=>boolean) => c.
}
----

=== The `^/` Function

The `^/` function specifies a collection filter. The result is a 
new collection based on a predicate applied to an existing collection.

[#filterFunctionProg]
.The Standard `^/` Function
[source,star]
----
(^/):all c,e ~~ filter[c->>e] |= (c,(e)=>boolean) => c.
}
----

[#foldingContract]
== The `folding` Contract

The `folding` contract represents left and/or right associative
fold over collections:

[#foldingContractProg]
.The Standard `folding` Contract
[source,star]
----
public contract all c,e ~~ folding[c->>e] ::= {
  foldRight:all x ~~ (((e,x)=>x),x,c) => x.
  foldLeft:all x ~~ (((e,x)=>x),x,c) => x.
}
----

As the name suggests, the `foldRight` function is intended to denote a
right-associative fold, and the `foldLeft` is intended to denote a
left-associative fold.

===  The `foldLeft` Map Function

The `foldLeft` function specifies a left-associative fold over a
collection. When implemented for `cons` lists, this uses the
definition:

[source,star]
----
foldLeft(F,U,.nil) => U.
foldLeft(F,U,.cons(H,T)) => foldLeft(F,F(H,U),T).
----

=== The `foldRight` Map Function

The `foldRight` function specifies a right-associative fold over a
collection. When implemented for `cons` lists, this uses the
definition:

[source,star]
----
foldRight(F,U,.nil) => U.
foldRight(F,U,.cons(H,T)) => F(H,foldRight(F,U,T)).
----

[#iterContract]
== The `iter` Contract

The `iter` contract is an abstraction that represents iteration
over collections. It is used in query expressions to model the search condition.

[#iterContractProg]
.The Standard `iter` Contract
[source,star]
----
public contract all s,t ~~ iter[s->>t] ::= {
  _iter:all x,e ~~ (s,x,(t,x)=>x) => x
}
----

=== The `_iter` Iteration Function

The `_iter` function specifies a key part of iteration over
collections: how individual elements of the collection should be
handled.

[#indexedIterContract]
== The `indexed_iter` Contract

The `indexed_iter` is analogous to the `_iter` contract,
oriented to iteration over key-value collections.

[#indexed_iterContractProg]
.The Standard `indexed_iter` Contract
[source,star]
----
public contract all s,k,v ~~ indexed_iter[s->>k,v] ::= {
  _ix_iter:all x,e ~~ (s,x,(k,v,x)=>x) => x
}
----

=== The `_ix_iter` Iteration Function

The `_ix_iter` function specifies a key part of iteration over key-value
collections: how individual elements of the collection should be handled.


[#visitorContract]
== The `visitor` Contract

The `visitor` contract embodies a walk across a data value.

[#visitorContractProg]
.The Standard `visitor` Contract
[source,star]
----
public contract all c,t ~~ visitor[c->>t] ::= {
  visit:(c,(t){}){}
}
----

=== The `visit` Function

The `visit` procedure calls a client procedure on a data value:

[#visitFunctionProg]
.The Standard `visit` Procedure
[source,star]
----
visit:all c,t ~~ visit[c->>t] |= (c,(t){}){}
}
----

Any implementation of `visitor` over a collection should invoke the
client procedure on invididual elements of the collection.

[#arithContract]
== The `arith` Contract

The `arith` contract encodes the basic -- so-called calculator --
functions.

[#arithContractProg]
.The Standard `arith` Contract
[source,star]
----
public contract all x ~~ arith[x] ::= {
  (+): (x,x)=>x.
  (-): (x,x)=>x.
  __minus: (x)=>x.
  zero: x.
  (*): (x,x)=>x.
  (/): (x,x)=>x throws exception.
  (%): (x,x)=>x throws exception.
  one:x.
}.
----

=== The `+` Function

The `+` function defines the addition of two elements:

[#plusFunctionProg]
.The `+` Function
[source,star]
----
(+) : all t ~~ arith[t] |= (t,t) => t.
----

NOTEL The `(+)` function takes two arguments of the same type and
returns a value of the same type as its arguments.

In fact, it is _this_ specification that ensures that there is no
implicit coercion between different kinds of numeric value.

=== The `-` Function

The `-` function defines the subtraction of one element from another.

[#minusFunctionProg]
.The `-` Function
[source,star]
----
(-) : all t ~~ arith[t] |= (t,t) => t.
----

NOTE: The `(-)` is a binary function. A separate function -- `_uminus` -- is
used to denote unary negation.

=== The `_uminus` Function

The `_uminus` function defines the unary negation of a number.

[#uminusFunctionProg]
.The `_uminus` Function
[source,star]
----
_uminus : all t ~~ arith[t] |= (t) => t.
----

NOTE:  The `_uminus` function is automatically substituted for
occurrences of unary minus in source programs. There is rarely a need
to explicitly refer to this function.

=== The `zero` Value

The `zero` value denotes the 0 value of the arithmetic type.

[#zeroProg]
.The `zero` Value
[source,star]
----
zero : all t ~~ arith[t] |= t. 
----

NOTE: The `zero` value is particularly useful when defining arithmetic
functions that should be neutral with respect to the actual type of
numeric value. Literal decimal numbers have a fixed type --
`integer`.

=== The `*` Function

The `*` function defines the multiplication of one element by another.

[#timesFunctionProg]
.The `*` Function
[source,star]
----
(*) : all t ~~ arith[t] |= (t,t) => t.
----

=== The `/` Function

The `/` function defines the division of one element by another.

[#divideFunctionProg]
.The `/` Function
[source,star]
----
(/) : all t ~~ arith[t] |= (t,t) => t throws exception.
----

NOTE: The `/` function (and the `%` function) are defined to throw an
`exception` if the divisor is zero.

=== The `%` Function

The `%` function defines the modulus of one element with respect
to another.

[#modFunctionProg]
.The `%` Function
[source,star]
----
(%) : all t ~~ arith[t] |= (t,t) => t throws exception.
----

===  The `one` Value

The `one` value denotes the 1 value of the arithmetic type; i.e.,
the _unit_ of multiplication.

[#oneProg]
.The `one` Value
[source,star]
----
one : all t ~~ arith[t] |= t. 
----

NOTE: Like the `zero`, the `one` value is particularly useful when
defining arithmetic functions that should be neutral with respect to
the actual type of numeric value.

[#bitArithmeticContract]
== The `bits` Contract

The `bits` contract encodes a suite of bitwise arithmetic.

[#bitsContractProg]
.The Standard `bits` Contract
[source,star]
----
public contract all x ~~ bits[x] ::= {
  (.|.):(x,x)=>x.
  (.&.):(x,x)=>x.
  (.^.):(x,x)=>x.
  (.~.):(x)=>x.
}
----

The various operations focus on a bitstring interpretation of numeric
values.

The `bits` contract has been implemented for ``integer``s.

=== The `.|.` bitwise or Function

The `.|.` function embodies bitwise union:

[#bitorFunctionProg]
.The `.|.` Function
[source,star]
----
(.|.) : all x ~~ bits[x] |= (x,x) => x.
----

=== The `.&.` bitwise and Function

The `.&.` function embodies bitwise union:

[#bitandFunctionProg]
.The `.&.` Function
[source,star]
----
(.&.) : all x ~~ bits[x] |= (x,x) => x.
----

=== The `.^.` bitwise exclusive or Function

The `.^.` function embodies bitwise union:

[#bitxorFunctionProg]
.The `.^.` Function
[source,star]
----
(.^.) : all x ~~ bits[x] |= (x,x) => x.
----

=== The `.~.` bitwise negation Function

The `.~.` function embodies unary negation:

[#bitnotFunctionProg]
.The `.~.` Function
[source,star]
----
(.~.) : all x ~~ bits[x] |= (x) => x.
----

[#coercionContract]
== The `coercion` Contract

The `coercion` contract embodies what it means to convert a value
of one type to another.

[#coercionContractProg]
.The Standard `coercion` Contract
[source,star]
----
public contract all s,d,e ~~ coercion[s,d->>e] ::= {
  _coerce:(s)=>d throws e
}.
----

The `coercion` contract involves three types: the source type, the result type
and the type of any exceptions that may be thrown.

=== The `_coerce` Function

The `_coerce` function defines a function that converts a value
of one type to another.

[#coerceFunctionProg]
.The `_coerce` Function
[source,star]
----
_coerce : all s,d,e ~~ coercion[s,d] |= (s) => d throws e.
----

The `_coerce` function may throw an exception -- if the coercion can fail.

[NOTE]
****
This is the basis of all coercion; expressions of the form:
[source,star]
----
foo :: type
----
amount to calls to the appropriate implementation of the
`_coerce` function.
****

[NOTE]
****
If the coercion is always guaranteed to succeed, then the `implementation`
declaration should mark the dependent type as `void`. For example, it is always possible to generate a `cons` list of `char` values from a `string`:
[source,star]
----
implementation coercion[string,cons[char]->>void] => {
  _coerce(S) => _explode(S)
}
----
The use of `void` here signals that no exception will be raised in this coercion.
****


