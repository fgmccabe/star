[#io]
= Input and Output

(((io)))
Input and output features include mechanisms for reading and writing
streams of characters, mechanisms for accessing and navigating file
directories and mechanisms for the appropriate formatting and parsing
of data.

== I/O Types

[#ioHandleType]
=== The I/O Handle Types

There are two so-called handle types associated with the I/O operations:
`inHandle` and `outHandle`.

[source,star]
----
public inHandle <~ {}.
public outHandle <~ {}.
----

The `inHandle` type is used to denote an active connection to a file source, and
`outHandle` is used to denote a connection to a file sink.

These are system defined types that are not represented by a type
definition.

[#ioExceptionType]
=== The `ioException` Type

When an i/o operation results in an error, an `ioException` is thrown.

[#ioException]
[source,star]
----
public ioException ::= .ioError | .pastEof | .notFound | .noPerm.
----

=== The `textEncoding` Type

(((text encoding)))
Accessing a file is associated with a text encoding. The available encodings are
defined in:

[#textEncoding]
[source,star]
----
public textEncoding ::= .rawEncoding | .utf8Encoding.
----

==== Raw Encoding
The `.rawEncoding` encoding is used when accessing a file with raw bytes.

==== Utf8 Encoding

The standard text encoding used by Star is UTF8. Tbis is signaled with the
`.utf8Encoding` enumerated symbol.

NOTE: Other encodings may be introduced in the future. This will be reflected in
the definition of the standard `textEncoding` type.


== File Handle functions

=== The `openInFile` function

The `openInFile` returns an `inHandle` if it is able to open the identified file.

[source,star]
----
openInFile:(string,textEncoding) => inHandle throw ioException.
----

If the file is present, and if it is possible to open the named file for
reading, then an `inHandle` bound to the file is returned. Otherwise, an
`ioException` will be thrown.

=== The `openOutFile` function

The `openOutFile` returns an `outHandle` if it is able to open the identified
file -- for output.

[source,star]
----
openOutFile:(string,textEncoding) => outHandle throw ioException.
----

If it is possible to create the identified file, then an `outHandle` bound to
the file is returned. Otherwise, an `ioException` will be thrown.

=== The `atEof` function

The `atEof` function can be used to determine if the input is already at its end
of file.

[source,star]
----
atEof:(inHandle) => boolean.
----

If `atEof` is true for a given input handle, then any subsequent read on the
handle will result in an `.pastEof` `ioException`.

=== The `close` procedure

The `close` procedure can be used to close either an input connection or an
output connection:

[source,star]
----
close: all h ~~ closer[h->>e] |= (h){} throws e
----

The above definition depends on an internally defined contract -- `closer`. In
practice, this procedure has two definitions -- depending on whether an output
handle or an input handle is being closed.

== Input functions

Input functions typically use an `inHandle` value as the source of data. Before
any input can be performed from a source, an `inhandle` must be generated using
a file open function.

=== The `rdChar` function

The `rdChar` function reads a single _character_ from the identified input channel:

[source,star]
----
public rdChar:(inHandle) => char throws ioException.
----

NOTE: If the encoding on the input is set to `.utf8Encoding`, then this will
read as many bytes as required (up to four) to read a single UTF scalar
value. If the encoding is `.rawEncoding` then only one byte will be read.

The `rdChar` function returns an `ioException` if something went wrong with the
read:
[cols="1,3"]
|===
| `.pastEof` | Already at end of file at start of read
| `.ioError` | Unspecified I/O error
|===

=== The `rdLine` function

The `rdLine` function reads a single line from the identified input channel, and returns it (not including the new-line character(s) itself):

[source,star]
----
public rdLine:(inHandle) => string throws ioException.
----

NOTE: If the encoding on the input is set to `.utf8Encoding`, then this will
read characters as UTF8 scalar values. If the encoding is `.rawEncoding` then
the input is treated as a byte sequence.
+
In the latter case, the function still terminates when a new-line sequence is detected.

The `rdLine` function returns an `ioException` if something went wrong with the
read:
[cols="1,3"]
|===
| `.pastEof` | Last line in file not well formed
| `.ioError` | Unspecified I/O error
|===

=== The `rdBytes` function

The `rdBytes` function returns a vector of bytes (using the `integer` type).

[source,star]
----
rdBytes:(inHandle,integer) => vect[integer] throws ioException.
----

The `rdBytes` function returns an `ioException` if something went wrong with the
read:
[cols="1,3"]
|===
| `.pastEof` | Not enough bytes in input
| `.ioError` | Unspecified I/O error
|===


=== The `rdFile` function

The `rdFile` function reads an entire file into a `string`:

[source,star]
----
public rdFile:(string,textEncoding) => string throws ioException.
----

The `rdFile` function returns an `ioException` if something went wrong with the
read:
[cols="1,3"]
|===
| `.notFound` | File not present
| `.noPerm` | No permission to access
| `.ioError` | Unspecified I/O error
|===


== Async input function

In addition to the synchronous I/O functions, there are asynchronous analogs also.

NOTE: asynchronous functions may only be invoked in the context of a <<task>>.

=== The `rdCharAsync` function

The `rdCharAsync` function is an asynchronous function that returns the next
`char` from the input handle:

[source,star]
----
public rdCharAsync:async (inHandle)=>char throws ioException.
----

The `rdCharAsync` function returns an `ioException` if something went wrong with the
read:
[cols="1,3"]
|===
| `.pastEof` | Already at end of file at start of read
| `.ioError` | Unspecified I/O error
|===


As noted above, `rdCharAsync` may only be invoked in the context of a `task`, or
another `async` function.

=== The `rdLineAsync` function

The `rdLineAsync` function reads a line from the input:

[source,star]
----
public rdLineAsync:async (inHandle)=> string throws ioException.
----

The `rdLineAsync` function returns an `ioException` if something went wrong with the
read:
[cols="1,3"]
|===
| `.pastEof` | Already at end of file at start of read
| `.ioError` | Unspecified I/O error
|===


=== The `rdBytesAsync` function

The `rdBytesAsync` function is an asynchronous function to read a vector of bytes.

[source,star]
----
rdBytesAsync:async (inHandle,integer) => vect[integer] throws ioException.
----

The vector of bytes is returned as a `vect` of `integer` values: one per byte read.

The `rdBytesAsync` function returns an `ioException` if something went wrong with the
read:
[cols="1,3"]
|===
| `.pastEof` | Not enough bytes in input
| `.ioError` | Unspecified I/O error
|===


=== The `rdFileAsync` function

The `rdFileAsync` function reads an entire file into a `string` asynchronously.

[source,star]
----
public rdFileAsync:async (string,textEncoding) => string throws ioException.
----

The `rdFileAsync` function returns an `ioException` if something went wrong with the
read:
[cols="1,3"]
|===
| `.notFound` | File not present
| `.noPerm` | No permission to access
| `.ioError` | Unspecified I/O error
|===


== Output functions

Outputting to a sink requires the use of an `outHandle` value, typically
generated using the `openOutFile` function.

=== The `wrChar` procedure

The `wrChar` procedure writes a character to an `outHandle`:

[source,star]
----
public wrChar:(outHandle,char){} throws ioException.
----

This procedure writes a character according to the text encoding used when
opening the file.

NOTE: If `.rawEncoding` is used and a character that would normally require more
than one byte to encode, only the least significant byte will be written to the
output.

=== The `wrText` procedure

The `wrText` writes a `string` to an `outHandle`:

[source,star]
----
public wrText:(outHandle,string){} throws ioException.
----

=== The `wrFile` procedure

The `wrFile` procedure does not require an open `outHandle`, it writes a
`string` as the contents of the output file.

[source,star]
----
public wrFile:(string,textEncoding,string){} throws ioException.
----

The `wrFile` procedure results in an `ioException` if something went wrong with
the file creation or write:

[cols="1,3"]
|===
| `.noPerm` | No permission to access
| `.ioError` | Unspecified I/O error
|===

== Async output procedures

These procedures write to output sinks asynchronously. That is, other <<task>>s
may be scheduled while the output operation completes.

=== The `wrCharAsync` procedure

This procedure writes a `char` value asynchronously to the output:

[source,star]
----
public wrCharAsync:async (outHandle,char){} throws ioException.
----

This procedure writes a single character to the output channel. Note that if the
text encoding of the output is set to `.rawEncoding`, then only the least
significant byte of the UTF scalar value will be written. If the encoding is
`.utf8Encoding` then the character is written out as a UTF8 sequence.

The write operation is not necessarily performed immediately; and this operation
must be performed in the context of a <<task>> or `async` function.

=== The `wrTextAsync` procedure

The `wrTextAsync` procedure writes out a `string` to the output channel.

NOTE: This is currently only supported for channels that have `utf8Encoding`.

The write is not necessarily performed immediately; and this operation must be
performed in the context of a <<task>> or `async` function. The caller will
resume when the operation has completed.

=== The `wrFileAsync` procedure

The `wrFileAsync` procedure writes a `string` as the entire contents of an
output file -- it takes a file name as an argument rather than an `outHandle`.

The file write is performed asynchronously; the caller is continued once the
file operation has been completed.

The `wrFileAsync` procedure results in an `ioException` if something went wrong with
the file creation or write:

[cols="1,3"]
|===
| `.noPerm` | Not permitted to write to file
| `.ioError` | Unspecified I/O error
|===

