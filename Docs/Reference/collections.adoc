[#collection]
= Collection Types

This chapter defines the standard collection types. Note that many of
the functions that are implemented over collection types are exposed
via contract implementations.

== Collection Types
(((type,collection)))
There are three basic collection types supported: `cons` lists,
the `map` type and the `set` type.

=== The Cons List
(((type,cons type)))(((cons type)))
The `cons` type is defined as though by the type definition:

[#consType]
.The `cons` List Type
[source,star]
----
all e ~~ cons[e] ::= .nil | .cons(e,cons[e]).
----

The standard contracts `equality`, `hashable`, `comp`,
`stream`, `sequence`, `sizeable`, `measured`,
`concat`, `head`, `iter`, `generate`,
`display`, `format`, `functor`, `monad`,
`mapping`, `folding`, `ixfold`, `searchable`,
`filter` and `membership` are implemented for the
`cons` type.

In addition, the `coercion` contract is implemented from
`cons` lists to `map`s, `string`s and `vect`ors.

[#mapType]
=== The Map Type

(((type,map type)))(((map type)))
The `map` type denotes a set of key/value pairs. Its type is only
partially exposed:

.The `map` Type
[source,star]
----
all k,v ~~ equality[k], hash[k] |= map[k,v] <~ {}
----

All uses of the `map` type require that the key type supports
both `equality` and `hash`.footnote:[This is because the
underlying implementation requires it.]

NOTE: The underlying implementation of `map` is based on 'Ideal Hash
Trees'; which offer effectively constant time performance for
accessing and modifying the `map`.

The standard contracts `equality`, `sizeable`,
`measured`, `display`, `indexed`, `ixfilter`,
`ixfold`, `iter`, `generate`, `sequemce`,
`stream` and `functor` are implemented for the `map`
type.

[#setType]
=== The Set Type

(((type,set)))
The `set` type supports set membership style functions. Its type
is partially exposed:

.The `set` Type
[source,star]
----
all e ~~ equality[e], hash[e] |= set[e] <~ {}
----

Like the `map` type, using the `set` requires that element
type supports `equality` and `hash`.

The standard contracts `sequence`, `display`,
`membership`, `setops`, `concat`, `sizeable`,
`iter`, `folding` and `generate` are implemented for
the `set` type.

[#vectorType]
=== The Vector Type

(((type,vector)))
The `vect` type denotes a vector type, a list type that is
oriented to random access.

.The `vect` Type
[source,star]
----
all k ~~ vect[k] <~ {}
----

NOTE: The underlying implementation of `vect` is based on a similar
strategy to the implementation of vectors in Clojure. Vectors are
represented as a multi-way branching tree; which offer effectively
constant time performance for accessing and modifying vectors up to a
significant size.

[#redBlackTree]
=== Red-Black Trees

(((type,brtree))) The `rbtree` type denotes a tree data structure based on the
concept of red-black trees. Red black trees are self-balancing trees that
guarantee a maximum degree of 'unbalanced-ness' in the tree: thus making their
performance more predictable than regular binary trees.

The `rbtree` type signature shows that they are a form of map type:

.The `red-black` Tree Type
[source,star]
----
all k,v ~~ comp[k], equality[k] |= rbtree[k,v] <~ {}
----

In order to use ``rbtree``s, it is necessary to import the `redblack` package:

[source,star]
----
import star.redblack
----

The standard contracts `display`, `equality`, `indexed`, `build`, `sequence`,
`stream`, `ixmap`, `ixfold`, `ixfilter`, `iter`, `_generate` and `sizeable` are
implemented for the `rbtree` type.

In addition, coercion is supported between `rbtree` values and `cons` lists of `keyval` pairs.

== Implemented Collection Contracts

For the vast majority of cases, the built-in functions that
are implemented for collections are mediated through contracts.

=== Equality Contract For Collections

The `equality` contract (<<equalityContract>>) is defined for
all the collection types; usually with requirement that the element
types also implement `equality`.


