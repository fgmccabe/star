[#coroutine]
= Coroutines

(((coroutines)))
(((execution,coroutines)))
A coroutine is a suspendable computation. Analogous to function calls,
except that a coroutine can be suspended -- allowing another
computation to continue -- and then later resumed. Not to be confused
with multi-threading, coroutines do give some of the same
responsiveness that multiple threads offer; except that coroutines all
operate on a single CPU thread.

There are two main syntactic structures that use coroutines at their
foundation: tasks and generators. A `task` is an expression that
computes a value, in the context of a `taskManager`. The taskManager's
role is to _schedule_ one or more `task` expressions until a
resolution is made.

A generator is an expression that determines the sequence of values in
an iteration.

Underlying both tasks and generators is the concept of a fiber. A fiber is
essentially a reified coroutine: it has an identity that is persistent through
the computation of the coroutine itself.footnote:[Although fibers have identity,
that identity is only available when provided: when the fiber is
created. Functions running as part of the coroutine cannot discover the fiber's
identity.]

[#generator]
== Generators

A `generator` is an expression that represents a computation that iterates over
a data value. Typically, the generator performs a `yield` action 
that signals to the generator's consumer that an element has been found.

Although it is possible to craft a consumer for a generator explicitly, in most
cases generator consumers are either a `for` loop (<<forAction>>) or a search
query (<<searchCondition>>).

A `generator` is a kind of expression:

[source,star]
----
expression --> generator.

generator --> ["generator"], action
----

For example, this expression:

[source,star]
----
intGen = generator{
  Ix := 1;
  while .true do{
    Ix := Ix!+2;
    yield Ix!
  }
}
----
defines the variable `intGen` to be a generator of odd integers: everytime it
`yields`, it will be with an add integer greater than one.

The type of a generator expression is `generator` of the type of elements it
yields:

[source,star]
----
type --> ["generator", "["], type, ["]"].
----

Generator expressions are typically not written explicitly. Many types implement
the `generate` contract that can be used to create generators:

[source,star]
----
public contract all c,e ~~ generate[c->>e] ::= {
  _generate:(c)=> generator[e]
}
----

The `generate` contract is implemented for `cons`, `map`, `range`, `string`,
`vector` and many other types.footnote:[If the reader implements their own
collection type, implementing `generate` allows their type to participate in
`for` loops and search queries.]

In addition, the standard `iterGenerator` function can be used to lift any
implementation of the `iter` contract into a generator.

=== Structure of a generator

A generator's body is an action. Within the action the `yield` operator is used
to yield to the consumer of the generator.

[#thisVariable]
Within the action body of a `generator` expression, the variable
`this` is bound -- to the generator itself. This allows the generator action to
call a function that itself yields:

[source,star]
----
treeGen(T) => generator{
  walkTree(T,(El) => valof{
    this yield El;
    valis ()} )
}
----

==== The `yield` operator

There are two variants of yield:
unary and binary:

[source,star]
----
action --> ["yield"], expression.
action --> expression, ["yield"], expression.
----

The unary form is equivalent to the binary form, with the left hand argument
being the special variable `this`.

The result of performing a `yield` is to pause the generator -- identified by
`this` or the left hand argument -- and 'return' a value to the consumer.

When the `generator` action completes, it is taken as a signal to the consumer
that there are no more elements to be yielded, and the for loop will terminate.

[#iterGenerator]
=== Creating a `generator` with `iterGenerator`

The `iterGenerator` function is a standard function that can be used to
implement generators:

[source,star]
----
public iterGenerator:all c,e ~~ iter[c->>e] |: (c) => generator[e].
----

It takes as argument a collection, for which type the `iter` contract has been
implemented.

[source,star]
----
public contract all s,t ~~ iter[s->>t] ::= {
  _iter:all x ~~ (s,x,(t,x)=>x) => x
}
----

The `iter` contract defines a general fold over the type. For example, the
implementation of `iter` for binary trees might look like:

[source,star]
----
implementation all e ~~ iter[tree[e]->>e] => let{.
  treeWalk(.empty,X,F) => X.
  treeWalk(.node(L,Lb,R),X,F) => treeWalk(R,F(Lb,treeWalk(L,X,F))).
.} in {
  _iter = treeWalk
}
----

TIP: Using `iterGenerator` is by far the simplest method to create generators.

Given this implementation, a generator the ``MyTree` value becomes:

[source,star]
----
iterGenerator(MyTree)
----

== Tasks, Task Groups, Async functions and Futures

A `task` is a suspendable computation. Tasks are executed in the context of a
task group -- whose implementation combines aspects of task scheduling and
returning the value of tasks.

A task can invoke any function, but some functions require the services of a
task group manager and can only be invoked by task computations. These functions
are marked as `async`.

Tasks are `future`-valued (see <<future>>). This means that a coroutine can
`waitfor` another task to complete and access the result.

A task group is a collection of ``tasks`s -- with an associated scheduler. The
scheduler is responsible for

* scheduling (i.e., performing) the tasks in its group
* implementing certain task services -- for example to allow new tasks to be added to the task group
* deciding when to terminate.

A program starts a coroutining session by invoking a task manager with a seed
collection of tasks. The call to the task manager does not complete until the
conditions set by the particular manager have been met. This typically involves
ensuring that all the tasks in the group have completed.



[#future]
=== Future

A `future` is a value that represents a value that may not be immediately
available. Futures are used, for example, with many I/O functions to 
represent the result of a delayed I/O operation.

The `future` type itself is opaque, but has two type arguments:

[source,star]
----
all x,e ~~ future[x,e] <~ {}
----

The standard way of accessing a `future` value is the `waitfor` function. The
signature for `waitfor` is:

[source,star]
----
waitfor:all x,e ~~ async (future[x,e]) => x throws e
----

The `async` modifier indicates that `waitfor` must be invoked in the context of
a `task`. As the signature suggests, `waitfor` either returns the ``future``s
value -- in the case that it was resolved successfully -- or throws an exception
-- in the case that the `future` was resolved with a rejection.

`waitfor` must be invoked in the context of a `task` because the `task` may be
suspended -- if the `futures` has not yet been resolved.

`future` values are returned by many of the standard I/O functions. However, it
is also possible for user code to create `future` values. The primary means for
creating a `future` is the `_cell_future` escape:

[source,star]
----
_cell_future:all x,e ~~ (ref either[x,e]) => future[x,e]
----

This standard function takes a reference to a cell whose type is `either[x,e]`
and creates a future from it. The `either` type is a standard type defined as:

[source,star]
----
public all a,b ~~ either[a,b] ::= .either(a) | .neither | .other(b).
----

I.e., an `either` value can be given an `a` value, a `b` value or no value.

Normally, a `future`is initialized with a reference to a `.neither` value:

[source,star]
----
makeAFuture:all x,e ~~ () => (future[x,e],ref either[x,e]).
makeAFuture() => valof{
  C = ref .neither;
  valis (_cell_future(C),C)
}
----

The future created this way will only beome resolved by setting the `C` to one
of the non-trivial values of the `either` type. On the other hand, the `future`
itself is typically returned as part of teh client function's API.

Note that setting the reference to `.either(V)` has the effect of resolving the
future, and setting it to `.other(E)` has the effect of rejecting the future: it
will cause `waitfor` to throw the value of the rejection as an exception.


[#fiber]
== Fibers

A fiber is a computation whose execution can be managed. Fibers can be
created, suspended and resumed. Fibers also have identity which allows
data structures to be created that contain fiber references.

Fibers represent the _foundational_ concept underlying the coroutining
features of Star -- they play a similar role as other
comparable concepts such as shift/reset, prompt/control and effects:
they are the basis of higher level features that programmers will more
typically use.

TIP: Although fibers are the foundation of coroutining, normally `fiber`
features are not used directly in regular programs: they are used in libraries
that, for example, implement features such as yield-style generators and green
threads.

[#fiberType]
=== Fiber Type

(((type, fiber)))
(((fiber type)))
The `fiber` type is used to characterize the type of fiber expressions. It
takes the form:
[#fiberTypeFig]
.Fiber Type
[source,star]
----
type --> fiberType.

fiberType --> ["fiber", "["], resumeType, [","], suspendType, ["]"].

resumeType --> type.

suspendType --> type.
----

The `resumeType` refers to values that can be sent to the fiber -- as it is
resumed -- and the `suspendType` type argument refers to values that the fiber
may suspend with (see below) -- i.e., may return to the external computation.

=== Create a `fiber`

A `fiber` is created using the built-in function: `_fiber`. Its main argument is
a _fiber function_.

==== Fiber functions

A fiber function is a function that denotes the computation that a
fiber performs.  The general form of the type of a fiber function is:

[source,star]
----
all r,s ~~ (fiber[r,s],r) => s
----

The `r` type indicates the type of the value given to the fiber whenever it is
resumed, and the `s` type indicates the type that the fiber will return and what
it will yield should it suspend.

Note the second occurrance of `r`: when a fiber is resumed for the first time,
the value given during the corresponding `_resume` operation is modeled as the
second argument to the fiber function.

The `_fiber` function takes a fiber function and returns a new
fiber that will execute that function -- when it is `resume`d.

The type of `_fiber` is:

[source,star]
----
_fiber: all r,s ~~ ((fiber[r,s],r)=>s)=>fiber[r,s]
----

I.e., it returns a new fiber.

=== Suspend using `suspend`

The `suspend` operator is used when a fiber wishes to suspend
itself. There are two arguments to `suspend`: the
identity of the fiber to be suspended and the value that determines the
_suspension event_:

[source,star]
----
(suspend): all r,s ~~ (fiber[r,s],s) => r
----

The returned value from a use of `suspend` is the value used
when the fiber is resumed using `resume`.

=== Resume using `resume`

The `resume` operator is used when one wishes to resume a fiber.
There are two arguments to `resume`: the
identity of the fiber to be resumed, and a value that determines the
_resumption event_:

[source,star]
----
(resume): all r,s ~~ (fiber[r,s],r) => s
----

The second argument -- of type `r` -- is passed to the fiber
being resumed. Since that fiber must be in a suspended state, the
`resume` function suspends the current fiber and resumes the
identified fiber.

The `resume` operator returns when either the fiber function of
the resumed fiber returns, or the resumed fiber suspends itself. In
both cases the value returned by `resume` is the value returned
by the fiber function -- or the value passed in a call to
`suspend`.

=== Retiring a fiber with `retire`

The `retire` function can be used by a fiber when it wished to
cease execution. This is an alternative method of exiting a fiber; the
normal way is simply return from the fiber function.

[source,star]
----
(retire): all r,s ~~ (fiber[r,s],s) => ()
----

The `retire` operator does not actually return. When invoked, the
fiber it is running will be terminated and the corresponding
`resume` expression will have as its value the second argument from the
`retire` expression.

