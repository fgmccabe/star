





=== Type Variables

A type variable a type identifier that is distinguished by being
introduced using an explicit quantifier -- either `all` or
`exists`.  The type expression:
[source,star]
----
all t ~~ cons[t]
----
denotes a list type of some unspecified element type -- identified by
the type variable `t`.

TIP: The collection of values associated with this type expression is a little
more difficult to visualize than the set of lists of integers (say). `cons[t]`
denotes a set of `cons` values; but without more information _we cannot say_
what the complete values look like -- it is dependent on the meaning of the type
variable `t`.

In order to properly understand the interpretation of a type variable
one must understand how the type variable is _bound_. In general,
there are three possibilities: the type variable may be identified
with (equal to) another type; the type variable may be bound by a
universal quantifier or by an existential quantifier.






A universally quantified type (see <<universalType>>) denotes a type
that allows all possible instantiations for the type variable. For
example, function types often involve universal types. A universally
typed function is expected to work _for all values_ of the type
variable -- which, in turn, means that the function definition can
make no assumptions about the actual type.

Existentially quantified types (see <<existentialType>>) are used to
denote _abstract types_; i.e., the existential quantifier signals
that there is a type that should be treated as an opaque _black
box_.

[source,star]
----
type --> quantifiedType.

quantifiedType --> quantifier*, type.

quantifier --> ["all", quantifierVar, ([","], quantifierVar)*, ["~~"].
quantifier --> ["exists", quantifierVar, ([","], quantifierVar)*, ["~~"].

quantifierVar --> identifier.
quantifierVar --> identifier, ["/"], decimal.
----

[#universalType]
==== Universally Quantified Types

(((type,universally quantified)))
(((universally quantified type)))
A universally quantified type denotes a type that is valid for all
substitutions of a type variable.

.Universal Type Expression
[source,star]
----
universalType --> ["all"], boundTypes, ["~~"], type.

boundTypes --> boundType, ([","], boundType)*.

boundType --> identifier | identifier, ["/"], decimal.
----

For example, the type expression:
[source,star]
----
all x ~~ (x,x)=>boolean
----
denotes the generic function type of two arguments that returns a
`boolean`.

There are two forms of `boundType`, a simple type variable and a
second form that includes an arity.

The first form of `boundType` introduces a regular type variable --
i.e., a variable which may be bound to any type. The second form is
used to introduce a higher-kinded type variable.

For example, the quantification:

[source,star]
----
all c/1 ~~ ...
----
denotes a variable which may only be bound to type constructors that
take one argument -- for example `cons`.

For example, consider the `group` type defined in:

[source,star]
----
group ::= group{
  type el = quality[el].
  zero : el.
  op : (el,el)=>el.
  inv : (el)=>el.
}
----

TIP: A `group` literal is analogous to a mathematical group: a
set which is closed under a binary operation and whose elements have
an inverse.

The contents of a `group` literal contain the definitions of the
elements, the binary operation, the zero element and the inverse
function.

The qualification of the `el` type that it supports `equality` allows
convenient access to equality of group elements. Without such a
qualification, equality would not be possible for programs using
`group` values.

An additional requirement for a group is that its operation is
associative. Such a property cannot be expressed in terms of type
constraints.

A `group` literal that implements the group for `integer`s
is shown in:

[#groupTypeProg]
.The `group` Type
[source,star]
----
IG = group{
  el ~> integer.
  zero = 0.
  op = (+).
  inv(X) => -X.
}
----

The `IG` value contains the elements of a group value. We can,
for example, access the `zero` of `IG` using the statement:
[source,star]
----
IZ : IG.el.
IZ = IG.zero.
----

This asserts that `IZ`'s type is whatever the encapsulated type
within `IG` is -- without being explicit about what that type is.

It is possible to construct functions over `group`s that varer to
encapsulated types. For example, the `invertGroup` function below
constructs a new group by _inverting_ the operation.

[#invertGroupProgram]
.A `group` Inverting Function
[source,star]
----
invertGroup : (group)=>group.
invertGroup(G) => group{
  type el = G.el.
  zero = G.zero.
  op(X,Y) => G.op(G.inv(X),G.inv(Y)).
  inv(X) => G.inv(X)
}
----



[#task]
== Tasks and Managers

A `task` is an expression that inhabits a coroutine. Tasks can
suspend themselves -- initiating another coroutine as they do so --
they can communicate with each other -- via channels and futures --
and are scheduled -- by an associated `taskManager`.

[#taskExpression]
=== Task Expressions

(((task expression)))
(((expression,task)))
A `task` expression consists of a `task`-labeled <<blockAction>>.

[#taskExpressionFig]
.Fiber Expression
[source,star]
----
taskExpression --> ["task"], action.
----

Task expressions denote computations that are expected to be performed
asynchronously. I.e., a task is a computation that can be suspended and then
resumed -- under the application's control.

A `task` is created with the `task` notation:
[source,star]
----
T = task{ logMsg(info,"This is a task action") }
----

Task expressions may have values; and may be composed and constructed like other
expressions. For example, the function:

[source,star]
----
tt(X) => task{
  Y = 2;
  valis X+Y
}
----

represents a rather elaborate way of adding 2 to a number. As with `T` above,
the expression:

[source,star]
----
I = tt(3)
----

is not an `integer` but an `integer`-valued task expression. The value returned
may be extracted using `waitfor`:

[source,star]
----
Five = waitfor(I)
----

As with all expressions, if there is a possibility that the task expression will
fail, then it should be encapsulated in a `try`-`catch` block:

[source,star]
----
ive = valof {
  try waitfor(I) catch {
    _ => {
      logMsg(info,"Was not expecting this");
      valis 0
    }
  }
}
----

[#taskType]
=== The `task` type

(((task type))) (((type,task)))
The `task` type is a standard type that is used to represent task expressions.

[source,star]
----
task[e] <~ {}
----

NOTE: Although the `task` type is described here as a normal type, it's
definition is hidden as its internals are not relevant to the programmer.


== Task-related Functions

(((task functions)))


== Channels and Messages

(((channels)))
A channel is a typed communications channel between `task`s. In
order for a `task` to 'send a message' to another `task`,
they would share the channel object itself and then the receiver would
use `recvRv` to wait for the message and the sender would use
`sendRv` to send the message.

[#channelType]
=== The `channel` Type

[source,star]
----
channel[t]
----

Like the `task` type, the `channel` type is _opaque_.

=== The `channel` Function

The `channel` function is used to create channels.
[source,star]
----
channel: all t ~~ ()=>channel[t]
----

Each created channel may be used for sending and receiving multiple
messages. However, the channel is typed; i.e., only messages of that
type may be communicated.

Channels are multi-writer multi-reader channels: any number of tasks
may be reading and writing to a channel. However, any given
communication is between two tasks: one sender and one receiver.

If more than one `task` is trying to send a message then it is
non-deterministic which message is sent. If more than one `task`
is trying to receive a message then only one will get the message.

Message receives and sends may take place in either order. However,
message communication is _synchronous_. I.e., both sender and receiver
are blocked until a communication occurs.

An immediate implication of synchronous communication is that there is
no buffer of messages associated with `channel`s.
