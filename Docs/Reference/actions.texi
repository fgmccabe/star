@node Actions
@chapter Actions

An action is the specification of an operation -- one that may be
@emph{performed}. Although actions are often viewed as being performed
solely for their effect on some shared state, action in @Star{} also
have a value associated with them. This value embodies the success (or
failure) of the action as it is performed.

There are three foundational forms of action expression, as delimited
in @refer{actionFig}. An action expression is an expression whose
value is determined by performing an action.

@float BNF,actionFig
@caption{Types of Action}
@display
@anchored{ActionExpression} ::= @refer{DoAction}
  | @refer{ActionAction}
  | @refer{TaskAction}
  | @refer{ValofAction}

@anchored{DoAction} ::= @code{'do'} @refer{BlockAction}

@anchored{ActionAction} ::= @code{'action'} @refer{BlockAction}

@anchored{TaskAction} ::= @code{'task'} @refer{BlockAction}

@anchored{ValofAction} ::= @code{'valof'} @refer{BlockAction}
@end display
@end float

The differences between the different forms represent a degree of
separation between the action and the expression:

@itemize @bullet
@item
A @code{valof} action is performed as the @code{valof} expression is
evaluated: the value of the expression is the value returned by the
body of the action.
@item
A @code{action} expression returns a term that can be performed. I.e., the
value of an @code{action} expression is an action; which, when
performed, will return a value.
@item
A @code{task} expression returns a computation that can be scheduled
independently of other actions.

This is analogous to coroutining in other programming languages.
@item
A @code{do} action is a non-specific form of action expression: its
semantics depends on whether the type is inferred to be an
@code{action} expression, @code{task} expression, or even some other
form of action expression.
@end itemize

@node Do Notation
@section Do Notation
@cindex Do notation
@cindex action expressions

The @code{do} notation is the standard syntax for writing actions.

@float BNF,doFig
@caption{Do Notation}
@display
@anchored{Action}::=@refer{NullAction}
  | @refer{BlockAction}
  | @refer{InvokeAction}
  | @refer{ValisAction}
  | @refer{BindAction}
  | @refer{DefnAction}
  | @refer{AssignmentAction}
  | @refer{IfThenElseAction}
  | @refer{WhileAction}
  | @refer{ForAction}
  | @refer{TryCatchAction}
  | @refer{ThrowAction}
@end display
@end float

@node Nothing
@subsection @code{nothing}
@cindex no operation
@findex nothing
The @code{nothing} action does nothing; and does not return a value;
or, more accurately, return the empty tuple:

@float BNF,nothingFig
@caption{No Operation}
@display
@anchored{NullAction} ::= @code{'nothing'} | @code{@{@}}
@end display
@end float

The @code{nothing} action (or @code{@{@}}) is equivalent to
@example
_valis(())
@end example

@node Block Action
@subsection Block Action
@cindex block action

An action block consists of a sequence of actions, enclosed in braces
(@code{@{@}}) and separated by semi-colons.

@float BNF,blockActionFig
@caption{Block Action}
@display
@anchored{BlockAction} ::= @code{'@{'} @refer{Action} @code{';'} @dots{} @code{';'} @refer{Action} @code{'@}'}
@end display
@end float

The empty action block -- @code{@{@}} -- is equivalent to the
@refer{NullAction}.

@quotation Note
The last action in an action block is not permitted to be a binding action.
@end quotation

@node Invoke Action
@subsection Invoke Action
@cindex invoke action

The @refer{InvokeAction} denotes the invokation of a
sub-computation. Typically, an @refer{InvokeAction} takes the form of a
call to an action returning function:
@float BNF,invokeActionFig
@caption{Invoke Action}
@display
@anchored{InvokeAction} ::= @refer{Expression} @refer{TupleLiteral}
@end display
@end float

The type of this expression should be one that is consistent with the
enclosing computation expression. Specifically, if the enclosing
computation is an @code{action}, then the invoked expression should
also return an @code{action}.

@node Valis Action
@subsection Valis Action
@cindex valis action
@findex valis

The @refer{ValisAction} creates a computation from an expression.

@float BNF,valisActionFig
@caption{Valis Action}
@display
@anchored{ValisAction} ::= @code{'valis'} @refer{Expression}
@end display
@end float

When a @code{valis} action is performed, its expression is evaluated
and that value is used as the value of the computation.

@node Bind Action
@subsection Bind Action
@cindex bind action

The @refer{BindAction} is used to extract the value of a computation and
pass it along as the value of this computation. The two computations
need not be of the same type -- although the exception types should be.

@float BNF,bindActionFig
@caption{Bind Action}
@display
@anchored{BindAction} ::= @refer{Pattern} @code{'<-'} @refer{Expression}
@end display
@end float

@quotation Note
A @refer{BindAction} may not be the last action in an @refer{BlockAction}.
@end quotation

@node Definition Action
@subsection Definition Action
@cindex definition action

The @refer{DefnAction} is used to bind a variable to a value -- that is
available to subsequent actions.

@float BNF,defnActionFig
@caption{Definition Action}
@display
@anchored{DefnAction} ::= @refer{Pattern} @code{'.='} @refer{Expression}
@end display
@end float

A @refer{DefnAction} differs from a @refer{BindAction} primarily in the
fact that the latter is used to unwrap a computation whereas the
@refer{DefnAction} computes any value and does not otherwise touch the
value.

The scope of a local variable declaration is from the local
declaration itself to the end of the containing @emph{BlockAction}.

@quotation Note
It is an error for a variable to be referenced within its own
definition. Recursive definitions are not permitted.
@end quotation

The left hand side of a definition is a @refer{Pattern}, not simply an
@refer{Identifier}.

One primary use for this form is to allow the unpacking of function
results.

For example, the function @code{ddivide} below returns a pair of values: the
quotient and the remainder result of dividing the first argument by
the second:

@example
ddivide:(integer,integer)=>(integer,integer).
ddivide(X,Y) => (X/Y,X%Y).
@end example

We can unpack the results of a call to @code{ddivide} using a
@refer{TuplePattern} on the left hand side of the declaration:

@example
(Q,R) .= ddivide(34,3)
@end example

which would have the effect of binding @code{Q} to @code{11}, and @code{R} to @code{1}.

@quotation Note
Like the @refer{BindAction}, it does not make sense for a
@refer{DefnAction} to be the last action in an @refer{BlockAction}.
@end quotation

@node Assignment Action
@subsection Assignment Action
@cindex assignment action
@findex :=

The @refer{AssignmentAction} is used to modify the contents of a
re-assignable variable.

It does not return a useful value (actually returns the empty tuple),
and so it is not normally part of a bind operation.

Variables that are assigned to must first have been introduced using a
@refer{DefnAction} of the form:

@example
@var{V} .= ref @var{Initial}
@end example

@float BNF,assignctionFig
@caption{Assignment Action}
@display
@anchored{AssignmentAction} ::= @refer{Variable} @code{':='} @refer{Expression}
@end display
@end float

@node Conditional Action
@subsection Conditional Action
@cindex conditional action

The @refer{IfThenElseAction} is used to denote a conditional computation.

@float BNF,condActionFig
@caption{If Then Else Action}
@display
@anchored{IfThenElseAction} ::= @code{'if'} @refer{Condition} @code{'then'} @refer{Action} @code{'else'} @refer{Action}
  | @code{'if'} @refer{Condition} @code{'then'} @refer{Action}
@end display
@end float

The action expressions of the @code{then} and @code{else} branches
must be of the same type. I.e., they must be the same computations of
the same type of value.

The second form of @refer{IfThenElseAction} -- which omits the
@code{else} branch -- is equivalent to one in which the else branch is
replaced by the @refer{NullAction}:

@example
if @var{Test} then
  @var{A}
else
  nothing
@end example

Because of this, and because of the constraint that both arms of an
@refer{IfThenElseAction} return the same type, the type returned by such
an action is always the empty tuple -- @code{()}.

@node While Action
@subsection While Action
@cindex while action
@findex while

The @refer{WhileAction} is used to denote an iterative computation that
repeats so long as some condition is satisfied.

@float BNF,whileActionFig
@caption{While Action}
@display
@anchored{WhileAction} ::= @code{'while'} @refer{Condition} @code{'do'} @refer{Action}
@end display
@end float

The enclosed action will be repeated zero or more times, for so long
as the test condition is satisfied.

The value returned by a @refer{WhileAction} is always the empty
tuple. Because of this, @refer{WhileAction}s nearly always achieve their
result by means of side-effects -- such as by assigning to
reassignable variables.

@node For Action
@subsection For Action
@cindex for action
@findex for

The @refer{ForAction} is used to denote an iterative computation that is governed by alternate solutions to a @refer{Condition}.

@float BNF,forActionFig
@caption{For Action}
@display
@anchored{ForAction} ::= @code{'for'} @refer{Condition} @code{'do'} @refer{Action}
@end display
@end float

The enclosed action will be repeated zero or more times, for so long
as the test condition is satisfied. Each such solution to the
@refer{Condition} may result in different bindings for variables --
those variables are in scope within the enclosed action.

For example, the action:
@example
for (X,Y) in parent && (Y,Z) in parent do @{
  gps := [(X,Z),..gps!]
@}
@end example
collects grandparents into the re-assignable variable @code{gps}.

Like @refer{WhileAction}s, the value returned by a @refer{ForAction} is
always the empty tuple.

@node Let Action
@subsection Let Action
@cindex let action
@findex let

The @refer{LetAction} allows an action to have local definitions
embedded within it. It plays the same role as let expressions do.

@float BNF,letActionFig
@caption{Let Action}
@display
@anchored{LetAction} ::= @code{'let'} @refer{LetEnvironment} @code{'in'} @refer{Action}
@end display
@end float

As with let expressions, there are two forms: the non-recursive form
-- using regular braces @code{@{@}} -- and the recursive form -- using
dot-braces (@code{@{..@}}.



@node Try Catch Action
@subsection Try Catch Action
@cindex try catch action
@findex try
@findex catch

The @refer{TryCatchAction} is used to denote a computation which may
need to respond to exception situations. 

@float BNF,tryCatchActionFig
@caption{Try Catch Action}
@display
@anchored{TryCatchAction} ::= @code{'try'} @refer{Action} @code{'catch'} @refer{Handler}
@anchored{Handler} ::= @refer{BlockAction}
                | @refer{Expression}
@end display
@end float

There are two forms of @refer{TryCatchAction}s: one where the handler is
very simple -- to the point of ignoring the exception itself -- and
the second where the handler should be a function from the error type
of the computation to a valid computation.

The first form is useful when the error value is discarded:
@example
@end example
and the second is used when the handler is expected to use the value:
@example
do@{
  try@{
    throw 10
  @} catch (E) => do @{
    logMsg("We got error $(E)")
  @}
@}
@end example



@quotation Note
The full form of the catch handler must use a @code{do} expression if
you want to use an action to respond to the error.
@end quotation

@node Throw Action
@subsection Throw Action
@cindex throw action
@findex throw

The @refer{ThrowAction} is used to denote a failed computation. The
@refer{ThrowAction} takes an error value which becomes the error value
of computation as a whole.

@float BNF,throwctionFig
@caption{Throw Action}
@display
@anchored{ThrowAction} ::= @code{'throw'} @refer{Expression}
@end display
@end float

When a @code{throw} action is performed, all subsequence actions are
skipped, up to an enclosing try-catch handler.

@quotation Note
If a computation throws an error value, and that error exception is
not caught by a @refer{TryCatchAction}, then the execution of the entire
program is terminated.
@end quotation

@node The @code{execution} Contract
@section The @code{execution} Contract

Action Expressions are expressions that denote an action -- the action
is performed when the action expression is performed in some way. This
is mediated by means of the @code{execution} contract.

@float BNF,executionFig
@caption{Execution Contract}
@example
public contract all m/2 ~~ execution[m] ::= @{
  _perform:all a,e ~~ (m[e,a])=>a.
  _valis:all a,e ~~ (a)=>m[e,a].
  _sequence:all a,b,e ~~ (m[e,a],(a)=>m[e,b]) => m[e,b].
  _catch:all a,e,f ~~ (m[e,a],(e)=>m[f,a]) => m[f,a].
  _raise: all a,e ~~ (e) => m[e,a].
@}
@end example
@end float

The @code{execution} contract is over a type function (@code{m/2}) and
has a dependent type that corresponds to the type of any exception or
error that may be raised during the computation.

@quotation Note
There are many potential ways of implementing the @code{execution}
contract; representing different computation characteristics. The
three standard implementations are modeled by the @code{result} type,
the @code{action} type and the @code{task} type; these also have
special syntax associated with them.
@end quotation

@quotation Note
The @code{execution} contract is reminiscent of the @code{monad}
contract. However, the focus is different: it is less about combining
actions and more about transitioning between actions and values.
@end quotation

@node The @code{result} Type
@subsection The @code{result} Type

The most basic implementation of the @code{execution} contract is
based on the @code{result} type. This reflects the fact that
computations can return in one of two ways: normally or abnormally.

@float BNF,resultTypeFig
@caption{Result Type}
@example
public all e,a ~~ result[e,a] ::= ok(a) | bad(e).
@end example
@end float

The @code{result} type embodies whether or not a computation
succeeded, and, in both case, what the value of the computation is.

The implementation of the @code{execution} contract for the
@code{result} type is especially simple:

@example
public implementation execution[result] => @{
  _perform(ok(X)) => X.

  _valis(X) => ok(X).

  _sequence(bad(E),_) => bad(E).
  _sequence(ok(A),F) => F(A).

  _catch(ok(X),_) => ok(X).
  _catch(bad(X),E) => E(X).

  _raise(S) => bad(S).
@}
@end example


@node The @code{action} Type
@subsection The @code{action} Type

As noted above, the @code{action} type denotes a form of action
expression where the action denoted by the expression may be performed
separately (and potentially multiply) from the expression itself.

@float BNF,actionTypeFig
@caption{Action Type}
@example
public all e,a ~~ action[e,a] ::= done(a) | delay(()=>action[e,a]) |err(e).
@end example
@end float

The delayed nature of an @code{action} type is captured via the
@code{delay} constructor: it contains a function that, when the action
is performed, computes the results of the action.

@quotation Note
It can be difficult to capture the essence of the @code{action}
type. Perhaps the most direct way is to note that an @code{action}
expression denotes a (typically) delayed action that can be performed
at some time.
@end quotation

The other cases of the @code{action} type denote completed states of
the action: when the ction is @code{done}, or when the action has
resulted in an @code{err}or.

The implementation of the @code{execution} contract for the
@code{action} type is slightly more complex than that for @code{result}

@example
public implementation execution[action] => @{
  _perform(done(X)) => X.
  _perform(delay(F)) => _perform(F()).

  _valis(X) => delay(()=>done(X)).

  _sequence(err(E),_) => err(E).
  _sequence(done(A),F) => delay(()=>F(A)).
  _sequence(delay(G),F) => delay(()=>_sequence(G(),F)).

  _catch(done(X),_) => done(X).
  _catch(delay(A),E) => _catch(A(),E).
  _catch(err(X),E) => E(X).

  _raise(S) => err(S).
@}
@end example

@node Performing Actions
@section Performing Actions

All actions have a value associated with them -- this is the value
that is returned by the action after it is performed.

There are several situations where actions are performed
automatically; however, the @refer{ValofExpression} is a principal way
in which an action can be performed and its value returned.

@node Valof Expression
@subsection Valof Expressions

@float BNF,valofExpressionFig
@caption{Valof Expression}
@display
@anchored{ValofExpression} ::= @code{'valof'} @refer{Expression}
@end display
@end float

The @refer{ValofExpression} is applied to an @refer{Action}. The
effect of this is to perform the action and return its value as the
value of the @refer{ValofExpression}.

@quotation WARNING
It is a fatal error for the performed action to return exceptionally
-- the performed action should return a value and not exit by means of
a @refer{ThrowAction}.
@end quotation

