@node Actions
@chapter Actions

An action is performed for the sake of its effect. @Star{} has a
normal complement of control flow instructions; although there are
some departures from some common patterns.

Apart from achieving some effect, actions are associated with a
value. This is the value of the action that is returned when action is
completed.

Actions may also be associated with a exception; in the case that the
action does not complete normally.

The @refer{ValofExpression} is used to denote that a value is to be
computed by performing actions. Similarly, many actions involve the
evaluation of expressions.

@node Actions and Types
@section Actions and Types
@cindex action types
@cindex action!types

Actions have two types associated with them: their @emph{value} type
and their @emph{exception} type.  The action's value type is the type
of any returned value -- i.e., the type of the expression associated
with any @refer{ValisAction}s within the action. The action's
exception type is the type of any exception that may be thrown by the
action.

@node Basic Action Forms
@section Basic Action Forms
@cindex basic action expressions

The basic actions include those in @ref{doFig}. There are additional
actions, as explained in @ref{Tasks}.

@float BNF,doFig
@caption{Different forms of action}
@display
@anchored{Action}::=@refer{NullAction}
  | @refer{BlockAction}
  | @refer{InvokeAction}
  | @refer{ValisAction}
  | @refer{DefnAction}
  | @refer{AssignmentAction}
  | @refer{IfThenElseAction}
  | @refer{WhileAction}
  | @refer{UntilAction}
  | @refer{ForAction}
  | @refer{CaseAction}
  | @refer{LetAction}
  | @refer{TryCatchAction}
  | @refer{ThrowAction}
  | @refer{LabeledAction}
  | @refer{BreakAction}
@end display
@end float

@node Nothing
@subsection @code{nothing}
@cindex no operation
@findex nothing
The @code{nothing} action does nothing; and does not return a value;
or, more accurately, return the empty tuple:

@float BNF,nothingFig
@caption{No Operation}
@display
@anchored{NullAction} ::= @code{@{@}}
@end display
@end float

The @code{@{@}} does nothing. Useful when you don't want to do anything.

@node Block Action
@subsection Block Action
@cindex block action

An action block consists of a sequence of actions, enclosed in braces
(@code{@{@}}) and separated by semi-colons.

@float BNF,blockActionFig
@caption{Block Action}
@display
@anchored{BlockAction} ::= @code{'@{'} @refer{Action} @code{';'} @dots{} @code{';'} @refer{Action} @code{'@}'}
@end display
@end float

The empty action block -- @code{@{@}} -- is equivalent to the
@refer{NullAction}.

@node Invoke Action
@subsection Invoke Action
@cindex invoke action

The @refer{InvokeAction} denotes the invokation of a
sub-computation. Typically, an @refer{InvokeAction} takes the form of
a call to a function.
@float BNF,invokeActionFig
@caption{Invoke Action}
@display
@anchored{InvokeAction} ::= @refer{Expression} @refer{TupleLiteral}
@end display
@end float

Any value that is returned by the function call is discarded; however,
if the function throws an exception then that exception is propagated
within the enclosing action.

@node Valis Action
@subsection Valis Action
@cindex valis action
@findex valis

The @refer{ValisAction} denotes that the action should terminate and return a value.

@float BNF,valisActionFig
@caption{Valis Action}
@display
@anchored{ValisAction} ::= @code{'valis'} @refer{Expression}
@end display
@end float

When a @code{valis} action is performed, its expression is evaluated
and that value is used as the value of the computation.

@quotation Note
It is possible that evaluating the expression of a @refer{ValisAction}
may cause an exception to be thrown. In that case, the
@refer{ValisAction} itself aborts and the exception is propagated to
the designated handler.
@end quotation

@node Throw Action
@subsection Throw Action
@cindex throw action
@findex throw

The @refer{ThrowAction} denotes that the action should terminate and throw a value.

@float BNF,throwActionFig
@caption{Throw Action}
@display
@anchored{ThrowAction} ::= @code{'throw'} @refer{Expression}
@end display
@end float

When a @code{throw} action is performed, its expression is evaluated
and that value is raised as an exception. The syntactically enclosing
action must either be a @refer{TryCatchAction} form, or the action
must be the top-level of a function and that function must have been
declared as throwing a value of the appropriate type.

@quotation Note
If evaluating the expression that denotes the exception to throw
itself throws an exception, that is a fatal error and causes overall
execution of the program to stop.
@end quotation

@quotation Note
There is no automatic search for an handling form: every @code{throw}
must be lexically accounted for.
@end quotation


@node Labeled Action
@subsection Labeled Action
@cindex labeled action

The @refer{LabeledAction} associates a @emph{label} with an
action. Apart from that label, the semantics of the labeled action is
not affected -- unless it lexically contains a @refer{BreakAction}.

@float BNF,labeledActionFig
@caption{Labeled Action}
@display
@anchored{LabeledAction} ::= @refer{Identifier} @code{':'} @refer{Action}
@end display
@end float


@node Break Action
@subsection Break Action
@cindex break action
@findex break

The @refer{BreakAction} denotes that the labeled action should
terminate. The action that was labeled is terminated, and computation
proceeds with its natural successor.

@float BNF,breakActionFig
@caption{Break Action}
@display
@anchored{BreakAction} ::= @code{'break'} @refer{Identifier}
@end display
@end float

When a @code{break} action is performed, it must refer to the label of
a syntactically enclosing action. That action is ended -- with no
further actions taking place within it -- and the labeled action's
natural successor is entered.

@quotation Example
Labeled actions and labeled breaks are a straightforward mechanism for
early exiting loops. For example, in the loop:
@example
firstMultiple(X,M) => valof@{
  L:@{
    for ix in range(1,X,1) do@{
      if ix%M==0 then
        break L
    @};
    valis "not found"
  @};
  valis "found"
@}
@end example
The @code{firstMultiple} function will return @code{"found"} if a
multiple of some @code{M} is found in a range; and @code{"not found"}
otherwise.

This is because, when a multiple is found, we exit the composite
action labeled @code{L}; which proceeds to the next action which
returns the @code{"found"} value.

If the loop ended normally, that is because no multiple was found, and
the action after the loop signals that.
@end quotation

@quotation Note
There is no run-time search for an enclosing label; nor are labels
first class entities. A label is an identifier that is used to
identify (sic) a specific action.

Labels can be nested, however. In the case that there are multiple
occurrences of a label in scope, a @code{break} will always refer to
the lexically innermost labeled action.
@end quotation

@node Definition Action
@subsection Definition Action
@cindex definition action

The @refer{DefnAction} is used to bind variables to a value -- that is
available to subsequent actions. The variables are denoted via a
@ref{Pattern}; which can be used, for example, to bind more than one
variable.

@float BNF,defnActionFig
@caption{Definition Action}
@display
@anchored{DefnAction} ::= @refer{Pattern} @code{'.='} @refer{Expression}
@end display
@end float

The scope of a variables declared in a definition action is from the
declaration itself to the end of the containing @emph{BlockAction}.

@quotation Note
It is an error for a variable to be referenced within its own
definition. Recursive definitions are not permitted.
@end quotation

The left hand side of a definition is a @refer{Pattern}, not simply an
@refer{Identifier}.

One primary use for this form is to allow the unpacking of function
results.

For example, the function @code{ddivide} below returns a pair of values: the
quotient and the remainder result of dividing the first argument by
the second:

@example
ddivide:(integer,integer)=>(integer,integer).
ddivide(X,Y) => (X/Y,X%Y).
@end example

We can unpack the results of a call to @code{ddivide} using a
@refer{TuplePattern} on the left hand side of the declaration:

@example
(Q,R) .= ddivide(34,3)
@end example

which would have the effect of binding @code{Q} to @code{11}, and @code{R} to @code{1}.

@quotation Note
If the expression evaluation resulted in an exception, then the match
is not attempted. If the match itself fails, then that is a fatal
error.
@end quotation

@node Assignment Action
@subsection Assignment Action
@cindex assignment action
@findex :=

The @refer{AssignmentAction} is used to modify the contents of a
re-assignable variable.

Variables that are assigned to must first have been introduced using a
@refer{DefnAction} of the form:

@example
@var{V} .= ref @var{Initial}
@end example

@float BNF,assignctionFig
@caption{Assignment Action}
@display
@anchored{AssignmentAction} ::= @refer{Variable} @code{':='} @refer{Expression}
@end display
@end float

@node Conditional Action
@subsection Conditional Action
@cindex conditional action

The @refer{IfThenElseAction} is used to denote a conditional computation.

@float BNF,condActionFig
@caption{If Then Else Action}
@display
@anchored{IfThenElseAction} ::= @code{'if'} @refer{Condition} @code{'then'} @refer{Action} @code{'else'} @refer{Action}
  | @code{'if'} @refer{Condition} @code{'then'} @refer{Action}
@end display
@end float

The second form of @refer{IfThenElseAction} -- which omits the
@code{else} branch -- is equivalent to one in which the else branch is
replaced by the @refer{NullAction}:

@example
if @var{Test} then
  @var{A}
else
  @{@}
@end example

@node While Action
@subsection While Action
@cindex while action
@findex while

The @refer{WhileAction} is used to denote an iterative computation that
repeats so long as some condition is satisfied.

@float BNF,whileActionFig
@caption{While Action}
@display
@anchored{WhileAction} ::= @code{'while'} @refer{Condition} @code{'do'} @refer{Action}
@end display
@end float

The enclosed action will be repeated zero or more times, for so long
as the test condition is satisfied.

@node Until Action
@subsection Until Action
@cindex until action
@findex until

The @refer{UntilAction} is used to denote an iterative computation that
repeats until a condition is satisfied.

@float BNF,untilActionFig
@caption{Until Action}
@display
@anchored{UntilAction} ::= @code{'do'} @refer{Action} @code{'until'} @refer{Condition}
@end display
@end float

The enclosed action will be performed at least once, and continued
until the test condition is satisfied.

@node For Action
@subsection For Action
@cindex for action
@findex for

@c The @refer{ForAction} is used to denote an iterative computation that
@c is governed by a @refer{Generator}.

@float BNF,forActionFig
@caption{For Action}
@display
@anchored{ForAction} ::= @code{'for'} @refer{Pattern} @code{in} @refer{Expression} @code{'do'} @refer{Action}
@end display
@end float

The @code{for} loop iterates over a collection and matches each element
against @emph{Pattern}; which will typically bind one or more variables
that are in scope for the body of the loop.

The type of the collection must implement the @code{generate} contract.

For example, the action:
@example
for (X,Y) in parent do @{
  if (Y,Z) in parent then
    gps := [(X,Z),..gps!]
@}
@end example
collects grandparents into the re-assignable variable @code{gps}.

@node Let Action
@subsection Let Action
@cindex let action
@findex let

The @refer{LetAction} allows an action to have local definitions
embedded within it. It plays the same role as let expressions do.

@float BNF,letActionFig
@caption{Let Action}
@display
@anchored{LetAction} ::= @code{'let'} @refer{LetEnvironment} @code{'in'} @refer{Action}
@end display
@end float

As with let expressions, there are two forms: the non-recursive form
-- using regular braces @code{@{@}} -- and the recursive form -- using
dot-braces (@code{@{..@}}.

@node Case Action
@subsection Case Action
@cindex case action

The @code{case} action selects one of a set of arms depending on the
value of a governing expression. It is the analog of the
@ref{CaseExpression}; oriented to performing actions.

@float BNF,caseActionFig
@caption{Case Action}
@display
@anchored{CaseAction} ::= @code{'case'} @refer{Expression} @code{'in'} @refer{CaseActionHandler}

@anchored{CaseActionHandler} ::=@code{@{} @refer{CaseActionRule} @code{.} @dots{} @code{.} @refer{CaseActionRule} @code{@}}

@anchored{CaseActionRule} ::= @ref{Pattern} @code{'=>'} @ref{Action}
  | @ref{Pattern} @code{'default'} @code{'=>'} @ref{Action}
@end display
@end float

@node Try Catch Action
@subsection Try Catch Action
@cindex try catch action
@findex try
@findex catch

The @refer{TryCatchAction} is used to denote a computation which may
need to respond to exception situations. 

@float BNF,tryCatchActionFig
@caption{Try Catch Action}
@display
@anchored{TryCatchAction} ::= @code{'try'} @refer{Action} @code{'catch'} @refer{CaseActionHandler}
@end display
@end float

The type of any exception thrown within the body of the
@code{try}@dots{}@code{catch} must be consistent with the handler. For
example, in:
@example
try@{
  throw 10
@} catch @{
  (E) => @{
    logMsg("We got error $(E)")
  @}
@}
@end example
the type of @code{E} is @code{integer}; which is consistent with the action
@example
throw 10
@end example
action.

@node Valof Expression
@subsection Valof Expressions

@float BNF,valofExpressionFig
@caption{Valof Expression}
@display

@refer{Expression} ::+= @refer{ValofExpression}

@anchored{ValofExpression} ::= @code{'valof'} @refer{BlockAction}
@end display
@end float

The @refer{ValofExpression} is applied to an @refer{Action}. The
effect of this is to perform the action and return its value as the
value of the @refer{ValofExpression}.

At least one of the actions within the @refer{BlockAction} must be a
@refer{ValisAction} -- which determines the value of the
@refer{ValofExpression} expression.



