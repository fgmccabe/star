@node Actions
@chapter Actions

An action is the performance of an operation in a particular
context. Actions in @Star{} are realized using the @code{execution}
contract.

@float BNF,actionFig
@caption{Types of Action}
@display
@anchored{ActionExpression} ::= @var{DoAction}
  | @var{ActionAction}
  | @var{TaskAction}

@anchored{DoAction} ::= @code{do} @var{Action}

@anchored{ActionAction} ::= @code{action} @var{Action}

@anchored{TaskAction} ::= @code{task} @var{Action}
@end display
@end float

@node The @code{execution} Contract
@section The @code{execution} Contract

Action Expressions are expressions that denote an action -- the action
is performed when the action expression is performed in some way. This
is mediated by means of the @code{execution} contract.@footnote{The
@code{execution} contract is strongly related to the @code{monad}
contract; except that it is slightly more elaborate.}

@float BNF,executionFig
@caption{Execution Contract}
@example
public contract all m/1,e ~~ execution[m->>e] ::= @{
  _lift:all a ~~ (a)=>m[a].
  _perform:all a ~~ (m[a])=>a.
  _sequence:all a,b ~~ (m[a],(a)=>m[b]) => m[b].
  _handle:all a ~~ (m[a],(e)=>m[a]) => m[a].
  _raise: all a ~~ (e) => m[a].
@}
@end example
@end float

The @code{execution} contract is over a type function (@code{m/1} and
has a dependent type that corresponds to the type of any exception or
error that may be raised during the computation.

@quotation Note
There are many potential ways of implementing the @code{execution}
contract; representing different computation characteristics. The two
standard implementations are modeled by the @code{action} type and the
@code{task} type; these also have special syntax associated with them.

In addition to these, there are several `non-standard` implementation
of the contract -- such as for @code{list}s and for the @code{option}
type.
@end quotation

@quotation Note
Although computation expressions are based on the functions in this
contract, most programmers will not use these directly. Instead, there
is an action notation that has a more familiar style for representing
actions.
@end quotation

@node @code{_lift} a value as a computation
@subsection @code{_lift} a value as a computation
@cindex Lift a value into computation

The @code{_lift} function takes an expression and makes it a computation.

@node @code{_perform} a computation
@subsection @code{_perform} a computation
@cindex Perform a computation

The @code{_perform} function takes a computation and performs it. It
is assumed that the computation does not return any form of error or exception.

@quotation Note
Use the @code{_handle} function to enable the handling of exceptions.
@end quotation

@node @code{_sequence} computations
@subsection @code{_sequence} computations
@cindex Combine computations

The @code{_sequence} function is a way of combining computations into
a sequential order. The type signature for @code{_sequence} is:
@example
_sequence:all a,b,m/1,e ~~ execution[m->>e] |: (m[a],(a)=>m[b]) => m[b].
@end example
Abstractly, the @code{_sequence} function takes two computations and
creates a new one that is the sequence composition of the two
computations.

In order to facilitate the flow of information between computations,
the second computation is modeled as a function from the value of the
first computation to a new computation.

If an exception arises in the first computation, then the second
computation is not performed and the exception becomes the value of
the whole computation.

@node @code{_handle} exceptional computations
@subsection @code{_handle} exceptional computations
@cindex Combine exceptional computations

The @code{_handle} function takes a computation that may result in an
exception and converts it into a potentially exception-free
computation. It does so by handling any exception that arises.

The type signature for @code{_handle} is:
@example
_handle:all a,m/1,e ~~ execution[m->>e] |: (m[a],(e)=>m[a]) => m[a].
@end example

The second argument to @code{_handle} is the exception handler. It is
expected to return a computation of the same type as the first
argument.

The expected semantics of @code{_handle} are that if the first
computation does not arise in an exception then that is the effective
computation of the result; otherwise, if the first computation does
result in an exception then the second argument is expected to take
that exception and return a new computation.@footnote{That is
presumably not exceptional.}

@node @code{_raise} an exception
@subsection @code{_raise} an exception
@cindex Raise an exception

The @code{_raise} function takes an expression and makes it an
exceptional computation. One of the effects of this is that the
exception is propagated through any subsequent computations -- unless
and until the exception is handled.

@node Expected invariants of computation
@subsection Expected invariants of computation
@cindex computation invariants
The different functions in the @code{execution} contract are expected
to work together in a coherent way. This is codified in a set of
invariants that any implementation of the contract is expected to
obey,

@enumerate
@item
@code{_perform} is a left identity of @code{_lift}.

I.e., for all @emph{E},
@example
_perform(_lift(@emph{E})) = @emph{E}
@end example
@item
@code{_lift} is a left identity of @code{_perform}.

I.e., for all non-exceptional @emph{C}:
@example
_lift(_perform(@emph{C})) = @emph{C}
@end example
This equality is not defined for computations @emph{C} that are the
result of @code{_raise}.

@item
Left identity @code{_lift} and @code{_sequence}

I.e., an expression of the form:
@example
_sequence(_lift @var{E},F)
@end example
is equivalent to
@example
F(@var{E})
@end example

@item
@code{_sequence} is associative.

I.e., a composition of the form:
@example
_sequence(_sequence(@var{C},@var{F}),@var{G})
@end example
is equivalent to
@example
_sequence(@var{C},(X)=>_sequence(F(X),G))
@end example
Notice that the form of the associativity is not the same as that for
arithmetic. This is because the @code{_sequence} function is
inherently assymetric.
@end enumerate

@c @node Actions and Type Safety
@c @subsection Actions and Type Safety
@c @cindex actionTypeSafety
@c The meaning of type safety is somewhat different for actions than for
@c expressions and functions: by definition, Actions do not denote values
@c in the way that expressions do.@footnote{Or rather, the value of an
@c action is a computation -- that will only result in a value if the
@c computation is performed.}

@c However, type safety still applies to actions. In particular,
@c different actions have different @emph{type constraints} that must be
@c satisfied; for example, an assignment action is @emph{type safe} if the
@c type of the variable is consistent with the expression and if the
@c variable is a re-assignable variable.

@c We use the meta-predicate @var{safe} to indicate that a particular
@c action is type safe. An assertion of the form:
@c @display
@c @typesafe{E,A}
@c @end display
@c means that the action @var{A} is type-consistent given the environment
@c @var{E}.


@node Do Notation
@section Do Notation
@cindex Do notation
@cindex action expressions

The @code{do} notation is a way of writing computation expressions in
a style that is likely to be familiar to programmers of other
programming languages.

@float BNF,doFig
@caption{Do Notation}
@display
@anchored{Action}::=@var{NullAction}
  | @var{BlockAction}
  | @var{InvokeAction}
@c  | @var{IgnoreAction}
  | @var{LiftAction}
  | @var{BindAction}
  | @var{DefnAction}
  | @var{AssignmentAction}
  | @var{IfThenElseAction}
  | @var{WhileAction}
  | @var{ForAction}
  | @var{TryCatchAction}
  | @var{ThrowAction}
@end display
@end float


@node Nothing
@subsection @code{nothing}
@cindex no operation
@findex nothing
The @code{nothing} action does nothing; and does not return a value; or, more accurately, return the empty tuple:

@float BNF,nothingFig
@caption{No Operation}
@display
@anchored{NullAction} ::= @code{nothing}
@end display
@end float

The @code{nothing} action is equivalent to
@example
_lift(())
@end example

@node Action Block
@subsection Action Block
@cindex action block

An action block consists of a sequence of actions, enclosed in braces
(@code{@{@}}) and separated by semi-colons.

@float BNF,blockActionFig
@caption{Action Block}
@display
@anchored{BlockAction} ::= @{ @var{Action} ; @dots{} ; @var{Action} @}
@end display
@end float

The empty action block -- @code{@{@}} -- is equivalent to the
@var{NullAction}.

Action blocks denote composition of actions using the @code{_sequence} function: for example, the actions @var{A}, @var{B} and @var{C} in:
@example
@{
  A; B; C
@}
@end example

are equivalent to the expression:
@example
_sequence(A,(_)=>_sequence(B,(_)=>C))
@end example
assuming that neither of @var{A} or @var{B} are @emph{binding} actions.

@quotation Note
The last action in an action block is not permitted to be a binding action.
@end quotation

@node Invoke Action
@subsection Invoke Action
@cindex invoke action

The @var{InvokeAction} denotes the invokation of a
sub-computation. Typically, an @var{InvokeAction} takes the form of a
call to an action returning function:
@float BNF,invokeActionFig
@caption{Invoke Action}
@display
@anchored{InvokeAction} ::= @var{Expression} @var{Argument Tuple}
@end display
@end float

The type of this expression should be one that is consistent with the
enclosing computation expression. Specifically, if the enclosing
computation is an @code{action}, then the invoked expression should
also return an @code{action}.

@node Lift Action
@subsection Lift Action
@cindex lift action
@findex lift

The @var{LiftAction} creates a computation from an expression.

@float BNF,liftActionFig
@caption{Lift Action}
@display
@anchored{LiftAction} ::= @code{lift} @var{Expression}
@end display
@end float

When a @code{lift} action is performed, its expression is evaluated
and that value is used as the value of the computation.

@node Return Action
@subsection Return Action
@cindex return action
@findex return

The @var{ReturnAction} creates a computation from an expression.

@float BNF,returnActionFig
@caption{Return Action}
@display
@anchored{ReturnAction} ::= @code{return} @var{Expression}
@end display
@end float

@quotation Note
The @code{return} action, within an action expression, is a synonym of
a @code{lift} expression.
@end quotation

@node Bind Action
@subsection Bind Action
@cindex bind action

The @var{BindAction} is used to extract the value of a computation and
pass it along as the value of this computation. The two computations
need not be of the same type -- although the exception types should be.

@float BNF,bindActionFig
@caption{Bind Action}
@display
@anchored{BindAction} ::= @var{Pattern} @code{<-} @var{Expression}
@end display
@end float

@quotation Note
A @var{BindAction} may not be the last action in an @var{BlockAction}.
@end quotation

@node Definition Action
@subsection Definition Action
@cindex definition action

The @var{DefnAction} is used to bind a variable to a value -- that is
available to subsequent actions.

@float BNF,defnActionFig
@caption{Definition Action}
@display
@anchored{DefnAction} ::= @var{Pattern} @code{=} @var{Expression}
@end display
@end float

A @var{DefnAction} differs from a @var{BindAction} primarily in the
fact that the latter is used to unwrap a computation whereas the
@var{DefnAction} computes any value and does not otherwise touch the
value.

The scope of a local variable declaration is from the local
declaration itself to the end of the containing @emph{BlockAction}.

@quotation Note
It is an error for a variable to be referenced within its own
definition. Recursive definitions are not permitted.
@end quotation

left hand side of a definition is a @var{Pattern}, not simply an
@var{Identifier}.

One primary use for this form is to allow the unpacking of function
results.

For example, the function @code{ddivide} below returns a pair of values: the
quotient and the remainder result of dividing the first argument by
the second:

@example
ddivide:(integer,integer)=>(integer,integer).
ddivide(X,Y) => (X/Y,X%Y).
@end example

We can unpack the results of a call to @code{ddivide} using a
@var{TuplePattern} on the left hand side of the declaration:

@example
(Q,R) = ddivide(34,3)
@end example

which would have the effect of binding @code{Q} to @code{11}, and @code{R} to @code{1}.

@quotation Note
Like the @var{BindAction}, it does not make sense for a
@var{DefnAction} to be the last action in an @var{BlockAction}.
@end quotation

@node Assignment Action
@subsection Assignment Action
@cindex assignment action
@findex :=

The @var{AssignmentAction} is used to modify the contents of a
re-assignable variable.

It does not return a useful value (actually returns the empty tuple),
and so it is not normally part of a bind operation.

There is a special case of the @var{AssignmentAction}: where the
variable being assigned to is new (i.e., not otherwise in scope). Such
an assignment is actually interpreted as establishing a local
re-assignable variable; just like the @var{DefnAction}. In this case,
the scope of the defined variable extends from the beginning of the
next action to the end of the enclosing @var{BlockAction}.


@float BNF,assignctionFig
@caption{Assignment Action}
@display
@anchored{AssignmentAction} ::= @var{Variable} @code{:=} @var{Expression}
@end display
@end float

@node Conditional Action
@subsection Conditional Action
@cindex conditional action

The @var{IfThenElseAction} is used to denote a conditional computation.

@float BNF,condActionFig
@caption{If Then Else Action}
@display
@anchored{IfThenElseAction} ::= @code{if} @var{Expression} @code{then} @var{Action} @code{else} @var{Action}
  | @code{if} @var{Expression} @code{then} @var{Action}
@end display
@end float

The action expressions of the @code{then} and @code{else} branches
must be of the same type. I.e., they must be the same computations of
the same type of value.

The second form of @var{IfThenElseAction} -- which omits the
@code{else} branch -- is equivalent to one in which the else branch is
replaced by the @var{NullAction}:

@example
if @var{Test} then
  @var{A}
else
  nothing
@end example

Because of this, and because of the constraint that both arms of an
@var{InThenElseAction} return the same type, the type returned by such
an action is always the empty tuple -- @code{()}.

@node While Action
@subsection While Action
@cindex while action
@findex while

The @var{WhileAction} is used to denote an iterative computation that
repeats so long as some condition is satisfied.

@float BNF,whileActionFig
@caption{While Action}
@display
@anchored{WhileAction} ::= @code{while} @var{Condition} @code{do} @var{Action}
@end display
@end float

The enclosed action will be repeated zero or more times, for so long
as the test condition is satisfied.

The value returned by a @var{WhileAction} is always the empty
tuple. Because of this, @var{WhileActions} nearly always achieve their
result by means of side-effects -- such as by assigning to
reassignable variables.

@node For Action
@subsection For Action
@cindex for action
@findex for

The @var{ForAction} is used to denote an iterative computation that is governed by alternate solutions to a @var{QueryCondition}.

@float BNF,forActionFig
@caption{For Action}
@display
@anchored{ForAction} ::= @code{for} @var{QueryCondition} @code{do} @var{Action}
@end display
@end float

The enclosed action will be repeated zero or more times, for so long
as the test condition is satisfied. Each such solution to the
@var{QueryCondition} may result in different bindings for variables --
those variables are in scope within the enclosed action.

For example, the action:
@example
for (X,Y) in parent && (Y,Z) in parent do @{
  gps := [(X,Z),..gps!]
@}
@end example
collects grandparents into the re-assignable variable @code{gps}.

Like @var{WhileAction}s, the value returned by a @var{ForAction} is
always the empty tuple.

@node Try Catch Action
@subsection Try Catch Action
@cindex try catch action
@findex try
@findex catch

The @var{TryCatchAction} is used to denote a computation which may
need to respond to exception situations. 

@float BNF,tryCatchActionFig
@caption{Try Catch Action}
@display
@anchored{TryCatchAction} ::= @code{try} @var{Action} @code{catch} @var{Handler}
@anchored{Handler} ::= @var{BlockAction}
                | @var{Expression}
@end display
@end float

There are two forms of @var{TryCatchAction}s: one where the handler is
very simple -- to the point of ignoring the exception itself -- and
the second where the handler should be a function from the error type
of the computation to a valid computation.

@node Throw Action
@subsection Throw Action
@cindex throw action
@findex throw

The @var{ThrowAction} is used to denote a failed computation. The
@var{ThrowAction} takes an error value which becomes the error value
of computation as a whole.

@float BNF,throwctionFig
@caption{Throw Action}
@display
@anchored{ThrowAction} ::= @code{throw} @var{Expression}
@end display
@end float

@quotation Note
If a computation throws an error value, and that error exception is
not caught by a @var{TryCatchAction}, then the execution of the entire
program is terminated.
@end quotation




