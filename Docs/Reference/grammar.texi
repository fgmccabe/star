@node Grammar Rules
@chapter Grammar Rules
@cindex grammar rules

There are many occasions when it is necessary to parse text. For
example, the @Star{} run-time has parses for URIs, json files as well
as for some internal formats.

The grammar rule notation is intended to make it straightforward to
develop parsers using a high level notation.

@node Grammar rule notation
@section Grammar rule notation

A grammar rule denotes a way of parsing a stream of elements. For example, the grammar rule:

@example
sumExp >> .sum(L,R) --> prodExp >> L, [`+`], sumExp >> R.
@end example

is a classic fragment from an expression parser. It states that a
@code{sumExp} can be formed by a @code{prodExp}, a @code{+} character
and a @code{sumExp}.

The expressions following the chevrons denote output: the output of the rule as a whole is the expression

@example
.sum(L,R)
@end example

assuming that the @code{prodExp} returns the value @code{L} and the
right hand side @code{sumExp} returns @code{R.}

The language is quite expressive, including support for many common
patterns -- such as repeated sequences and interleaved sequences.

@float BNF,grammarRuleFig
@caption{Grammar Rule Notation}
@display
@anchored{Grammar Rule} ::= @refer{GrammarRuleHead} @code{-->} @refer{RuleBody}

@anchored{GrammarRuleHead} ::= @refer{NonTerminal} @code{>>} @refer{Expression}

@anchored{RuleBody} ::= @refer{NonTerminal} |
  @refer{Terminal} |
  @refer{RuleBody} @code{,} @refer{RuleBody} |
  @refer{RuleBody} @code{|} @refer{RuleBody} |
  @refer{RuleBody} @code{*} |
  @refer{RuleBody} @code{*} @refer{RuleBody} |
  @code{~} @refer{RuleBody} |
  @refer{RuleBody} @code{>>} @refer{Pattern} |
  @code{@{} @refer{Condition} @code{@}} |
  @code{fail} |
  @code{end}
@end display
@end float

@node Grammar Rule Type
@subsection Grammar Rule Type

The type of a grammar non-terminal is a function type:

@example
stream[s->>t] |: (s) => option[(r,s)]
@end example

where @code{s} is the type of the stream of tokens (@code{t}) being
parsed. The result of a successful parse is a pair: a value (@code{r})
and the remaining part of the stream (@code{s}).

Where a grammar symbol has arguments, they follow the stream type.

@node Terminal Symbols
@subsection Terminal Symbols

Terminal symbols are denoted by patterns, enclosed in square brackets,
that are used to match successive tokens from the input stream.

@float BNF,terminalSymbolFig
@caption{Terminal Symbols}
@display
@anchored{Terminal} ::= @code{[} @refer{Pattern} @code{,} @dots{} @code{,} @refer{Pattern} @code{]}
@end display
@end float

The @refer{Pattern} is used to match against a single token in the input.

Sequences of terminals can be written enclosed within a common set of
square brackets.

@node Non Terminal Symbols
@subsection Non Terminal Symbols

Non terminal symbols refer to the application of a grammar rule. Non
terminals are denoted by either by an identifier -- the name of the
grammar being referred to -- or by an applicative expression.

The latter are a useful means of introducing context sensitivity to a
grammar. For example, in the rule:

@example
termLeft(Pr) >> (.app(Op,[A]),OPr) --> [O],
  @{(OPr,RP,Op)?=prefix(O) && OPr=<Pr @}, term(RP)>>(A,_).
@end example

The argument @code{Pr} to the @code{termLeft} non-terminal is used to
indicate the desired operator priority in a prefix operator
combination.

Non-terminals can produce values, as can be seen here, and within a
rule, the value returned by a non-terminal can be matched against.
  
@float BNF,nonTerminalSymbolFig
@caption{Non Terminal Symbols}
@display
@anchored{NonTerminal} ::= @refer{Identifier} | @refer{ApplicativeExpression}
@end display
@end float






