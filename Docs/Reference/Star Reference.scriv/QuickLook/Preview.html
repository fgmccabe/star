<html>

<head>
<title>Star Reference</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<!-- NOTE: margin property = top-right-bottom-left -->
<style type="text/css">

	body {background-color: #e2e2e2}
    
    p.topLevelItemTitle {
    	margin: 30px 0px 5px 0px;
    	font-family: Times, Times New Roman, Palatino, Cochin, Serif;
    	font-size: 30px;
    	}
    	
    p.folderTitle {
    	margin: 30px 0px 5px 0px;
    	font-family: Times, Times New Roman, Palatino, Cochin, Serif;
    	font-size: 18px;
    	}
    
    p.itemTitle {
    	margin: 30px 0px 5px 0px;
    	font-family: Helvetica, Arial, Sans-Serif;
    	font-size: 12px;
    	font-weight: bold;
    	}
    	
    p.itemText {
    	margin: 0px 0px 10px 0px;
    	font-family: Helvetica, Arial, Sans-Serif;
    	font-size: 12px;
    	}
    	
    p.itemTextStart {
    	margin: 30px 0px 10px 0px;
    	font-family: Helvetica, Arial, Sans-Serif;
    	font-size: 12px;
    	}
    
    .page {border: 1px solid #c0c0c0; background: #fff}
    
    hr {
        border: none;
        height: 1px;
        color: #d4d4d4;
        background-color: #d4d4d4;
      	}
      	
    hr.afterTitle {
    	margin-top: -3px;
    }
      	
    hr.afterText {
    	margin-top: 30px;
    }
      	
    ul {
      	list-style-type: none;
      	padding-left: 30px;
      	}
      	
</style>

</head>

<body>

<table border="0" width="100%" cellspacing="3">
<tr>
<td>

<table class="page" width="100%" cellspacing="10" cellpadding="2">

<!-- Top margin -->
<!-- Not needed, because of the padding above titles. -->
<!--<tr><td height="15px"></td></tr>-->

<tr>

<!-- 42 + 30 of list indent = 72 - one inch. -->
<!-- Actually that ends up too much, so we do 25 + 30 = 55px. -->
<td width="25px">

<td valign="top">

<ul>
<li>
<p class="topLevelItemTitle">Foreword</p>
</li>
<li>
<p class="topLevelItemTitle">Introduction</p>
<p class="itemText">Star is a high-level symbolic programming language oriented to the needs of large-scale high performance processing in modern parallel and distributed computing environments.</p>
<p class="itemText">Star is a functional-first language -- in that functions and other programs are first class values. However, it is explicitly not a pure language: it has support for updatable variables and structures. However, its bias is definitely in favor of functional programming and in order to get the best value from programming in S...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">About This Reference</p>
<p class="itemText">This reference is the language definition of the Star language. It is intended to be thorough and as precise as possible in the features discussed. However, where appropriate, we give simple examples as illustrative background to the specification itself.</p>
</li>
<li>
<p class="itemTitle">Syntax Rules</p>
<p class="itemText">Throughout this document we introduce many syntactic features of the language. We use a variant of traditional BNF grammars to do this. The meta-grammar can be described using itself; as shown below.</p>

</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Meta Grammar</p>
<p class="itemText"></p>
<p class="itemText">MetaGrammar ::= Production .. Production</p>
<p class="itemText">Production ::= NonTerminal ::=  Body</p>
<p class="itemText">Production ::+= NonTerminal ::+= Body</p>
<p class="itemText">Body ::= Quoted | NonTerminal | Choice | Optional | Sequence | ( Body )</p>
<p class="itemText">Quoted ::= Characters</p>
<p class="itemText">NonTerminal ::= Identifier</p>
<p class="itemText">Choice ::= Body |..| Body</p>
<p class="itemText">Optional ::= [ Body ]</p>
<p class="itemText">Sequence ::= Body  op .. op Body [+]</p>
<p class="itemText">Meta-Grammar Used in this Reference</p>
<p class="itemText">Some grammar combinations are worth explaining as they occur quite frequently and may not be standard in BNF-style grammars. For example the ...</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Typographical Conventions</p>
<p class="itemText">Any text on a programming language often has a significant number of examples of programs and program fragments. In this reference, we show these using a typewriter-like font, often broken out in a display form:</p>
<p class="itemText">...</p>
<p class="itemText">P : integer</p>
<p class="itemText">...</p>
<p class="itemText">We use the ... ellipsis to explicitly indicate a fragment of a program that is embedded in a context.</p>
<p class="itemText">Occasionally, we have to show a somewhat generic fragment of a program where you, the programmer, are expected to put your own text in. We highlight such areas using ...</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="topLevelItemTitle">Syntax</p>
<p class="itemText">Given the extensible nature of Star, this description of syntax focuses on the term-level syntax: well formed forms of the language. This is composed of two layers: the lexical syntax which defines legal tokens and the grammar which defines legal combinations of tokens.</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Lexical Syntax</p>
<p class="itemText">Star source text is based on the Unicode character set. This means that identifiers and string values may directly use any Unicode characters. However, all the standard operators and keywords fall in the ASCII subset of Unicode.</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Comments and White Space</p>
<p class="itemText"></p>
<p class="itemText">Input is tokenized according to rules that are similar to most modern programming languages: contiguous sequences of characters are assumed to belong to the same token unless the class of character changes -- for example, a punctuation mark separates sequences of letter characters. In addition, white space and comments serve as token boundaries; otherwise white space and comments are ignored by the higher-level semantics of the language.</p>
<p class="itemText">Ignorable ::= LineComment</p>
<p class="itemText"> | BlockComment</p>
<p class="itemText"> | WhiteSpace</p>
<p class="itemText">I...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Line Comment </p>
<p class="itemText">A line comment consists of a --␠ (a double dash followed by a space) or a --\t followed by all characters up to the next new-line. Here,  \t refers to the Horizontal Tab.</p>
<p class="itemText">LineComment ::= ( --␠  | --\t) Char .. Char \n</p>
<p class="itemText">Line Comment</p>
</li>
<li>
<p class="itemTitle">Block Comment</p>
<p class="itemText">A block comment consists of the characters /* followed by any characters and terminated by the characters */.</p>
<p class="itemText"></p>
<p class="itemText">BlockComment ::= /* Char .. Char */</p>
<p class="itemText">Block Comment</p>
<p class="itemText">Each form of comment overrides the other: a /* sequence in a line comment is not the start of a block comment, and a --  sequence in a block comment is similarly not the start of a line comment but the continuation of the block comment.</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Number Literals</p>
<p class="itemText">Star supports integer values, floating point values, and character codes as numeric values.</p>
<p class="itemText">NumericLiteral ::= Decimal</p>
<p class="itemText">  | Hexadecimal</p>
<p class="itemText">  | FloatingPoint</p>
<p class="itemText">  | CharacterCode</p>
<p class="itemText">Numeric Literals</p>
<p class="itemText"></p>
<p class="itemText">[TIP] The lexical syntax for numeric values is for positive values only. The interpretation of negative numeric literals is part of the grammar, not the lexical notation.</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Decimal Literals</p>
<p class="itemText">An integer is written using the normal decimal notation:</p>
<p class="itemText">1  34 -99</p>
<p class="itemText"></p>
<p class="itemText">Decimal::=Digit ... Digit+</p>
<p class="itemText">Digit::=0|1|2|3|4|5|6|7|8|9</p>
<p class="itemText">Integer Literals</p>
<p class="itemText"></p>
<p class="itemText">[TIP] All integers are represented as at least 64 bit values.</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Hexadecimal Integers</p>
<p class="itemText">A hexadecimal number is an integer written using hexadecimal notation. A hexadecimal number consists of a leading 0x followed by a sequence of hex digits. For example,</p>
<p class="itemText">0x0 0xff 0x34fe</p>
<p class="itemText">are all hexadecimals.</p>
<p class="itemText"></p>
<p class="itemText">Hexadecimal::= 0x Hex ... Hex+</p>
<p class="itemText">Hex::= 0|1|2|3|4|5|6|7|8|9|a|b|c|d|e|f</p>
<p class="itemText">Hexadecimal numbers</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Floating Point Numbers</p>
<p class="itemText">Floating point numbers are written using a notation that is familiar. For example,</p>
<p class="itemText">234.45  1.0e45</p>
<p class="itemText">The notation for floating point is:</p>
<p class="itemText">FloatingPoint::=Decimal . Decimal [e[-]Decimal]]</p>
<p class="itemText">Floating Point numbers</p>
<p class="itemText">[TIP] All floating point number are represented to a precision that is at least equal to 64-bit double precision. There is no equivalent of single-precision floating pointer numbers.</p>
</li>
<li>
<p class="itemTitle">Character Codes</p>
<p class="itemText">The character code notation allows a number to be based on the Unicode CodePoint value of a character. Any Unicode character code point can be entered in this way:</p>
<p class="itemText">0cX 0c[ 0c\n 0c</p>
<p class="itemText">For example, 0c\n is the codepoint associated with the new line character, i.e., its value is 10.</p>
<p class="itemText">[TIP] Unicode has the capability to represent up to one million character code points.</p>
<p class="itemText">CharacterCode::=0cCharRef</p>
<p class="itemText">Character Codes</p>
<p class="itemText">[TIP] A CharacterCode is an integer. This notation allows string processing programs to repre...</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Strings and Characters</p>
<p class="itemText">A string consists of a sequence of characters -- specifically CharRefs. There is no specific type in Star for the characters themselves.</p>
<p class="itemText">[CAUTION] The reasons for this are due to the fact that Unicode string values cannot be always be represented as a unique sequence.</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Character Reference</p>
<p class="itemText">A CharRef is a denotation of a single character; which is either a ‘regular’ character or an escape sequence.</p>
<p class="itemText">CharRef ::= Char | Escape</p>
<p class="itemText">Escape::=\b|\d|\e|\f|\n|\r|\t|\v |\ Char | \u Hex ... Hex;</p>
<p class="itemText">Character Reference</p>
<p class="itemText">For most characters, the character reference for that character is the character itself. For example, the string "T" contains the character T. However, certain standard characters are normally referenced by escape sequences consisting of a backslash character followed by other charact...</p>
</li>
<li>
<p class="itemTitle">Quoted Strings</p>
<p class="itemText">A string is a sequence of character references (CharRef) enclosed in double quotes; alternately a string may take the form of a triple-quoted BlockString. In addition, quoted strings support interpolation — expressions that are embedded in a string and are formatted in place.</p>
<p class="itemText">StringLiteral ::= " StrChar ... StrChar “ | BlockString</p>
<p class="itemText">StrChar ::= CharRef | Interpolation</p>
<p class="itemText">Interpolation ::= [$| #] Identifier [FormattingSpec]]</p>
<p class="itemText">  |[$| #] ( Expression ) [FormattingSpec ]</p>
<p class="itemText">FormattingSpec ::= : CharRef ... C...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Block String </p>
<p class="itemText">In addition to the normal notation for strings, there is a block form of string that permits raw character data to be processed as a string.</p>
<p class="itemText">BlockString::=""" Char ... Char """</p>
<p class="itemText">Block String Literal</p>
<p class="itemText">The block form of string allows any characters in the text and performs no interpretation of those characters.</p>
<p class="itemText">Block strings are written using triple quote characters at either end. Any new-line characters enclosed by the block quotes are considered to be part of the strings.</p>
<p class="itemText">The normal interpretation...</p>
</li>
</ul>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Identifiers</p>
<p class="itemText">Identifiers are used to denote operators, keywords and variables. There are four main kinds of identifier: regular alpha-numeric identifiers, graphic identifiers, multi-word identifiers and quoted identifiers. However, semantically, all these are essentially equivalent: they all identify some variable or some type.</p>
<p class="itemText">Identifier::=AlphaNumeric</p>
<p class="itemText">  | MultiWordIdentifier</p>
<p class="itemText">  | GraphicIdentifier</p>
<p class="itemText">  | QuotedIdentifier</p>
<p class="itemText">Identifier Syntax</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Alphanumeric Identifiers</p>
<p class="itemText">Identifiers in Star are based on the Unicode definition of identifier. For the ASCII subset of characters, the definition corresponds to the common form of identifier -- a letter followed by a sequence of digits and letters. However, non-ASCII characters are also permitted in an identifier.</p>
<p class="itemText">AlphaNumeric::=LeadChar BodyChar...BodyChar</p>
<p class="itemText">LeadChar::=LetterNumber</p>
<p class="itemText">  | LowerCase</p>
<p class="itemText">  | UpperCase</p>
<p class="itemText">  | TitleCase</p>
<p class="itemText">  | OtherNumber</p>
<p class="itemText">  | OtherLetter</p>
<p class="itemText">  | ConnectorPunctuation</p>
<p class="itemText">BodyChar::=LeadChar</p>
<p class="itemText">  | ModifierLetter</p>
<p class="itemText">  ...</p>
</li>
<li>
<p class="itemTitle">Multi-word Identifiers</p>
<p class="itemText">A MultiWordIdentifier is an Identifier that is written as a contiguous sequence of alphanumeric words. Although written as multiple words, a MultiWordIdentifier is logically a single identifier. For example, the combination of words:</p>
<p class="itemText">group by</p>
<p class="itemText">is logically a single multi-word identifier whose name is ‘group by’.</p>
<p class="itemText">There are a few standard MultiWordIdentifiers, as outlined below. In addition, MultiWordIdentifiers can be defined as operators.</p>
<p class="itemText"></p>
<p class="itemText">`any of` | `group by` | `has value` |</p>
<p class="itemText">`such that` | `coun...</p>
</li>
<li>
<p class="itemTitle">Punctuation Symbols and Graphic Identifiers</p>
<p class="itemText">The standard operators often have a graphic form -- such as +, and =<. <<standardGraphicsTable>> contains a complete listing of all the standard graphic-form identifiers.</p>
<p class="itemText">GraphicIdentifier ::= SymbolicChar .. SymbolicChar</p>
<p class="itemText">SymbolicChar ::= Char excepting BodyChar</p>
<p class="itemText">Graphic Identifiers</p>
<p class="itemText"></p>
<p class="itemText">`!` | `#<` |`%%` | `-->` | `:!` | `;` | `=>` | `\|` |</p>
<p class="itemText">`!`=| `#<>` | `*` | `->` | `:\|` | `;*` | `\|>` | `*` |</p>
<p class="itemText">`#` | `#@` | `**` | `.` | `:*` | `<` |`<\|` | `>` |</p>
<p class="itemText">`##` | `+` | `..,` |`:+` |`<=` | `>=` | `~` |</p>
<p class="itemText">`\`#\$|`...</p>
</li>
<li>
<p class="itemTitle">Operator Defined Tokens</p>
<p class="itemText">When a new operator is defined it may be that it takes the form of a normal identifier; as in:</p>
<p class="itemText">#infix(‘hello’,50)</p>
<p class="itemText">However, it is also possible to define an operator from special characters:</p>
<p class="itemText">#prefix(‘|.|’,80)</p>
<p class="itemText">The operator identifier — |.| — is not a normal alphanumeric identifier.</p>
<p class="itemText">When such a declaration is processed, the tokenizer extends itself to include the new operator identifier as a valid token. Hence an operator may be constructed out of any characters.</p>
<p class="itemText">[WARNING] It is not permissible to ...</p>
</li>
<li>
<p class="itemTitle">Quoted Identifiers</p>
<p class="itemText">A quoted identifiers is denoted by a sequence of CharRefs enclosed in single quotes. Recall that strings are enclosed in double quotes.</p>
<p class="itemText">QuotedIdentifier ::= 'StrChar .. StrChar'</p>
<p class="itemText">Quoted Identifier</p>
<p class="itemText">A quoted identifier suppresses any operator or keyword interpretation that the identifier might otherwise have.</p>
<p class="itemText">[TIP] This can be useful for external facing interfaces where, for example, the name of a field in a structure must have a particular form -- even if that would otherwise be a keyword.</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Standard Keywords</p>
<p class="itemText">There are a number of keywords which are reserved by the language -- these may not be used as identifiers or in any other role.</p>
<p class="itemText"></p>
<p class="itemText">This table lists the standard keywords:</p>
<p class="itemText">let</p>
<p class="itemText">this</p>
<p class="itemText">ref</p>
<p class="itemText">import</p>
<p class="itemText">public</p>
<p class="itemText">private</p>
<p class="itemText">open</p>
<p class="itemText">contract</p>
<p class="itemText">implementation</p>
<p class="itemText">type</p>
<p class="itemText">where</p>
<p class="itemText">assert</p>
<p class="itemText">all</p>
<p class="itemText">exists</p>
<p class="itemText">Standard Keywords</p>
<p class="itemText">[TIP] On those occasions where it is important to have an identifier that is a keyword it is possible to achieve this by enclosing the keyword in single quotes.</p>
<p class="itemText">For example, while type is a keyword in the language; enclo...</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Grammar</p>
<p class="itemText">The grammar of Star is based on a notation which makes extensibility easier to achieve. Thus, at the core, the grammar is very simple and straightforward -- it is based on an operator precedence grammar.</p>
<p class="itemText">[TIP] This choice gives us two key benefits: it is simple to understand and it is simple to extend.</p>
<p class="itemText">However, it also makes certain other aspects more challenging. In particular, an operator precedence grammar knows less about the program as it is parsed. This means that syntax errors are liable ...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Operator Precedence Grammar</p>
<p class="itemText">An operator grammar allows us to write expressions like:</p>
<p class="itemText">X * Y + X / Y</p>
<p class="itemText">and to know that this means the equivalent of:</p>
<p class="itemText">(X * Y) + (X / Y)</p>
<p class="itemText">or more specifically:</p>
<p class="itemText">‘+’(‘*’(X, Y), ‘/‘(X, Y))</p>
<p class="itemText">Operator precedence grammars are often used to capture arithmetic-style expressions. In Star we extend the concept to cover the entire language.</p>
<p class="itemText">For example, an equation such as:</p>
<p class="itemText">double(X) => X*X</p>
<p class="itemText">can be interpreted – by treating => as an operator – as:</p>
<p class="itemText">'=>'(double(X),’*’(X,X))</p>
<p class="itemText">Of course, this is merely a parse of t...</p>
</li>
<li>
<p class="itemTitle">Standard Operators</p>
<p class="itemText">A key input to the grammar is the table of operators. Star starts with a number of standard operators, but this can be extended via the use of extensions to the language.</p>
<p class="itemText">The standard operators that are part of the core language and the base extensions are listed below. Operators in this table are listed in order of priority. Together with a priority, operators can also be considered to prefix, infix, postfix, or some combination of the three.</p>
<p class="itemText">The priority of an operator is the indication of the...</p>
</li>
<li>
<p class="itemTitle">Defining new Operators</p>
<p class="itemText">Operators can be defined using one of the meta-statements listed below:</p>
<p class="itemText">OperatorDeclaration ::= # [force] ( PrefixOperator | InfixOperator | PostfixOperator</p>
<p class="itemText"> | BracketDeclaration)</p>
<p class="itemText">PrefixOperator ::= prefix( OperatorName , Integer) |</p>
<p class="itemText">    prefixAssoc( OperatorName , Integer )</p>
<p class="itemText">InfixOperator ::= left( OperatorName , Integer ) |</p>
<p class="itemText">     infix( OperatorName , Integer ) |</p>
<p class="itemText">     right( OperatorName , Integer )</p>
<p class="itemText">PostfixOperator ::= postfix( OperatorName , Integer) |</p>
<p class="itemText">    postfixAssoc( OperatorName , Integer )</p>
<p class="itemText">...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Infix Operator Definition</p>
<p class="itemText">A statement of the form:</p>
<p class="itemText">#infix(‘myOp’,730).</p>
<p class="itemText">defines the operator myOp to be an infix operator, with priority 730.</p>
<p class="itemText">Defining an operator does not define anything about its semantics -- except that in the case of an infix operator, it has two arguments.</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Left Associative Infix Operator</p>
<p class="itemText">A statement of the form:</p>
<p class="itemText">#left(‘lftOp’,730).</p>
<p class="itemText">defines the operator lftOp to be a left-associative infix operator, with priority 730. That means that expression such as</p>
<p class="itemText">A lftOp B lftOp C lftOp D</p>
<p class="itemText">will be parsed as though written:</p>
<p class="itemText">((A lftOp B) lftOp C) lftOp D</p>
</li>
<li>
<p class="itemTitle">Right Associative Infix Operator</p>
<p class="itemText">A statement of the form:</p>
<p class="itemText">#right(‘rgtOp’,730).</p>
<p class="itemText">defines the operator rgtOp to be a right associate infix operator, with priority 730. Exressions such as</p>
<p class="itemText">A rgtOp B rgtOp C rgtOp D</p>
<p class="itemText">will be parsed as though written:</p>
<p class="itemText">(A rgtOp (B rgtOp (C rgtOp D)))</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Prefix Operator</p>
<p class="itemText">A statement of the form:</p>
<p class="itemText">#prefix(‘prOp’,730).</p>
<p class="itemText">defines the operator prOp to be a prefix operator, with priority 730.</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Associative Prefix Operator</p>
<p class="itemText">A statement of the form:</p>
<p class="itemText">#prefixAssoc(‘prOp’,730).</p>
<p class="itemText">defines the operator prOp to be an _associative_ prefix operator, with priority 730. That means that expressions such as:</p>
<p class="itemText">prOp prOp prOp A</p>
<p class="itemText">are permitted, and have interpretation:</p>
<p class="itemText">(prOp (prOp (prOp A)))</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Postifx Operator</p>
<p class="itemText">A statement of the form:</p>
<p class="itemText">#postfix(‘psOp’,730).</p>
<p class="itemText">defines the operator psOp to be a postfix operator, with priority 730.</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Associative Postfix Operator</p>
<p class="itemText">A statement of the form:</p>
<p class="itemText">#postfixAssoc(‘psOp’,730).</p>
<p class="itemText">defines the operator psOp to be an associative postfix operator, with priority 730. That means that expressions such as:</p>
<p class="itemText">A psOp psOp psOp</p>
<p class="itemText">are permitted, and have interpretation:</p>
<p class="itemText">(((A psOp) psOp) psOp)</p>

</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Forced Operator Declaration</p>
<p class="itemText">Normally, any attempt to re-declare an operator will result in a syntax error being raised. However, there may be situations where it is important to be able to change an existing operator declaration.</p>
<p class="itemText">[TIP] Note that a given identifier may be defined as a prefix operator, an infix operator and a postfix operator. Each of these are treated separately.</p>
<p class="itemText">The force directive is used in this situation:</p>
<p class="itemText">#force(infix(‘as’,200)).</p>
<p class="itemText">has the effect of changing the existing operator priority of the as operat...</p>
</li>
<li>
<p class="itemTitle">Symbolic Operators</p>
<p class="itemText">An operator may consist of a single Identifier, a sequence of Identifiers or it may consist of a QuotedIdentifier containing a sequence of so-called symbolic characters. In this form, the first character of the operator may not be a digit or a letter. In addition, none of the characters may be a space or other white-space character.</p>
<p class="itemText">However, other than these constraints the characters in the operator declaration may be any legal unicode character.</p>
<p class="itemText">[TIP] For the sake of programmers' sanity we str...</p>
</li>
<li>
<p class="itemTitle"> Multi-word Operators</p>
<p class="itemText">A multi-word operator defines a new MultiWordIdentifier; i.e., a special combination of alpha numeric words that form a single logical identifier.</p>
<p class="itemText">Multi-word operators are defined like regular operators, except that their names contain spaces. For example, the operator declaration:</p>
<p class="itemText">#infix(‘no more’,500).</p>
<p class="itemText">defines the combination of words no followed by more as a single operator of priority 500.</p>
<p class="itemText">A multi-word operator is only an operator when all of its constituent words are present. If one or more...</p>
</li>
<li>
<p class="itemTitle">Bracketing pairs</p>
<p class="itemText">The Star grammar also permits a special feature that may be used to support language extensions -- defined bracket pairs.</p>
<p class="itemText">A regular bracket pair is a pair of tokens such as ( and ) which are used to 'protect' expressions where there may be an operator precedence clash -- the classic example being</p>
<p class="itemText">(2+3)*4</p>
<p class="itemText">which has a different meaning to</p>
<p class="itemText">2+3*5</p>
<p class="itemText">Declaring bracket operators allows new forms of syntax. For example, the statement:</p>
<p class="itemText">#pair(‘begin’,’end’,2000).</p>
<p class="itemText">can be used to all programmers to use Algol-...</p>
</li>
</ul>
</ul>
</ul>
<hr class="afterText"/>

<li>
<p class="topLevelItemTitle">Types</p>
<p class="itemText">Star is a strongly, statically, typed language. That means that all values and all variables must have a unique well-defined type that is determinable by inspecting the text of the program -- effectively at `compile time'.</p>
<p class="itemText">The type system of Star consists of a method for declaring new types, for annotating variables (and by extension programs) with their types and a system of verifying the type consistency of programs.</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">What is a Type?</p>
<p class="itemText">A Type is an expression that denotes a set of values.</p>
<p class="itemText">[TIP] Although a type is an expression, type expressions should not be confused with normal expressions. Types play no part in evaluation.</p>
<p class="itemText">Viewed as sets, types have some particular properties: no value may be a member of more than one type set; all values are members of exactly one type set.</p>
<p class="itemText">A TypeDefinition introduces a new type and defines what values belong to the type. A TypeAnnotation is an assertion that a particular expression -- usua...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Type Safety</p>
<p class="itemText">The connection between the argument type of a `cons` type expression and the actual elements of lists is denoted by a type inference rule. Type inference rules are rules for relating expressions and statements in the language to the types associated with that statement. For example, the rule:</p>
<p class="itemText">E |= El1:T .. E |= Eln:T => E |= cons of [El1,..,Eln] : cons[T]</p>
<p class="itemText">says that if the expressions El1:T through Eln:T all have type T, then the list expression</p>
<p class="itemText">cons of [El1,..,Eln]</p>
<p class="itemText">has type cons[T]. This is the ...</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Type Annotations</p>
<p class="itemText">In many cases it is not necessary to explicitly declare the type of a variable. However, it is good practice to declare explicitly the types of programs; especially within thetaEnvironments.</p>
<p class="itemText">For example, a generic function consLength that takes a `cons` list and returns an integer would have the declaration:</p>
<p class="itemText">consLength:all t ~~ (cons[t])=>integer</p>
<p class="itemText">This is an example of a universally quantified type -- see <<universalType>> for more details.</p>
</li>
<li>
<p class="itemTitle">Types of Types</p>
<p class="itemText">There are several different kinds of type expressions that the Star programmer will encounter:</p>
<p class="itemText">Type::=TypeExpression</p>
<p class="itemText">  | TypeVariable | ReferenceType</p>
<p class="itemText">  | TupleType | RecordType</p>
<p class="itemText">  | FunctionType | PatternType | ConstructorType</p>
<p class="itemText">  | TypeQuantifier ‘~~’ Type</p>
<p class="itemText">  | TypeConstraint ‘|:’ Type</p>
<p class="itemText">  | `(` <<Type>> `)`</p>
<p class="itemText">  | EncapsulatedType</p>
<p class="itemText"></p>
<p class="itemText">TypeQuantifier ::= UniversalQuantifier | ExistentialQuantifier</p>
<p class="itemText">Types of Types</p>
<p class="itemText"></p>
<p class="itemText">There are two main kinds of type expressions -- so-called structural type expressions and name...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Type Expressions</p>
<p class="itemText">TypeExpression ::= TypeConstructor [Type ,..., Type ]</p>
<p class="itemText">  | Identifier</p>
<p class="itemText"></p>
<p class="itemText">TypeConstructor ::= Identifier | TypeVar</p>
<p class="itemText">Type Expressions</p>
<p class="itemText"></p>
<p class="itemText">A TypeExpression is a term that identifies a class of values by name. The name may or may not have TypeArguments -- in which case, the type is said to be parameterized.</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Simple Types</p>
<p class="itemText">A simple type is TypeExpression with no type arguments. Some simple types are pre-defined, this gives a table of such types:</p>
<p class="itemText">Type</p>
<p class="itemText">Description</p>
<p class="itemText">boolean</p>
<p class="itemText">used for logical values and conditions</p>
<p class="itemText">integer</p>
<p class="itemText">type of integer values</p>
<p class="itemText">float</p>
<p class="itemText">type of floating point numbers</p>
<p class="itemText">string</p>
<p class="itemText">type of string values</p>
<p class="itemText">quoted</p>
<p class="itemText">type of abstract syntax</p>
<p class="itemText">Standard Pre-defined Types</p>

</li>
<li>
<p class="itemTitle">Parameterized Types</p>
<p class="itemText">A parameterized TypeExpression consists of a TypeConstructor applied to one of more Type arguments. For example, the standard cons type constructor has one type argument -- the type of elements of the list.</p>
<p class="itemText">A parameterized type has a type arity -- the number of type arguments it expects. This is defined when the type itself is defined. It is an error to write a type expression involving an incorrect number of type arguments.</p>
<p class="itemText">Parameterized types may be defined using a TypeDefinition statement.</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Variable Type Constructors</p>
<p class="itemText">A type expression of the form:</p>
<p class="itemText">c[t1,...,tn]</p>
<p class="itemText">where c is a</p>
<p class="itemText">type variable -- i.e., bound by a quantifier -- denotes a rather special form of type: a type constructor expression. Like other parameterized type expressions, this expression does not denote a single type; but a set of types. For example, the type expression:</p>
<p class="itemText">c[integer]</p>
<p class="itemText">denotes a type `something of integer'.</p>
<p class="itemText">A subsequent constraint on c may cause it to be bound to the TypeConstructor cons (say), in which case the type expression becomes ...</p>
</li>
</ul>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Tuple Types</p>
<p class="itemText">A tuple type is a tuple of types; written as a sequence of type expressions enclosed in parentheses.</p>
<p class="itemText">TupleType ::= ()</p>
<p class="itemText">  | (( Type ))</p>
<p class="itemText">  | (Type ,.., Type)+2</p>
<p class="itemText">Tuple Type</p>
<p class="itemText">A tuple type denotes a fixed grouping of elements. Each element of the tuple may have a different type.</p>
<p class="itemText">There are two special cases in TupleTypes: the empty tuple and the singleton tuple type.</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Empty Tuple Type</p>
<p class="itemText">The empty tuple type:</p>
<p class="itemText">()</p>
<p class="itemText">refers to the empty tuple. It is useful primarily for writing function types where the function has no arguments:</p>
<p class="itemText">()=>string</p>
<p class="itemText">When used as the return type of a function, the () type denotes a void result:</p>
<p class="itemText">(integer)=>()</p>
<p class="itemText">[TIP] The () type -- sometimes referred to as the unit type -- is also used to denote the return type of some actions.</p>
</li>
<li>
<p class="itemTitle">Singleton Tuple Type</p>
<p class="itemText">A singleton tuple must be written with two parentheses. This is to disambiguate such terms from simple expression parentheses. A type expression of the form:</p>
<p class="itemText">(integer)</p>
<p class="itemText">is equivalent to just the integer type; whereas</p>
<p class="itemText">((integer))</p>
<p class="itemText">denotes the single element tuple type whose element type is integer.</p>
<p class="itemText">[NOTE:] This does not apply in all contexts. Especially when the tuple type is part of a function type — it is not necessary to wrap the single argument type in double parentheses:</p>
<p class="itemText">(string)=>integer</p>
<p class="itemText">Howe...</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Record Type</p>
<p class="itemText">A RecordType is a type expression that denotes a named association of fields and types. A record type is written as a sequence of type annotations enclosed in braces.</p>
<p class="itemText">RecordType ::=  {Annotation ; .. ;Annotation }</p>
<p class="itemText">TypeEquality ::= type Identifier = Type</p>
<p class="itemText">Record Type</p>
<p class="itemText">Record types are used as the type of anonymous records (see <<anonRecord>>). They are also the basis of other features of the type language -- including the ConstructorType and Contracts.</p>
<p class="itemText">Two record types are equivalent if their eleme...</p>
</li>
<li>
<p class="itemTitle">Function Type</p>
<p class="itemText">A function type denotes a function value. It takes the form of a possibly empty sequence of argument types -- denoting the types of the arguments to the function -- enclosed in parentheses; followed by the result type of the function. </p>
<p class="itemText">FunctionType ::= TupleType => Type</p>
<p class="itemText">Function Type</p>
<p class="itemText">For example, a function of two arguments -- an integer and a string that returns a list of strings has a type that takes the form:</p>
<p class="itemText">(integer,string) => cons[string]</p>

</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Procedure Type</p>
<p class="itemText"></p>
<p class="itemText">====</p>
<p class="itemText">[[procedureType]]</p>
<p class="itemText">(((procedure type)))</p>
<p class="itemText">(((type,procedure)))</p>
<p class="itemText"></p>
<p class="itemText">A procedure is an abstraction of an action. I.e., a procedure is a function that does not return a value but is executed purely for its side effect(s). This is expressed in the form of procedure types, which take the form of a function type that returns an empty tuple:</p>
<p class="itemText">TupleType => ()</p>
<p class="itemText">For example, a procedure that takes string and integer arguments would have the type signature:</p>
<p class="itemText">(string,integer)=>()</p>
<p class="itemText">And the type:</p>
<p class="itemText">()=>()</p>
<p class="itemText">denotes t...</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Pattern Abstraction Type</p>
<p class="itemText">A PatternAbstraction is an abstraction of a pattern. Pattern abstractions allow patterns to be treated as first class values -- i.e., passed in as arguments to programs and bound to variables -- and they may be applied in contexts where patterns are valid.</p>
<p class="itemText">PatternType ::= TupleType <= Type</p>
<p class="itemText">Pattern Type</p>
<p class="itemText">Pattern abstractions match a pattern, and extract values from that pattern; values that, in turn, may be matched against where the pattern abstraction is applied.</p>
<p class="itemText">For example, a PatternAbstraction...</p>
</li>
<li>
<p class="itemTitle">Constructor Type</p>
<p class="itemText">A constructor is a special function that is introduced in an AlgebraicType definition.</p>
<p class="itemText">[NOTE] Constructors are special because they can be viewed simultaneously as a function and as a pattern. Hence the form of the constructor reflects that bidirectionality.</p>
<p class="itemText">ConstructorType::=Type <=> Type</p>
<p class="itemText">Constructor Type</p>
<p class="itemText">The left hand side of a constructor type should either be a TupleType or an RecordType -- depending on whether the denoted constructor is a term constructor constructor or a record constructor...</p>
</li>
<li>
<p class="itemTitle">Reference Type</p>
<p class="itemText">A re-assignable variable is given a reference type.</p>
<p class="itemText">ReferenceType ::= ref Type</p>
<p class="itemText">Reference Type</p>
<p class="itemText">Reference types allow the programmer to distinguish re-assignable variables from other values; in particular they allow one to distinguish between binding to the value of a re-assignable variable or to its name.</p>
<p class="itemText">[NOTE] The latter is not as common, but is important to support abstractions involving re-assignable variables.</p>

</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Type Variables</p>
<p class="itemText">A type variable is a variable which may be bound to a type. Depending on whether the scope of a type variable is explicitly determined or implicitly determined, type variables are written as regular identifiers -- they are distinguished from regular named types by virtue of the quantifier they are bound by.</p>
<p class="itemText">TypeVariable ::= Identifier</p>
<p class="itemText">Type Variables</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Type Variable Kind</p>
<p class="itemText"></p>
<p class="itemText">Type variables are associated with a Kind -- which constrains the kinds (sic) of types that the type variables may be bound to. For example, a Kind of type implies that the type variable may be bound to any valid type -- but may not be bound to a TypeConstructor.</p>
<p class="itemText">[NOTE] The different kinds of type variable may not be mixed: it is not permissible to bind a type variable to a TypeConstructor, and vice versa.</p>
<p class="itemText">The Kind of a type variable is given by its quantifier declaration.</p>
<p class="itemText">For example, given:</p>
<p class="itemText">a...</p>
</li>
<li>
<p class="itemTitle">Scope of Type Variables</p>
<p class="itemText">All type variables have a scope which generally follows the scoping rules for normal variables.</p>
<p class="itemText">There are two particular cases that are important: type variables introduced via TypeDefinitions and those introduced via explicitly quantified type expressions.</p>
<p class="itemText">A variable introduced in the head of an AlgebraicType definition, or in the head of a Contract definition are in scope throughout the definition or contract respectively.</p>

</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Universally Quantified Types</p>
<p class="itemText">A universal type denotes a type that is valid for all substitutions of a type variable.</p>
<p class="itemText">UniversalType::= all BoundType,..,BoundType ~~ Type</p>
<p class="itemText">BoundType ::= Identifier | Identifier / Decimal</p>
<p class="itemText">Universal Type Expression</p>
<p class="itemText">The first form of BoundType introduces a regular type variable -- i.e., a variable of Kind type. The second form is used to introduce a higher-kinded type variable.</p>
<p class="itemText">For example, the quantification:</p>
<p class="itemText">all c/1 ~~ ...</p>
<p class="itemText">denotes a type variable of kind TypeConstructor.</p>
<p class="itemText">[TIP] Higher kinded type...</p>
</li>
<li>
<p class="itemTitle">Existentially Quantified Types</p>
<p class="itemText">An existential type denotes an abstract type.</p>
<p class="itemText">ExistentialType ::= exists BoundType,..,BoundType ~~ Type</p>
<p class="itemText">Existential Type Expression</p>
<p class="itemText">An existentially quantified type denotes a type within which there is an abstract type: i.e., the type exists but the expression is not explicit about which type.</p>
<p class="itemText">Existential types are most often used in the type signatures of abstract data types. For example, the term in the statement:</p>
<p class="itemText">R = {</p>
<p class="itemText">  type el = integer</p>
<p class="itemText">  op(X,Y) => X+Y</p>
<p class="itemText">}</p>
<p class="itemText">has type:</p>
<p class="itemText">exists el ~~ { el :: type...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Encapsulated Types</p>
<p class="itemText">An EncapsulatedType is a reference to a type that is embedded within a record.</p>
<p class="itemText">EncapsulatedType::=Expression . Identifier</p>
<p class="itemText">Encapsulated Type</p>
<p class="itemText">As noted above, record literals may have types embedded within them. Such a record type is existentially quantified.</p>
<p class="itemText">It is possible to access the type embedded within such a record -- albeit with some restrictions:</p>
<p class="itemText">The form of an EncapsulatedType reference is limited to terms of the form:</p>
<p class="itemText">R.t</p>
<p class="itemText">where R is a Variable whose type interface contains the type t.</p>
<p class="itemText">Mo...</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Type Constraints</p>
<p class="itemText">A TypeConstraint is a constraint on a Type; usually implying a constraint on the possible binding of a TypeVariable. For example, a Contract refers to a named collection of functions and a TypeVariable constrained by a ContractConstraint means that any concrete instantiation of the TypeVariable must be to a Type that implements the Contract — or more accurately, there must be an implementation of the contract that satsifies the Type.</p>
<p class="itemText">Similarly, a FieldConstraint constrains the TypeVariable so th...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Contract Constraints</p>
<p class="itemText">A ContractConstraint is a requirement on a Type -- or tuple of Types -- that whatever type it is, that there must exist an implementation of the Contract for the Type.</p>
<p class="itemText">For example, the type constraint expression:</p>
<p class="itemText">comparable[t]</p>
<p class="itemText">means that the type variable t may only unify with concrete types that implement the comparable contract.</p>
<p class="itemText">[NOTE] If t is unified with another type variable, then the constraints on both type variables are merged.</p>
<p class="itemText">[NOTE] Since only named types may implement Contracts, it is...</p>
</li>
<li>
<p class="itemTitle">Field Constraints</p>
<p class="itemText">A FieldConstraint is a requirement on a variable that whatever type it is, it should have particular attributes of particular types defined for it.</p>
<p class="itemText">FieldConstraint ::= Type <~ { <<TypeAnnotation>> ..  <<Annotation>> }</p>
<p class="itemText">Field Constraint</p>
<p class="itemText">For example, in</p>
<p class="itemText">r <~ { alpha : string. beta : long }</p>
<p class="itemText"></p>
<p class="itemText">if r is unified against a concrete type then that type's RecordType interface must contain both of alpha and beta. In addition, the fields must be of the right types.</p>
<p class="itemText">[NOTE] It is also possible to require that a...</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Type Annotations</p>
<p class="itemText">A TypeAnnotation is a statement that declares a variable to have a certain Type.</p>
<p class="itemText">For example,</p>
<p class="itemText">alpha:all t ~~ (t)=>string</p>
<p class="itemText">is a TypeAnnotation that asserts that the type of alpha is a generic function that returns a string.</p>
<p class="itemText">TypeAnnotation ::= Identifier : Type</p>
<p class="itemText">Type Annotations</p>
</li>
<li>
<p class="itemTitle">Type Definitions</p>
<p class="itemText">A type definition is a statement that introduces a new type into the current scope. There are two forms of type definition statement: the TypeAlias definition and the AlgebraicType definition. In addition, the TypeWitness is used to declare a type.</p>
<p class="itemText">TypeDefinition ::= TypeAlias | AlgebraicType | TypeWitness</p>
<p class="itemText">Type Definition Statements</p>

</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Type Alias</p>
<p class="itemText">A type alias is a statement that introduces a new type name by mapping it to an existing type expression.</p>
<p class="itemText">TypeAlias::= TypeSpec <~ Type</p>
<p class="itemText">Type Alias Definition Statement</p>
<p class="itemText">[NOTE] Type aliases may be parameterized -- in the sense that the type being defined may be parameterized and that the definiens may also be parameterized.</p>
<p class="itemText">Note that the any type variables on the right hand side of a TypeAlias statement must also have been mentioned on the left hand side.</p>
<p class="itemText">For example, the statement:</p>
<p class="itemText">time <~ intege...</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Algebraic Type Definitions</p>
<p class="itemText">An algebraic type definition is a statement that introduces a new type; it also defines the possible values associated with the type.</p>
<p class="itemText">An algebraic type definition introduces the new type and defines one or more Constructors -- separated by the | operator.</p>
<p class="itemText">A Constructor is a specification of a value of a type; i.e., constructors paint a picture of the shape of potential values of the type.</p>
<p class="itemText">There are three kinds of Constructor: enumerated symbols, term constructor constructors and labeled record c...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Enumerated Symbol</p>
<p class="itemText">An enumerated symbol is written as an identifier. The fact that an identifier has been mentioned in a type definition is sufficient to `mark' it as a value -- and not as a variable for example.</p>
<p class="itemText">EnumeratedSymbol::=Identifier</p>
<p class="itemText">Enumerated Symbols</p>
<p class="itemText">The standard type boolean is defined in terms of two enumerated symbols: true and false:</p>
<p class="itemText">boolean ::= true | false</p>
<p class="itemText">[NOTE] An enumerated symbol must be unique across all types within the scope of the type definition.</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Type Safety</p>
<p class="itemText">An enumerated symbol occurring within a type definition has the defined type.</p>
<p class="itemText">[NOTE] A particular consideration should be made for the case where an enumerated symbol is part of a universally quantified type.</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Term Constructor</p>
<p class="itemText">A term constructor expression or pattern is written in the style of a function call. The specification of the term constructor uses types in argument positions to denote the type of the corresponding argument.</p>
<p class="itemText">TermConstructor ::= Identifier `(` Type ,.., Type `)`</p>
<p class="itemText">Term Constructor</p>
<p class="itemText">For example, a type definition for wrapping return values with an error code could have a definition:</p>
<p class="itemText">all t ~~ returnType[t] ::= error(string) | ok(t)</p>
<p class="itemText">A function returning a value of type returnType would either return ...</p>
</li>
<li>
<p class="itemTitle">Record Constructor</p>
<p class="itemText">Labeled records denote constructors whose elements are addressed by name rather than by argument position. A labeled record specification consists of a collection TypeAnnotations. In addition, the record specification may include default values for some (or all) of the attributes of the record.</p>
<p class="itemText">RecordConstructor ::= Identifier `{` ElementType .. ElementType `}`</p>
<p class="itemText">ElementType ::= TypeAnnotation</p>
<p class="itemText">  | Identifier `default` `=` Expression</p>
<p class="itemText">  | Identifier `default` `:=` Expression</p>
<p class="itemText">  | DefltEquation</p>
<p class="itemText">  | `a...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Default Values</p>
<p class="itemText">It is permitted to associate a default value with a field of an record constructor. A default value is simply an expression for an attribute that is used should a particular record literal expression  not contain a value for that field.</p>
<p class="itemText">For example, for convenience, we might add default annotations in the twoThree type defined above, resulting in the type definition in:</p>
<p class="itemText">all s ~~ twoThree[s] ::=</p>
<p class="itemText">  three{ left:twoThree[s].</p>
<p class="itemText">         left default = empty.</p>
<p class="itemText">         label:s.</p>
<p class="itemText">         right:twoThree[s]...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Defaults of ref Fields</p>
<p class="itemText">To declare a default value for a ref field, the form:</p>
<p class="itemText">Identifier default := Expression</p>
<p class="itemText">should be used. For example, in the type:</p>
<p class="itemText">account ::= account{</p>
<p class="itemText">  balance:ref integer</p>
<p class="itemText">  balance default := 0</p>
<p class="itemText">}</p>
<p class="itemText">the balance field is a ref field, and its default value is 0.</p>

</li>
</ul>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Type Variables and Safe Algebraic Type Definitions</p>
<p class="itemText">For an AlgebraicType definition to be safe requires a constraint on type variables within the definition. In particular, it is not permitted to introduce a type variable in any of the constructors in the definition.</p>
<p class="itemText">[NOTE] Specifically, any unbound type variables mentioned in a type definition must also occur within the TypeSpec or be bound by an enclosing type quantifier.</p>
<p class="itemText">For example, the type definition:</p>
<p class="itemText">all t ~~ opaque ::= op(t)</p>
<p class="itemText">is not valid because the type variable t mentioned in the op con...</p>
</li>
<li>
<p class="itemTitle">Algebraic Interface Record</p>
<p class="itemText">An AlgebraicType definition induces an interface that is composed of all the fields in any of the <<RecordConstructor>>s that are defined within the definition.</p>
<p class="itemText">This interface -- which takes the form of a RecordType -- contains a TypeAnnotation for every TypeAnnotation that is present in a RecordConstructor.</p>
<p class="itemText">For example, the interface for the account type above consists of:</p>
<p class="itemText">{</p>
<p class="itemText">  balance:ref integer</p>
<p class="itemText">}</p>
<p class="itemText">This interface is used when determining the type soundness of a RecordAccess expression.</p>
<p class="itemText">[NOTE] T...</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Type Witness Definition</p>
<p class="itemText">A TypeWitness definition declares that a given type exists. It is used to assert that a given existential type exists.</p>
<p class="itemText">TypeWitness ::= `type` Identifier `=` Type</p>
<p class="itemText">Type Witness Statement</p>
<p class="itemText">For example, in the expression:</p>
<p class="itemText">group{</p>
<p class="itemText">  type elem = integer.</p>
<p class="itemText">  inv(X) => -X.</p>
<p class="itemText">  op(X,Y) => X+Y.</p>
<p class="itemText">  zero = 0.</p>
<p class="itemText">}</p>
<p class="itemText">the statement:</p>
<p class="itemText">type elem = integer.</p>
<p class="itemText">asserts that the type integer is a witness for the existentially quantified type elem.</p>
<p class="itemText">[NOTE] TypeWitness statements are inherently internal statements: the witness type...</p>
</li>
<li>
<p class="itemTitle">Contracts</p>
<p class="itemText">A contract is a specification of a set of functions and action procedures that form a coherent collection of functionality. Associated with a Contract are one or more Types -- the contract is said to be over those types.</p>

</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Contract Definition</p>
<p class="itemText">A contract definition is a statement that defines the functions and action procedures associated with a contract. As can be seen below, a contract statement associates a contract name -- together with a set of type variables -- with a set of TypeAnnotations that define the elements of the contract. Within the Contract statement, a TypeAnnotation may refer to the type(s) in the contract head.</p>
<p class="itemText">Contract ::= `contract` ContractSpec `::=` RecordType</p>
<p class="itemText">ContractSpec ::= [ TypeQuantifier ] Identifier [ Ty...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Functional Dependencies</p>
<p class="itemText">For certain forms of contract, it may be that the type parameters may not all be independent of each other. For example, consider the standard iterable contract which reads:</p>
<p class="itemText">contract all coll, el ~~ iterable[coll ->> el] ::= {</p>
<p class="itemText">  iterate: all r ~~</p>
<p class="itemText">      (coll,(el,IterState[r])=>IterState[r],IterState[r]) =></p>
<p class="itemText">        IterState[r];</p>
<p class="itemText">}</p>
<p class="itemText">The intention of the iterable contract is to support processing collections of elements in a sequential manner. The type parameter coll identifies the collection to be ...</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Contract Implementation</p>
<p class="itemText">A contract implementation is a specification of how a contract may be implemented for a specific type combination.</p>
<p class="itemText">Implementation::=`implementation` ContractSpec [`default`] `=>` Expression</p>
<p class="itemText">Contract Implementation Statement</p>
<p class="itemText">The Types mentioned in ContractSpec must be either TypeExpressions or, in the case of a default implementation, TypeVariables.</p>
<p class="itemText">[NOTE] In particular, it is not permitted to define an implementation of a contract for FunctionTypes, PatternTypes, nor for UniversalTypes or Existe...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Implementing Contracts with Functional Dependencies</p>
<p class="itemText">Implementing a contract which has a functional dependency is exactly analogous to implementing a regular contract. The dependent type(s) must be identified in the implementation statement. For example, the initial part of the implementation of the sequence contract over strings and integers is:</p>
<p class="itemText">implementation sequence[string->>integer] => {</p>
<p class="itemText">Note that this implementation implies that a sequence over a string fixes the element type to integer -- i.e., a unicode CodePoint.</p>
</li>
<li>
<p class="itemTitle">Default Contract Implementation</p>
<p class="itemText">A default implementation for a contract denotes an implementation to use for a contract when there is no known implementation. This can occur in two common situations: where a contract function is used that references a type that does not have an implementation for the contract, and where there is no type information.</p>
<p class="itemText">[TIP] It is strongly recommended that the default implementation is generic; i.e., that the definition of the individual functions are generic. The contract type should be denoted ...</p>
</li>
<li>
<p class="itemTitle">Recursive Contract Implementations</p>
<p class="itemText">More complex contract implementations may require the use of auxiliary function definitions; and hence may involve the use of let expressions.</p>
<p class="itemText">For example, this is an implementation of the comparable contract for cons values.</p>
<p class="itemText">implementation all t ~~ comparable[t], equality[t] |: comparable[cons[t]] =></p>
<p class="itemText">  let{</p>
<p class="itemText">    consLess([],[_ ,.. _]) => true</p>
<p class="itemText">    consLess([X,..L1],[X,..L2]) => consLess(L1,L2)</p>
<p class="itemText">    consLess([X,.._], [Y,.._]) where X<Y => true</p>
<p class="itemText">    consLess(_,_) default => false</p>
<p class="itemText"></p>
<p class="itemText">    consLessEq([],_...</p>
</li>
<li>
<p class="itemTitle">Automatic Synthesis of Contract Implementations</p>
<p class="itemText">In some cases, the regular implementation of a contract by be predicted by examining the algebraic type definition itself. The Star compiler automatically generates implementations of the equality and the pPrint contracts, for example, by inspecting the type definition itself.</p>
<p class="itemText">A programmer may extend this system of atomically implementing contracts by implementing a special macro whose name is of the form implement_name. A type definition that is marked:</p>
<p class="itemText">person ::= some{</p>
<p class="itemText">  name:string;</p>
<p class="itemText">} | noOne...</p>
</li>
<li>
<p class="itemTitle">Resolving Overloaded Definitions</p>
<p class="itemText">When a program refers to a contract-defined function -- i.e., a variable that is declared within a contract -- then that reference must be resolved to an actual program before the program can be said to be executable.</p>
<p class="itemText">For example, consider the expression:</p>
<p class="itemText">A+3</p>
<p class="itemText">The (+) function is part of the arith contract which means that we need to resolve the call to (+) to an actual implemented function.</p>
<p class="itemText">The type signature for (+) is:</p>
<p class="itemText">all t ~~ arith[t] |: (t,t)=>t</p>
<p class="itemText">where the constraint</p>
<p class="itemText">arith[t]</p>
<p class="itemText">is satisfied fo...</p>
</li>
<li>
<p class="itemTitle">Standard Contracts</p>
<p class="itemText">The language defines a few contracts as standard. These cover, for example, the concepts of equality, comparable, and sizeable entities and the arith operations. These contracts are integral to the semantics of the language.</p>
<p class="itemText"></p>
<p class="itemText">Contract</p>
<p class="itemText">Description</p>
<p class="itemText">equality[t]</p>
<p class="itemText">Definition of semantic equality</p>
<p class="itemText">comparable[t]</p>
<p class="itemText">Definition of comparability</p>
<p class="itemText">arith[t]</p>
<p class="itemText">Basic arithmetic</p>
<p class="itemText">math[t]</p>
<p class="itemText">Misc math functions</p>
<p class="itemText">trig[t]</p>
<p class="itemText">Trigonometry functions</p>
<p class="itemText">bitstring[t]</p>
<p class="itemText">Bitwise functions</p>
<p class="itemText">sizeable[t]</p>
<p class="itemText">Definition of size and empty</p>
<p class="itemText">sequence[t...</p>
</li>
</ul>
</ul>
<hr class="afterText"/>

<li>
<p class="itemTitle">Type System</p>
<p class="itemText">The type system consists of a language of type expressions and a set of rules for showing consistency between types and programs.</p>
<p class="itemText">The foundation of these rules are the rules that relate one type to another; and the primary relationship involved here is subsumption.</p>
<p class="itemText">In addition there are rules for determining when various constraints are satisfied and there are rules that relate specific expressions to types.</p>
</li>
<li>
<p class="itemTitle">Type Subsumption</p>
<p class="itemText">The type system is based on the concept of type _subsumption_. One type subsumes another if either it is already equivalent under some substitution or it is `more general' than the other.</p>
<p class="itemText"></p>
<p class="itemText">The intuition is that if a function expects a certain kind of argument then either a value of exactly that type or one that is more general may be supplied.</p>
<p class="itemText"></p>
<p class="itemText">We express this formally in terms of a subsumption relation `subsume`:</p>
<p class="itemText">\[</p>
<p class="itemText">T\sub1\subsume{}T\sub2</p>
<p class="itemText">\]</p>
<p class="itemText">is read as</p>
<p class="itemText">\begin{quote}</p>
<p class="itemText">$T\sub1$ subsumes, or is mor...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Subsumption of Basic Types</p>
<p class="itemText"></p>
<p class="itemText"></p>
<p class="itemText">\begin{itemize}</p>
<p class="itemText">\item One <<TypeExpression>> subsumes another if they have the same arity, and if their type constructors and type arguments pairwise subsume:</p>
<p class="itemText">\begin{prooftree}</p>
<p class="itemText">\AxiomC{\entail{E,\theta\sub0}{t\sub1\subsume u\sub1\leadsto\theta\sub1}\sequence{\ }\entail{E,\theta\sub{n-1}}{t\subn\subsume u\subn\leadsto\theta\subn}}</p>
<p class="itemText">\AxiomC{\entail{E,\theta\subn}{C\sub1\subsume C\sub2\leadsto\theta}}</p>
<p class="itemText">\BinaryInfC{\entail{E,\theta\sub0}{C\sub1\ `of`\ (t\sub1\sequence{,}t\subn)\ \subsume\ C\sub2\ `o...</p>
</li>
<li>
<p class="itemTitle">Subsumption of Tuples and Records</p>
<p class="itemText"></p>
<p class="itemText">\begin{itemize}</p>
<p class="itemText"></p>
<p class="itemText">\item One <<TupleType>> subsumes another if they are of the same length and each of their successive elements pairwise subsume.</p>
<p class="itemText">\begin{prooftree}</p>
<p class="itemText">\AxiomC{\entail{E,\theta\sub0}{t\sub1\subsume u\sub1\leadsto\theta\sub1}\sequence{\quad}\entail{E,\theta\sub{n-1}}{t\subn\subsume u\subn\leadsto\theta\subn}}</p>
<p class="itemText">\UnaryInfC{\entail{E,\theta\sub0}{(t\sub1\sequence{,}t\subn)\ \subsume\ (u\sub1\sequence{,}u\subn)\leadsto\theta\subn}}</p>
<p class="itemText">\end{prooftree}</p>
<p class="itemText">where $t\subi$ and $u\subi$ are types.</p>
<p class="itemText"></p>
<p class="itemText"></p>
<p class="itemText">\...</p>
</li>
<li>
<p class="itemTitle">Subsumption of Function Types</p>
<p class="itemText"></p>
<p class="itemText"></p>
<p class="itemText">The rules for subsumption for function types introduces the concept of _contravariance_.</p>
<p class="itemText"></p>
<p class="itemText">\begin{itemize}</p>
<p class="itemText"></p>
<p class="itemText">\item A function type $F\sub1$ subsumes $F\sub2$ if the result types subsume and the argument types contra-subsume:</p>
<p class="itemText"></p>
<p class="itemText">\begin{prooftree}</p>
<p class="itemText">\AxiomC{\entail{E,\theta\subi}{r\sub1\subsume{}r\sub2\leadsto\theta\sub0}}</p>
<p class="itemText">\AxiomC{\entail{E,\theta\sub0}{a\sub2\subsume{}a\sub1\leadsto\theta\sub{o}}}</p>
<p class="itemText">\BinaryInfC{\entail{E,\theta\subi}{a\sub1`=>`r\sub1\subsume{}a\sub2`=>`r\sub2\leadsto\theta\sub{o}}}</p>
<p class="itemText">\en...</p>
</li>
<li>
<p class="itemTitle">Subsumption of Quantified Types</p>
<p class="itemText"></p>
<p class="itemText">Subsumption of quantified types must take into account the implied semantics of the quantifiers: a <<UniversalType>> is less general than its bound type and so on.</p>
<p class="itemText"></p>
<p class="itemText">For simplicity of presentation we assume that all quantified types have been alpha-renamed so that no two quantified terms have the same bound variable.</p>
<p class="itemText"></p>
<p class="itemText">\begin{itemize}</p>
<p class="itemText">\item Any type subsumes its universally quantified variant if its subsumes a `refreshed' variant of the latter:</p>
<p class="itemText"></p>
<p class="itemText">\begin{prooftree}</p>
<p class="itemText">\AxiomC{\entail{E,\theta\subi}{t\...</p>
</li>
</ul>
</ul>
<hr class="afterText"/>

<li>
<p class="topLevelItemTitle">Programs</p>
<p class="itemText">= Programs</p>
<p class="itemText">[[programs]]</p>
<p class="itemText"></p>
<p class="itemText">This chapter focuses on the organization of programs using functions, procedures and other computational forms. Apart from program values themselves, a key concept is the <<thetaEnvironment>>. This is where many programs, types etc. are defined. <<thetaEnvironment>>s are also first-class values -- showing up as <<AnonymousRecord>>s.</p>
<p class="itemText"></p>
<p class="itemText"></p>
<p class="itemText">[[thetaEnvironment]]</p>
<p class="itemText">== Theta Environment</p>
<p class="itemText">(((theta environment)))</p>
<p class="itemText">(((program declaration)))</p>
<p class="itemText"></p>
<p class="itemText">A <<thetaEnvironment>> consists of a set of d...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Expressions</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Expressions</p>
<p class="itemText">[[expressions]]</p>
<p class="itemText"></p>
<p class="itemText">An expression is a form that denotes a _value_. Evaluation is the computational process of realizing the denoted value.</p>
<p class="itemText">\begin{figure}[htbp]</p>
<p class="itemText">\begin{eqnarray*}</p>
<p class="itemText">[[Expression]]Expression::=<<Variable>>\\</p>
<p class="itemText">  | <<ScalarLiteral>>\\</p>
<p class="itemText">  | <<AlgebraicConstructor>>\\</p>
<p class="itemText">  | <<ApplicativeExpression>>\\</p>
<p class="itemText">  | <<ConditionalExpression>>\\</p>
<p class="itemText">  | <<CaseExpression>>\\</p>
<p class="itemText">  | <<Condition>>\\</p>
<p class="itemText">  | <<LetExpression>>\\</p>
<p class="itemText">  | <<ValueExpression>>\\</p>
<p class="itemText">  | <<AnonymousFunction>>\\...</p>
</li>
<li>
<p class="itemTitle">Variables</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Variables</p>
<p class="itemText">[[variables]]</p>
<p class="itemText"></p>
<p class="itemText">(((variable)))</p>
<p class="itemText">(((expressions,variable)))</p>
<p class="itemText"></p>
<p class="itemText">A <<Variable>> is a placeholder that denotes a value. Variables may be used to denote many kinds of values -- arithmetic values, complex data structures and programs.</p>
<p class="itemText"></p>
<p class="itemText">\begin{figure}[htbp]</p>
<p class="itemText">\begin{eqnarray*}</p>
<p class="itemText">[[Variable]]Variable::=<<Identifier>></p>
<p class="itemText">\end{eqnarray*}</p>
<p class="itemText">\vskip-1.5ex.Variables[[variableFig]]</p>
<p class="itemText">\end{figure}</p>
<p class="itemText"></p>
<p class="itemText">\begin{aside}</p>
<p class="itemText">Any given variable has a single type associated with it and may only be boun...</p>
</li>
<li>
<p class="itemTitle">Patterns</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Patterns</p>
<p class="itemText">[[patterns]]</p>
<p class="itemText">(((patterns)))</p>
<p class="itemText">Patterns are templates that are used to match against a value; possibly binding one or more variables to components of the matched value. Patterns are used as guards in equations, as filters in query expressions and in `for` loops. Patterns represent one of the fundamental mechanisms that can guide the course of a computation.</p>
<p class="itemText"></p>
<p class="itemText">\begin{figure}[htbp]</p>
<p class="itemText">\begin{eqnarray*}</p>
<p class="itemText">[[Pattern]]Pattern::=<<ScalarPattern>>\\</p>
<p class="itemText">  | <<Variable>>\\</p>
<p class="itemText">  | <...</p>
</li>
<li>
<p class="itemTitle">Conditions</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Conditions</p>
<p class="itemText">[[conditions]]</p>
<p class="itemText">Conditions are used to express constraints. For example, a `where` pattern (see <<guardPattern>>) uses a condition to attach a semantic guard to a pattern. Conditions are also as guards on _equations_ (see <<equations>>) and in other forms of rule.</p>
<p class="itemText"></p>
<p class="itemText"></p>
<p class="itemText">\begin{aside}</p>
<p class="itemText">Conditions should not be confused with `boolean`-values expressions; the fundamental semantics of conditions is based on _satisfiability_ -- not _evaluation_ -- see <<querySemantic...</p>
</li>
<li>
<p class="itemTitle">Grammar Rules</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Parsing Text</p>
<p class="itemText">[[parsing]]</p>
<p class="itemText"></p>
<p class="itemText">String processing is one of the most important functions in many applications. In addition to the use of regular expressions for basic string processing, there is also support for more powerful string processing in the form of a built-in grammar notation.</p>
<p class="itemText">(((parsing text)))</p>
<p class="itemText">(((text parsing)))</p>
<p class="itemText">(((string,parsing)))</p>
<p class="itemText">(((grammar notation)))</p>
<p class="itemText"></p>
<p class="itemText">Program~\vref{exprGrammar} shows a simple example of a grammar that can be used to parse and evaluate simp...</p>
</li>
<li>
<p class="itemTitle">Macros</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Macro Language</p>
<p class="itemText">[[MacroLanguage]]</p>
<p class="itemText">The macro language supports the rewriting of parse tree structures -- prior to type checking.</p>
<p class="itemText">\begin{aside}</p>
<p class="itemText">The fact that macro processing applies before type checking implies that it is both possible and required to translate non-native Star program fragments into Star programming constructs.</p>
<p class="itemText">\end{aside}</p>
<p class="itemText"></p>
<p class="itemText">\begin{aside}</p>
<p class="itemText">As a result it is not possible to use the macro  language to construct a program expression that is unparsable -- al...</p>
</li>
<li>
<p class="itemTitle">Packages</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Packages and Libraries</p>
<p class="itemText">[[packages]]</p>
<p class="itemText">(((package@`package` structure)))</p>
<p class="itemText">A <<Package>> represents a `unit of compilation' -- i.e., the contents of a source file.</p>
<p class="itemText"></p>
<p class="itemText">(((libraries)))</p>
<p class="itemText">Star libraries are built using a combination of <<Package>>s and catalogs. A catalog is a mapping from names to locations that is used to inform the Star language system of the physical locations of <<Package>>s.</p>
<p class="itemText"></p>
<p class="itemText">== Package Structure</p>
<p class="itemText">[[packageStructure]]</p>
<p class="itemText">(((what is in a package@what is in a `p...</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="topLevelItemTitle">Computation</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Computation Expressions</p>
<p class="itemText">[[computation]]</p>
<p class="itemText">Computation expressions are a special form of expression notation that permits computations to be performed in an augmented fashion. One standard example is the `task` expression -- see <<concurrent>> -- where the computations identified may be performed in parallel or asynchronously.</p>
<p class="itemText"></p>
<p class="itemText">The core concepts behind <<ComputationExpression>>s are captured in three contracts -- the  `computation` contract (see Program~\vref{computatio...</p>
</li>
<hr class="afterText"/>
<ul>
<li>
<p class="itemTitle">Actions</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Actions</p>
<p class="itemText">[[actions]]</p>
<p class="itemText">(((action)))</p>
<p class="itemText"></p>
<p class="itemText">An action is the performance of an operation in a particular context.</p>
<p class="itemText"></p>
<p class="itemText">\begin{figure}[htbp]</p>
<p class="itemText">\begin{eqnarray*}</p>
<p class="itemText">[[Action]]Action::=<<NullAction>>\ |\ <<ActionBlock>>\\</p>
<p class="itemText">  | <<LocalVariable>>\ |\ <<TypeAnnotation>>\\</p>
<p class="itemText">  | <<Assignment>>\ |\ <<InvokeAction>>\ |\ <<IgnoreAction>>\\</p>
<p class="itemText">  | <<ForLoop>>\ |\ <<WhileLoop>>\ |\ <<ConditionAction>>\\</p>
<p class="itemText">  | <<SwitchAction>>\ |\ <<LetAction>>\\</p>
<p class="itemText">  | <<ValisAction>>\ |\ <<AssertAction>>\\</p>
<p class="itemText">  | <<AbortAction...</p>
</li>
</ul>
<hr class="afterText"/>

<li>
<p class="topLevelItemTitle">Strings</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Strings</p>
<p class="itemText">[[strings]]</p>
<p class="itemText">A string is a sequence of Unicode characters that denotes a fragment of text. This chapter focuses on the built-in functions that are based on the `string` type.</p>
<p class="itemText"></p>
<p class="itemText">== The Structured String `pP` Type</p>
<p class="itemText">[[ppType]]</p>
<p class="itemText">(((pP type)))</p>
<p class="itemText">(((type,pP@`pP`)))</p>
<p class="itemText">The `pP` type -- as defined in Program~\vref{ppTypeProg} -- denotes a `structured `string`' value where the structure may be used to represent lines, sub sequences and so on.</p>
<p class="itemText">\begin{aside}</p>
<p class="itemText">A primary purpose of...</p>
</li>
<li>
<p class="topLevelItemTitle">Sequences</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Sequences and Collections</p>
<p class="itemText">[[lists]]</p>
<p class="itemText">[[listExpressions]]</p>
<p class="itemText">(((list expression)))</p>
<p class="itemText">(((expressions,list)))</p>
<p class="itemText">There are many primary contracts that together relate to collections and sequences:</p>
<p class="itemText">\begin{description}</p>
<p class="itemText">`concatenate`:: defines what it means to concatenate two collections.</p>
<p class="itemText">`explosion`:: defines the twin functions of explode and implode. Typically used to inspect and pack scalar entities.</p>
<p class="itemText">`foldable`:: is a contract that defines the classic `fold' functions of leftFol...</p>
</li>
<li>
<p class="topLevelItemTitle">Associative Dictionaries</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Associative Dictionaries</p>
<p class="itemText">[[associativeMap]]</p>
<p class="itemText"></p>
<p class="itemText">(((expressions,associative dictionary)))</p>
<p class="itemText">(((associative dictionary expression)))</p>
<p class="itemText">Dictionaries allow the programmer to establish an associative mapping between pairs of elements. They are convenient when it is not known what the actual elements of the association will be at design time.</p>
<p class="itemText"></p>
<p class="itemText">\begin{aside}</p>
<p class="itemText">An important property of dictionaries is that there can be at most _one_ value associated with a given key. This is one of t...</p>
</li>
<li>
<p class="topLevelItemTitle">Numeric Expressions</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Numeric Expressions</p>
<p class="itemText">[[numbers]]</p>
<p class="itemText">(((expressions,arithmetic)))</p>
<p class="itemText"></p>
<p class="itemText">The basis of artithmetic expressions are several contracts: the `arithmetic` contract which provides definitions of the familiar `calculator' functions of `+`, `-`, `*` and `/`; the `math` contract which defines the extended set of mathematical functions; the `trig` contract which defines standard trigonometric functions; and the `bitstring` contract which gives definitions for bitwise manipulation of inte...</p>
</li>
<li>
<p class="topLevelItemTitle">Queries</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Queries</p>
<p class="itemText">[[queries]]</p>
<p class="itemText">(((queries)))</p>
<p class="itemText">A <<Query>> is an expression that denotes a value implicitly -- by operations and constraints on other identified values. Typically, the result of a query is an `list` but it may be of any <<Type>> -- provided that it implements the `sequence` contract.</p>
<p class="itemText"></p>
<p class="itemText">There are several `flavors' of query: the `all` query (shown in <<allSolutionsFig>>) projects a subset over one or more base collections; the _N_ `of` query extracts a list containin...</p>
</li>
<li>
<p class="topLevelItemTitle">Concurrency</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Concurrent Execution</p>
<p class="itemText">[[concurrent]]</p>
<p class="itemText">(((concurrent execution)))</p>
<p class="itemText">(((execution,parallel)))</p>
<p class="itemText"></p>
<p class="itemText">Concurrent and parallel execution of Star programs involves two inter-related concepts: the `task` and the `rendezvous`. A `task` is a form of <<ComputationExpression>> with support for parallel and asynchronous execution.  A `rendezvous` represents a `meeting place' between two or more independent activities. In particular, messages may be exchanged between `task`s at a `rendezv...</p>
</li>
<li>
<p class="topLevelItemTitle">Time and Date</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">\chapter{Date and Time}</p>
<p class="itemText">\label{dateAndTime}</p>
<p class="itemText"></p>
<p class="itemText">\section{The `date` Type}</p>
<p class="itemText">Date and time support revolves around the `date` built-in type. The type definition for `date` is straightforward:</p>
<p class="itemText"></p>
<p class="itemText">[listing]</p>
<p class="itemText">type date is date(\_long) or never</p>
<p class="itemText"></p>
<p class="itemText"></p>
<p class="itemText">\begin{aside}</p>
<p class="itemText">The `\_long` argument to the constructor is a so-called `raw value', not to be confused with the `long` built-in type (see <<longType>>). The `\_long` value is the number of milliseconds since Jan 1, 1970.</p>
<p class="itemText"></p>
<p class="itemText">Under normal circu...</p>
</li>
<li>
<p class="topLevelItemTitle">Actors</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Actors</p>
<p class="itemText">[[actors]]</p>
<p class="itemText">(((actors)))</p>
<p class="itemText"></p>
<p class="itemText">An `actor` is an encapsulation of behavior and state that is capable of interacting with other `actor`s. footnote:[Actors in Star should not be confused with Hewitt actors \cite{agha-hew:87}. Although both Hewitt actors and Star actors are a paradigm for distributed computing; Star actors are somewhat higher-level in that their primary mode of interaction is based on speech actions. Star actors are like actors in a play: they recite li...</p>
</li>
<li>
<p class="topLevelItemTitle">Input Output</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Input and Output</p>
<p class="itemText">[[io]]</p>
<p class="itemText"></p>
<p class="itemText">Input and output features include mechanisms for reading and writing streams of characters, mechanisms for accessing and navigating file directories and mechanisms for the appropriate formatting and parsing of data.</p>
<p class="itemText"></p>
<p class="itemText">The I/O streaming features are organized into a number of layers:</p>
<p class="itemText">\begin{itemize}</p>
<p class="itemText">\item At the `block' layer, an I/O operation is represented as a `task` -- see <<concurrent>> and <<computation>>. The value of an input task is ty...</p>
</li>
<li>
<p class="topLevelItemTitle">Threads</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Concurrent Execution</p>
<p class="itemText">[[threads]]</p>
<p class="itemText">(((Concurrent execution)))</p>
<p class="itemText">(((threads)))</p>
<p class="itemText"></p>
<p class="itemText">Concurrent execution involves the use of `spawn` (and the related parallel execution operator `//`) to initiate concurrent execution; together with a set of features intended to constrain that concurrent execution.</p>
<p class="itemText"></p>
<p class="itemText">\begin{figure}[htbp]</p>
<p class="itemText">\begin{eqnarray*}</p>
<p class="itemText">[[Action]]Action&\arrowplus&<<ParallelAction>>\\</p>
<p class="itemText">  | <<SpawnAction>>\\</p>
<p class="itemText">  | <<WaitAction>>\\</p>
<p class="itemText">  | <<SyncAction>>%\\</p>
<p class="itemText">%  | <<AtomicAction>></p>
<p class="itemText">\end{...</p>
</li>
<li>
<p class="topLevelItemTitle">System Functions</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= System Functions</p>
<p class="itemText">[[systemFunctions]]</p>
<p class="itemText"></p>
<p class="itemText">== Time Functions</p>
<p class="itemText">[[timeFunctions]]</p>
<p class="itemText">(((time functions)))</p>
<p class="itemText"></p>
<p class="itemText">=== `nanos` -- Time since start</p>
<p class="itemText">[listing]</p>
<p class="itemText">nanos has type ()=>long</p>
<p class="itemText"></p>
<p class="itemText"></p>
<p class="itemText">The `nanos` function returns the number of nanoseconds since the application started.</p>
<p class="itemText">\begin{aside}</p>
<p class="itemText">Note that the returned time may not actually be accurate to the nearest nanosecond. The precise accuracy depends on the accuracy of the clock available to the operating system.</p>
<p class="itemText">\end{aside}</p>
<p class="itemText">\begin{aside}</p>
<p class="itemText">For ...</p>
</li>
<li>
<p class="topLevelItemTitle">Concepts and Ontologies</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= Concepts and Ontologies</p>
<p class="itemText">[[ontology]]</p>
<p class="itemText"></p>
<p class="itemText">Many programs have embedded within them numerous `constant' values that often denote specific concepts. Often these concepts refer to data that the program expects to see in its input at some point, or will produce in its output.</p>
<p class="itemText"></p>
<p class="itemText">Related to this, an application may need to be _internationalized_ -- that is, be translated for use in different countries by people speaking different languages -- and/or _localized_ -- that is, be pr...</p>
</li>
<li>
<p class="topLevelItemTitle">JSON</p>
<p class="itemText">%!TEX root = reference.tex</p>
<p class="itemText">= JSON</p>
<p class="itemText">(((JSON}\index{Using the JSON type)))</p>
<p class="itemText"></p>
<p class="itemText">The JSON Infoset type, or just `json` type, allows values to be represented in a way that is easily digestible by many web-based tools -- including browsers. The `json` type is semantically equivalent to the JSON structure defined in \cite{rfc4627}. However, the `json` type represents a statically typed representation of JSON values.</p>
<p class="itemText"></p>
<p class="itemText">In addition to basic handling of JSON values, Star provides a form of path notation that a...</p>
</li>
</ul>

</td>
<td width="55px">
</td>
</tr>

<!-- Bottom margin -->
<tr><td height="15px"></td></tr>

</table>

</td>
</tr>
</table>

</body>
</html>
