{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 A 
\i Type
\i0  is an expression that denotes a set of values.\
\pard\tx720\tx1080\tx1440\li720\sl264\slmult1\sb240\sa240\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::0>
\f0 [TIP] Although a type is an expression, type expressions should not be confused with normal expressions. Types play no part in evaluation.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1 \cf0 <!$Scr_Ps::0>
\f0\fs26 Viewed as sets, types have some particular properties: no value may be a member of more than one type set; all values are members of exactly one type set.\
A 
\i TypeDefinition
\i0  introduces a new type and defines what values belong to the type. A 
\i TypeAnnotation
\i0  is an assertion that a particular expression -- usually a variable -- has a certain type.\
For many simple cases, a type is denoted by an identifier. For example, the type identifier 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 string
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26  denotes the set of all strings. More explicitly, a value has type 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 string
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26  {\field{\*\fldinst{HYPERLINK "scrivcmt://1A161EE6-BDBD-4027-84C1-A94B7B557A77"}}{\fldrslt iff}} it belongs to the set denoted by the symbol 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 string
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26 .\
Many value-sets are effectively infinite in size: the size of the set of 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 string
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26 s is essentially unbounded; as is the set of 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 integer
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26  values.\
In addition to sets of values denoted by identifiers; there are other kinds of value sets that have more complex type expressions. For example, the set of 
\i tuples
\i0  is denoted not by a single type expression but a 
\i schema
\i0  of type expressions -- each taking a form such as:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::1>
\f2\fs22 (t\sub 1\nosupersub ,..,t\sub n\nosupersub )
\f0\fs26 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::1>
\f0\fs26 For example, the type expression\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::1>
\f2\fs22 (integer)=>string
\f0\fs26 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::1>
\f0\fs26 denotes the set of functions that take a unary tuple \'97 containing 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 integer
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26  as an argument and produce a 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 string
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26  value. Like the set of all integers, this set is also infinite in size.\
The language for denoting types is quite expressive. It is possible to have types that are parameterized; that is they are composed from other type expressions. It is also possible to have types that are not explicitly named but are defined by constraints.\
A simple example of a parameterized type is the `cons` type: a `cons` type expression always involves the mention of another type -- the type of elements of the list. The type expression\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::1>
\f2\fs22 cons[string]
\f0\fs26 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::1>
\f0\fs26 denotes the type expression associated with lists whose elements are all 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 string
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26  values. Other examples of 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 cons
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26  type include lists of integers:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::1>
\f2\fs22 cons[integer]
\f0\fs26 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::1>
\f0\fs26 and even lists of lists of string valued functions:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::1>
\f2\fs22 cons[cons[(integer)=>string]]
\f0\fs26 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::1>
\f0\fs26 [NOTE] Technically, the `cons` symbol in:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::1>
\f2\fs22 cons[integer]
\f0\fs26 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::1>
\f0\fs26 is a 
\i TypeConstructor
\i0 : it takes a type as an argument and returns another type as result.\
Often it is convenient to be able to `talk' about types without being specific about the type itself; for this purpose we use 
\i TypeVariable
\i0 s.\
A type variable is distinguished by an explicit quantifier -- either a 
\i UniversalType
\i0  or a 
\i ExistentialType
\i0 . The type expression:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::1>
\f2\fs22 all t ~~ cons[t]
\f0\fs26 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::1>
\f0\fs26 denotes a 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 cons
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26  list type of some unspecified element type -- identified by the type variable 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 t
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26 .\
\pard\tx720\tx1080\tx1440\li720\sl264\slmult1\sb240\sa240\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::0>
\f0 [TIP] The value set associated with this type expression is a little more difficult to visualize than the set of lists of integers (say). 
\f1 <$Scr_Cs::2>
\f2\fs22 cons[t]
\f1\fs24 <!$Scr_Cs::2>
\f0  denotes a set of 
\f1 <$Scr_Cs::2>
\f2\fs22 cons
\f1\fs24 <!$Scr_Cs::2>
\f0  values; but without more information 
\i we cannot say
\i0  what the complete values look like -- it is dependent on the meaning of the type variable 
\f1 <$Scr_Cs::2>
\f2\fs22 t
\f1\fs24 <!$Scr_Cs::2>
\f0 .\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1 \cf0 <!$Scr_Ps::0>
\f0\fs26 In order to properly understand the interpretation of a type variable one must understand how the type variable is bound. In general, there are three possibilities: the type variable may be identified with (equal to) another type; the type variable may be bound by a universal quantifier or by an existential quantifier.\
A universally quantified type (see 
\i universalType
\i0 ) denotes a type that allows all possible instantiations for the type variable. For example, function types often involve universal types. A universally typed function is expected to work `for all values' of the type variable -- which, in turn, means that the function definition can make no assumptions about the actual type.\
Existentially quantified types (see 
\i existentialType
\i0 ) are  used to denote abstract types; i.e., the existential quantifier signals that there is a type that should be treated as an opaque black box.}