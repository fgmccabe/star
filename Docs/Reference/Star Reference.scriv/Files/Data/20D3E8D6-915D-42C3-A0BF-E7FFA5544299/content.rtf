{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 %!TEX root = reference.tex\
= Input and Output\
[[io]]\
\
Input and output features include mechanisms for reading and writing streams of characters, mechanisms for accessing and navigating file directories and mechanisms for the appropriate formatting and parsing of data.\
\
The I/O streaming features are organized into a number of layers:\
\\begin\{itemize\}\
\\item At the `block' layer, an I/O operation is represented as a `task` -- see <<concurrent>> and <<computation>>. The value of an input task is typically some fragment of data from the input. An output task always has `()` as its value.\
\\item At the data layer, I/O operations are represented via lazily executed `sequence`s of terms. In particular, it is possible to use the sequence notation -- see <<sequenceNotation>> to represent streams of data being consumed or produced.\
\\end\{itemize\}\
\
In addition to the layering of lazy streams on top of block data, there is a natural distinction in the handling of input vs output.\
\
For processing input, the dominant metaphor is one of _parsing_: the input occurrence is parsed in order to extract the required data in terms of the application. For example, an application processing a sequence of records of people would prefer the input to be a sequence of `person` records.\
\
For generating output, being able to emit `person` records is important. It is also important to be able to intersperse such records with fragments of canned text. Thus the natural data type for elements of output is the _structured string_ -- see <<ppType>>.\
}