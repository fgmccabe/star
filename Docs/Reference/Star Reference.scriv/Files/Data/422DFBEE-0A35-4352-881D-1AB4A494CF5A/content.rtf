{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 A 
\i TypeConstraint
\i0  is a constraint on a 
\i Type
\i0 ; usually implying a constraint on the possible binding of a 
\i TypeVariable
\i0 . For example, a 
\i Contract
\i0  refers to a named collection of functions and a 
\i TypeVariable
\i0  constrained by a 
\i ContractConstraint
\i0  means that any concrete instantiation of the 
\i TypeVariable
\i0  must be to a 
\i Type
\i0  that implements the 
\i Contract
\i0  \'97 or more accurately, there must be an implementation of the contract that satsifies the 
\i Type
\i0 .\
Similarly, a 
\i FieldConstraint
\i0  constrains the 
\i TypeVariable
\i0  so that any binding must be to a 
\i Type
\i0  that has the named field in its definition.\
For example, using 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 arith
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  as a constraint allows us to say `the type can be anything that implements a form of arithmetic'. The type expression:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::0>
\f2\fs22 arith[t] |: t
\f0\fs26 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::0>
\f0\fs26 denotes this kind of constrained type.\
[NOTE] It is possible to view a type variable binding itself as a form of constraint: if we bind the type variable 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 t
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  to the type 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 integer
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  then we are constraining the type 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 t
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  to be equal to 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 integer
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26 .\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::1>
\f0\i\fs26 TypeConstraint ::= ContractConstraint\
  | FieldConstraint\
  | InstanceConstraint\
  | TupleConstraint\
  | TypeConstraint ,.., TypeConstraint\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\sa160\pardirnatural\qc\partightenfactor0

\f1\i0\fs24 \cf0 <!$Scr_Ps::1><$Scr_Ps::2>
\f0\fs26 Type Constraints\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::2>
\f0\fs26 A type expression of the form:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::0>
\f2\fs22 comparable[t], arith[t] |: (t)=>t
\f0\fs26 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::0>
\f0\fs26 denotes a unary function type for any type that implements both the 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 comparable
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  and the 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 arith
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  contracts.\
[NOTE] In many cases type inference will automatically result in constraints being added to type expressions.\
It is possible mix different forms of 
\i TypeConstraint
\i0 ; for example, if a 
\i TypeVariable
\i0  must be bound to a type that implements the 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 comparable
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  contract as well as having the 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 integer
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26 -typed 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 ident
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  attribute, the type expression:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::0>
\f2\fs22 comparable[t], t <~ \{ ident:integer \}
\f0\fs26 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::0>
\f0\fs26 captures this.\
[NOTE] If a constrained type variable is unified with another type variable, then the constraints of the two variables are merged. It may be that such a merging of constraints is not possible; in such a case, the unification will fail and the type variables are not compatible.\
}