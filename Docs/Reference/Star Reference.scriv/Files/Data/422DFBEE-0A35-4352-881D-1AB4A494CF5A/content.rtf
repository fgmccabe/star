{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 \
[[typeConstraints]]\
(((type,constraints)))\
\
A <<TypeConstraint>> is a constraint on a <<Type>>; usually implying a constraint on the possible binding of a <<TypeVariable>>.\
\
Generally, a <<TypeConstraint>> on a <<TypeVariable>> restricts in some sense the possible bindings for that type variable. For example, a <<Contract>> refers to a named collection of functions and a <<TypeVariable>> constrained by a <<ContractConstraint>> means that any concrete instantiation of the <<TypeVariable>> must be to a <<Type>> that `implement`s the <<Contract>>.\
\
Similarly, a <<FieldConstraint>> constrains the <<TypeVariable>> so that any binding must be to a <<Type>> that has the named field in its definition.\
\
For example, using `arithmetic` as a constraint allows us to say `the type can be anything that implements a form of arithmetic'. The type expression:\
[listing]\
arithmetic[t] |: t\
\
denotes this kind of constrained type.\
\
[NOTE]\
It is possible to view a type variable binding itself as a form of constraint: if we bind the type variable `t` to the type `integer` then we are constraining the type `t` to be equal to `integer`.\
\
\
[[typeConstraintFig]]\
.Type Constraints\
****\
[[TypeConstraint]]TypeConstraint ::= <<ContractConstraint>>\
  | <<FieldConstraint>>\
  | <<InstanceConstraint>>\
  | <<HasKindConstraint>>\
  | <<TupleConstraint>>\
  | <<TypeConstraint>> ,.., <<TypeConstraint>>\
****\
\
A type expression of the form:\
[listing]\
comparable[t], arithmetic[t] |: (t)=>t\
\
denotes a unary function type for any type that implements both the `comparable` and the `arithmetic` contracts (see <<comparisonPredicates>> and <<arithmeticContract>>).\
\
[NOTE]\
In many cases type inference will automatically result in constraints being added to type expressions.\
\
It is possible mix different forms of <<TypeConstraint>>; for example, if a <<TypeVariable>> must be bound to a type that implements the `comparable` contract as well as having the `integer`-typed `ident` attribute, the type expression:\
[listing]\
comparable[t], t <~ \{ ident:integer \}\
\
captures this.\
\
[NOTE]\
If a constrained type variable is unified with another type variable, then the constraints of the two variables are merged. It may be that such a merging of constraints is not possible; in such a case, the unification will fail.\
\
===}