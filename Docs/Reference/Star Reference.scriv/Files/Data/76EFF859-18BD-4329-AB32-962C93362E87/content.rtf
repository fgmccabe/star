{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 %!TEX root = reference.tex\
= Actors\
[[actors]]\
(((actors)))\
\
An `actor` is an encapsulation of behavior and state that is capable of interacting with other `actor`s. footnote:[Actors in Star should not be confused with Hewitt actors \\cite\{agha-hew:87\}. Although both Hewitt actors and Star actors are a paradigm for distributed computing; Star actors are somewhat higher-level in that their primary mode of interaction is based on speech actions. Star actors are like actors in a play: they recite lines to each other and are choreographed by the author.] Actors represent a way of expressing multiple loci of computation that can interact and collaborate.\
\
\\begin\{aside\}\
From a programming methodology perspective, there is some correspondence between actors and objects in `Object Oriented Programming'.  It is useful to view an actor as being an active entity that is responsible for some aspect of the overall problem being addressed in the application.\
\\end\{aside\}\
\
The core of actors in Star is the interaction protocol that they support. This protocol is based on three _speech actions_: `notify` which is used to notify an actor that some event has happened; `request` which is used to request an actor to perform an action; and `query` which is used to ask an actor a question.\
\
== A Chatty actor Example\
[[talkers]]\
By way of introduction, we first demonstrate `actor`s with a simple scenario -- a `chatty' situation involving two `actor`s talking to each other in an endless cycle footnote:[We shall see that the length of the conversation is limited by the available stack depth.] -- illustrated in <<pingPongProg>>.\
\\begin\{figure\}[htbp]\
\\begin\{center\}\
\\includegraphics[width=0.6\\textwidth]\{diagrams/PingAndPong.pdf\}\
.Ping and Pong actors\
[[pingPongProg]]\
\\end\{center\}\
\\end\{figure\}\
\
Each of `ping` and `pong` have an `ear` by which they `hear' events. This is signaled by their type which is an `actor` type that references `ear` as an `occurrence` of `string`s. Program~\\vref\{chattySchema\} shows a `type` `alias` definition that captures this in a `type alias`.\
\\begin\{program\}\
[listing]\
type talker is alias of actor of \\\{\
  ear has type occurrence of string;\
\\\}\
\
.Type Schema Used by Chatty `actor`s\
[[chattySchema]]\
\\end\{program\}\
\
=== Chatty Actor Generator\
[[chattyGenerator]]\
Although `actor`s are first class values; in many cases it makes sense to use generator functions to construct `actor`s. This structural device allows encapsulation of the creation of the `actor`. In this scenario the two actors are generated by the generator function shown in Program~\\vref\{chattyGeneratorProgram\}.\
\\begin\{program\}\
[listing]\
chatty has type (()=>talker)=>talker;\
chatty(Who) is actor\\\{\
 on Msg on ear do\\\{\
   logMsg(info,"I heard \\$Msg");\
   notify Who() with "Did you hear [\\$Msg]?" on ear;\
\\\};\
\
.The `chatty` Actor Generator\
[[chattyGeneratorProgram]]\
\\end\{program\}\
\
The `chatty` generator takes the form of a single argument function that returns an actor. The function's argument is the actor that the chatty actor 'knows about'.\
\
The `chatty` actor itself is very simple: it listens to an event on its `ear`; and when it perceives one it logs it -- see <<logMsg>> -- and uses the `notify` <<SpeechAction>> to inform its partner that it `heard' something.\
\
There are three kinds of <<SpeechAction>>; however, in this scenario we only use the `notify` action.\
\
\\begin\{aside\}\
In general, an `actor` may learn about other `actor`s in a variety of ways -- they may be told explicitly about them in a speech action, they may search for them in a central repository. In this case, we build in to the actor a reference to the conversational partner.\
\\begin\{aside\}\
Note that the form of this information itself comes in the form of a function. I.e., the argument to the `chatty` actor is a zero-argument function whose value is the `actor` with whom to continue the conversation. The reason for this shall be explained below.\
\\end\{aside\}\
\\end\{aside\}\
\
=== Setting up a Scenario\
We construct our scenario by defining two actors -- `ping` and `pong` -- in terms of the `chatty` function. The two actors `bounce' off of each other in a circular interdependent structure. In the scenario, we build in the interdependence by passing each `actor` to the other -- in a <<thetaEnvironment>> -- and making use of <<MemoFunction>>s:\
[listing]\
let\\\{\
  def ping is memo chatty(pong);\
  def pong is memo chatty(ping);\
\\\}\
\
\\begin\{aside\}\
The use of <<MemoFunction>>s allows us to express the cyclic structure of the two actors in conversation without violating the normal rules of evaluation.\
\\end\{aside\}\
Of course, each of `ping` and `pong` are functionally identical as they were generated by the same generator function.\
\
=== Starting the Interaction\
In order to start the two actors off, we send one of them a `notify` <<SpeechAction>>:\
[listing]\
let\\\{\
  def ping is memo chatty(pong);\
  def pong is memo chatty(ping);\
\\\} in \\\{ notify ping() with "hello" on ear \\\}\
\
\
Once started, the actors `ping` and `pong` will notify each other of events in an endless cycle -- although each communication will be larger than the previous:\
[listing]\
ping \{\\rm\{\}to\} pong: hello\
pong \{\\rm\{\}to\} ping: Did you hear [hello]?\
ping \{\\rm\{\}to\} pong: Did you hear [Did you hear [hello]?]?\
...\
\
\
An actor wishing to respond to an event uses an <<EventRule>> to `catch' events it is interested in. In the case of these chatty actors, their response is to log the message and echo a response, using the rule:\
[listing]\
on Msg on ear do\\\{\
   logMsg(info,"I heard \\$Msg");\
   notify Who() with "Did you hear [\\$Msg]?" on ear;\
\\\};\
\
Speech actions are completed when the `target' `actor` has performed its response to the action. In the case of a `notify` this means that the responding `actor` has triggered all relevant <<EventRule>>s. In this case, that means the log message _and_ the `notify` to the actor's partner.\
\
\\begin\{aside\}\
One side-effect of this is that cycles like the one in this scenario are liable to exhaust the system evaluation stack fairly quickly. This program is destined to terminate with a `StackOverflow' exception.\
\\end\{aside\}\
\
\\begin\{program\}\
[listing]\
chatty is package\\\{\
  import speech;\
\
  type talker is alias of actor of \\\{\
    ear has type occurrence of string;\
  \\\}\
\
  chatty has type (()=>talker)=>talker;\
  chatty(Who) is actor\\\{\
    on Msg on ear do\\\{\
      logMsg(info,"I heard \\$Msg");\
      notify Who() with "Did you hear [\\$Msg]?" on ear;\
    \\\};\
  \\\}\
\
  prc main() do \\\{\
    let\\\{\
      def ping is memo chatty(pong);\
      def pong is memo chatty(ping);\
    \\\} in \\\{ notify ping() with "hello" on ear \\\}\
  \\\}\
\\\}\
\
.The Complete `chatty` Actor Scenario\
[[chattyProgram]]\
\\end\{program\}\
The complete scenario is shown in Program~\\vref\{chattyProgram\}. Note that, in order to use `actor`s, it is necessary to import the `speech` package.\
\
There are three aspects of `actor`s that fit together to complete the picture of programming with actors: the architectural structure of actors, the speech action model for how actors interact with each other, and the various kinds of <<ActorRules>> that implement the behavior behind the actors' interactions. <<SpeechAction>>s are described in <<contentLanguage>>; <<ActorRules>> are described in <<actorRules>> and the structure of an `actor` is described in <<actorStructure>>.\
\
== Actors' Speech\
[[contentLanguage]]\
(((content language)))\
(((speech actions)))\
(((actor communication)))\
(((asking actors to do things)))\
(((querying actors)))\
(((performatives)))\
\
The interaction between actors is based on the concept of _speech actions_ -- `actions' that involve communication between actors.\
\
\\begin\{aside\}\
The somewhat anthropomorphic term `speech action' is a reference to _Speech Act Theory_, first promulgated by John L. Austin in \\cite\{austin:60\}. Here, we use the term to refer to any of a standard range of actions involving the communication between `actor`s.\
\\end\{aside\}\
\
\\begin\{aside\}\
Although we refer to the different forms of interaction collectively as speech actions; in fact, syntactically some are <<Action>>s and queries are actually <<Expression>>s.\
\\end\{aside\}\
\
A speech action consists of a _performative_ and associated _content_. The standard performatives allow one actor to _notify_ another actor of an event, to _request_ that an actor perform an action and to _query_ for the value of an expression.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
_Action_&\\arrowplus&<<NotifySA>>|<<RequestSA>>\\\\\
_Expression_&\\arrowplus&<<QuerySA>>\\\\\
[[SpeechAction]]SpeechAction::=<<NotifySA>>|<<RequestSA>>|<<QuerySA>>\
\\end\{eqnarray*\}\
.Speech Actions\
[[speechActionFig]]\
\\end\{figure\}\
\
The content of a speech action is interpreted relative to a _schema_. Each actor has a schema of the particular kinds of events, actions and queries that the actor is capable of responding to. This schema is represented by a <<TypeInterfaceType>> that is an argument of the <<ActorType>>.\
\
=== Actor Type\
[[actorType]]\
(((actors,type of)))\
(((type,actor@`actor`)))\
Every `actor` has an <<ActorType>> -- which exposes elements that can be accessed via the different _speech actions_ as outlined in <<contentLanguage>>. It also exposes elements that the `actor` uses in its speech actions.\
\
As shown in <<actorTypeFig>>, an `actor` type takes an argument type which must be a <<TypeInterfaceType>> which defines the actor's schema.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
_Type_&\\arrowplus&<<ActorType>>\\\\\
[[ActorType]]ActorType::=`actor`\\ `of`\\ <<RecordType>>\\\\\
  | `concurrent actor`\\ `of`\\ <<RecordType>>\
\\end\{eqnarray*\}\
.Actor Type\
[[actorTypeFig]]\
\\end\{figure\}\
\
There are two forms of <<ActorType>> -- the `concurrent` form relates to an actor that executes in an independent task (see <<taskExpressions>> and <<concActor>>)\
\
=== Notifying Actors\
[[notify]]\
(((speech action,notify)))\
(((communicating events to actors)))\
(((performatives,notify@`notify`)))\
\
The `notify` speech action `informs' an actor of an event. An event is an occurrence of something that is relevant to someone; in this case the actor being notified.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[NotifySA]]NotifySA::=`notify`\\ <<Expression>>\\ `with`\\ <<Expression>>\\ `on`\\ <<Identifier>>\
\\end\{eqnarray*\}\
.Notify Speech Action\
[[NotifySAFig]]\
\\end\{figure\}\
\
\\begin\{aside\}\
In terms of speech act theory, a `notify` of the form:\
[listing]\
notify A with E on C\
\
can be considered to be equivalent to:\
[listing]\
INFORM(A,Happened(C(E)))\
\
where `INFORM` is the basic action in speech -- of the talker informing the listener of something -- and `Happened` corresponds to a predicate that signifies that some occurrence has happened.\
\\end\{aside\}\
\
A `notify` action of the form:\
[listing]\
notify _Ag_ with _Exp_ on _Id_\
\
has the effect of notifying the specifically identified actor  `_Ag_` that an event has occurred. Specifically, the event is denoted by the value of `_Exp_` and the `channel' it is on is identified by `_Id_`.\
\
\\begin\{aside\}\
Since events may be coming from multiple sources it is not possible to constrain absolutely the processing order of events. However, since a <<NotifySA>> is blocked until the responding actor has processed it, it _is_ required that all events from a given source are processed in the order that they are generated. See <<actorTypes>>.\
\\end\{aside\}\
\
\\paragraph\{Stream Type\}\
[[eventType]]\
A `notify` action requires that there be an appropriate `occurrence` type on the responding actor's schema.\
\
(((occurrence,occurrence type@`occurrence` type)))\
(((occurrence type@`occurrence` type)))\
(((type, occurrence@`occurrence`)))\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
_Type_&\\arrowplus&_EventType_\\\\\
_EventType_::=`occurrence`\\ `of`\\ _Type_\
\\end\{eqnarray*\}\
.Event Type\
[[eventTypeFig]]\
\\end\{figure\}\
\
\\begin\{aside\}\
The `occurrence` type is actually a generic type; its argument refers to the type of the element of the `occurrence`.\
\\end\{aside\}\
\
For example, an `actor` that responds to update events about the temperature of a boiler might offer a type signature such as\
[listing]\
boilerActor has type actor of \\\{\
  temp has type occurrence of float;\
\\\}\
\
\
\\begin\{aside\}\
`occurrence` types are _only_ permitted within an `actor` type structure.\
\\end\{aside\}\
\
==== Type Safety\
\
For `notify` to be type safe, the _responding_ actor must declare an appropriate element in its schema; i.e., it must have an `occurrence` of the right type for the identified channel:\
\\begin\{prooftree\}\
\\def\\defaultHypSeparation\{\}\
\\AxiomC\{\\typeprd\{E\}\{A\}\{`actor of`O\\ `where`\\ O`implements``\\\{`N`has type occurrence of`\\ T`\\`\}\}\}\
\\AxiomC\{\\typeprd\{E\}\{Evt\}\{T\}\}\
\\BinaryInfC\{\\typesafe\{E\}\{`notify` A `with `Evt\\ `on`\\ N\}\}\
\\end\{prooftree\}\
\
=== Querying Actors\
[[query]]\
(((querying actors)))\
(((performatives,query@`query`)))\
\
The `query` speech action is used to ask actors questions. A <<QuerySA>> takes the form of an expression that is evaluated `against' the schema of the responding actor's schema.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[QuerySA]QuerySA::=`query`\\ <<Expression>>\\ [<<ExportSelection>>]]\\ `with`\\ <<Expression>>\\\\\
[[ExportSelection]ExportSelection::=`'s`\\ <<Identifier>>\\ [`'n`\\ <<Identifier>>\\sequence\{'n\}\\ <<Identifier>>\\ ]]\
\\end\{eqnarray*\}\
.Actor Query Speech Action\
[[actorQueryFig]]\
\\end\{figure\}\
\
Syntactically, a `query` takes the form of an _Expression_ -- rather than an action. This is because queries have values associated with them -- even though they are actions! The value of the `query` expression is the result of evaluating the query in the context of the responding actor.\
\
%\\begin\{aside\}\
%In terms of Speech Act Theory, a `query` can either be regarded as a primitive performative, or it can be interpreted as an INFORM of a DESIRE to be INFORMED. A query of the form:\
%[listing]\
%query A with Exp\
%\
%has interpretation:\
%[listing]\
%INFORM(A,DESIRES(self,INFORM(VALUE-OF(Exp))))\
%\
%where `self` refers to the asking entity.\
%\
%There is additional semantics in a <<QuerySA>> that reflects the fact that the `answer' comes back as part of the original speech action and not as a subsequent speech action.\
%\\end\{aside\}\
\
The elements of the actor's schema that are accessed by the query expression are identified explicitly via the <<ExportSelection>>. For example, if an actor has the type:\
[listing]\
stocker has type actor of \\\{\
  average has type (eventTime,eventTime)=>float;\
  volume has type (eventTime,eventTime)=>float;\
\\\}\
\
then a query of the `stocker`'s `average` and `volume` would look like:\
[listing]\
query stocker's average 'n volume with average(34,10)*volume(34,10)\
\
\\begin\{aside\}\
Only those elements of the actor's schema that are mentioned explicitly in the <<ExportSelection>> will reference the responding actor's schema. All other references are regarded either as local to the query or free -- in effect referencing variables from the caller's context.\
\\end\{aside\}\
\
==== Type Safety\
An actor's schema is used to validate the type safety of a `query` against the actor:\
\\begin\{prooftree\}\
\\def\\defaultHypSeparation\{\\hskip 0pt\}\
\\AxiomC\{\\typeprd\{E\}\{A\}\{O`where`O`implements\\\{`N\\sub1`has type`T\\sub1\\sequence\{;\}N\\subn`has type`T\\subn`\\`\}\}\}\
\\AxiomC\{\\typeprd\{O\}\{Q\}\{T\\sub\{Q\}\}\}\
\\BinaryInfC\{\\typeprd\{E\}\{`query`\\ A`'s`\\ N\\sub1\\sequence\{'n\}N\\subn\\ `with`\\ Q\}\{T\\sub\{Q\}\}\}\
\\end\{prooftree\}\
\
\
=== Requesting Action from an Actor\
[[request]]\
(((requesting action from an actor)))\
(((performatives,request@`request`)))\
\
A `request` denotes a request that an actor perform an _Action_. The assumption is that an `actor` may modify its internal state as a result of responding to the `request`.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
_RequestSA_::=`request`\\ <<Expression>>\\ [<<ExportSelection>>]\\ `to`\\ _Action_\\\\\
\\end\{eqnarray*\}\
.Request Speech Action\
[[RequestSAFig]]\
\\end\{figure\}\
\
Similarly to the <<QuerySA>>, the elements of the actor's schema that are accessed by the <<Action>> -- and any embedded expressions within the <<Action>> -- are identified explicitly via the <<ExportSelection>>. For example, if an actor has the type:\
[listing]\
bank has type actor of \\\{\
  setBalance has type (float)=>();\
  currentBalance has type ()=>float;\
\\\}\
\
then a request to increase the `bank`'s balance by 20\\% would look like:\
[listing]\
request bank's setBalance 'n currentBalance to\
    setBalance(currentBalance()*1.2)\
\
\\begin\{aside\}\
Again, as with <<QuerySA>>, only those elements of the actor's schema that are mentioned explicitly in the <<ExportSelection>> will reference the responding actor's schema. All other references are regarded either as local to the query or free -- in effect referencing variables from the caller's context.\
\\end\{aside\}\
\
==== Type Safety\
_RequestSA_s do not have a type but, like other actions, must be type-safe.\
\
\\begin\{prooftree\}\
\\def\\defaultHypSeparation\{\\hskip 0pt\}\
\\AxiomC\{\\typeprd\{E\}\{A\}\{O`where`O`implements\\\{`N\\sub1`has type`T\\sub1\\sequence\{;\}N\\subn`has type`T\\subn`\\`\}\}\}\
\\AxiomC\{\\typesafe\{E\}\{A\}\}\
\\BinaryInfC\{\\typesafe\{E\}\{`request`\\ A`'s`\\ N\\sub1\\sequence\{'n\}N\\subn\\ `to`\\ A\}\}\
\\end\{prooftree\}\
\
== Actor Structure\
[[actorStructure]]\
(((actors,structure of)))\
An `actor` consists of a set of <<ActorRule>>s -- enclosed in an `actor\\\{...\\`\} structure -- that define how the `actor` responds to <<SpeechAction>>s.\
\\begin\{figure\}[H]\
\\begin\{eqnarray*\}\
[[Actor]]Actor::=`actor``\\\{`<<ActorRule>>\\sequence\{;\}<<ActorRule>>`\\`\}\\\\\
  | `concurrent actor``\\\{`<<ActorRule>>\\sequence\{;\}<<ActorRule>>`\\`\}\\\\\
[[ActorRule]]ActorRule::=<<EventRule>>\\ |<<Definition>>\
\\end\{eqnarray*\}\
.Actor Structure\
[[actorStructureFig]]\
\\end\{figure\}\
Actors are first-class values: they can be bound to variables, passed as arguments to functions and stored in structures. However, as noted in <<chattyGenerator>>, it is often convenient to arrange for actors to be generated via generator functions.\
\
\\begin\{aside\}\
Actors are typically structured into a separate communicative `actor` `head' and an active `body' with a `using` or `let` (see <<letExpression>>).\
The head contains the rules that support the interactions with other actors, and the body contains functionality that defines what the actor can do.\
\\end\{aside\}\
\
An example of this is shown in Program~\\vref\{stockTicker\} which defines an actor that keeps information of recent stock trades. footnote:[This should not be construed as an authoritative example of an actor that handles price updates.]\
\
\\begin\{program\}\
[listing]\
stocker() is actor\\\{\
  on (Price,When) on tick do extend prices with (Price,When);\
\
  average(Frm,To) is valof\\\{\
    def Prices is all Pr where (Pr,W) in prices and Frm=<W and W<To;\
    valis Prices/size(Prices);\
  \\\}\
\
  prc clear(Frm,To) do delete ((Pr,W) where Frm=<W and W<To) in prices;\
\\\} using \\\{\
  prices has type list of ((float,eventTime));\
  def prices is list of [];\
\\\}\
\
.A Stock Actor\
[[stockTicker]]\
\\end\{program\}\
\
An `actor` may contain <<EventRule>>s to allow it to respond to `notify` speech actions; otherwise, any valid <<Definition>> may be present in an `actor`.\
\
=== Event Rules\
[[actorRules]]\
(((actors,event rules)))\
(((events,rules)))\
An event rule is a rule that is used to respond to `notify` speech actions. An event is an occurrence of something that is `of interest' to an `actor`.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[EventRule]EventRule::=`on`\\ <<Pattern>>\\ `on`\\ <<Identifier>>\\ [`where`\\ <<Condition>>]]\\ `do`\\ <<Action>>\
\\end\{eqnarray*\}\
.Event Rules\
[[eventRuleFig]]\
\\end\{figure\}\
\
<<EventRule>>s have a two part structure: a pattern that matches an event on a particular occurrence and an <<Action>> body. In addition, an <<EventRule>> may have an optional <<Condition>> that must be satisfied before the rule can `fire'.\
(((condition,in event rules)))\
(((event rule conditions)))\
\
There may be any number of event rules about a given occurrence. All the <<EventRule>>s that apply will fire on receipt of a given `notify`.\
\
\
=== Responding to Requests\
[[requestResponse]]\
(((actor,responding to `requests`)))\
(((responding to `actor` `requests`)))\
\
<<RequestSA>>s are handled using <<Procedure>>s. The <<RequestSA>> may refer to more than one <<Procedure>>; and may even refer to other functions and variables that are exposed by the `actor`. Each `call' within the <<RequestSA>> is fielded by directly calling the appropriate <<Procedure>> or <<Function>> within the actor.\
\
(((how a request is handled@how a `request` is handled)))\
(((waiting for requests)))\
\
The `stocker` actor in Program~\\vref\{stockTicker\} will respond to a `clear` `request` by removing elements from its memory.\
\
\
=== Querying an Actor\
[[actorQuery]]\
(((actor,query an)))\
(((query,an actor)))\
\
Queries to actors are handled simply by evaluating an expression in the context of the `actor`. In particular, if the `query` is of a `list`, then the evaluation will often involve the use of `view` definitions.\
\
== The Speech Contract\
[[speechContract]]\
The foundation of actors in Star is the `speech` contract that is defined in Program~\\vref\{speechContractProg\}. This contract relies on the `result` type -- which is defined in Program~\\vref\{successTypeProg\}.\
\
\\begin\{program\}\
[listing]\
type result of t is success(t)\
  or denied(reason)\
  or failed(exception);\
\
type reason is busy or noPermission\
\
.Success Result Type\
[[successTypeProg]]\
\\end\{program\}\
\
\
\\begin\{program\}\
[listing]\
contract speech over t determines (u,a) where execution over a is \\\{\
  _query has type for all s such that\
      (t,(u)=>s,()=>quoted,()=>dictionary of (string,quoted))=> a of s;\
  _request has type\
      (t,(u)=>(),()=>quoted,()=>dictionary of (string,quoted)) => a of ()\
  _notify has type (t,(u)=>()) => a of ();\
\\\};\
\
.Speech Contract Used by `actor`s\
[[speechContractProg]]\
\\end\{program\}\
\
This contract is generally not referenced explicitly by `actor`-based programs as Star has syntactic features to support `actor`s and speech actions. Individual <<SpeechAction>>s are mapped to equivalent calls to `\\_query`, `\\_request` or `\\_notify`.\
\
Speech actions are encoded into calls to the three functions in the `speech` contract: a `notify` becomes a call to `\\_notify`, specifically the `notify` action:\
\
[listing]\
notify _Ag_ with _Event_ on _Channel_\
\
becomes:\
[listing]\
_notify(_Ag_, (AA)=>_Channel_(_Event_))\
\
\
A `query` is encoded into a call of `\\_query` with four arguments. Specifically, the `query`:\
[listing]\
query _Ag_ with _Expression_\
\
becomes:\
[listing]\
\\_query(_Ag_, (AA)=>_Expression_, ()=><|_Expression_|>,\
      ()=> dictionary of ["_F\\sub1_"->F\\sub1 as quoted\\sequence\{,\}"_F\\subn_"->F\\subn as quoted])\
\
where\
[listing]\
dictionary of ["_F\\sub1_"->F\\sub1 as quoted\\sequence\{,\}"_F\\subn_"->F\\subn as quoted]\
\
is a dictionary of all the free variables in _Expression_ and the expressions of the form\
[listing]\
"F\\subi"->F\\subi as quoted\
\
are, in effect, a _serialization_ of the value of the free variable as a `quoted` value.\
\
The function:\
[listing]\
()=><|_Expression_|>\
\
can be used by the receiver of the `query` if it either does not trust the function or if it needs to transform the query in some way.\
\
A `request` speech action has similar processing to the `query`. The `request`:\
\
[listing]\
request _Ag_ to _Act_\
\
is translated to the call:\
[listing]\
_request(_Ag_, (AA)=>_Act_, ()=><|_Act_|>,\
       ()=>dictionary of ["_F\\sub1_"->F\\sub1 as quoted\\sequence\{,\}"_F\\subn_"->F\\subn as quoted])\
\
with a similar interpretation of the arguments.\
\
Note that references within the `query` and `request` speech action to elements of the target's interface become dot-references (<<RecordAccess>>) of the form:\
[listing]\
AA.foo\
\
\
== Different Types of Actor\
[[actorTypes]]\
There are two `standard' implementations of actor: a light weight actor that has similar computational characteristics as conventional objects and a concurrent actor which is associated with its own `task`.\
\
=== Light Weight Actors\
[[liteActor]]\
\
The simple light weight actor as defined by the `actor` type in Program~\\vref\{actorTypeProg\} is essentially a simple wrapper around a <<RecordType>>.\
\
\\begin\{program\}\
[listing]\
type actor of t is act0r(t);\
\
.Standard Light Weight `actor` Type\
[[actorTypeProg]]\
\\end\{program\}\
\
The implementation of the speech contract for `actor` is shown in Program~\\vref\{actorSpeechProg\}.\
\
\\begin\{program\}\
[listing]\
implementation speech over for all t such that actor of t determines t is \\\{\
  \\_query(act0r(Ac),Qf,_,_) is Qf(Ac);\
  prc \\_request(act0r(Ac),Rf,_,_) do Rf(Ac);\
  prc \\_notify(act0r(Ac),Np) do Np(Ac);\
\\\};\
\
.Actor's Implementation of the Speech Contract\
[[actorSpeechProg]]\
\\end\{program\}\
\\begin\{aside\}\
What is not shown here is how the internals of `actor`s -- in particular  <<EventRule>>s -- are implemented.\
\\end\{aside\}\
\
=== Concurrent Actors\
[[concActor]]\
A concurrent actor is written slightly differently to a light weight actor; and has a different type and different behavior. Its internals are sufficiently complex that we do not expose them and leave the `concurrent actor` type abstract:\
[listing]\
concurrent actor has kind type of type;\
\
The public type for a `concurrent actor` is\
[listing]\
concurrent actor of \\\{ ... \\\}\
\
which is aliased to the `concActor` type for convenience.\
\
Concurrent actors sequentialize all access to them them -- only one speech action is processed at a given time. If multiple speech actions are attempted simultaneously all but one is blocked while it is processed by the `concurrent actor`.\
\
Concurrent actors execute on an independent background `task` -- see <<backgroundTask>>. The normal operational semantics for speech actions still holds with concurrent actors: except that a `notify` completes as soon as the concurrent actor starts processing it but before it completes processing the `notify`.\
\
Program~\\vref\{concSieveProg\} shows an example using `concurrent actor`s. This is a variation of the famous `Sieve of Erastosthenes' method for finding prime numbers.\
\
\\begin\{program\}\
[listing]\
filterActor(P) is concurrent actor\\\{\
  private var Nx :=  (_) => task\\\{\\\};\
\
  \\\{ Nx := newPrime \\\};\
\
  private newPrime(X) is let\\\{\
    def Fx is filterActor(X);\
\
    filterPrime(XX) is task\{ notify Fx with XX on input\};\
  \\\} in task \\\{\
      logMsg(info,"new prime $X");\
      Nx := filterPrime;\
  \\\};\
\
  on X on input do \\\{\
    perform task \\\{\
      if X\\%P!=0 then\
        perform Nx(X);\
    \\\}\
  \\\}\
\\\}\
\
.Sieve of Erastosthenes as Concurrent Actors\
[[concSieveProg]]\
\\end\{program\}\
\
\
\\begin\{aside\}\
Concurrent actors are more complex internally than simple actors. As such they have a higher internal performance penalty. However, the great merit of concurrent actors is that they can exploit parallelism where it is available.\
\\end\{aside\}\
}