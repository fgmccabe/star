{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 \
=== Let Expressions\
[[letExpression]]\
(((expressions,let expression@`let` expression)))\
(((let expression@`let` expression)))\
\
A `let` expression allows an expression to be defined in terms of  auxiliary definitions. There are two forms of the <<LetExpression>> -- allowing the programmer to choose whether the auxiliary definitions should precede the bound expression or follow it.\
\
In addition, it is possible to use a record-valued expression in place of the set of definitions.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[LetExpression]]LetExpression::=`let`\\ <<thetaEnvironment>>\\ `in`\\ <<Expression>>\\\\\
  | <<Expression>>\\ `using`\\ <<thetaEnvironment>>\
\\end\{eqnarray*\}\
.Let Expression\
[[letExpressionFig]]\
\\end\{figure\}\
\
(((theta environment)))\
A `let` expression consists of a body -- which is a <<thetaEnvironment>> -- and a bound <<Expression>>. Within the <<thetaEnvironment>> may occur any of the permitted forms of definition: function definitions, variable definitions, type definitions, and so on. The scope of these definitions includes the bound expression.\
\
\\begin\{aside\}\
`let` expressions are an important program structuring tool for programmers. It is worth emphasizing that `let` expressions are expressions! They can be used in many, perhaps unexpected, places.\
\
For example, a `sort` function may require a comparison predicate in order to operate. This can be supplied as a named function:\
[listing]\
pComp has type (person,person)=>boolean\
pComp(someone\{name=N1\},someone\{name=N2\}) is N1<N2\
\
def S is sort(L,myCompare)\
\
Or, the same may be achieved where the call to `sort` is not so conveniently close to a theta environment:\
[listing]\
sort(L, let\{\
  pComp has type (person,person)=>boolean\
   |  pComp(someone\{name=N1\},someone\{name=N2\}) is N1<N2\
\} in pComp)\
\
The `let` expression has major applications when constructing function-returning functions.\
\\end\{aside\}}