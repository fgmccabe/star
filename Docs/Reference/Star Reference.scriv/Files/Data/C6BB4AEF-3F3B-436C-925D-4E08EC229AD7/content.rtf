{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 \
==== Type Safety\
Since a sequence expression is essentially a macro for the use of the `sequence` contract, its type safety determined by the `sequence` contract in Program~\\vref\{sequenceContractDef\}.\
\
== Index and Slice Notation\
[[indexNotation]]\
(((index notation)))\
(((notation for indexed access)))\
\
In a similar vein to the <<Sequence>> notation, the <<IndexExp>> notation provides a high-level notation for accessing elements and subsets of collections.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
_Expression_&\\arrowplus&<<IndexExp>>\\\\\
[[IndexExp]]IndexExp::=<<Index>>\\ |\\ <<IndexWith>>\\ |\\ <<Slice>>\\\\\
[[Index]Index::=<<Expression>>\\ `[`<<Expression>>`]]`\\\\\
[[IndexWith]IndexWith::=<<Expression>>\\ `[``with`\\ <<Expression>>`->`<<Expression>>`]]`\\\\\
  | <<Expression>>\\ `[``without`\\ <<Expression>>`]`\\\\\
[[Slice]Slice::=<<Expression>>\\ `[`<<Expression>>`:`<<Expression>>`]]`\\\\\
  | <<Expression>>\\ `[`<<Expression>>`:``]`\
\\end\{eqnarray*\}\
.Index and Slice Expressions\
[[indexExpressionFig]]\
\\end\{figure\}\
\
\\begin\{aside\}\
There is some subtlety in the interpretation of index expressions; depending on whether the <<IndexExp>> is an expression, or whether it is the left hand side of an assignment:\
[listing]\
L[Ix] := E\
\
\
In the sections that follow, and in <<sequenceUpdate>>, we show the different interpretations of an index expression.\
\\end\{aside\}}