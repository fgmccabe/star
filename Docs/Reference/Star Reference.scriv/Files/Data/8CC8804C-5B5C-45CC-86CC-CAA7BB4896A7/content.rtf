{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 \
[[defaultImplementation]]\
(((default implementation of contracts)))\
(((type,contracts!implementation!default)))\
(((default@`default`)))\
\
A `default` implementation for a contract denotes an implementation to use for a contract when there is no known implementation. This can occur in two common situations: where a contract function is used that references a type that does not have an implementation for the contract, and where there is no type information.\
\
[TIP]\
It is strongly recommended that the `default` implementation is generic; i.e., that the definition of the individual functions are generic. The contract type should be denoted by a variable and all the contract functions should be generic.\
\
For example, the implementation statement:\
[listing]\
implementation all r ~~ equality[r] default = \{\
  L=R => __equal(L,R)\
\}\
\
uses a generic internal definition of `__equal`.\
\
\
As noted above, a `default` implementation is only used in restricted circumstances:\
\
No available implementation::\
If a contract is referenced for a type that does not implement the contract then the `default` implementation will be used.\
+\
For example, given a contract:\
[listing]\
----\
contract foo over t is \{\
  bar has type (t)=>boolean;\
\}\
----\
and the functional expression:\
[listing]\
----\
bar("fred")\
----\
then, if `foo` is not implemented for `string`s then the `default` implementation will be used for this expression. Of course, if there is no `default` implementation then a compile error will be flagged.\
\
\
Variable type::\
In a few circumstances a reference may be made to a contract involving no known types. For example, in the condition:\
[listing]\
XX = nil\
\
there is a hidden type variable associated with the enumerated symbol `nil`.\
\
The symbol `nil` is from the standard definition of `cons`:\
[listing]\
all t ~~ cons[t] ::= nil | cons(t,cons[t])\
\
Since the type of `nil` is under-constrained -- i.e., the type of `nil` as an expression involves a type variable that is not constrained at all by the `nil` symbol -- even if `equality` is implemented for many types there is no way of knowing which implementation to use in this situation. In this case, a `default` implementation will be used if provided.\
\
\
====}