{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 \
=== Constructor Literals\
[[positionalConstructor]]\
(((expression,positional constructor)))\
(((positional constructor literal)))\
<<ConstructorLiteral>> expressions denote data constructor values. In particular, it refers to constructors that are introduced in an algebraic <<TypeDefinition>>.\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[ConstructorLiteral]]ConstructorLiteral::=<<Identifier>>`(`<<Expression>>`,`...`,`<<Expression>>`)`\
\\end\{eqnarray*\}\
.Constructor Literal Expression\
[[positionalConstructorFig]]\
\\end\{figure\}\
This definition also determines the valid types of the arguments to the constructor. For example, the type definition:\
[listing]\
type address is noWhere or someWhere(string,integer,string)\
\
defines `someWhere` as the identifier of a <<ConstructorLiteral>> and any instance must have exactly three arguments: a `string`, an `integer` and a `string`.\
\
\\paragraph\{Accessing Elements of a Constructor Literal\}\
(((positional constructor literal,accessing elements)))\
The only way that elements of a <<ConstructorLiteral>> can be _accessed_ is via a pattern match -- see <<posConPattern>>. For example, given the definition of `address` above, we can `unpack' its argument using a pattern such as in\
[listing]\
city(someWhere(City,_,_)) is City}