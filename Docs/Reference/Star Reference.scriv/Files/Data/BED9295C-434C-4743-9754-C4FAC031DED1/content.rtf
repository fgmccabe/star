{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 \
(((types,existentially quantified)))\
(((existentially quantified type)))\
(((exists`exists`)))\
\
An existential type denotes an _abstract_ type.\
\
[[existentialTypeFig]]\
.Existential Type Expression\
****\
[[ExistentialType]]ExistentialType ::= `exists` <<BoundType>>,..,<<BoundType>> `~~` <<Type>>\
****\
\
An existentially quantified type denotes a type within which there is an _abstract type_: i.e., the type exists but the expression is not explicit about which type.\
\
Existential types are most often used in the type signatures of abstract data types. For example, the term in the statement:\
[listing]\
R = \{\
  type el = integer\
  op(X,Y) => X+Y\
\}\
\
has type:\
[listing]\
exists el ~~ \{ el :: type; op:(el,el)=>el \}\
\
[NOTE]\
Note that the fact that within the record the type `el` is identified as `integer` does not escape the record itself. Externally, the existence of the type is known but not what it is.\
\
It is permissible to refer to the type within the record by a dot reference.\
\
[TIP]\
Existentially quantified types are generally not inferred for variables: i.e., if a variable has an existential type then that must be explicitly annotated.\
\
Existential types are inferred, however, for <<Record>>s that contain a <<TypeDefinition>> statement.\
\
====}