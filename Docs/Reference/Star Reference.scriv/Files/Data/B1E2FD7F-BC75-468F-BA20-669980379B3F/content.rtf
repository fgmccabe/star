{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 \
[[typeAlias]]\
(((type,alias)))\
A type alias is a statement that introduces a new type name by mapping it to an existing type expression.\
\
.Type Alias Definition Statement\
[[typeAliasDefinitionFig]]\
****\
[[TypeAlias]]TypeAlias::=`type` <<TypeSpec>> `\\=>` <<Type>>\
****\
\
[NOTE]\
====\
Type aliases may be parameterized -- in the sense that the type being defined may be parameterized and that the definiens may also be parameterized.\
\
Note that the any type variables on the right hand side of a <<TypeAlias>> statement must also have been mentioned on the left hand side.\
====\
\
For example, the statement:\
[listing]\
type time => integer\
\
declares a new type that is an alias for `time` -- i.e., that it is actually equivalent to the `integer` type.\
\
[TIP]\
Type aliases allow the programmer to signal that a particular type is being used in a special way. In addition, during program development, type aliases are useful to provide markers for types that will be elaborated further with a regular algebraic definition.\
\
Type aliases have no run-time presence. In fact, they may be viewed as a simple form of type macro -- type expressions that match the left hand side are replaced by the type expression on the right hand side. However, type aliases have some definite constraints: a type alias may not be, directly or indirectly, recursive.\
\
===}