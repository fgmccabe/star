{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 %!TEX root = reference.tex\
= Expressions\
[[expressions]]\
\
An expression is a form that denotes a _value_. Evaluation is the computational process of realizing the denoted value.\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[Expression]]Expression::=<<Variable>>\\\\\
  | <<ScalarLiteral>>\\\\\
  | <<AlgebraicConstructor>>\\\\\
  | <<ApplicativeExpression>>\\\\\
  | <<ConditionalExpression>>\\\\\
  | <<CaseExpression>>\\\\\
  | <<Condition>>\\\\\
  | <<LetExpression>>\\\\\
  | <<ValueExpression>>\\\\\
  | <<AnonymousFunction>>\\\\\
  | <<MemoFunction>>\\\\\
  | <<TypedExpression>>\\\\\
  | <<QuotedExpression>>\
\\end\{eqnarray*\}\
.Expression\
[[expressionFig]]\
\\end\{figure\}\
\
\\begin\{aside\}\
This chapter does not cover all forms of expression. Other chapters that address particular forms of expression include <<variables>> (variables), <<lists>> (list expressions), <<strings>> (string expressions) and <<actors>> (actors).\
\\end\{aside\}\
\
== Variables in Expressions\
[[varExpression]]\
(((variable)))\
A variable as an expression is simply an occurrence of the variable's identifier (see <<variableFig>>).\
\
==== Type Safety\
The type associated with a variable expression is derived from the type recorded for the variable in the environment.\
\\begin\{prooftree\}\
\\AxiomC\{`( v`,T\\sub\{v\}\\ `)`$\\in\\ $E\}\
\\UnaryInfC\{\\typeprd\{E\}\{`v`\}\{T\\sub\{v\}'\}\}\
\\end\{prooftree\}\
where `T\\sub\{v`'\} is derived from `T\\sub\{v`\} by means of _refreshing_. I.e., if `T\\sub\{v`\} takes the form:\
[listing][mathescape=true]\
for all t$\\subi\{\}$ such that T\
\
then `T\\sub\{v`'\} is `T` with all occurrences of type variable `t\\subi` replaced with new type variables.\
\
\
== Scalar Literal Expressions\
[[scalarExpression]]\
\
There are three forms of scalar literal expression: numeric literals, string literals and enumerated symbols.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[ScalarLiteral]]ScalarLiteral::=<<Integer>>\\\\\
  | <<Long>>\\\\\
  | <<Float>>\\\\\
  | <<Decimal>>\\\\\
  | <<String>>\\\\\
  | <<EnumeratedSymbol>>\
\\end\{eqnarray*\}\
.Scalar Literals\
[[scalarExpressionFig]]\
\\end\{figure\}\
\
=== 32-bit Integer Literals\
[[integerType]]\
(((type,integer@`integer`)))\
\
The `integer` type is used to denote integral values in the range -2147483648..2147483647. In addition to the `normal' integers, there is a special denoted value -- `nonInteger` -- that denotes an invalid integer.\
\
Integers may be written in a variety of styles (see <<numericLiteral>>; the most common form is the simple <<Decimal>> notation.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[Integer]]Integer::=<<IntegerLiteral>>\\\\\
  | <<Hexadecimal>>\\\\\
  | <<CharacterCode>>\
\\end\{eqnarray*\}\
.Integer Literals\
[[integerExpressionFig]]\
\\end\{figure\}\
\
\\noindent\
The `integer` type is a so-called boxed type. Underlying the `integer` type is the raw type that denotes numeric value itself.\
(((type,integer@`integer`!raw)))\
\
The `integer` type can be defined using:\
[listing]\
type integer is integer(integer_)\
\
where `integer\\_` type is the raw type used internally to denote the machine representation of a 32-bit integer.\
[[rawInteger]]\
\\begin\{aside\}\
A raw `integer\\_` is written with a trailing underscore:\
[listing]\
34_\
\
In general, for an integer literal:\
[listing]\
34\
\
is equivalent to the expression:\
[listing]\
integer(34_)\
\
\\end\{aside\}\
\
==== Largest and Smallest `integer`s\
The `largeSmall` contract is implemented for `integer`s. This contract (see <<largeSmall>>) defines the largest and the smallest `integer`s; its implementation is equivalent to\
[listing]\
implementation largeSmall over integer is \{\
  def largest is integer(0x7fffffff_);\
  def smallest is integer(0x80000000_);\
\}\
\
\
=== 64 bit Integer Literals\
[[longType]]\
(((type,long@`long`)))\
\
The `long` type is used to denote integral values in the range $-2^\{63\} \\mbox\{ to \} 2^\{63\}-1$ footnote:[I.e., -9223372036854775808..\{\}9223372036854775807].\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[Long]]Long::=<<Decimal>>`L`\\\\\
  | <<Hexadecimal>>`L`\
\\end\{eqnarray*\}\
.Long Literals\
[[longExpressionFig]]\
\\end\{figure\}\
\
As with `integer`s, the `long` type is a boxed type; is is defined equivalently to:\
[listing]\
type long is long(long_)\
\
The `long\\_` type is a raw type used internally that denotes the machine representation of a 64-bit integer. Raw `long\\_` literals may be written using the underscore suffix (after the long indicator):\
[listing]\
45l_\
\
\
\\begin\{aside\}\
There is no automatic conversion between `integer` values and `long` values. The <<TypeCoercion>> expression may be used to convert between them. If `X` is an `integer` variable, then\
[listing]\
X as long\
\
may be used to convert its value to `long`.\
\\begin\{aside\}\
Where converting from `integer` to `long` does not lose any precision, the same cannot be said for other conversions.\
\\end\{aside\}\
\\end\{aside\}\
\
==== Largest and Smallest `long`s\
The `largeSmall` contract is implemented for `long`s. This contract (see <<largeSmall>>) defines the largest and the smallest `long` integers; its implementation is equivalent to\
[listing]\
implementation largeSmall over long is \{\
  def largest is long(0x7fffffffffffffffL_)\
  def smallest is long(0x8000000000000000L_)\
\}\
\
\
\
=== Floating Point Literals\
[[floatType]]\
(((type,float@`float`)))\
\
The `float` type is used to represent fractional values. Floating point numbers are represented as IEEE double precision -- i.e., 64 bit.\
\
\\begin\{figure\}[H]\
\\begin\{eqnarray*\}\
[[Float]]Float::=<<FloatingPoint>>\
\\end\{eqnarray*\}\
.Floating Point Literals\
[[floatExpressionFig]]\
\\end\{figure\}\
\
==== Largest and Smallest `float`s\
The `largeSmall` contract is implemented for `float`ing point numbers. Its implementation is equivalent to\
[listing]\
implementation largeSmall over float is \{\
  def largest is __bits_float(0x7fefffffffffffffL_)\
  def smallest is __bits_float(0x1L_)\
\}\
\
\
where `\\_\\_bits\\_float` is a special function that allows a 64 bit bit string to represent a floating point number (the bit string _is_ the bit representation of the floating point number).\
\
=== Decimal Number Literals\
[[decimalype]]\
(((type,decimal@`decimal`)))\
\
The `decimal` point type is used to denote arbitrary precision decimal fractional values.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[DecimalNumber]]DecimalNumber::=<<Decimal>>\
\\end\{eqnarray*\}\
.Decimal Literals\
[[decimalExpressionFig]]\
\\end\{figure\}\
\
The `decimal` type is defined equivalently to:\
[listing]\
type decimal is decimal(decimal_)\
\
where `nonDecimal` is used to denote non-legal decimal values.\
\
\\begin\{aside\}\
`decimal` numbers are based on a decimal representation. This means that `decimal` numbers can represent certain fractional values exactly which `float` numbers cannot.\
\
However, `decimal` computation is often substantially more expensive than `float`ing point computation.\
\\end\{aside\}\
\
=== String Literals\
[[stringType]]\
(((type,string@`string`)))\
\
The `string` type is used to denote string values.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[String]]String::=<<StringLiteral>>\
\\end\{eqnarray*\}\
.String Expression[[stringInterpolationFig]]\
\\end\{figure\}\
\
The `string` type is defined equivalently to:\
[listing]\
type string is string(string_)\
\
The simplest form of `string` literal is a sequence of characters enclosed in double-quotes -- see <<string>>.\
\
In addition, quoted strings may include _interpolation_ expressions -- which are embedded expressions whose values are interpolated into the actual string value.\
\
=== String Interpolation\
[[StringInterpolation]]\
(((string,interpolation)))\
String interpolation refers to the embedding of variables and expressions in string literals. The actual string value of an interpolated `string` literal requires the evaluation of those variables and expressions.\
\
For example, given a variable `X` with the value 24, then:\
[listing]\
"this has the value of X: $X"\
"$(X*X) people saw this"\
\
would have values:\
[listing][mathescape=true]\
"this has the value of X: 24" $\{\\rm and\}$ "576 people saw this"\
\
respectively.\
\
There are two modes of string interpolation: the dollar form corresponds to `display`ing a value and the hash form corresponds to _coercing_ a value to a `string` value (see <<typeCoercionExpression>>). The former produces a string which is intended to be parseable as the original value. It is also the form that is universally supported by all non-programmatic types.\
\
\\begin\{aside\}\
If a `string` interpolation expression itself contains a string, the various quoting mechanisms for strings apply to that string also. I.e., it is not necessary to `double-quote' strings within `string` interpolation expressions.\
\
For example, the `string` expression in:\
[listing]\
logMsg(info,"The price of cheese is $(priceOf("cheese"))");\
\
works as expected: the argument to the `priceOf` function is the string literal `"cheese"`. An even more nested example is:\
[listing]\
logMsg(info,"The price of $P is $(priceOf("SKU$P"))");\
\
In this example, we have a `string` interpolation expression embedded within another `string` interpolation expression.\
\\end\{aside\}\
\
An <<Interpolation>> expression may be followed by a <<FormattingSpec>>. If present, then this specification is used to guide how values are formatted.\
\
For example, the value of\
[listing]\
"--\\$(120345567):999,999,999,999;--"\
\
is the string:\
[listing]\
"--120,345,567--"\
\
Detailed formatting is controlled by the `format` contract -- see <<formatContract>> -- which in turn means that different types of expression will have type appropriate ways of specifying the formatting.\
\
==== Semantics of String Interpolation\
\
String variable interpolation expressions may refer to variables that are in scope at the location of the string literal itself.\
\
The meaning of a string interpolation is slightly different for the two forms of interpolation. An expression of the form:\
[listing][escapechar=|]\
"|_prefix_|$(|_Exp_|)|_suffix_|"\
\
is interpreted as:\
[listing][mathescape=true]\
"$_prefix_$"++display($_Exp_$)++"$_suffix_$"\
\
whereas the expression:\
[listing][mathescape=true]\
"$_prefix_$\\#($_Exp_$)$_suffix_$"\
\
is interpreted as being equivalent to:\
[listing][mathescape=true]\
"$_prefix_$"++($_Exp_$ as string)++"$_suffix_$"\
\
\
\\begin\{aside\}\
The difference between `display` and `as` becomes most obviously apparent with `string`s themselves. Assuming that the variable `L` is bound to the `string` `"hello"`, the value of\
[listing]\
"alpha#(L)beta"\
\
is the string\
[listing]\
"alphahellobeta"\
\
whereas the value of\
[listing]\
"alpha$(L)beta"\
\
is\
[listing]\
"alpha\\"hello\\"beta"\
\
But in general, there may be many differences between the two forms of displayed value.\
\\end\{aside\}\
\
If a <<FormattingSpec>> is present, then the translation takes that into account also. For example, the expression:\
[listing][escapechar=|]\
"|_prefix_|$(|_Exp_|):|_Format_|;|_suffix_|"\
\
is equivalent to the expression:\
[listing][mathescape=true]\
"$_prefix_$"++_format($_Exp_$,$_Format_$)++"$_suffix_$"\
\
where `\\_format` is part of the `format` contract -- see <<formatContract>>.\
\
\\begin\{aside\}\
Note that this translation is the same for either the `\\$` or `\\#` interpolation form.\
\\end\{aside\}\
\
\
=== Enumerated Symbols\
[[enumeratedSymbol]]\
(((expression,enumerated symbol)))\
(((enumerated symbol)))\
Enumerated symbols are written using regular identifiers (see <<enumSymbolFig>>). Such a symbol must first have been declared within a type definition statement -- see <<enumSymbol>> -- which also determines the type of the symbol.\
\
For example, the `boolean` type definition has two <<EnumeratedSymbol>>s in its definition: `true` and `false`. Thus\
[listing]\
true\
\
is an expression consisting of an <<EnumeratedSymbol>> from the definition:\
[listing]\
type boolean is true or false;\
\
\
== Algebraic Constructor Expressions\
[[algebraicConstructors]]\
\
The <<AlgebraicConstructor>> expressions are those that refer to constructors that are defined in <<AlgebraicType>> definitions -- _or those that arise from standard type schemas such as tuples and anonymous records_.\
\
There are two primary forms of <<AlgebraicConstructor>>s: positional <<ConstructorLiteral>> terms and <<RecordLiteral>> terms.\
\
Records allow their fields to be addressed individually.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[AlgebraicConstructor]]AlgebraicConstructor::=<<EnumeratedSymbol>>\\\\\
  | <<ConstructorLiteral>>\\\\\
  | <<TupleLiteral>>\\\\\
  | <<RecordLiteral>>\\\\\
  | <<AnonymousRecord>>\\\\\
  | <<RecordAccess>>\\\\\
  | <<SequenceExpression>>\
\\end\{eqnarray*\}\
.Algebraic Constructor Expressions\
[[algebraicExpressionFig]]\
\\end\{figure\}\
\
\
=== Enumerated Symbol\
[[enumeratedSymbol]]\
(((expression,enumerated symbol)))\
(((enumerated symbol literal)))\
<<EnumeratedSymbol>>s denote symbolic values. In particular, it refers to symbols that are introduced in an algebraic <<TypeDefinition>>.\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[EnumeratedSymbol]]EnumeratedSymbol::=<<Identifier>>\
\\end\{eqnarray*\}\
.Enumerated Symbol Expression\
[[enumeratedSymbolFig]]\
\\end\{figure\}\
Enumerated symbols have no internal structure; they are often used to define enumerations or for sentinels. For example, the <<Boolean>> standard type can be defined\
[listing]\
type boolean is false or true\
\
and the standard cons-list type uses `nil` to mark the empty list:\
[listing]\
type cons[t] is cons(t,cons[t]) or nil\
\
\
=== Constructor Literals\
[[positionalConstructor]]\
(((expression,positional constructor)))\
(((positional constructor literal)))\
<<ConstructorLiteral>> expressions denote data constructor values. In particular, it refers to constructors that are introduced in an algebraic <<TypeDefinition>>.\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[ConstructorLiteral]]ConstructorLiteral::=<<Identifier>>`(`<<Expression>>`,`...`,`<<Expression>>`)`\
\\end\{eqnarray*\}\
.Constructor Literal Expression\
[[positionalConstructorFig]]\
\\end\{figure\}\
This definition also determines the valid types of the arguments to the constructor. For example, the type definition:\
[listing]\
type address is noWhere or someWhere(string,integer,string)\
\
defines `someWhere` as the identifier of a <<ConstructorLiteral>> and any instance must have exactly three arguments: a `string`, an `integer` and a `string`.\
\
\\paragraph\{Accessing Elements of a Constructor Literal\}\
(((positional constructor literal,accessing elements)))\
The only way that elements of a <<ConstructorLiteral>> can be _accessed_ is via a pattern match -- see <<posConPattern>>. For example, given the definition of `address` above, we can `unpack' its argument using a pattern such as in\
[listing]\
city(someWhere(City,_,_)) is City\
\
\
=== Tuples\
[[TupleTerms]]\
(((expressions,tuple)))\
(((tuples)))\
(((informal combinations of elements)))\
A tuple consists of a sequence of expressions separated by commas and enclosed in parentheses. In effect, a tuple is a <<ConstructorLiteral>> where the <<Identifier>> is omitted -- and is automatically generated.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[TupleLiteral]]TupleLiteral::=`()`\\\\\
  | `((`<<Expression>>`))`\\\\\
  | `(`<<Expression>>\\sequence\{,\}<<Expression>>`)`\\plustwo\
\\end\{eqnarray*\}\
.Tuple Literal Expression\
[[tupleLiteralFig]]\
\\end\{figure\}\
\
Tuples allow a straightforward of the `casual' grouping of values together without requiring a specific type definition of a data structure.\
\\begin\{aside\}\
Unlike <<ConstructorLiteral>>s, tuples _cannot_ be defined using a <<TypeDefinition>>. Instead, the tuple types form a _type schema_.\
\\begin\{aside\}\
Not a single type, because each arity of anonymous tuple type denotes a different type. However, all tuples are related by their tuple-ness.\
\\end\{aside\}\
\\end\{aside\}\
\
In that tuples can be used to group elements together, they are somewhat similar to arrays. However, unlike arrays, each element of a tuple may be of a different type, and also unlike arrays, tuple elements may not be accessed via an indexing operation: tuples can only be `unwrapped' by some form of pattern matching.\
\
For example, if the `split` function splits a list into a front half and back half, it may be used in a statement of the form:\
[listing]\
def (F,B) is split(L)\
\
which has the effect of unpacking the result of the `split` function call and binding the variables `F` and `B` to the front half and back half of the list `L`.\
\
\
The tuple notation is unremarkable except for two cases: the single element tuple and the zero element tuple.\
\
\
==== Zero-ary Tuples\
[[zeroTuple]]\
(((tuple,zero-ary)))\
Zero-element tuples _are_ permitted. A zero-element tuple, which is written\
[listing]\
()\
\
is essentially a symbol.\
\
==== Singleton Tuples\
(((single element tuples)))\
(((tuples,single element)))\
Some special handling is required to represent tuples of one element.\
\
The principal issue is the potential ambiguity between a tuple with one element and a normal operator override expression.\
\
For example,\
[listing]\
(a+b)*c\
\
is such a case: the inner term `(a+b)` is not intended to denote a tuple but simply the sum of `a` and `b`.\
\
A singleton tuple _may_ be written; by doubly parenthesizing it. An expression of the form:\
[listing]\
((34))\
\
denotes a singleton tuple with the integer 34 in it.\
\
\\begin\{aside\}\
Fortunately, singleton tuples are not often required in programs.\
\\end\{aside\}\
\
=== Record Literals\
[[recordLiteral]]\
(((expressions,record literal)))\
(((record literal)))\
A record literal is a collection of values identified by name.\
\
Like <<ConstructorLiteral>>s, the <<RecordLiteral>> must have been defined with a <<TypeDefinition>> statement. This also constrains the types of the expressions associated with the fields.\
\
\
\\begin\{figure\}[H]\
\\begin\{eqnarray*\}\
[[RecordLiteral]]RecordLiteral::=<<Record>>\\ |<<ThetaRecord>>\\\\\
[[Record]]Record::=<<Expression>>`\\\{`<<RecordElement>>\\sequence\{;\}<<RecordElement>>`\\`\}\\\\\
[[RecordElement]]RecordElement::=<<Identifier>>\\ `=`\\ <<Expression>>\\\\\
  | <<Identifier>>\\ `:=`\\ <<Expression>>\\\\\
  | `type`\\ <<Identifier>>\\ `=`\\ <<Type>>\
\\end\{eqnarray*\}\
.Record Literal Expression[[recordLiteralFig]]\
\\end\{figure\}\
\
\
There are two variants of the <<RecordLiteral>>: the <<Record>> form and the <<ThetaRecord>> form. This section focuses on the former.\
\
For example, given the type definition:\
[listing]\
type employee is emp\{\
  name has type string;\
  hireDate has type date;\
  salary has type ref integer;\
  dept has type ref string;\
\}\
\
A literal `emp` value will look like:\
[listing]\
def E is emp\{\
  name = "Fred Nice";\
  hireDate = today();\
  salary := 23000;\
  dept := "mail"\
\}\
\
\\begin\{aside\}\
Fields whose type is a `ref`erence type -- see <<referenceType>> -- are defined within the record using the `:=` operator. All other fields are defined using the `=` operator.\
\\end\{aside\}\
\
For any given <<RecordLiteral>> _all_ the fields of the record must be associated with a value. This value is either explicitly given or can be supplied by a `default` declaration within the type definition itself.\
\
Fields within a <<RecordLiteral>> are identified by name; and may be written in any order.\
\
=== Anonymous Records\
[[anonRecord]]\
(((expression,anonymous records)))\
(((anonymous records)))\
\
An anonymous record is one which does not have an explicit label.\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[AnonymousRecord]]AnonymousRecord::=`\\\{`<<RecordElement>>`;`...`;`<<RecordElement>>`\\`\}\\\\\
  | `\\\{`<<Definition>>\\sequence\{;\}<<Definition>>`\\`\}\
\\end\{eqnarray*\}\
.Anonymous Record Literal Expression[[anonRecordLiteralFig]]\
\\end\{figure\}\
\
For example, an anonymous record consisting of a `name` and an `address` may be written:\
[listing]\
\{name="Fred; address="1 Main St"\}\
\
Anonymous records have, as their type, a <<RecordType>> (see <<recordType>>). The type of this record would be represented by:\
[listing]\
\{ name has type string; address has type string\}\
\
\
=== Accessing Fields of a Record\
[[dotAccess]]\
(((record literal,accessing)))\
(((expressions,accessing record fields)))\
\
Record access expressions access the value associated with a field of a record value. The result may either be the field value, or a new record with a replaced field value.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[RecordAccess]]RecordAccess::=<<Expression>>\\ `.`\\ <<Identifier>>\
\\end\{eqnarray*\}\
.Record Access Expression[[recordAccessFig]]\
\\end\{figure\}\
\
An expression of the form\
[listing]\
A.F\
\
where `F` is the name of an attribute of the record `A` denotes the value of that attribute. For example, given the type definition\
[listing]\
type person is someone\{\
  name has type string;\
  age has type integer;\
\}\
\
and a `person` value bound to `P`:\
[listing]\
def P is someone\{ name="fred"; age=32 \}\
\
then the expression `P.name` has value `"fred"`.\
\
The (`.`) access operator is also used in cases where an anonymous record is used; for example given the record:\
[listing]\
def R is \{ alpha = "a"; beta=4\}\
\
then `R.alpha` has value `"a"`\
\\begin\{aside\}\
The binding of the record access operator (`.`) is very strong. Thus, expressions such as\
`A.L[ix]` and `A.F(a,b*3)`\
are equivalent to\
[listing][mathescape=true]\
(A.L)[ix] $\{\\rm and\}$ (A.F)(a,b*3)\
\
respectively.\
\\end\{aside\}\
\
==== Type Safety\
The type safety of a record access expression is couched in terms of <<AttributeConstraint>>s: i.e., a record access expression implies that a value satisfies the appropriate <<AttributeConstraint>>.\
\
\\begin\{prooftree\}\
\\AxiomC\{\\typeprd\{E\}\{R\}\{T\\ `where`\\ T\\ `implements`\\ `\\\{F has type `T\\sub\{f\}`\\`\}\}\}\
\\UnaryInfC\{\\typeprd\{E\}\{R.F\}\{T\\sub\{f\}\}\}\
\\end\{prooftree\}\
\\begin\{aside\}\
This formulation of the type safety of record access expressions allows for some quite powerful usages. For example, the function:\
[listing]\
getName(R) is R.name\
\
has type:\
[listing]\
getName has type for all r,f such that\
  (r)=>f where r implements \{name has type f\}\
\
In effect, we can define programs that depend on particular attributes without having to be concrete about the actual types of the records being accessed.\
\\end\{aside\}\
\
=== Theta Records\
[[thetaRecords]]\
(((record literal,theta)))\
(((theta record)))\
\
A <<ThetaRecord>> is a record whose contents is specified by means of a <<thetaEnvironment>>. There are variants corresponding to labeled and anonymous records.\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[ThetaRecord]ThetaRecord::=[<<Expression>>]]`\\\{`<<Definition>>\\sequence\{;\}<<Definition>>`\\`\}\
\\end\{eqnarray*\}\
.Theta Record Literal Expression[[thetaRecordLiteralFig]]\
\\end\{figure\}\
\
Externally, a <<ThetaRecord>> is the same as a regular <<Record>>; internally, however, its fields are defined very differently using <<Definition>>s rather than attribute assignments.\
\
If the record is labeled, then, as with all labeled records, the definitions within the <<thetaEnvironment>> must correspond exactly to the type definition.\
\
<<ThetaRecord>>s are especially convenient when the fields of the record are program values. For example, assuming a type definition such as:\
[listing]\
type onewayQ of t is onewayQ\{\
  add has type (t)=>();\
  take has type ()=>t;\
\}\
\
the literal:\
[listing]\
onewayQ\{\
  private var Q := list of [];\
  prc add(X) do \{\
    Q := list of [Q..,X]\
  \}\
  take() is valof\{\
    def H is head(Q);\
    Q := tail(Q);\
    valis H\
  \}\
\}\
\
defines a `onewayQ` record with two exposed program values -- `add` and `take`.\
\
\\begin\{aside\}\
If there are `extra' definitions, they should be marked `private` which will exclude them from the record's type signature.\
\\end\{aside\}\
\
\\begin\{aside\}\
A <<ThetaRecord>> has many of the characteristics of an object in OO languages -- except that there is no concept of inheritance; nor is there a direct equivalence of the `self` or `this` keyword.\
\\end\{aside\}\
\
==== `private` fields\
[[privateField]]\
(((private fields@`private` fields)))\
(((fields,private@`private`)))\
A definition within a <<ThetaRecord>> that is marked `private` does _not_ `contribute' to the external type of the record; and neither can such an attribute be accessed via the <<RecordAccess>> expression.\
\
=== Record Substitution Expression\
[[recordOverride]]\
(((replacing values in a record)))\
(((expressions,substitute@`substitute`)))\
(((record values,replacing fields)))\
An expression of the form:\
[listing][mathescape=true]\
A substitute \{att$\\sub1$=$<<Expression>>\\sub1\\sequence\{;\}$att$\\subn$=$<<Expression>>\\subn$\}\
\
denotes the value obtained by replacing the attributes `att`\\subi\{\} in `A` with the expressions <<Expression>>\\subi.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
_Expression_&\\arrowplus&<<Expression>>\\ `substitute`\\ <<AnonymousRecord>>\
\\end\{eqnarray*\}\
.Record Override Expression[[recordOverrideFig]]\
\\end\{figure\}\
\
For example, the expression\
[listing]\
P substitute \{age=33\}\
\
has value\
[listing]\
someone\{name="fred"; age=33\}\
\
\\begin\{aside\}\
This expression has a separate value to that of `P` itself; evaluating the `substitute` does not side-effect `P`.\
\\end\{aside\}\
\
\\noindent\
The semantics of `substitute` is based on the notion of a `shallow copy'. The value of the expression:\
[listing]\
P substitute \{ age=33 \}\
\
is a new term whose fields consist of all the fields of `P` -- with the exception of the `age` field. The `substitute` expression does not imply a `deep' or complete copy of its left hand side.\
\\begin\{aside\}\
(((expressions,substitute@`substitute`!ref fields@`ref` fields)))\
(((record values,replacing ref fields@replacing `ref` fields)))\
(((ref field@`ref` field)))\
This only has significance if the record contains any `ref` fields. In particular, the resulting expression _contains_ the same `ref` fields as the original; and a subsequent assignment to a `ref` field will affect both the original and the substituted term.\
\
For example, given this type definition:\
[listing]\
type account is account\{\
  name has type string;\
  balance has type ref float;\
\}\
\
and given the variable bindings:\
[listing]\
def A is account\{ name = "fred"; balance := 0.0 \};\
def B is A substitute \{ name = "peter" \}\
\
then `A` and `B` both share the _same_ `ref` field. An assignment to one:\
[listing]\
A.balance := 5.9\
\
is an assignment to the other. In this case, the value of `B.balance` is also `5.9`\
\\end\{aside\}\
\\begin\{aside\}\
Note that if the _right hand side_ of a `substitute` contains a `ref` field, then the result will have the `ref` field from the right hand side, not the original.\
\
For example, if we have:\
[listing]\
def C is A substitute \{ balance := 4.5 \}\
\
then `C` _does not_ share a `ref` with `A` and updating either will not affect the other.\
\\end\{aside\}\
\
==== Type Safety\
The type safety of an attribute substitute expression is couched in terms of <<AttributeConstraint>>s.\
\\begin\{prooftree\}\
\\AxiomC\{\\typeprd\{E\}\{R\}\{T\\sub\{R\}\\ `where`\\ T\\sub\{R\}\\ `implements`\\ T\\sub\{S\}\}\}\
\\AxiomC\{\\typeprd\{E\}\{S\}\{S\\sub\{S\}\\ `where`\\ S\\sub\{S\}\\ `implements`\\ T\\sub\{S\}\}\}\
\\BinaryInfC\{\\typeprd\{E\}\{R\\ `substitute`\\ S\}\{T\\sub\{R\}\}\}\
\\end\{prooftree\}\
The implication is that the `substitution' record `S` only contains attributes that are also present in the `substitute' expression `R`.\
\
== Optional Expressions\
[[optionExpression]]\
(((option expression@`option` expression)))\
\
An `option` expression is used to handle cases where a value is not always guaranteed. The `option` type is built-in but is defined as though by the algebraic type definition in Program~\\vref\{optionTypeProg\}.\
\
\\begin\{program\}\
[listing]\
type option of t is none or some(t)\
\
.The `option` Type\
[[optionTypeProg]]\
\\end\{program\}\
\
The `option` type is intended to convey one of two possibilities: a given value exists -- in which case the `some` constructor is used -- or no value exists -- in which case `none` is used.\
\
For example,\
[listing]\
some("alpha")\
\
signals the definite `string` value `"alpha"`; whereas\
[listing]\
none\
\
signals that there is no value.\
\
The `option` type can be used as the return type of functions that must reliably signal whether or not a value exists.\
\\begin\{aside\}\
The `option` type serves as a normal `replacement' for `null` that one sees in languages like Java.\
\\end\{aside\}\
\
In addition to the `someValue` and `?.` operators -- described below in <<someValue>> and <<optionChaining>> -- two conditions are defined specifically for `option` expressions: `present` (see <<presentCond>>) and `has value` (see <<hasValueCond>>).\
\
=== Unwrap Option Value -- `someValue`\
[[someValue]]\
(((unwrap option value)))\
\
The `someValue` unwraps a `some` value and returns its contents. It is defined by the equation:\
\
[listing]\
someValue(some(X)) is X\
\
\
\\begin\{aside\}\
\\begin\{aside\}\
The `someValue` function is partial. It is not defined in the case that its argument is not a `some` value. If `someValue` is invoked with q\{none\} then the program will terminate.\
\
For this reason, the programmer should consider whether the `has value` condition (see <<hasValueCond>>) is a better fit.\
\\end\{aside\}\
\\end\{aside\}\
\
=== Option Field Access -- `?.`\
[[optionChaining]]\
(((?. operator@`?.` operator)))\
(((accessing an optional value)))\
(((option chaining)))\
\
The `?.` operator can be used similarly to a normal record field access (see \\vref\{dotAccess\}) except that it takes an `option`al argument and returns an `option` value.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
<<RecordAccess>>&\\arrowplus&<<Expression>>\\ `?.`\\ <<Identifier>>\
\\end\{eqnarray*\}\
.Optional Record Access Expression[[optionAccessFig]]\
\\end\{figure\}\
\
The form of a optional field access is also similar to the field access; an expression of the form:\
[listing]\
A?.F\
\
will access the `F` field from the wrapped record value in `A`. The result type of a option field access is also an `option`al.\
\
For example, suppose that `R` has the type given by\
[listing]\
R has type option of Person\
\
\
Its type can be approximated by (the difference is that field labels are not themselves functions):\
[listing]\
(?.) has type for all r,s such that\
  (option of r,(r=>s))=>option of s\
\
I.e., it has a similar type to the `map` function (see \\vref\{mapFunction\}) in the `mappable` contract.\
\
However, it is actually best understood as a macro form. The macro definition of `?.` can be given in a single line macro:\
[listing]\
#?R ?. ?F ==> map((RR)=>RR.F,R)\
\
where `map` is the implementation of the `mappable` contract for the `option` type.\
\
=== Default Option Expression -- `or else`\
[[optionDefltChain]]\
(((or else operator@`or else` operator)))\
(((accessing an optional value with default)))\
(((option chaining)))\
\
The `or else` operator can be used to unwrap an `option`al value -- giving a default in the case that it is actually `none`\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
<<Expression>>&\\arrowplus&<<Expression>>\\ `or else`\\ <<Expression>>\
\\end\{eqnarray*\}\
.Optional Chaining with Default[[optionIndexAccessFig]]\
\\end\{figure\}\
\
The form of a optional access is:\
[listing]\
O or else D\
\
where `O` has type `option of t` and `D` has type `t`. If `O` has value `some(X)` then the value is `X`, otherwise it is `D`.\
\
Like `?.`, `or else` can be best understood as a macro:\
[listing]\
# ?O or else ?D ==> _optionDeflt(O,()=>D)\
_optionDeflt(some(X),_) is X\
 |  _optionDeflt(none,D) is D()\
\
Notice that the default expression is not evaluated unless the value of `O` is `none`.\
\
The `or else` operator is right associative. This means that they can be chained  together if more than one default is possible:\
[listing]\
A or else B or else C\
\
\
== Collection and Sequence Expressions\
[[sequenceExpression]]\
(((sequence,expressions)))\
(((expressions,sequence)))\
(((of@`of`,expression)))\
\
Collection expressions and sequence expressions are a syntactic feature that make it straightforward to represent collective values. The difference between a `collection` and a `sequence` is that the latter embodies a sequential ordering of the elements. A `collection` may have an ordering present; but that is not required by the contract and is not enforced in the notation.\
\
\
A sequence expression represents a use of the standard `sequence` contract (see Program~\\vref\{sequenceContractDef\}) to construct sequences of values.\
\
\\begin\{aside\}\
There is a similar form to <<SequenceExpression>> which is used to denote _queries_ -- the programmer's analog of set abstractions. <<Query>> expressions are defined in Chapter~\\ref\{queries\}.\
\\end\{aside\}\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
_Expression_&\\arrowplus&<<SequenceExp>>\\\\\
[[SequenceExp]SequenceExp::=<<SequenceType>>\\ `of``[`<<ExpSequence>>`]]`\\\\\
  | `[`<<ExpSequence>>`]`\\\\\
[[ExpSequence]ExpSequence::=[<<Expression>>`..,`]<<Expression>>\\sequence\{,\}<<Expression>>[`,..`<<Expression>>]]\\\\\
[[SequenceType]]SequenceType::=<<Identifier>>\
\\end\{eqnarray*\}\
.Sequence Expression\
[[sequenceExpressionFig]]\
\\end\{figure\}\
I.e., a sequence expression consists of a sequence of <<Expression>>s separated by commas. In addition, either -- but not both -- the tail or the front of the sequence may be denoted by an expression. Otherwise the sequence is nil-terminated.\
\
An expression of the form:\
[listing][escapechar=|]\
|_Label_| of [|_E\\sub1_\\sequence\{,\}_E\\subn_|]\
\
is equivalent to the expression:\
[listing][escapechar=|]\
_cons(|_E\\sub1_\\sequence\{,\}|_cons(|_E\\subn_|,_nil())|\\sequence\{\}|) has type |_Label_| of %t|\\sub\{new\}|\
\
_provided that \\emph\{Label_ is the label of a <<Type>> that implements the `sequence`  contract\} -- see <<sequenceContract>> and where `\\%t\\sub\{new`\} is a new type variable not occurring elsewhere. Included in that contract are two functions -- denoting the empty sequence (`\\_nil()`) and a non-empty sequence (`\\_cons()`) -- that are used to build the true value of a sequence expression.\
\
A sequence can be built up from other sequences by prepending to them. An expression of the form:\
[listing][escapechar=|]\
|_Label_| of [|_E\\sub1_\\sequence\{,\}_E\\sub\{n-1_\}`,..`_E\\subn_|]\
\
is equivalent to the expression:\
[listing][escapechar=|]\
_cons(|_E\\sub1_\\sequence\{,\}|_cons(|_E\\sub\{n-1_\}|,|_E\\subn_|)|\\sequence\{\}|)\
\
\
Conversely, a sequence may be `front' loaded and be defined by appending elements to a `front' expression:\
[listing][escapechar=|]\
|_Label_| of [|_F_`..,`_E\\sub1_\\sequence\{,\}_E\\subn_|]\
\
is equivalent to the expression:\
[listing][escapechar=|]\
_apnd(|\\sequence\{\}|_apnd(|_F_|,|_E\\sub1_|)|\\sequence\{\}_E\\subn_|)\
\
\
\\begin\{aside\}\
It is also possible to have a sequence expression is that is _both_ front-loaded and back-loaded:\
[listing][escapechar=|]\
|_Label_| of [|_F_|..,|_M_|,..|_T_|]\
\
is equivalent to:\
[listing][escapechar=|]\
_apnd(_cons(|_F_|,|_M_|),|_T_|)\
\
which, in turn, is equivalent to:\
[listing][escapechar=|]\
_cons(|_F_|,_apnd(|_M_|,|_T_|))\
\
\\end\{aside\}\
\
==== Type Safety\
Since a sequence expression is essentially a macro for the use of the `sequence` contract, its type safety determined by the `sequence` contract in Program~\\vref\{sequenceContractDef\}.\
\
== Index and Slice Notation\
[[indexNotation]]\
(((index notation)))\
(((notation for indexed access)))\
\
In a similar vein to the <<Sequence>> notation, the <<IndexExp>> notation provides a high-level notation for accessing elements and subsets of collections.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
_Expression_&\\arrowplus&<<IndexExp>>\\\\\
[[IndexExp]]IndexExp::=<<Index>>\\ |\\ <<IndexWith>>\\ |\\ <<Slice>>\\\\\
[[Index]Index::=<<Expression>>\\ `[`<<Expression>>`]]`\\\\\
[[IndexWith]IndexWith::=<<Expression>>\\ `[``with`\\ <<Expression>>`->`<<Expression>>`]]`\\\\\
  | <<Expression>>\\ `[``without`\\ <<Expression>>`]`\\\\\
[[Slice]Slice::=<<Expression>>\\ `[`<<Expression>>`:`<<Expression>>`]]`\\\\\
  | <<Expression>>\\ `[`<<Expression>>`:``]`\
\\end\{eqnarray*\}\
.Index and Slice Expressions\
[[indexExpressionFig]]\
\\end\{figure\}\
\
\\begin\{aside\}\
There is some subtlety in the interpretation of index expressions; depending on whether the <<IndexExp>> is an expression, or whether it is the left hand side of an assignment:\
[listing]\
L[Ix] := E\
\
\
In the sections that follow, and in <<sequenceUpdate>>, we show the different interpretations of an index expression.\
\\end\{aside\}\
\
=== Accessing Elements of a Collection\
[[indexedAccess]]\
(((indexed access to collection)))\
(((access list with index)))\
An expression of the form:\
[listing]\
C[ix]\
\
is equivalent to the expression\
[listing]\
_index(C,ix)\
\
\\begin\{aside\}\
The type of the resulting value from an indexed access is `option`al -- see <<optionExpression>>. I.e., since it cannot be guaranteed -- in general -- that the element exists, the resulting type expresses that uncertainty.\
\
You can extract the underlying value by using the `someValue` function -- see <<someValue>> -- but a safer way is to use a `has value` condition (see <<hasValueCond>>.\
\\end\{aside\}\
\
The presence of an element can be tested in one of two ways: by using the `present` predicate -- see <<presentCond>>:\
[listing]\
present C[Ix]\
\
which tests whether `C` has an element at index `Ix` or using the special condition:\
[listing]\
C[Ix] has value V\
\
which are equivalent to\
[listing]\
_index(C,Ix) matches some(_)\
\
and\
[listing]\
_index(C,Ix) matches some(V)\
\
respectively.\
\
=== Substitutions in a Collection\
It is possible to denote the collection obtained by _substituting_ an element -- or deleting an element -- with expressions such as:\
[listing]\
C[with Kx->Vx]\
\
and\
[listing]\
C[without Kx]\
\
which represent\
[listing]\
_set_indexed(Cx,Kx,Vx)\
\
and\
[listing]\
_delete_indexed(Cx,Kx)\
\
respectively.\
\
=== Slicing Collections\
A more powerful form of accessing single elements from a collection is the _slice_ notation. A slice expression takes the form:\
[listing][escapechar=|]\
|_C_|[|_From_|:|_To_|]\
\
which denotes the subset of elements `starting' at `_From_` and `ending' (but _not_ including) with `_To_`.\
\
The special variant:\
[listing][escapechar=|]\
|_C_|[|_From_|:]\
\
denotes all the remaining elements of the collection after `From`.\
\
\\begin\{aside\}\
Related to the indexing and slicing expressions are the indexed assignments -- as can be seen in <<sequenceUpdate>>.\
\\end\{aside\}\
\
== Function Application Expressions\
[[functionApplication]]\
(((expressions,function application)))\
(((function application expression)))\
\
A function application expression `applies' a function to zero or more arguments.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[ApplicativeExpression]]ApplicativeExpression::=<<Expression>>`(`<<Expression>>\\sequence\{,\}<<Expression>>`)`\
\\end\{eqnarray*\}\
.Function Application Expression\
[[applicativeExpressionFig]]\
\\end\{figure\}\
\
It is quite normal for the function expression being applied to arguments itself to be the result of a function application. For example, given the function `double`:\
[listing]\
double has type for all s such that (((s)=>s))=>((s)=>s)\
double(F) is (X) => is F(F(X))\
\
we can apply `double` to `inc`:\
[listing]\
inc has type (integer)=>integer\
inc(X) is X+1;\
\
to get an expression such as:\
[listing]\
double(inc)(3)\
\
which has value 5.\
\
==== Type Safety\
[[functionApplyType]]\
(((type,function application)))\
The primary type safety rule for function application is that the types of the arguments of the application match the argument types of the function. The type of the resulting expression is the return type associated with the function.\
\
\\begin\{prooftree\}\
\\AxiomC\{\\typeprd\{E\}\{`F`\}\{`(`t\\sub1\\sequence\{,\}t\\subn`)=>`t\}\}\
\\AxiomC\{\\typeprd\{E\}\{`e\\sub1`\}\{t\\sub1\}\\sequence\{\\ \}\\typeprd\{E\}\{`e\\subn`\}\{t\\subn\}\}\
\\BinaryInfC\{\\typeprd\{E\}\{`F(e\\sub1`\\sequence\{,\}`e\\subn)`\}\{t\}\}\
\\end\{prooftree\}\
\
== Control Expressions\
[[controlExpression]]\
The so-called control expressions involve and modify the meaning of other expressions and actions.\
\
=== Conditional Expressions\
[[conditionalExpression]]\
(((expressions,conditional)))\
(((conditional expression)))\
\
A conditional expression applies a predicate <<Condition>> to decide whether or not to `take' the `then' branch or the `else' branch.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[ConditionalExpression]]ConditionalExpression::=`(`<<Condition>>`?`<<Expression>>`:`<<Expression>>`)`\
\\end\{eqnarray*\}\
.Conditional Expression\
[[conditionalExpressionFig]]\
\\end\{figure\}\
\
The value of a conditional expression depends on whether the <<Condition>> is satisfiable or not. If the <<Condition>> is satisfiable, then the expression is equivalent to the `then' branch of the conditional expression; otherwise it is equivalent to the `else' branch.\
\
For example, the expression:\
[listing]\
(P in members ? X>Y : X<Y)\
\
is equivalent to one of `X>Y` or `X<Y` depending on whether the <<Condition>>:\
[listing]\
P in members\
\
is satisfiable -- i.e., has at least one solution.\
\
The condition of a conditional expression may introduce variables, depending on the form of the condition -- for example, if the <<Condition>> is a <<SearchCondition>> condition like that above. These variables are `in scope' within the `then' part of the conditional expression but are _not_ in scope for the `else' part.\
\
\\paragraph\{Evaluation Order\}\
The only guarantees as to evaluation of a conditional expression are that\
\\begin\{enumerate\}\
\\item the conditional will be evaluated prior to evaluating either arm of the conditional\
\\item only one of the arms will be evaluated -- depending on the value of the condition.\
\\end\{enumerate\}\
\
==== Type Safety\
The type safety requirements of a conditional expression are that the types of the two arms of the conditional are the same, and that the condition itself is \\safeinf\{\}:\
\
\\begin\{prooftree\}\
\\AxiomC\{\\typesat\{E\}\{C\}\}\
\\AxiomC\{\\typeprd\{E\}\{Th\}\{t\}\}\
\\AxiomC\{\\typeprd\{E\}\{El\}\{t\}\}\
\\TrinaryInfC\{\\typeprd\{E\}\{`(`C`?`Th`:`El`)`\}\{t\}\}\
\\end\{prooftree\}\
\
\
=== Switch Expressions\
[[caseExpression]]\
(((expressions,case@`case`)))\
(((case expression@`case` expression)))\
\
A `switch` expression uses a selector expression and a set of equations to determine which value to return.\
\\begin\{aside\}\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[CaseExpression]]CaseExpression::=`switch`\\ <<Expression>>\\ `in`\\ <<CaseBody>>\\\\\
[[CaseBody]]CaseBody::=`\\\{`<<CaseArm>>\\sequence\{`;`\}<<CaseArm>>`\\`\}\\\\\
[[CaseArm]]CaseArm::=`case`\\ <<Pattern>>\\ `is`\\ <<Expression>>\\\\\
  | `case`\\ <<Pattern>>\\ `default`\\ `is`\\ <<Expression>>\
\\end\{eqnarray*\}\
.Case Expression\
[[caseExpressionFig]]\
\\end\{figure\}\
\
The `selector' expression is evaluated, and then, at most one of the <<CaseArm>>s is selected based on whether the <<Pattern>> matches or not. If one of these does match, then the corresponding <<Expression>> on the right hand side is evaluated as the value of the `switch`.\
\
Program~\\vref\{dogCaseProg\} shows a simple example of a `switch` expression, in this mapping `string`s to `integer`s.\
\\begin\{program\}\
[listing]\
switch Alpha in \{\
  case "dog" is 1;\
  case "pup" is 2;\
  case _ default is -1\
\}\
\
.A `case` of Dogs Program[[dogCaseProg]]\
\\end\{program\}\
\
\
Each <<CaseArm>>'s pattern may introduce variables; these variables are `in scope' only for the corresponding right hand side expression.\
\
Optionally, a `switch` expression may have a `default` clause. This clause determines the value of the expression if none of the other <<CaseArm>>s match.\
\
\\begin\{aside\}\
The <<Pattern>> associated with a `default` should always apply. If the `default` clause does not match then an exception will be raised.\
\\end\{aside\}\
\
\\paragraph\{Evaluation Order\}\
Other than handling of the `default` case, the different <<CaseArm>>s are attempted in the order of appearance in the text.\
\
I.e., the `default` <<CaseArm>> is tried only if all other <<CaseArm>>s do not apply.\
\
==== Type Safety\
The type safety requirements of a `case` expression are that the types of the patterns of each <<CaseArm>> are the same, and are the same as the selector expression. In addition, the right hand sides of the <<CaseArm>>s should also be consistently typed.\
\
\\begin\{prooftree\}\
\\AxiomC\{\\typeprd\{E\}\{S\}\{T\}\}\
\\AxiomC\{\\typeprd\{E\}\{P\\subi\}\{T\}\}\
\\AxiomC\{\\typeprd\{E$\\cup\{\}$varsIn(P\\subi)\}\{E\\subi\}\{T\\sub\{e\}\}\}\
\\TrinaryInfC\{\\typeprd\{E\}\{`switch`\\ S\\ `in\\\{`\\sequence\{\}`;``case`\\ P\\subi\\ `is`\\ E\\subi`;`\\sequence\{\}`\\`\}\}\{T\\sub\{e\}\}\}\
\\end\{prooftree\}\
\
In the case that there is a `default` clause, then that too must agree:\
\\begin\{prooftree\}\
\\AxiomC\{\\typeprd\{E\}\{S\}\{T\}\}\
\\AxiomC\{\\typeprd\{E\}\{P\\subi\}\{T\}\}\
\\AxiomC\{\\typeprd\{E$\\cup\{\}$varsIn(P\\subi)\}\{E\\subi\}\{T\\sub\{e\}\}\}\
\\TrinaryInfC\{\\typeprd\{E\}\{`switch`\\ S\\ `in\\\{`\\sequence\{\}`;``case`\\ P\\subi\\ `is`\\ E\\subi`;`\\sequence\{\}`case`\\ P\\subn\\ `default`\\ `is`\\ E\\subn`\\`\}\}\{T\\sub\{e\}\}\}\
\\end\{prooftree\}\
\
`switch` expressions may not be used that often explicitly. However, the compiler will often construct them during the process of compiling functions.\
\\end\{aside\}\
\
=== Let Expressions\
[[letExpression]]\
(((expressions,let expression@`let` expression)))\
(((let expression@`let` expression)))\
\
A `let` expression allows an expression to be defined in terms of  auxiliary definitions. There are two forms of the <<LetExpression>> -- allowing the programmer to choose whether the auxiliary definitions should precede the bound expression or follow it.\
\
In addition, it is possible to use a record-valued expression in place of the set of definitions.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[LetExpression]]LetExpression::=`let`\\ <<thetaEnvironment>>\\ `in`\\ <<Expression>>\\\\\
  | <<Expression>>\\ `using`\\ <<thetaEnvironment>>\
\\end\{eqnarray*\}\
.Let Expression\
[[letExpressionFig]]\
\\end\{figure\}\
\
(((theta environment)))\
A `let` expression consists of a body -- which is a <<thetaEnvironment>> -- and a bound <<Expression>>. Within the <<thetaEnvironment>> may occur any of the permitted forms of definition: function definitions, variable definitions, type definitions, and so on. The scope of these definitions includes the bound expression.\
\
\\begin\{aside\}\
`let` expressions are an important program structuring tool for programmers. It is worth emphasizing that `let` expressions are expressions! They can be used in many, perhaps unexpected, places.\
\
For example, a `sort` function may require a comparison predicate in order to operate. This can be supplied as a named function:\
[listing]\
pComp has type (person,person)=>boolean\
pComp(someone\{name=N1\},someone\{name=N2\}) is N1<N2\
\
def S is sort(L,myCompare)\
\
Or, the same may be achieved where the call to `sort` is not so conveniently close to a theta environment:\
[listing]\
sort(L, let\{\
  pComp has type (person,person)=>boolean\
   |  pComp(someone\{name=N1\},someone\{name=N2\}) is N1<N2\
\} in pComp)\
\
The `let` expression has major applications when constructing function-returning functions.\
\\end\{aside\}\
\
==== Type Safety\
The primary safety requirement for a `let` expression is that the statements that are defined within the body are type consistent. This is the same requirement for any theta environment.\
\
The type of a `let` expression is the type of the bound expression.\
\
\
=== Memo Function\
[[memoFunction]]\
(((memo function)))\
(((expressions,memo)))\
\
A `memo` function encapsulates a single expression as a zero arity function that is guaranteed to be evaluated only once.\
\
A `memo` function is a function that `remembers' the value it first returned. Subsequent invocations of the function simply return that first value.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[MemoFunction]]MemoFunction::=`memo`\\ <<Expression>>\
\\end\{eqnarray*\}\
.Memo Function\
[[memoFunctionFig]]\
\\end\{figure\}\
\
Memo functions have an important role in cases where a group of variables is mutually recursive; a situation that is not normally permitted. For example, consider the pair:\
[listing]\
def Jack is someone\{\
    def name is "jack";\
    spouse() is Jill\
  \}\
def Jill is someone\{\
    def name is "jill";\
    spouse() is Jack\
  \}\
\
assuming this type definition:\
[listing]\
type Person is someone\{\
  name has type string;\
  spouse has type ()=>Person;\
\}\
\
\
This pair of definitions is not permitted because the value of `Jack` depends on the variable `Jill`, which in turn depends on `Jack`.\
\\begin\{aside\}\
The reason it is not permitted is that partially constructed values are not permitted. In fact, any attempt to actually compute this pair of values would simply result in an infinite loop.\
\\end\{aside\}\
\
However, the very similar pair of definitions:\
[listing]\
JackF() is someone\{\
    def name is "jack";\
    spouse() is JillF()\
  \}\
JillF() is someone\{\
    def name is "jill";\
    spouse() is JackF()\
  \}\
\
is permitted -- because mutually recursive functions are permitted. However, in some cases, especially those involving internal state, a call to normal zero-arity function is not equivalent to the result of the function. In this example, each invocation of `spouse` results in a new value; whose state is independent of other instances.\
\
To permit this, the `memo` function is semantically a function; but since each time it is called it is guaranteed to return the identical result it has the same semantics as a shared variable:\
[listing]\
def JackM is memo someone\{\
    def name is "jack";\
    spouse() is JillM()\
  \}\
def JillM is memo someone\{\
    def name is "jill";\
    spouse() is JackM()\
  \}\
\
\
==== Evaluation Semantics\
As noted above, the primary guarantee that a `memo` function offers is that it's expression is only evaluated once.\
\
An expression of the form:\
[listing][escapechar=|]\
memo |<<Expression>>|\
\
denotes a function value. Each time the `memo` expression is evaluated a new function value is `created'. In this regard, a `memo` function is no different to an `ordinary' anonymous function.\
\
\\begin\{aside\}\
The only sense in which it makes a material difference how `memo` functions are computed is through the binding of free variables within the`memo`'d expression.\
\
In general, each evaluation of a `memo` function -- or a `function` expression -- may result in different bindings for free variables within the <<Expression>>.\
\
If the function has no free variables then the compiler _may_ simply construct a static entity for the function.\
\\end\{aside\}\
\
When a `memo` function is entered then one of three possibilities may occur: either the `memo` function has never been entered, the `memo` function has already returned a value or there is a concurrent activity that is computing `within' the function.\
\
\\begin\{itemize\}\
\\item If the `memo` function has never been entered before then its expression is evaluated, recorded internally within the function, and the computed value is returned as the value.\
\\item If the `memo` function has previously returned then the recorded value is returned.\
\\item If the `memo` function is currently being computed then the call is blocked until the ongoing computation is completed. At which point the call is handled in the same way as a subsequent call to the `memo` function.\
\\end\{itemize\}\
\
==== Type Safety\
The type of a `memo` function is determined by the type of the memo'd expression:\
\
\\begin\{prooftree\}\
\\AxiomC\{\\typeprd\{E\}\{M\}\{T\\sub\{M\}\}\}\
\\UnaryInfC\{\\typeprd\{E\}\{`memo`\\ M\}\{`()=>`T\\sub\{M\}\}\}\
\\end\{prooftree\}\
\
=== Value Expressions\
[[valueExpression]]\
(((valof expression@`valof` expression)))\
(((expressions,valof@`valof`)))\
\
The `valof` expression computes a result based on the execution of a sequence of actions; the last (executed) action being a `valis` action.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[ValueExpression]]ValueExpression::=`valof`\\ <<ActionBlock>>\\\\\
  | `valof`\\ <<Expression>>\
\\end\{eqnarray*\}\
.Valof Expressions\
[[valueExpressionFig]]\
\\end\{figure\}\
\
There may be a number of actions within the `valof` action; however, when a `valis` action is executed the `valof` is terminated and the value of the `valof` expression is the value associated with the `valis` action.\
\
\\begin\{aside\}\
Each `valof` expression must contain at least one `valis` action. The execution of any of the `valis` actions terminates the `valof` itself; it acts much like a `return` in other programming languages.\
\\end\{aside\}\
\
The `valof` expression is useful for those occasions where it is necessary to side-effect some variable as part of evaluation of an expression. The classic example of this is the counter, as illustrated in Program~\\vref\{counterProg\}.\
\\begin\{program\}\
[listing]\
var Count := 0;\
counter has type ()=>integer;\
counter() is valof\{\
  Count := Count+1;\
  valis Count\
\};\
\
.A Counting Program[[counterProg]]\
\\end\{program\}\
\\begin\{aside\}\
Although the `valof` expression form _allows_ functions to be written in a procedural style, their use should be minimized to those cases where it is essential. In general, procedural programs are harder to debug and maintain and, furthermore, limit the potential for highly parallel execution.\
\\end\{aside\}\
\
==== Type Safety\
A `valof` expression is type safe if each of the actions contained within it are type consistent, and its type is the type of the expression referenced in the `valis` actions within the body of the `valor`.\
\
The type of a `valof` expression is the type of the expression associated with the `valis` actions embedded within it.\
\
\\begin\{prooftree\}\
\\AxiomC\{\\typesafe\{E\}\{A\}\}\
\\AxiomC\{\\typeprd\{E\}\{V\}\{T\}\}\
\\AxiomC\{$`valis`\\ E\\in A$\}\
\\TrinaryInfC\{\\typeprd\{E\}\{`valof`\\ A\}\{T\}\}\
\\end\{prooftree\}\
\\begin\{aside\}\
The \\safeinf\{\} meta-predicate is used of actions; and is true iff the action is consistent in its use of variables and types. See <<actionTypeSafety>>.\
\\end\{aside\}\
\
== Quoted Expressions\
[[quotedText]]\
\
The `quote` expression is used to `convert' a fragment of Star source text into a form that can be processed by Star programs.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[QuotedExpression]]QuotedExpression::=`quote(`<<QExpression>>`)`\\\\\
  | `<|`<<QExpression>>`|>`\\\\\
[[QExpression]]QExpression::=`unquote(`<<Expression>>`)`\\\\\
  | `?`<<Expression>>\\\\\
  | <<Expression>>\
\\end\{eqnarray*\}\
.Quoted Expressions\
[[quotedExpressionFig]]\
\\end\{figure\}\
\
\
(((quoted expression notation)))\
There are two forms of quoted forms: using the `quote` keyword -- together with the `unquote` keyword -- and special `<| |>` brackets -- with embedded `?` marks. Semantically they are identical; except that the latter is potentially a little easier to use.\
\
The `quote` expression takes the form:\
[listing][escapechar=$]\
quote($_SyntacticForm_$)\
\
Alternately, the special `<|` brackets `|>` may be used:\
[listing][mathescape=true]\
<|$_SyntacticForm_$|>\
\
The type of a `quote` expression is `quoted` -- whose description is shown in Program~\\vref\{quotedProg\}.\
\
_SyntacticForm_ may be any valid Star term; it is _not_ checked apart from correct use of operators. It does not have to be syntactically valid -- again, with the exception that operators must balance appropriately.\
\\begin\{aside\}\
One of the salient differences between the `quote` form of a quoted expression and the `<|` bracketed `|>` form is that the maximum priority of operators in the latter form is 2000 whereas it is 1000 within the `quote` form.\
\\end\{aside\}\
\
For example, the expression:\
[listing]\
<|A+45|>\
\
is equivalent to the expression:\
[listing][mathescape=true]\
applyAst(L$\\sub1$,nameAst(L$\\sub2$,"+"),[nameAst(L$\\sub3$,"A"), integerAst(L$\\sub4$,45)])\
\
Note that the various `L\\subi` refer to `astLocation` terms and that no check is made whether the `variable' `A` is defined or of the right type.\
\
\
=== Unquoting\
Within a `quote`d expression, the `unquote` term -- or, equivalently, the `?` term, can be used to escape the quoting mechanism and insert variable text.\
\
For example, in the expression:\
[listing]\
<| ?A + 45 |>\
\
the identifier `A` now does refer to a normal variable -- whose type must be `quoted`. If, say, `A` had the value:\
[listing]\
<| "fred" |>\
\
then the above expression is equivalent to:\
[listing]\
<| "fred" + 45 |>\
\
\
=== Automatic Quoting\
It is possible to mark a type definition in such a way as to automatically construct coercion between the type and `quoted`. This is done by adding an `implementing` clause to the <<TypeDefinition>>. For example\
[listing]\
type person is some\{\
  name has type string;\
\} or noOne\
  implementing quotable\
\
results in an implementation for coercion between `person` values and `quoted` representations of `person`. I.e.,\
[listing]\
some\{name = "who"\} as quoted\
\
is enabled by the `implementing quotable` clause.\
\
=== The Type of Abstract Syntax Terms\
The foundation of this is the standard `quoted` type which defines the structure of quoted fragments. The `quoted` type is defined in Program~\\vref\{quotedProg\} and the ancillary type `astLocation` is defined in Program~\\vref\{locationProg\}.\
\\begin\{program\}\
[listing]\
type quoted is nameAst(astLocation,string)\
            or boolAst(astLocation,boolean)\
            or stringAst(astLocation,string)\
            or integerAst(astLocation,integer)\
            or longAst(astLocation,long)\
            or floatAst(astLocation,float)\
            or decimalAst(astLocation,decimal)\
            or applyAst(astLocation,quoted,list[quoted])\
\
.The `quoted` Type[[quotedProg]]\
\\end\{program\}\
\
=== Locations\
The `quoted` forms include an `astLocation` field that indicates where the `quoted` term first appeared in a program. This type is defined in Program~\\vref\{locationProg\}.\
\\begin\{program\}[htb]\
[listing]\
type astLocation is _someWhere\{\
    source has type uri;\
    charCount has type integer;\
    lineCount has type integer;\
    lineOffset has type integer;\
    length has type integer;\
  \}\
  or noWhere;\
\
.The `astLocation` Type[[locationProg]]\
\\end\{program\}\
\
==== The `current' location\
[[locationVar]]\
(((Accessing source locations)))\
\
The standard keyword `\\_\\_location\\_\\_` denotes the source location of each of its occurrences. It is a pseudo-variable: it has a type and value; but its value is based on the text of the program that it is embedded in:\
[listing]\
__location__ has type astLocation;\
\
\\begin\{aside\}\
The related expression -- `\\hash\{`\\_\\_location\\_\\_\} -- is used within macro rules to denote the location the term that is reduced by a given macro rule.\
\\end\{aside\}\
\
== Typed Expressions\
[[typeExpression]]\
(((expressions,type)))\
(((type expressions)))\
A type annotation expression is an explicit declaration of the type of an expression. A type coercion expression denotes a conversion of a value so that it conforms to a particular type.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[TypedExpression]]TypedExpression::=<<TypeCoercion>>\\\\\
%  | <<TypeCastExpression>>\\\\\
  | <<TypeAnnotationExpression>>\
\\end\{eqnarray*\}\
.Type Expression\
[[typedExpressionFig]]\
\\end\{figure\}\
\
\
=== Type Annotation Expression\
[[typeAnnotationExpression]]\
A <<TypeAnnotationExpression>> is an expression that is annotated with a <<Type>>. The annotation amounts to an assertion that the <<Type>> of the expression is as annotated.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[TypeAnnotationExpression]]TypeAnnotationExpression::=`(`<<Expression>>\\ `has type`\\ <<Type>>`)`\
\\end\{eqnarray*\}\
.Type Annotation Expression\
[[typeAnnotatedExpressionFig]]\
\\end\{figure\}\
\
\\begin\{aside\}\
The <<TypeAnnotationExpression>> should not be confused with _type casting_ as is found in some languages. The <<TypeAnnotationExpression>> is a way for the programmer to communicate exactly what the expected type of an expression is; analogously to the <<TypeAnnotation>>s found in <<thetaEnvironment>>s.\
\\end\{aside\}\
\
%=== Type Cast Expression\
%[[typeCastExpression]]\
%(((expressions,type cast)))\
%(((type cast,expression)))\
%(((as@`as`,expression)))\
%A <<TypeCastExpression>> expression marks an explicit declaration of the type of an expression. It also delays actual type checking of the castee to runtime.\
%\
%\\begin\{figure\}[htbp]\
%\\begin\{eqnarray*\}\
%[[TypeCastExpression]]TypeCastExpression::=<<Expression>>\\ `cast`\\ <<Type>>\
%\\end\{eqnarray*\}\
%.Type Cast Expression\
%[[typeCastExpressionFig]]\
%\\end\{figure\}\
%\
%==== Type Safety\
%A type cast is an inherently dynamic operation; as far as type consistency is concerned the only constraint on the type of the left hand side is that its value is consistent with the declared type.\
%\
%In effect, the type consistency check may be delayed until the expression is actually evaluated.\
%\
%However, the declared type may be assumed to be the type of the cast expression -- a fact that may be used by the type checker.\
%\
%\\begin\{prooftree\}\
%\\AxiomC\{\\typeprd\{E\}\{Ex\}\{T\\sub\{Ex\}\}\}\
%\\AxiomC\{\\entail\{E,\\theta\\sub0\}\{T\\subsume T\\sub\{Ex\}\\leadsto\\theta\\sub\{o\}\}\}\
%\\BinaryInfC\{\\typeprd\{E\}\{Ex` cast `T\}\{T\}\}\
%\\end\{prooftree\}\
%\
%\\begin\{aside\}\
%A type cast expression only `makes sense' in a few situations: for example, if either the cast type is type `any` or the type of the castee expression is of type `any`.\
%\
%This is because type consistency is based on type equality and the only legitimate form of type casting is where the value already has the correct type.\
%\
%However, using type casting with type `any` allows so-called _heterogenous_ structures where they would not ordinarily be permitted.\
%\
%For example, the `list` expression:\
%[listing]\
%list of [1, "alpha", list of []]\
%\
%is not valid because the types of the elements of the type are not consistent. But, the expression:\
%[listing]\
%list of [1 cast any, "alpha" cast any, list of [] cast any]\
%\
%_is_ valid, is actually of type `list[any]`. However, in order to `unwrap' elements of the list it will generally be required to `cast` the elements back out of the `any` type.\
%\\end\{aside\}\
%\
=== Type Coercion Expression\
[[typeCoercionExpression]]\
[[typeCoercionContract]]\
(((expressions,type coercion)))\
(((type coercion expression)))\
A <<TypeCoercion>> expression denotes a conversion of a value from one type to another.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
[[TypeCoercion]]TypeCoercion::=`(`<<Expression>>\\ `as`\\ <<Type>>`)`\
\\end\{eqnarray*\}\
.Type Coercion Expression\
[[typeCoercionExpressionFig]]\
\\end\{figure\}\
\
The primary difference between _type casting_ and _type coercion_ is that the former can never result in any change in the value under consideration. For example, coercing a `float` value to an `integer` value has the potential to change the value (stripping any fractional part of the value).\
\
Type coercion is supported by a special `coercion` <<Contract>> shown in Program~\\vref\{typeCoercionContractFig\}.\
\
\\begin\{program\}\
[listing]\
contract coercion over (s,t) is \{\
  coerce has type (s)=>t\
\};\
\
[[typeCoercionContractFig]]\
.Coercion Contract `coercion`\
\\end\{program\}\
\
\\begin\{aside\}\
Specifically, an expression of the form:\
[listing]\
X as integer\
\
is equivalent to the expression:\
[listing]\
(coerce(X) has type integer)\
\
where the `... has type integer` has the effect of declaring that the expression has type `integer` and the `coerce` function is an overloaded function that references a type-specific implementation -- based on the source type of `X` and `integer`.\
\\end\{aside\}\
\
There are many standard coercions available, as listed in <<standardCoercions>>. However, it is also possible for a programmer to define their own type coercion by appropriately implementing the `coercion` contract.\
\
\
\\begin\{table\}\
.Standard Type Coercions[[standardCoercions]]\
\\begin\{center\}\
\\begin\{tabular\}\{|ll|ll|ll|\}\
\\hline\
Source Type&Target Type&Source&Target&Source&Target\\\\\
\\hline\
`string`&`integer`&\
`integer`&`string`&\
`string`&`long`\\\\\
`long`&`string`&\
`string`&`fixed`&\
`fixed`&`string`\\\\\
`string`&`float`&\
`float`&`string`&\
`string`&`decimal`\\\\\
`decimal`&`string`&\
`integer`&`long`&\
`integer`&`fixed`\\\\\
`integer`&`float`&\
`integer`&`decimal`&\
`long`&`integer`\\\\\
`long`&`fixed`&\
`long`&`float`&\
`long`&`decimal`\\\\\
`float`&`integer`&\
`float`&`long`&\
`float`&`fixed`\\\\\
`float`&`decimal`&\
`decimal`&`integer`&\
`decimal`&`long`\\\\\
`decimal`&`fixed`&\
`decimal`&`float`&&\\\\\
\\hline\
\\end\{tabular\}\
\\end\{center\}\
\\end\{table\}\
}