{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 A universal type denotes a type that is valid for all substitutions of a type variable.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::0>
\f0\i\fs26 UniversalType::= 
\f1\i0\fs24 <$Scr_Cs::3>
\f2\fs22 all
\f1\fs24 <!$Scr_Cs::3>
\f0\i\fs26  BoundType,..,BoundType 
\f1\i0\fs24 <$Scr_Cs::3>
\f2\fs22 ~~
\f1\fs24 <!$Scr_Cs::3>
\f0\i\fs26  Type\
BoundType ::= Identifier | Identifier 
\f1\i0\fs24 <$Scr_Cs::3>
\f2\fs22 / 
\f1\fs24 <!$Scr_Cs::3>
\f0\i\fs26 Decimal\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\sa160\pardirnatural\qc\partightenfactor0

\f1\i0\fs24 \cf0 <!$Scr_Ps::0><$Scr_Ps::1>
\f0\fs26 Universal Type Expression\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::1>
\f0\fs26 The first form of 
\i BoundType
\i0  introduces a regular type variable -- i.e., a variable of 
\i Kind
\i0  type. The second form is used to introduce a higher-kinded type variable.\
For example, the quantification:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::2>
\f2\fs22 all c/1 ~~ ...
\f0\fs26 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::2>
\f0\fs26 denotes a type variable of kind 
\i TypeConstructor
\i0 .\
[TIP] Higher kinded type variables are most commonly used in the context of 
\i Contract
\i0  definitions.\
Star will infer the type of expressions; including functions and definitions. However, the compiler does 
\i not
\i0  generalize: i.e., it will never infer a universally quantified type (or an existentially quantified one).\
One consequence of this is that all definitions of so-called 
\i generic
\i0  programs must have an explicit type annotation. \
[NOTE] The reason for this is that explicit types provide superior documentation to programs -- especially where the actual type is complex.\
For example, the  
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 dblFilter
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  function below applies its argument function in two different situations -- one for each element of each pair in the input list.\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::2>
\f2\fs22 dblFilter:all u,v ~~\
     (all t~~(t)=>t, cons[(u,v)])=>cons[(u,v)]\
dblFilter(M,[]) => []\
dblFilter(M,[(A,B),..L]) =>\
      [(M(A),M(B)),..dblFilter(M,L)]\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\sa160\pardirnatural\qc\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::2><$Scr_Ps::1>
\f0\fs26 A 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 double
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  filter\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::1>
\f0\fs26 It is important to note that any actual function argument supplied to 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 dblFilter
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  will itself have to be generic -- i.e., its type will also be universally quantified.}