{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 \
[[universalType]]\
(((types,universally quantified)))\
(((universally quantified type)))\
\
A universal type denotes a type that is valid for all substitutions of a type variable.\
\
[[universalTypeFig]]\
.Universal Type Expression\
****\
[[UniversalType]]UniversalType::= `all` <<BoundType>>,..,<<BoundType>>\\ `~~` <<Type>>\
\
[[BoundType]]BoundType ::= <<Identifier>> | <<Identifier>>``/``<<Decimal>>\
****\
\
The first form of <<BoundType>> introduces a regular type variable -- i.e., a variable of <<Kind>> `type`. The second form is used to introduce a higher-kinded type variable.\
\
For example, the quantification:\
\
[listing]\
all c/1 ~~ ...\
\
denotes a type variable of kind `type[type]`.\
\
[TIP]\
Higher kinded type variables are most commonly used in the context of <<Contract>> definitions.\
\
Star will infer the type of expressions; but does _not_ infer the types associated with defined variables -- i.e., variables defined in `let` environments and at the top-level of a package.\
\
Furthermore, the type checker _never_ infers a so-called generic type (a type that has universally or existentially quantified variables)\
\
One consequence of this is that all top-level definitions must have an explicit type annotation; and all generically typed expressions footnote:[This can happen if function-valued argument to a function is going to be used in different situations within the function then that argument needs to explicitly marked as universal.] must be explicitly quantified.\
\
[NOTE]\
The reason for this is that explicit types provide superior documentation to programs -- especially where the actual type is complex.\
\
For example, the  `dblFilter` function in Program~\\vref\{dblFilter\} applies a `map` function in two different situations -- one for each element of each pair in the input list.\
\
[[dblFilter]]\
.A `double` filter\
[listing]\
dblFilter:all u,v ~~\
     (all t~~(t)=>t, cons[(u,v)])=>cons[(u,v)]\
dblFilter(M,[]) => []\
dblFilter(M,[(A,B),..L]) =>\
      [(M(A),M(B)),..dblFilter(M,L)]\
\
It is important to note that any actual function argument supplied to `dblFilter` will itself have to be generic -- i.e., its type will also be universally quantified.\
\
\
[[existentialType]]\
===}