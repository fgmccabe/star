{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 \
[[recordType]]\
===\
A <<RecordType>> is a type expression that denotes a named association of fields and types. A record type is written as a sequence of type annotations enclosed in braces.\
\
\
[[recordTypeFig]]\
.Record Type\
****\
[[RecordType]]RecordType ::= `\{`<<Annotation>> ; .. ;<<Annotation>> `\}`\
\
[[TypeEquality]]TypeEquality ::= `type` <<Identifier>> `=` <<Type>>\
****\
\
Record types are used as the type of anonymous records (see <<anonRecord>>). They are also the basis of other features of the type language -- including the <<ConstructorType>> and <<Contract>>s.\
\
Two record types are equivalent if their elements are pair-wise equivalent. Note that the _order_ of elements is not important. For example, given the types:\
[listing]\
\{a:string ; b:integer \}\
\
and\
[listing]\
\{b:integer ; a:t \}\
\
these types unify -- assuming that `t` is a bound type variable, provided that `t` is unifiable with `string`.\
\
[NOTE]\
All user-defined types -- i.e., types defined by an <<AlgebraicType>> definition -- have a <<RecordType>> interface associated with them. This, as is detailed in <<algebraicInterface>>, defines a type for all of the fields in any of the constructors for the type. In turn, this permits a <<RecordAccess>> expression to apply to a user-defined type as well as a <<RecordType>>.}