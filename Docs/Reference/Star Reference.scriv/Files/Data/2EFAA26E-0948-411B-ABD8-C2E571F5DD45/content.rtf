{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 \
==== Type Safety\
The type safety of a record access expression is couched in terms of <<AttributeConstraint>>s: i.e., a record access expression implies that a value satisfies the appropriate <<AttributeConstraint>>.\
\
\\begin\{prooftree\}\
\\AxiomC\{\\typeprd\{E\}\{R\}\{T\\ `where`\\ T\\ `implements`\\ `\\\{F has type `T\\sub\{f\}`\\`\}\}\}\
\\UnaryInfC\{\\typeprd\{E\}\{R.F\}\{T\\sub\{f\}\}\}\
\\end\{prooftree\}\
\\begin\{aside\}\
This formulation of the type safety of record access expressions allows for some quite powerful usages. For example, the function:\
[listing]\
getName(R) is R.name\
\
has type:\
[listing]\
getName has type for all r,f such that\
  (r)=>f where r implements \{name has type f\}\
\
In effect, we can define programs that depend on particular attributes without having to be concrete about the actual types of the records being accessed.\
\\end\{aside\}}