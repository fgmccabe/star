{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 \
[[conFun]]\
(((constructor,positional constructor)))\
(((positional constructor)))\
(((type,positional constructor)))\
\
A term constructor expression or pattern is written in the style of a function call. The specification of the term constructor uses _types_ in argument positions to denote the type of the corresponding argument.\
\
[[positionalConFig]]\
.Term Specifier\
****\
[[TermConstructor]]TermConstructor ::= <<Identifier>> `(` <<Type>> ,.., <<Type>> `)`\
****\
\
For example, a type definition for wrapping return values with an error code could have a definition:\
[listing]\
all t ~~ returnType[t] ::= error(string) | ok(t)\
\
A function returning a value of type `returnType` would either return `ok(_value_)` or `error("_message_")`, where the message explained the error.\
\
term constructors are well suited to situations where the number of arguments is limited and fairly obvious.\
\
[NOTE]\
Any type variables that are referred to within a <<TermConstructor>> constructor must either be bound by explicit quantifiers or must appear in the head of the <<AlgebraicType>> definition itself.\
\
\
====}