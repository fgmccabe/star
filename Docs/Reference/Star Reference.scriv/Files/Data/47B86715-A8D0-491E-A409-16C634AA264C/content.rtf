{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 There are several different kinds of type expressions that the Star programmer will encounter:\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::0>
\f0\i\fs26 Type::=TypeExpression\
  | TypeVariable | ReferenceType\
  | TupleType | RecordType\
  | FunctionType | PatternType | ConstructorType\
  | TypeQuantifier \'91
\f1\i0\fs24 <$Scr_Cs::2>
\f2\fs22 ~~\'92
\f1\fs24 <!$Scr_Cs::2>
\f0\i\fs26  Type\
  | TypeConstraint \'91
\f1\i0\fs24 <$Scr_Cs::2>
\f2\fs22 |:\'92
\f1\fs24 <!$Scr_Cs::2>
\f0\i\fs26  Type\
  | 
\f1\i0\fs24 <$Scr_Cs::2>
\f2\fs22 `(`
\f1\fs24 <!$Scr_Cs::2>
\f0\i\fs26  <<Type>> 
\f1\i0\fs24 <$Scr_Cs::2>
\f2\fs22 `)`
\f1\fs24 <!$Scr_Cs::2>
\f0\i\fs26 \
  | EncapsulatedType\
\
TypeQuantifier ::= UniversalQuantifier | ExistentialQuantifier
\i0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\sa160\pardirnatural\qc\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::0><$Scr_Ps::1>
\f0\fs26 Types of Types\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::1>
\f0\fs26 \
There are two main kinds of type expressions -- so-called 
\i structural
\i0  type expressions and 
\i named
\i0  type expression. A structural type expression encodes by convention the permitted 
\i forms
\i0  of values of that type. By contrast, a named type expression is defined via some form of 
\i TypeDefinition
\i0 .\
A classic example of a structural type expression is the function type. A function type expression defines both the types of the arguments and result type of the function. But, more importantly, it signals that the value is a function.\
A good example of a named type is the standard 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 integer
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26  type. The word 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 integer
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26  does not signal by itself that the allowable operations on integer values include arithmetic, comparison and so on. That information must come from additional statements and declarations.\
One of the other differences between structural and named type expressions is that the latter may be used to denote recursive types, whereas the former cannot.\
[TIP] A recursive type is one whose values may contain elements that are themselves of the same type. For example, in a 
\f1\fs24 <$Scr_Cs::2>
\f2\fs22 tree
\f1\fs24 <!$Scr_Cs::2>
\f0\fs26  type: the nodes of the tree are typically themselves trees.}