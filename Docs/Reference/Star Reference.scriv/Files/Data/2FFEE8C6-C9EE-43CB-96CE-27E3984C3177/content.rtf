{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 A contract implementation is a specification of how a contract may be implemented for a specific type combination.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::0>
\f0\i\fs26 Implementation::=`
\f1\i0\fs24 <$Scr_Cs::3>
\f2\fs22 implementation
\f1\fs24 <!$Scr_Cs::3>
\f0\i\fs26 ` ContractSpec [`
\f1\i0\fs24 <$Scr_Cs::3>
\f2\fs22 default
\f1\fs24 <!$Scr_Cs::3>
\f0\i\fs26 `] `=>` Expression\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\sa160\pardirnatural\qc\partightenfactor0

\f1\i0\fs24 \cf0 <!$Scr_Ps::0><$Scr_Ps::1>
\f0\fs26 Contract Implementation Statement\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::1>
\f0\fs26 The 
\i Types
\i0  mentioned in 
\i ContractSpec
\i0  must be either 
\i TypeExpressions
\i0  or, in the case of a 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 default
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  implementation, 
\i TypeVariable
\i0 s.\
[NOTE] In particular, it is not permitted to define an implementation of a contract for 
\i FunctionTypes
\i0 , 
\i PatternTypes
\i0 , nor for 
\i UniversalTypes
\i0  or 
\i ExistentialTypes
\i0 .\
It is permissible, however, to implement 
\i Contracts
\i0  for 
\i TupleTypes
\i0  and 
\i RecordTypes
\i0 .\
The body of a contract implementation must be an expression that gives a definition for each of the elements of the contract specification.\
[NOTE] A contract implementation may either take the form of a regular 
\i AnonymousRecord
\i0  or an anonymous 
\i ThetaRecord
\i0 .\
Usually, the implementation of a contract is fairly straightforward. For example, this gives the implementation of the standard 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 sizeable
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  contract for the 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 cons
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  type:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::2>
\f2\fs22 implementation all e ~~ sizeable[cons[e]] => \{\
  size(nil) => 0.\
  size(cons(_,T)) => size(T)+1.\
  isEmpty(nil) => true.\
  isEmpty(_) default => false\
\}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\sa160\pardirnatural\qc\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::2><$Scr_Ps::1>
\f0\fs26 Implementation of 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 sizeable
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  for 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 cons
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  values
\f1\fs24 <!$Scr_Ps::1>}