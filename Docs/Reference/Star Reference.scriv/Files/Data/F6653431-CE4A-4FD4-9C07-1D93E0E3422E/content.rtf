{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 For certain forms of contract, it may be that the type parameters may not all be independent of each other. For example, consider the standard 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 iterable
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  contract which reads:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::0>
\f2\fs22 contract all coll, el ~~ iterable[coll ->> el] ::= \{\
  iterate: all r ~~\
      (coll,(el,IterState[r])=>IterState[r],IterState[r]) =>\
        IterState[r];\
\}
\f0\fs26 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::0>
\f0\fs26 The intention of the 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 iterable
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  contract is to support processing collections of elements in a sequential manner. The type parameter 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 coll
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  identifies the collection to be iterated over; and the type parameter 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 el
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  identifies the type of each element.\
However, the collection's type uniquely determines the type of each element: the element type is not independent of the collection. For example, to iterate over a 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 cons[t]
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26 , each element will be of type 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 t
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26 ; and to iterate over a 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 string
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  each element will be a 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 integer
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  even though the 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 string
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  type does not mention 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 integer
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26 .\
[NOTE] Each 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 integer
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  represents a unicode code point in the 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 string
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26 .\
Using a 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 ->>
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  clause in a contract -- and in corresponding contract implementation statements -- allows the contract designer to signal this relationship.}