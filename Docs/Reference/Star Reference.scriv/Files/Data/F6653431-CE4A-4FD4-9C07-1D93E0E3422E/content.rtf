{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 \
[[ContractFunctionalDependency]]\
(((type,contracts!functional dependencies)))\
(((functional dependencies in contracts)))\
(((determines@`determines`)))\
\
For certain forms of contract, it may be that the type parameters may not all be independent of each other. For example, consider the standard `iterable` contract (defined in <<iterateContractProg>>) which reads:\
[listing]\
contract all coll, el ~~ iterable[coll ->> el] <~ \{\
  iterate: all r ~~\
      (coll,(el,IterState[r])=>IterState[r],IterState[r]) =>\
        IterState[r];\
\}\
\
The intention of the `iterable` contract is to support processing collections of elements in a sequential manner. The type parameter `coll` identifies the collection to be iterated over; and the type parameter `el` identifies the type of each element.\
\
However, the collection's type uniquely determines the type of each element: the element type is not independent of the collection. For example, to iterate over a `cons[t]`, each element will be of type `t`; and to iterate over a `string` each element will be a `integer` even though the `string` type does not mention `integer`.\
\
[NOTE]\
Each `integer` represents a unicode code point in the `string`.\
\
Using a `\\->>` clause in a `contract` -- and in corresponding contract `implementation` statements -- allows the contract designer to signal this relationship.\
\
===}