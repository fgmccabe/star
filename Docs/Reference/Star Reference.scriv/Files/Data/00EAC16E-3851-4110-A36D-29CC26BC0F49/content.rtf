{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 An 
\i EncapsulatedType
\i0  is a reference to a type that is embedded within a record.\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::0>
\f0\i\fs26 EncapsulatedType::=Expression 
\f1\i0\fs24 <$Scr_Cs::3>
\f2\fs22 .
\f1\fs24 <!$Scr_Cs::3>
\f0\i\fs26  Identifier\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\sa160\pardirnatural\qc\partightenfactor0

\f1\i0\fs24 \cf0 <!$Scr_Ps::0><$Scr_Ps::1>
\f0\fs26 Encapsulated Type\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::1>
\f0\fs26 As noted above, record literals may have types embedded within them. Such a record type is existentially quantified.\
It is possible to access the type embedded within such a record -- albeit with some restrictions:\
The form of an 
\i EncapsulatedType
\i0  reference is limited to terms of the form:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::2>
\f2\fs22 R.t
\f0\fs26 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::2>
\f0\fs26 where 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 R
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  is a 
\i Variable
\i0  whose type interface contains the type 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 t.
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26 \
More generally, an 
\i EncapsulatedType
\i0  reference may involve a sequence of field names where each intermediate field name refers to a sub-record:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::2>
\f2\fs22 R.f1.f2.t
\f0\fs26 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::2>
\f0\fs26 An encapsulated type is strictly opaque: it is assumed to be different to all other types. Which means that effectively 
\i only
\i0  the other fields of the record variable 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 R
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  contain functions and values that can be used in conjunction.\
For example, consider the 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 group
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  type defined in:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::2>
\f2\fs22 group ::= group\{\
  el :: quality[el] |: type\
\
  zero : el\
  op : (el,el)=>el\
  inv : (el)=>el\
\}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\sa160\pardirnatural\qc\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::2><$Scr_Ps::1>
\f0\fs26 The 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 group
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  Type\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::1>
\f0\fs26 \
[TIP] A 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 group
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  literal is analogous to a mathematical group: a set which is closed under a binary operation and whose elements have an inverse.\
The contents of a 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 group
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  literal contain the definitions of the elements, the binary operation, the zero element and the inverse function.\
The qualification of the 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 el
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  type that it supports 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 equality
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  allows convenient access to equality of group elements. Without such a qualification, equality would not be possible for programs using 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 group
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  values.\
An additional requirement for a group is that its operation is associative. Such a property cannot be expressed in terms of type constraints.\
A 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 group
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  literal that implements the group for 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 integers
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  is shown in:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::2>
\f2\fs22 IG = group\{\
  type el = integer.\
  zero = 0.\
  op = (+).\
  inv(X) => -X.\
\}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\sa160\pardirnatural\qc\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::2><$Scr_Ps::1>
\f0\fs26 The 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 integer
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 group
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  Record\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::1>
\f0\fs26 The 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 IG
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  value contains the elements of a group value. We can, for example, access the 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 zero
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  of 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 IG
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  using the statement:\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::2>
\f2\fs22 IZ : IG.el\
IZ = IG.zero
\f0\fs26 \
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::2>
\f0\fs26 This asserts that 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 IZ
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26 's type is whatever the encapsulated type within 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 IG
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  is -- without being explicit about what that type is.\
It is possible to construct functions over 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 groups
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  that refer to encapsulated types. For example, the 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 invertGroup
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  function below constructs a new group by inverting the operation.\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::2>
\f2\fs22 invertGroup(G) => group\{\
  type el = G.el.\
  zero = G.zero.\
  op(X,Y) => G.op(G.inv(X),G.inv(Y)).\
  inv(X) => G.inv(X).\
\}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl264\slmult1\sa160\pardirnatural\qc\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::2><$Scr_Ps::1>
\f0\fs26 A 
\f1\fs24 <$Scr_Cs::3>
\f2\fs22 group
\f1\fs24 <!$Scr_Cs::3>
\f0\fs26  Inverting Function
\f1\fs24 <!$Scr_Ps::1>}