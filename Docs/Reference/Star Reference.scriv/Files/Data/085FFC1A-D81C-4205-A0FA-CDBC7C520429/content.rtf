{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 %!TEX root = reference.tex\
= Concurrent Execution\
[[concurrent]]\
(((concurrent execution)))\
(((execution,parallel)))\
\
Concurrent and parallel execution of Star programs involves two inter-related concepts: the `task` and the `rendezvous`. A `task` is a form of <<ComputationExpression>> with support for parallel and asynchronous execution.  A `rendezvous` represents a `meeting place' between two or more independent activities. In particular, messages may be exchanged between `task`s at a `rendezvous`.\
\
The concurrency concepts and features are inspired by similar features found in Concurrent ML \\cite\{reppy:99\}; which, in turn, have similar underpinnings as Hoare's Concurrent Sequential Processes \\cite\{hoare:85\}.\
\
== Accessing Concurrency Features\
\
\\begin\{aside\}\
In order to access the concurrency features described in this chapter it is required to `import` the `concurrency` package:\
[listing]\
import concurrency;\
\
\\end\{aside\}\
\
== Tasks\
[[tasks]]\
The foundation for concurrency is the <<TaskExpression>>. A `task` is a <<ComputationExpression>> that denotes a computation that may be performed in parallel with other computations.\
\
=== Task Expressions\
[[taskExpressions]]\
\
A `task` expression consists of a `task`-labeled <<ActionBlock>>.\
\
\\begin\{figure\}[htbp]\
\\begin\{eqnarray*\}\
_Expression_&\\arrowplus&<<TaskExpression>>\\\\\
[[TaskExpression]]TaskExpression::=`task`\\ `\\\{`\\ <<Action>>\\sequence\{;\}<<Action>>`\\`\}\
\\end\{eqnarray*\}\
.Task Expression\
[[taskExpressionFig]]\
\\end\{figure\}\
\
<<TaskExpression>>s denote computations that are expected to be performed asynchronously or in parallel.\
\
A `task` is `created' with the `task` notation:\
[listing]\
def T is task\\\{ logMsg(info,"This is a task action") \\\}\
\
\\begin\{aside\}\
Apart from `background` tasks (see <<backgroundTask>>), a <<TaskExpression>> is not `started' until it is `perform`ed or `valof` is applied.\
\\end\{aside\}\
In order to start the task, the task must be `perform`ed:\
[listing]\
perform T\
\
This is the same as for all <<ComputationExpression>>s.\
\
<<TaskExpression>>s may have values; and may be composed and constructed like other expressions. For example, the function:\
[listing]\
tt(X) is task\\\{\
  def Y is 2;\
  valis X+Y;\
\\\}\
\
represents a rather elaborate way of adding 2 to a number. As with `T` above, the expression:\
[listing]\
def I is tt(3)\
\
is not an `integer` but an `integer`-valued <<TaskExpression>>. The value returned may be extracted using `valof`:\
[listing]\
def Five is valof I\
\
As with all <<ComputationExpression>>s, if there is a possibility that the <<TaskExpression>> will fail, then the `on abort` variant of `valof` should be used:\
[listing]\
Fdef ive is valof I\
  on abort \\\{ E do \\\{\
    logMsg(info,"Was not expecting this");\
    valis nonInteger\
  \\\}\
\\\}\
\
\
=== The `task` type\
[[taskType]]\
The `task` type is a standard type that is used to represent <<TaskExpression>>s. It also represents the `concurrency Monad'.\
\
[listing]\
task has kind type of type\
\
\
\\begin\{aside\}\
Although the `task` type is implemented as a normal type, it's definition is hidden as its internals are not relevant to the programmer. Hence, it is declared using the <<HasKind>> statement rather than with a <<AlgebraicType>> definition.\
\\end\{aside\}\
\
== Task-related Functions\
[[taskFunctions]]\
(((task functions)))\
\
=== Background Task\
[[backgroundTask]]\
The `background` function takes a `task` and performs it in the background (i.e., in parallel with the invoking call). The value of the `background` task is the same as the value of the backgrounded task.\
[listing]\
background has type for all t such that (task of t)=>task of t\
\
\\begin\{aside\}\
`background` is a standard prefix operator; defined as:\
[listing]\
\\#prefix((background),900);\
\
hence a call to `background` may be written without parentheses.\
\\end\{aside\}\
\
== Rendezvous\
[[rendezvous]]\
\
A rendezvous is a coordination point between two or more independent tasks. Typically, these represent message communication but can involve time-outs, i/o operations and so on.\
\
=== The `rendezvous` Type\
[[rendezvousType]]\
The `rendezvous` type is a standard type that denotes a rendezvous.\
[listing]\
rendezvous has kind type of type;\
\
\\begin\{aside\}\
It is an opaque type -- i.e., its existence is public, but its definition is not.\
\\end\{aside\}\
\
=== Waiting for a Rendezvous\
[[waitfor]]\
The `wait for` function is used to wait at a rendezvous until the rendezvous `occurs'.\
\
[listing]\
wait for has type for all t such that (rendezvous of t)=>task of t\
\
\
\\begin\{aside\}\
The `wait for` function name is also a multi-word prefix operator defined:\
[listing]\
\\#prefix("wait for",999);\
\
\\end\{aside\}\
\
Waiting for a `rendezvous` is the central mechanism that multiple `task`s may use to coordinate their activities.\
\
The result of waiting for a `rendezvous` is also a `task`. This means, for example, that there can be a distinction between a `coordination point' between `task`s and the computation enabled by that coordination.\
\
=== The `alwaysRv` Rendezvous Function\
[[alwaysRendezvous]]\
(((rendezvous,alwaysRv@`alwaysRv`)))\
\
The `alwaysRv` returns a `rendezvous` that is always `ready'. It has a single argument which is returned -- wrapped as a `task` -- by `wait for`.\
\
[listing]\
alwaysRv has type for all t such that (t)=>rendezvous of t\
\
\
In effect, the `alwaysRv` rendezvous obeys the law:\
\\begin\{equation*\}\
`wait for alwaysRv(X)`\\ \\equiv\\ `task\\\{ valis X\\`\}\
\\end\{equation*\}\
\
=== The `neverRv` Rendezvous\
[[neverRendezvous]]\
(((rendezvous,never@`never`)))\
\
The `neverRv` `rendezvous` is _never_ `ready'.\
\
[listing]\
neverRv has type for all t such that rendezvous of t\
\
\
\\begin\{aside\}\
Waiting for a `neverRv` rendezvous is rarely useful by itself; but is especially useful when combined with `guardRv`.\
\\end\{aside\}\
\
=== The `chooseRv` Rendezvous Function\
[[chooseRvFun]]\
(((rendezvous,choose@`choose`)))\
(((multiple rendezvous)))\
(((selecting from many rendezvous)))\
\
The `chooseRv` rendezvous function is used to combine a collection of rendezvous into a single non-deterministic disjunction. Waiting for a `chooseRv` rendezvous is successful if one of its `arms' is successful.\
\
[listing]\
chooseRv has type for all s,t such that (s)=>rendezvous of t\
                  where sequence over s determines rendezvous of t\
\
\
The argument to `chooseRv` is a `sequence` of `rendezvous` values -- any of which may activate in order to activate the `chooseRv`.\
\
The `chooseRv` rendezvous combinator is important because it allows a one-of selection from multiple alternatives.\
\
\\begin\{aside\}\
Waiting on a `chooseRv` rendezvous is successful when one of the `rendezvous` in its argument collection becomes available -- i.e., a call of `wait for` on the `chooseRv` collection completes when `wait for` would complete on one of the elements of that collection.\
\
If more than one element `rendezvous` is ready then one of them will be selected non-deterministically.\
\\end\{aside\}\
\
\\begin\{aside\}\
The `chooseRv` `rendezvous` is analogous to the Unix-style `select` function; except that rather than being limited to waiting for an I/O descriptor to be ready, the `chooseRv` rendezvous allows many different forms of rendezvous to be selected from.\
\\end\{aside\}\
\
For example, the rendezvous expression:\
[listing]\
chooseRv(list of [sendRv(Ch,"M"), timeoutRv(10)])\
\
can be used to represent a combination of trying to send a message on the `Ch` channel -- see <<sendRvFun>> -- or if no one received the message within 10 milliseconds then giving up on the send.\
\
=== The `guardRv` Rendezvous\
[[guardRvFun]]\
(((rendezvous,guardRv@`guardRv`)))\
(((guarded rendezvous)))\
\
A `guardRv` function is used to dynamically compute a `rendezvous`. Applied just before a rendezvous is waited on, the `quardRv` allows the precise rendezvous to be computed dynamically.\
\
[listing]\
guardRv has type for all t such that\
                 (task of rendezvous of t) => rendezvous of t\
\
\
The argument to `guardRv` is a `task`; the `valof` of which is the actual `rendezvous`. Guards are evaluated -- `valof`'ed -- immediately prior to actually waiting for the `rendezvous`.\
\
A classic use of `guardRv` is to enable a semantic condition to be satisfied before enabling a particular `rendezvous`. For example, if it `did not make sense' to accept a message on a channel unless a particular `queue` was non-empty could be represented with:\
[listing]\
var Q := queue of [];\
...\
testQ() is task\\\{\
  if empty(Q) then\
    valis neverRv\
  else\
    valis recvRv(Ch)\
\\\}\
...\
wait for guardRv(testQ())\
\
\
=== The `wrapRv` Rendezvous Function\
[[wrapRvFun]]\
(((wrap rendezvous)))\
(((rendezvous,wrap)))\
\
A `wrapRv` can be used to `convert' a `rendezvous` of one type to another form. This is often used to enable one `rendezvous` to `count as' another `rendezvous`.\
\
[listing]\
wrapRv has type for all a,b such that\
                (rendezvous of a, (a) => task of b) => rendezvous of b\
\
\
The first argument of `wrapRv` is the `rendezvous` that is actually waited on. The second argument is a function that takes the result of that `rendezvous` and returns a new `task` using that return value.\
\
One use for the `wrapRv` function is to perform another `rendezvous` wait. For example:\
[listing]\
requestReply(SCh,RCh,Msg) is guardRv(sendRv(Ch,Msg),\
                                (_) => wait for recvRv(RCh))\
\
will send a `Msg` on the `send channel' `SCh`; and once that message was successfully sent will wait for a reply on the `RCh` channel.\
\
`requestRepl` is a `rendezvous`-valued function; and so can be used in conjunction with other `rendezvous` expressions. For example, to send a message to two other `task`s but only wait for one result we might use:\
[listing]\
def R is valof wait for chooseRv\\\{\
  requestReply(S1,RCh);\
  requestReply(S2,RCh)\
  \\\}\
\
\
=== The `withNackRv` Rendezvous\
[[nackRvFun]]\
The `withNackRv` function can be used to discover if another rendezvous _was not_ triggered.\
[listing]\
withNackRv has type for all t such that\
                    ((rendezvous of ())=>rendezvous of t)=>rendezvous of t\
\
\
The argument to `withNackRv` is a function which is invoked during synchronization -- analogously to the `guardRv` function -- to construct the `rendezvous` to be monitored. If that `rendezvous` is _not_ selected -- in a call to `wait for` -- then a special _abort_ rendezvous _is_ selected. That abort rendezvous is the one that is passed in to the argument function.\
\
For example, in the expression:\
[listing]\
withNackRv(F)\
\
`F` should be a function that takes a `rendezvous` and returns a `rendezvous`:\
[listing]\
F(A) is recvRv(Ch)\
\
The type of `A` is `rendezvous of ()`.\
\
Waiting on `withNackRv(F)` is similar to a `wait for` the `rendezvous`\
[listing]\
recvRv(Ch)\
\
\
If this `rendezvous` is selected then nothing further happens.\
\
However, if this `rendezvous` were in a `chooseRv` and a different `rendezvous` were selected then `A` becomes 'available'. In effect, `A` being active means that the `recvRv` was not activated.\
\
A slightly more complex example should illustrate this:\
[listing]\
showMsg(Ch) is let\\\{\
  F(A) is valof\\\{\
    ignore background task \\\{\
      ignore wait for A; -- will block unless recvRv not active\
      logMsg(info,"Did not receive message");\
    \\\}\
    valis recvRv(Ch)\
  \\\}\
\\\} in withNackRv(F)\
\
If we used this to `wait for` a message; perhaps with a `timeoutRv`:\
[listing]\
wait for chooseRv(list of [\
  showMsg(Chnl),\
  timeoutRv(1000)\
])\
\
then, if a timeout occurred the message\
[listing]\
Did not receive message\
\
would appear in the log.\
\
=== The `timeoutRv` Rendezvous\
[[timeoutRvFun]]\
(((rendezvous,timeout)))\
\
The `timeoutRv` function returns a `rendezvous` that will be available a certain number of milliseconds after the start of the `wait for`.\
[listing]\
timeoutRv has type (long)=>rendezvous of ()\
\
The timeout interval starts at some point after the `wait for` function has been entered; and it is guaranteed to be `available' some time _after_ the required number of milliseconds.\
\\begin\{aside\}\
It is not possible to guarantee a precise timeout interval -- in the sense of some computation proceeding at exactly the right moment.\
\
Thus, any time-sensitive computation triggered by `timeoutRv` should takes its own measurement of the `current' time when it is activated.\
\\end\{aside\}\
\
\\noindent\
The `timeoutRv` is most often used in conjunction with other `rendezvous` functions;  typically a message receive or message send `rendezvous`.\
\
For example, the expression:\
[listing]\
wait for chooseRv(list of [\
  sendRv(Ch,"Hello"),\
  timeoutRv(100)\
]\
\
represents an attempt to send the `"Hello"` message on the `Ch` channel; but the message send will be abandoned shortly after 100 milliseconds have elapsed.\
\
=== The `atDateRv` Rendezvous Function\
[[atDateRvFun]]\
(((rendezvous,timeout)))\
The `atDateRv` is similar to the `timeoutRv` rendezvous; except that instead of a fixed interval of milliseconds the timeout is expressed as a particular `date` value.\
[listing]\
atDateRv has type (date)=>rendezvous of ()\
\
The `atDateRv` will be triggered some time after the specified date.\
\
== Channels and Messages\
[[channels]]\
\
A channel is a typed communications channel between `task`s. In order for a `task` to `send a message' to another `task`, they would share the channel object itself and then the receiver would use `recvRv` to wait for the message and the sender would use `sendRv` to send the message.\
\
=== The `channel` Type\
[[channelType]]\
\
[listing]\
channel has kind type of type;\
\
\
Like the `rendezvous` and `task` types, the `channel` type is _opaque_.\
\
=== The `channel` Function\
[[channelFun]]\
\
The `channel` function is used to create channels.\
[listing]\
channel has type for all t such that ()=>channel of t\
\
Each created channel may be used for sending and receiving multiple messages. However, the channel is typed; i.e., only messages of that type may be communicated.\
\
Channels are multi-writer multi-reader channels: any number of tasks may be reading and writing to a channel. However, any given communication is between two tasks: one sender and one receiver.\
\
If more than one `task` is trying to send a message then it is non-deterministic which message is sent. If more than one `task` is trying to receive a message then only one will get the message.\
\
Message receives and sends may take place in either order. However, message communication is _synchronous_. I.e., both sender and receiver are blocked until a communication occurs.\
\
An immediate implication of synchronous communication is that there is no buffer of messages associated with `channel`s.\
\
=== Receive Message Rendezvous\
[[recvRvFun]]\
The `recvRv` function takes a `channel` and returns a `rendezvous` that represents a wait for a message on the `channel`.\
\
[listing]\
recvRv has type for all t such that (channel of t)=>rendezvous of t\
\
\
To actually receive a message on a channel, first the `rendezvous` must be created, then it must be `waited for', and then the message itself is extracted from the resulting `task`:\
[listing]\
Data is valof wait for recvRv(_Channel_)\
\
\
As noted in <<channelFun>>, if more than one `task` is actively waiting for a message on the same channel then it is non-deterministic which `task` will `get' the first message. All other `task`s will continue to be blocked until a subsequent message is sent.\
\
=== Send Message Rendezvous\
[[sendRvFun]]\
The `sendRv` function is used to send messages on `channel`s.\
\
[listing]\
sendRv has type for all t such that (channel of t,t)=>rendezvous of ()\
\
\
The result of a `sendRv` function is a `rendezvous`. Waiting on this `rendezvous` amounts to the attempt to send the message on the `channel`.\
\
\\begin\{aside\}\
Note that the type of `rendezvous` returned by `sendRv` is\
[listing]\
rendezvous of ()\
\
I.e., there is no `value' associated with a successful send message.\
\\end\{aside\}\
}