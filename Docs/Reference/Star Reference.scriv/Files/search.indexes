<?xml version="1.0" encoding="UTF-8"?>
<SearchIndexes Version="1.0">
    <Documents>
        <Document ID="B3D4155C-1624-4108-BD76-FE377085CF5C">
            <Title>Expressions-44</Title>
            <Text>
=== Type Annotation Expression
[[typeAnnotationExpression]]
A &lt;&lt;TypeAnnotationExpression&gt;&gt; is an expression that is annotated with a &lt;&lt;Type&gt;&gt;. The annotation amounts to an assertion that the &lt;&lt;Type&gt;&gt; of the expression is as annotated.

\begin{figure}[htbp]
\begin{eqnarray*}
[[TypeAnnotationExpression]]TypeAnnotationExpression::=`(`&lt;&lt;Expression&gt;&gt;\ `has type`\ &lt;&lt;Type&gt;&gt;`)`
\end{eqnarray*}
.Type Annotation Expression
[[typeAnnotatedExpressionFig]]
\end{figure}

\begin{aside}
The &lt;&lt;TypeAnnotationExpression&gt;&gt; should not be confused with _type casting_ as is found in some languages. The &lt;&lt;TypeAnnotationExpression&gt;&gt; is a way for the programmer to communicate exactly what the expected type of an expression is; analogously to the &lt;&lt;TypeAnnotation&gt;&gt;s found in &lt;&lt;thetaEnvironment&gt;&gt;s.
\end{aside}</Text>
        </Document>
        <Document ID="A0FE53BF-8BE7-46C5-964F-A3600C3773A3">
            <Title>Function Type</Title>
            <Text>A function type denotes a function value. It takes the form of a possibly empty sequence of argument types -- denoting the types of the arguments to the function -- enclosed in parentheses; followed by the result type of the function. 
FunctionType ::= TupleType =&gt; Type
Function Type
For example, a function of two arguments -- an integer and a string that returns a list of strings has a type that takes the form:
(integer,string) =&gt; cons[string]
</Text>
        </Document>
        <Document ID="B1E2FD7F-BC75-468F-BA20-669980379B3F">
            <Title>Type Alias</Title>
            <Text>A type alias is a statement that introduces a new type name by mapping it to an existing type expression.
TypeAlias::= TypeSpec &lt;~ Type
Type Alias Definition Statement
[NOTE] Type aliases may be parameterized -- in the sense that the type being defined may be parameterized and that the definiens may also be parameterized.
Note that the any type variables on the right hand side of a TypeAlias statement must also have been mentioned on the left hand side.
For example, the statement:
time &lt;~ integer
declares a new type that is an alias for time -- i.e., that it is actually equivalent to the integer type.
[TIP] Type aliases allow the programmer to signal that a particular type is being used in a special way. In addition, during program development, type aliases are useful to provide markers for types that will be elaborated further with a regular algebraic definition.
Type aliases have no run-time presence. In fact, they may be viewed as a simple form of type macro -- type expressions that match the left hand side are replaced by the type expression on the right hand side. However, type aliases have some definite constraints: a type alias may not be, directly or indirectly, recursive.
</Text>
        </Document>
        <Document ID="24E459F1-0706-476B-BFF6-708939094B0A">
            <Title>Grammar Rules</Title>
            <Text>%!TEX root = reference.tex
= Parsing Text
[[parsing]]

String processing is one of the most important functions in many applications. In addition to the use of regular expressions for basic string processing, there is also support for more powerful string processing in the form of a built-in grammar notation.
(((parsing text)))
(((text parsing)))
(((string,parsing)))
(((grammar notation)))

Program~\vref{exprGrammar} shows a simple example of a grammar that can be used to parse and evaluate simple arithmetic expressions. This example shows how grammar rules not only capture the syntax of expressions, and the _lexical structure_ of elements of expressions but also how a grammar can _extract values_ as a result of parsing a string.

== Grammar Rules
[[grammarRules]]
(((grammar rules)))
(((rules,grammar)))

A &lt;&lt;GrammarRule&gt;&gt; is a rule that may be used in parsing text. The syntax for grammar rules is defined in &lt;&lt;grammarRuleFig&gt;&gt;.

\begin{figure}[htbp]
\begin{eqnarray*}
_Statement_&amp;\arrowplus&amp;&lt;&lt;Grammar&gt;&gt;\\
[[Grammar]]Grammar::=&lt;&lt;GrammarRule&gt;&gt;\sequence{;}&lt;&lt;GrammarRule&gt;&gt;\\
[[GrammarRule]GrammarRule::=&lt;&lt;GrammarRuleHead&gt;&gt;\ [from\ &lt;&lt;GrammarBody&gt;&gt;]]\\
[[GrammarRuleHead]GrammarRuleHead::=&lt;&lt;Identifier&gt;&gt;[`(`&lt;&lt;Identifier&gt;&gt;\sequence{,}&lt;&lt;Identifier&gt;&gt;`)`]]\ \gapp\ &lt;&lt;Expression&gt;&gt;\\
[[GrammarBody]]GrammarBody::=&lt;&lt;RegularExpression&gt;&gt;\\
  | `\{`\ &lt;&lt;Condition&gt;&gt;`\`}\\
  | &lt;&lt;NonTerminal&gt;&gt;\\
  | &lt;&lt;GrammarBody&gt;&gt;\sequence{,}&lt;&lt;GrammarBody&gt;&gt;\\
  | &lt;&lt;NonTerminal&gt;&gt; `*`[&lt;&lt;RegularExpression&gt;&gt;]\\
  | &lt;&lt;NonTerminal&gt;&gt; `+`[&lt;&lt;RegularExpression&gt;&gt;]\\
  | `(` &lt;&lt;GrammarBody&gt;&gt; `)`\\
[[NonTerminal]NonTerminal::=&lt;&lt;Identifier&gt;&gt;[`(`&lt;&lt;Expression&gt;&gt;\sequence{,}&lt;&lt;Expression&gt;&gt;`)`]]\ \gapp\ &lt;&lt;Pattern&gt;&gt;
\end{eqnarray*}
.Grammar Rules
[[grammarRuleFig]]
\end{figure}

The grammar notation addresses several of the issues involved in parsing text: identifying the `tokens' in the text, identifying the syntactic structures in the text and extracting semantic values from the parse.

=== Grammar Type
[[grammarType]]
(((type,grammar)))
(((grammar type)))

A grammar is just a particular form of &lt;&lt;PatternAbstraction&gt;&gt;, following the same type form:
[listing]
(T\sub1,...,T\subn) &lt;= T

where `T\subi` and T are all types.

The arguments to a non-terminal allow the grammar to be _context sensitive_; the arguments to the non-terminal may be used -- in conjunction with values generated as a result of parsing -- to help instantiate grammar conditions.
\end{quote}

\begin{program}
[listing]
expr(L+R) from factor(L), `\bsl{}+`, factor(R);
expr(L-R) from factor(L), `-`, factor(R);
expr(E) from factor(E);

factor(L*R) from term(L), `\bsl{}*`, term(R;
factor(L/R) from term(L), `/`, term(R;
factor(F) from term(T);

term(atoi(N)) from `([0-9]+:N)`;
term(T) from `\bsl{}(`, expr(T), `\bsl{})`;

.A Simple Expression Evaluator Grammar[[exprGrammar]]
\end{program}

=== Tokens
Tokens in a grammar refer to individual sequences of characters. The foundation of tokens in grammar rules are the same regular expressions as used in `string` patterns (see &lt;&lt;regularExpressions&gt;&gt;).

If a value is associated with a token type -- such as the name of a identifier token -- the value may be extracted using the `:` operator (see &lt;&lt;variableRegexp&gt;&gt;). For example, a grammar rule such as:
[listing]
iden(Id from `([a-zA-Z]\bsl{}w*:Id)`;

`produces' an identifier using the regular expression variable extraction feature.

== Parsing Text
[[parsingText]]
The `\gapp` &lt;&lt;Expression&gt;&gt; is used to invoke a grammar on a string and return the result of that parse. &lt;&lt;parseExpFig&gt;&gt; gives the syntax for parse expressions.

\begin{figure}[htbp]
\begin{eqnarray*}
_Expression_&amp;\arrowplus&amp;&lt;&lt;ParseExpression&gt;&gt;\\
[[ParseExpression]]ParseExpression::=&lt;&lt;Expression&gt;&gt;\ \gapp\ &lt;&lt;NonTerminal&gt;&gt;
\end{eqnarray*}
.Parse Expression
[[parseExpFig]]
\end{figure}

An expression of the form:
[listing]
"3+4*5"(expr

denotes a `request' to parse the string `"3+4*5"` with the grammar identified by `expr`. The value of the expression is the value extracted by the grammar; in this case the result should be 23.

==== Type Safety
A &lt;&lt;ParseExpression&gt;&gt; is type safe if the identified non-terminal is appropriate for the circumstances:
\begin{prooftree}
\AxiomC{\typeprd{E}{`g`}{`(`t\sub1,...,t\subn`)\gapp`t}}
\AxiomC{\typeprd{E}{a\sub1}{t\sub1}\sequence{\quad}\typeprd{E}{a\subn}{t\subn}}
\AxiomC{\typeprd{E}{`s`}{`string`}}
\TrinaryInfC{\typeprd{E}{`s(g(`a\sub1\sequence{`,`}a\subn`)`}{t}}
\end{prooftree}


\begin{program}
[listing]
type abstract is id(string)
  or int(integer)
  or str(string)
  or seq(list[abstract])
  or app(abstract,abstract)
  or sq(abstract,abstract)
  or br(abstract,abstract);

term(P) is pattern(T) from left(P)((L,LP), right(P,L,LP)(T);

left(P)((app(Op,seq([L])),PP) from prefix((Op,PP,RP), \{PP=&lt;P\},
       term(R)(L;
left(_)((L,0) from term0(L;

right(P,L,LP)(T from
       infix((Op,LLP,IP,RP), \{ LLP&gt;=LP and IP=&lt;P \},
       term(RP)(R,
       right(RP,app(Op,seq([L,R])),IP)(T;
right(P,L,LP)(T from
       postfix((Op,LLP,PP), \{ LLP&gt;=LP and PP=&lt;P \},
       right(P,app(Op,seq([L])),PP);
right(P,T,_)(T;

term0(app(Op,seq(A)) from primitive(Op,
       `(`, term(1000)(A * `,`, `)`;
term0(sq(Op,A) from primitive(Op, `[`, term(1000)(A, `]`;
term0(br(Op,A) from primitive(Op, `\{`, term(1000)(A, `\}`;
term0(T from primitive(T;

primitive(id(Id) from iden(Id, \{not Id in Opers\};
primitive(int(I as integer) from `[0-9]+:I`;
primitive(str(S) from `"([^"]*:S)"`;

iden(Nm from `([a-zA-Z_][a-zA-Z_0-9]*:Nm)`;

infix((Op,Lp,Pp,Rp) from iden(Op, \{(Op,Lp,Pp,Rp) in infixOps \};

infixOps is \{ (";",1999,2000,2000); ...; (".",249,250,249); \};

\vspace{-2ex}
.Operator Precedence Grammar[[srOpPrecGrammar]]
\end{program}
</Text>
        </Document>
        <Document ID="3B425F17-6AEB-4983-8C67-5167CFE5B4E9">
            <Title>Dedication</Title>
            <Text>










Insert dedication here.</Text>
            <Notes>Feel free to delete this document if you don’t need it.</Notes>
        </Document>
        <Document ID="82BBE02E-A6D5-44B4-AD6E-0FCA32529815">
            <Title>Simple Types</Title>
            <Text>A simple type is TypeExpression with no type arguments. Some simple types are pre-defined, this gives a table of such types:
Type
Description
boolean
used for logical values and conditions
integer
type of integer values
float
type of floating point numbers
string
type of string values
quoted
type of abstract syntax
Standard Pre-defined Types
</Text>
        </Document>
        <Document ID="A55F9F4C-12C9-4526-A25A-A9B4B38B406E">
            <Title>Type Variable Kind</Title>
            <Text>
Type variables are associated with a Kind -- which constrains the kinds (sic) of types that the type variables may be bound to. For example, a Kind of type implies that the type variable may be bound to any valid type -- but may not be bound to a TypeConstructor.
[NOTE] The different kinds of type variable may not be mixed: it is not permissible to bind a type variable to a TypeConstructor, and vice versa.
The Kind of a type variable is given by its quantifier declaration.
For example, given:
all t ~~ cons[t] ::= nil | cons(t, cons[t]).
The type variable t may be bound to a type expression such as cons[string] but not to a higher-kinded type (such as cons itself).
On the other hand, the type variable c in
contract all c/1 mappable[c] ::= {
  fmap:all e,f ~~ ((e)=&gt;f,c[e])=&gt;c[f]
}
is a higher-kinded type variable: it can be bound to a unary TypeConstructor — such as cons — but  it may not be bound to a regular type or to any non-unary TypeConstructor.</Text>
        </Document>
        <Document ID="F64041CB-6F63-49E1-906B-4577DAA4ABA4">
            <Title>Contract Definition</Title>
            <Text>A contract definition is a statement that defines the functions and action procedures associated with a contract. As can be seen below, a contract statement associates a contract name -- together with a set of type variables -- with a set of TypeAnnotations that define the elements of the contract. Within the Contract statement, a TypeAnnotation may refer to the type(s) in the contract head.
Contract ::= `contract` ContractSpec `::=` RecordType
ContractSpec ::= [ TypeQuantifier ] Identifier [ TypeArgSpec [`-&gt;&gt;` TypeArgSpec ]]
Contract Statement
For example, the contract that underlies type coercion is:
contract all s,t ~~ coercion[s,t] ::= {
  coerce:(s)=&gt;t
}
A contract statement may also include defaults for the names defined in the contract. If a given contract implementation does not give an implementation for a name that has a default associated for it, then the default is used.
[NOTE] Default specifications may use variables that are in scope at the point of the contract specification.
[TIP] An important usage pattern for contracts is to represent abstract types. An abstract type is one defined by its contract rather than one defined by an explicit type definition.
For example, the arith contract defines a set of arithmetic functions. However, it can also be interpreted as a definition of an abstract type of arithmetic values -- the values that implement the arith contract.</Text>
            <Comments>This is generally not the same scope as where a contract implementation is given.</Comments>
        </Document>
        <Document ID="79B9338D-9884-4981-800B-0DAE87A1C3A7">
            <Title>Character Reference</Title>
            <Text>A CharRef is a denotation of a single character; which is either a ‘regular’ character or an escape sequence.
CharRef ::= Char | Escape
Escape::=\b|\d|\e|\f|\n|\r|\t|\v |\ Char | \u Hex ... Hex;
Character Reference
For most characters, the character reference for that character is the character itself. For example, the string "T" contains the character T. However, certain standard characters are normally referenced by escape sequences consisting of a backslash character followed by other characters; for example, the new-line character is typically written \n. The standard escapes references are shown below:
Escape
Meaning
\b
Backspace
\d
Delete
\e
Escape
\f
Form Feed
\n
New Line
\r
Carriage Return
\t
Horizontal Tab
\v
Vertical Tab
\u Hex … Hex ;
Code Point
\ Char
A Char itself
Character Escapes
Apart from the standard character references, there is a hex encoding for directly encoding unicode characters that may not be available on a given keyboard:
\u34ff;
This notation accommodates the Unicode's varying width of character codes -- from 8 bits through to 20 bits.</Text>
        </Document>
        <Document ID="A097A466-32FF-491F-8E6B-6DCD12185DE1">
            <Title>Foreword</Title>
        </Document>
        <Document ID="3473F9DE-8DAE-4FBC-8AC5-90E91204D208">
            <Title>Postifx Operator</Title>
            <Text>A statement of the form:
#postfix(‘psOp’,730).
defines the operator psOp to be a postfix operator, with priority 730.</Text>
        </Document>
        <Document ID="96776348-B035-46DA-A5A5-210E99B93774">
            <Title>Front Matter</Title>
            <Notes>Note that in the “Metadata” pane of the Inspector, under “Section Type”, the “Default Subdocument Type” is set to “Front Matter”. This setting causes all subdocuments of this folder to use the “Front Matter” section type by default (that is, when “Structure-Based” is selected as the section type).

This saves us from having to manually assign the “Front Matter” section type for each document we place into this folder.

During Compile, documents assigned the “Front Matter” section type will be laid out differently from documents in the main body of the manuscript.</Notes>
        </Document>
        <Document ID="60D37027-5A0F-4CA1-BA8F-0F527FC7BB6D">
            <Title>Contents</Title>
        </Document>
        <Document ID="68588047-46A1-47CB-92B5-62B66057AE27">
            <Title>Expressions-30</Title>
            <Text>
==== Type Safety
[[functionApplyType]]
(((type,function application)))
The primary type safety rule for function application is that the types of the arguments of the application match the argument types of the function. The type of the resulting expression is the return type associated with the function.

\begin{prooftree}
\AxiomC{\typeprd{E}{`F`}{`(`t\sub1\sequence{,}t\subn`)=&gt;`t}}
\AxiomC{\typeprd{E}{`e\sub1`}{t\sub1}\sequence{\ }\typeprd{E}{`e\subn`}{t\subn}}
\BinaryInfC{\typeprd{E}{`F(e\sub1`\sequence{,}`e\subn)`}{t}}
\end{prooftree}</Text>
        </Document>
        <Document ID="30096F7F-91FE-4A55-BBAC-DBD62E601765">
            <Title>Syntax Rules</Title>
            <Text>Throughout this document we introduce many syntactic features of the language. We use a variant of traditional BNF grammars to do this. The meta-grammar can be described using itself; as shown below.
</Text>
        </Document>
        <Document ID="37C808A0-B652-4ADA-B055-8396DF813766">
            <Title>Sequences</Title>
            <Text>%!TEX root = reference.tex
= Sequences and Collections
[[lists]]
[[listExpressions]]
(((list expression)))
(((expressions,list)))
There are many primary contracts that together relate to collections and sequences:
\begin{description}
`concatenate`:: defines what it means to concatenate two collections.
`explosion`:: defines the twin functions of explode and implode. Typically used to inspect and pack scalar entities.
`foldable`:: is a contract that defines the classic `fold' functions of leftFold, rightFold, leftFold1 and rightFold1.
`indexable` and `sliceable`:: are functions that define random access within a collection.
`iterable` and `indexed\_iterable`:: define processing a collection with a client function -- used for iterations and queries.
`reversible`:: defines the `reverse` function.
`sequence`:: is a core set of patterns and functions that defines what it means to process and/or build a collection sequentially.
`sets`:: define the set-oriented functions of intersection, union and complement.
`sizeable`:: is a pair of functions that define the size of a collection and whether the collection is empty or not.
`sorting`:: defines the sort function.
`updateable`:: is a set of functions that define the updating of collections by adding to a collection, merging collections, updating based on patterns and so on.
\end{description}
Many of these contracts are associated with special syntactic forms.
\begin{aside}
The term `collection' is used informally here. Not all types need implement all the contracts defined here. However, for a type to be considered a collection, it should implement all four contracts.
\end{aside}

In addition to the standard collection contracts, there are several standard types,  `list` and `cons` that represent basic forms of sequence.


== Sequence Notation
[[sequenceNotation]]
The `sequence` contract has additional syntactic support in the form of specific sequence notation for expressions (see &lt;&lt;sequenceExpression&gt;&gt;) and patterns (see &lt;&lt;sequencePattern&gt;&gt;).

An expression of the form:
[listing][escapechar=|]
[E|\sub1\sequence{,}|E|\subn|]

is equivalent to the expression:
[listing][escapechar=|]
_cons(E|\sub1|,|\sequence{}|_cons(E|\subn|,_nil())|\sequence{}|)

Similarly, the pattern:
[listing][escapechar=|]
[P|\sub1\sequence{,}|P|\subn|]
is equivalent to the expanded pattern:
[listing][escapechar=|]
_pair(P|\sub1,\sequence{}|_pair(P|\subn|,_empty())|\sequence{}|)

This notation makes literals involving the `sequence` contract easier to write.

=== The `sequence` Contract
[[sequenceContract]]
(((sequence contract@`sequence` contract)))
The `sequence` contract defines the equivalent of an abstract type that is `about' sequences. It is defined in Program~\vref{sequenceContractDef}. The elements of the `sequence` contract are sufficient to allow abstract sequential processing of sequences.

\begin{program}[hbtp]
[listing]
contract sequence over s determines e is {
  _empty has type ()&lt;=s;
  _pair has type (e,s)&lt;=s;
  _cons has type (e,s)=&gt;s;
  _apnd has type (s,e)=&gt;s;
  _back has type (s,e)&lt;=s;
  _nil has type ()=&gt;s;
}

.The Standard `sequence` Contract[[sequenceContractDef]]
\end{program}
\noindent
For example, the `reverse` function in Program~\vref{reverseProgram} is defined for any form of sequence; i.e., for any type that implements the `sequence` contract.
\begin{program}[hbtp]
[listing]
reverse has type for all e,t such that (t)=&gt;t where
  sequence over t determines e
reverse(S) is let{
  rev(_empty(),R) is R
  |  rev(_pair(H,T),R) is rev(T,_cons(H,R))
} in rev(S,_nil());

.A `sequence` Reversal Function[[reverseProgram]]
\end{program}
\begin{aside}
The `sequence` contract has a _functional dependency_ -- see &lt;&lt;ContractFunctionalDependency&gt;&gt;. This captures the intuition that sequences are about an element type; but the actual type of each element depends on the particular implementation of the `sequence`.
\end{aside}

=== `\_empty` -- Empty Sequence Pattern
[[emptyPattern]]
(((sequence contract@`sequence` contract,empty@`empty`)))
[listing]
_empty has type for all e,t such that ()&lt;=t
                 where sequence over t determines e


The `\_empty` pattern is satisfied when matching an empty sequence.

\begin{aside}
The use of pattern abstractions is a normal feature of contracts that are aimed at defining an abstract type.
\end{aside}

=== `\_pair` -- Non-Empty Sequence Pattern
[[nonEmptyPattern]]
(((sequence contract@`sequence` contract,pair@`pair`)))
[listing]
_pair has type type for all e,t such that (e,t)&lt;=t
                     where sequence over t determines e


The `\_pair` pattern is satisfied when matching an non-empty sequence. A successful match results in the head and tail part of the sequence also being match.

=== `\_cons` -- Add to Front of Sequence
[[consFunction]]
(((sequence contract@`sequence` contract,cons@`cons`)))
[listing]
_cons has type type for all e,t such that (e,t)=&gt;t
                     where sequence over t determines e

The `\_cons` function is used to `cons' an element to the front of a `sequence` -- returning a new sequence with the new element at the front.

=== `\_apnd` -- Add to End of Sequence
[[appendFunction]]
(((sequence contract@`sequence` contract,apnd@`apnd`)))
[listing]
_apnd has type type for all e,t such that (t,e)=&gt;t
                     where sequence over t determines e

The `\_apnd` function is used to append an element to the end of a `sequence`. I.e., a subsequent match against the `sequence` using the `\_pair` pattern will 'pick up' the newly appended element only after all existing elements have been removed.

\begin{aside}
Depending on the implementation type that backs a particular `sequence`, the performance of the `\_cons` and `\_apnd` functions may be radically different.
\end{aside}

=== `\_back` -- Non-Empty Sequence Pattern
[[backPattern]]
(((sequence contract@`sequence` contract,back@`back`)))
[listing]
_back has type type for all e,t such that (t,e)&lt;=t
                     where sequence over t determines e


Like the `\_pair` pattern, the `\_back` pattern is satisfied when matching an non-empty sequence. A successful match results in the last element of the sequence being matched -- as well as the front portion of the sequence.

\begin{aside}
Depending on the implementation type that backs a particular `sequence`, the performance of the `\_pair` and `\_back` patterns may be radically different.
\end{aside}

=== `\_nil` -- Construct Empty Sequence
[[newFunction]]
(((sequence contract@`sequence` contract,cons@`cons`)))
[listing]
_nil has type type for all e,t such that ()=&gt;t
                    where sequence over t determines e

The `\_nil` function is used to construct an empty instance of the sequence.

== Collection Notation
Like the sequence notation, the collection notation is intended to allow collections that are not known to be sequences to be represented concisely in a type-independent way.

== The `concatenate` Contract
[[concatenateContract]]
(((concatenate contract@`concatenate` contract)))
The `concatenate` contract defines a single function that implements the `concatenation' of two values together.

\begin{program}[H]
[listing]
contract concatenate over s is {
  (++) has type (s,s)=&gt;s;
}

.The Standard `concatenate` Contract[[concatenateContractDef]]
\end{program}
\noindent

=== `++` -- Concatenate Sequences
[[concatFunction]]
(((concatenate contract@`concatenate` contract,++@`++`)))
(((concatenate sequences)))
[listing]
(++) has type for all s such that (s,s)=&gt;s where concatenate over s

The meaning of `S++T` is a new sequence where the elements of `S` come `first' and the elements of `T` come `next'.

== The `reversible` Contract
[[reversibleContract]]
(((reversible contract@`reversible` contract)))
The `reversible` contract defines a single function that implements the `reverse' of function.

\begin{program}[H]
[listing]
contract reversible over s is {
  reverse has type (s)=&gt;s;
}

.The Standard `reversible` Contract[[reversibleContractDef]]
\end{program}
\noindent

=== `reverse` -- Reverse Sequences
[[reverseFunction]]
(((reversible contract@`reversible` contract,reverse`reverse`)))
(((reverse sequences)))
[listing]
reverse has type for all s such that (s)=&gt;s where reversible over s

The meaning of `reverse(S)` is a new sequence where the elements of `S` are reversed.

\begin{aside}
The `reversible` contract is implemented for `list`s, `cons` lists and `string`s.
\end{aside}
== The `sets` Contract
[[setsContract]]
The standard `sets` contract defines set operations over collections.
(((sets contract@`sets` contract)))

\begin{program}[hbtp]
[listing]
contract sets over s is {
  union has type (s,s)=&gt;s;
  intersect has type (s,s)=&gt;s;
  complement has type (s,s)=&gt;s;
}

.The Standard `sets` Contract[[setContractDef]]
\end{program}
\noindent

=== `union` -- Union
[[unionFunction]]
(((sets contract@`sets` contract,union@`union`)))
(((union sequences)))
[listing]
union has type for all s such that (s,s)=&gt;s where sets over s

The meaning of `union(S,T)` is a new sequence consisting of elements of `S` merged with elements of `T`. Duplicate elements -- elements that appear in both `S` and `T` will not be duplicated in the result.

\begin{aside}
Although duplicates are eliminated as noted, if either of `S` or `T` already contains duplicates, then there may be duplicates in the result.
\end{aside}

\begin{aside}
There is no guarantee that the order of elements in the result reflects the order of elements in either of the sources of the `union` -- unless the type implementing the `sets` contract is already ordered.
\end{aside}

=== `intersect` -- Intersection
[[intersectFunction]]
(((sets contract@`sets` contract,intersect@`intersect`)))
(((intersect sequences)))
[listing]
intersect has type for all s such that (s,s)=&gt;s where sets over s

The meaning of `intersect(S,T)` is a new sequence consisting of elements of `S` intersected with elements of `T`. Only elements that appear in both `S` and `T` will appear in the result.

\begin{aside}
There is no guarantee as to the order of elements in the result of `intersect`.
\end{aside}

=== `complement` -- Complement
[[complementFunction]]
(((sets contract@`sets` contract,complement@`complement`)))
(((complement sequences)))
[listing]
complement has type for all s such that (s,s)=&gt;s where sets over s

The meaning of `complement(S,T)` is a new sequence consisting of elements of `S` which _do not_ occur within `T`.

\begin{aside}
There is no guarantee as to the order of elements in the result of `complement`.
\end{aside}


== The `sorting` Contract
[[sortingContract]]
The `sorting` contract defines what it means to `sort' a collection. The contract itself is defined in Program~\vref{sortContractProg}.

\begin{program}[H]
[listing]
contract sorting over coll determines el is {
  sort has type
      (coll,(el,el)=&gt;boolean) =&gt; coll;
}

.The `sorting` Contract[[sortContractProg]]
\end{program}

=== `sort` -- Sort a Collection
[[sortFunction]]
(((sorting contract@`sorting` contract,sort`sort`)))
(((sort a collection)))
[listing]
sort has type for all el, coll such that
    (coll,(el,el)=&gt;boolean) =&gt; coll where
       sorting over coll determines el


The `sort` function sorts a function -- using a supplied comparator function to compare elements. The comparator function should return true if the second argument is greater than or equal to the first.

\begin{aside}
The actual sort algorithm used is not represented here.
\end{aside}

The `sorting` contract is implemented for the `list` type and the `cons` list type.

== The `sizeable` Contract
[[sizeableContract]]
The standard `sizeable` contract is defined for those collections that have a concept of size associated with them.

(((type,contracts! sizeable@`sizeable`)))
(((sizeable contract@`sizeable` contract)))

The `sizeable` contract -- which is defined in Program~\vref{sizeableContractProg} -- defines the functions `size` and `isEmpty`.

\begin{program}
[listing]
contract sizeable of t is {
  size has type (t) =&gt; integer;
  isEmpty has type (t) =&gt; boolean;
}

.The Standard `sizeable` Contract[[sizeableContractProg]]
\end{program}

=== `size` -- Size of a `sizeable` Collection
[[sizeFunction]]
(((sizeable contract@`sizeable` contract,size@`size`)))
[listing]
size has type for all t such that (t)=&gt;integer where sizeable over t


The `size` function returns the number of elements of a `sizeable` collection. The precise meaning of the `size` function is likely to be type-specific; for example, for `string`s, the `size` of a `string` is the number of characters in the string.

=== `isEmpty` -- Is a `sizeable` Collection Empty
[[isEmptyFunction]]
(((sizeable contract@`sizeable` contract,isEmpty@`isEmpty`)))
[listing]
isEmpty has type for all t such that (t)=&gt;boolean where sizeable over t

The `isEmpty` function returns `true` if the collection has no elements.

== The `indexable` Contract
[[indexableContract]]
The `indexable` contract defines the functions that relate to the `indexable' expressions.

\begin{program}
[listing]
contract indexable over s determines (k,v) is {
  _index has type (s,k)=&gt;option of v;
  _set_indexed has type (s,k,v)=&gt;s;
  _delete_indexed has type (s,k)=&gt;s;
}

.The Standard `indexable` Contract[[indexableContractDef]]
\end{program}

The `indexable` contract defines what it means to access an element of a collection by index, and how such collections may be updated. The contract is parameterized both over the collection type and the index type -- a fact made use of to allow `dictionary` values to also be indexed.

\begin{aside}
Note that special notation supports high-level access to the `indexable` and `sliceable` contracts, as can be seen in &lt;&lt;indexNotation&gt;&gt; and &lt;&lt;sequenceUpdate&gt;&gt;.
\end{aside}

=== `\_index` -- Index Element
[[indexFunction]]
(((indexable contract@`indexable` contract,_index@`\_index`)))
[listing]
_index has type for all s,k,v such that (s,k)=&gt;option of v
                where indexable over s determines (k,v)

\begin{aside}
The type of the index depends on the implementation of the contract. In the case of `list`s, the index is `integer`; and the first index is zero.
\end{aside}
\begin{aside}
If the index is not valid, for example if the index into a list is longer than the list, then `none` is returned.
\end{aside}

=== `\_set\_indexed` -- Replace Element
[[indexReplaceFunction]]
(((indexable contract@`indexable` contract,_set_indexed@`\_set\_indexed`)))
(((replace element in collection)))
[listing]
_set_indexed has type for all s,k,v such that (s,k,v)=&gt;s
                        where indexable over s determines (k,v)

The `\_set\_indexed` function is used to represent the result of replacing an indexed element of a collection with a new value. The value returned is a new collection with every element identical to the original except that the ix\super{th} element is replaced.

If the index is out of range, i.e., if there is no element in the collection that corresponds to the requested index, then an error exception will be raised.

=== `\_delete\_indexed` -- Remove Element
[[indexDeleteFunction]]
(((indexable contract@`indexable` contract,_delete_indexed@`\_delete\_indexed`)))
(((remove element from collection)))

[listing]
_delete_indexed has type for all s,k,v such that (s,k)=&gt;s
                           where indexable over s determines (k,v)

The `\_delete\_indexed` function is used to remove an element from a collection. The `\_delete\_indexed` function returns a collection with the identified element removed. The element to delete is identified by its key, not by the kay/value pair.

\begin{aside}
If the index is out of range, i.e., if there is no element in the collection that corresponds to the requested index, then an error exception may be raised -- depending on the implementation of the contract.
\end{aside}

== The `sliceable` Contract
[[sliceableContract]]
The `sliceable` contract defines what it means to extract and update sub-sequences of collections. The contract -- defined in Program~\vref{sliceableContractProg} -- contains functions that extract a subsequence and replace a subsequence.
\begin{program}[htb]
[listing]
contract sliceable over t is {
  _slice has type (t,integer,integer)=&gt;t;
  _splice has type (t,integer,integer,t)=&gt;t;
}

.The `sliceable` Contract[[sliceableContractProg]]
\end{program}
As detailed below, the `sliceable` contract is supported by a `slice' notation that is based on the square bracket notation used to support indexing elements of collections.

=== `\_slice` -- Extract Subsequence
[[sliceFunction]]
(((sliceable contract@`sliceable` contract,_slice@`\_slice`)))
(((extract subsequence of sequence)))
[listing]
_slice has type for all t such that (t,integer,integer)=&gt;t
                 where sliceable over t

The meaning of `\_slice(S,Fr,To)` is that a subset of the sequence in `S` is extracted, starting with index position `Fr` up to -- but not including -- the index position `To`. The first index of the sequence is assumed to be zero.

If `To` is smaller than the length of the sequence then then the result will be shortened accordingly.

The `\_slice` function has a special syntax which is similar to that used for list indexing:
[listing]
C[Fr:To]

is equivalent to the expression
[listing]
_slice(C,Fr,To)


\begin{aside}
The contract signature, and the type signature for `\_slice` do not mention the type of the elements of the sequence.
\end{aside}

\begin{aside}
For any sequence `S`, for any positive integers `F` $\ge0$ and `T`$\ge$`F`, the following identity is expected to hold for implementations of `\_slice`:
[listing]
S[F:T]++S[T:size(S)] = S

Note, in particular if `F` is greater than or equal to the `size` of the sequence then the result of `\_slice` will be an empty sequence. This is different to the behavior for `\_index` where an exception is `raise`d when the index is not present in the sequence.
\end{aside}

\begin{aside}
In addition to being implemented for `list`s, and `cons` lists, the `sliceable` contract is also implemented for `string`s. In the latter case, the `sliceable` contract defines the equivalent of sub-string and string-replace.
\end{aside}

=== `\_splice` -- Replace Subsequence
[[spliceFunction]]
(((sliceable contract@`sliceable` contract,_splice@`\_splice`)))
(((replace subsequence of sequence)))
[listing]
_splice has type for all t such that (t,integer,integer,t)=&gt;t
                  where sliceable over t

The meaning of `\_splice(S,Fr,To,R)` is that a subsequence of `S` is replace with `R`. Starting with index position `Fr`, the elements up until -- but not including -- the position `To` are replaced by `R`. The first index of the sequence is assumed to be zero.

If `To` is greater than or equal to the `size` of the sequence then the result will be to replace the remaining of the sequence with the new elements.

The `\_splice` function has a special syntax which is similar to that used for updating list elements:
[listing]
C[Fr:To] := S

is equivalent to the action
[listing]
C := _splice(C,Fr,To,S)


== The `iterable` Contract
[[iterableContract]]
The `iterable` contract defines what it means to `iterate' over a collection. The contract itself is defined in Program~\vref{iterateContractProg} and it makes use of the standard `IterState` type.

\begin{program}[H]
[listing]
contract iterable over coll determines el is {
  _iterate has type
    for all r such that
      (coll,(el,IterState of r)=&gt;IterState of r,IterState of r) =&gt;
        IterState of r;
}

type IterState of t is NoneFound or NoMore(t) or ContinueWith(t);

.The `iterable` Contract[[iterateContractProg]]
\end{program}

The `iterable` contract defines a single function -- `\_iterate` -- which is used to `iterate' over a collection applying a client function to each element of the collection.

=== `\_iterate` -- Iterate over collection
[[iterateFunction]]
(((iterable contract@`iterable` contract,\_iterate@`\_iterate`)))
(((iterate over collection)))
[listing]
_iterate has type
    for all coll, el, r such that
      (coll,(el,IterState of r)=&gt;IterState of r,IterState of r) =&gt;
        IterState of r
      where iterable over coll determines el


The `\_iterate` function traverses a collection -- in an order that is `natural' to teh type of the collection -- applying a `client function' to each element.

The client function has the type:
[listing]
(el,IterState of r)=&gt;IterState of r

where `El` is an element of the collection and `State` and `NewState` represent the `state' of the iteration and are of the type `IterState`.

\begin{aside}
The idea is that the client function `processes' the candidate in the context of previous invocations of the client function and returns a new state that reflects the result.
\end{aside}

\begin{description}
`NoneFound`:: The `NoneFound` enumerated symbol denotes an empty state. The client may return a `NoneFound` result if the state represents a null situation.

\begin{aside}
The `\_iterate` function should not interpret `NoneFound` as a signal to terminate the iteration.
\end{aside}
`ContinueWith`::
The `ContinueWith` constructor is used to denote a partially completed state. The client function returns a `ContinueWith` when the denoted state may be augmented by further processing of elements of the collection.
`NoMore`::
The `NoMore` constructor is used to denote a completed state. The client function returns a `NoMore` value when it intends to signal that no further processing of the collection by the `\_iterate` function should be performed.

The `\_iterate` function should terminate processing the collection if the client function returns an `NoMore` value.
\end{description}

For example, to find positive integer values in a collection this client function could be used:
[listing]
findPositive(X, ContinueWith(L)) where X&gt;=0 is
       ContinueWith(cons(X,L))
 |  findPositive(_,S) default is S;

\begin{aside}
The `\_iterate` function is used automatically for &lt;&lt;SearchCondition&gt;&gt;s; however, the programmer is also free to explicitly use the `\_iterate` function.
\end{aside}

\begin{aside}
The precise form of the declaration of `\_iterate` within the `iterable` contract bears some additional explanation -- since it takes the form of an explicitly quantified type.

The `\_iterate` function is somewhat independent of the nature of the client function -- it applies the client function and terminates when the client function indicates that it is `done'. However, the precise state information that the client function is collecting is not relevant to the `\_iterate` function. In effect, the `\_iterate` function needs its client function to be generic.

In addition, since the semantics of the `\_iterate` function does not depend on the generic state that the client function collects it would not be correct to incorporate `r` as an additional type argument to the contract itself.

Hence the formulation of `\_iterate` as an explicitly universally quantified function _within_ the contract.
\end{aside}

== The `indexed\_iterable` Contract
[[indexedIterableContract]]
The `indexed\_iterable` contract defines what it means to `iterate' over a sequence where elements have a location within the sequence. The contract itself is defined in Program~\vref{indexedIterateContractProg} and it also makes use of the standard `IterState` type seen in Program~\vref{iterateContractProg}.

\begin{program}[H]
[listing]
contract indexed_iterable over s determines (k,v) is {
  _ixiterate has type
    for all r such that
      (s,(k,v,IterState of r)=&gt;IterState of r,IterState of r) =&gt;
        IterState of r;
}

.The `indexed\_iterable` Contract[[indexedIterateContractProg]]
\end{program}

The `indexed\_iterable` contract defines a single function -- `\_ixiterate` -- which is used to `iterate' over a sequence applying a client function to each element of the collection whilst keeping track of the index of the element within the collection that is being processed.

=== `\_ixiterate` -- Iterate over collection
[[indexIterateFunction]]
(((indexed\_iterable contract@`indexed\_iterable` contract,\_ixiterate@`\_ixiterate`)))
(((iterate over collection)))
[listing]
_ixiterate has type
    for all coll,k,v,r such that
      (coll,(k,v,IterState of r)=&gt;IterState of r,IterState of r) =&gt;
        IterState of r
      where indexed\_iterable over coll determines (k,v)


The `\_ixiterate` function traverses a collection -- in an order that is `natural' to the type of the collection -- applying a `client function' to each element. As it traverses the collection `\_ixiterate` keeps track of the index of the element within the collection.

The client function takes the form:
[listing]
client(Ix,El,State) is NewState

where `Ix` is a value that denotes the `position' of the element within the collection, `El` is an element of the collection and `State` and `NewState` represent the `state' of the iteration and are of the type `IterState`.

The interpretation of the `State` is the same as for the `iterable` contract.

For example, to find the location within a `cons` list[an] element that is greater than zero we can use the client function:
[listing]
indexOfPositive(Ix,X, ContinueWith(L)) where X&gt;=0 is
      ContinueWith(cons(Ix,L))
 |  indexOfPositive(_,_,S) default is S;

\begin{aside}
The `\_ixiterate` function is used automatically in &lt;&lt;IndexedSearch&gt;&gt; conditions; however, the programmer is also free to explicitly use the `indexed\_iterable` contract.
\end{aside}

== The `mappable` Contract
[[mappableContract]]
The `mappable` contract defines what it means to be able to apply a function over a collection. It contains a single `map` function:

\begin{program}[H]
[listing]
contract mappable over c is {
  map has type for all e,f such that ((e)=&gt;f,c of e) =&gt; c of f;
}

.The `mappable` Contract[[mapContractProg]]
\end{program}

=== `map` -- Apply a transformation to a collection
[[mapFunction]]

The `map` function applies a function to a collection to produce a new collection. Its type is given by:
[listing]
map has type for all e,f such that ((e)=&gt;f,c of e) =&gt; c of f where
  mappable over c

For example, we can use `map` to construct a list of `string` representations of `integer` values by mapping `display` (see \vref{displayFunction}):

[listing]
map(list of [1,2,3,4],display)

the value of which is the `list`:
[listing]
list of ["1","2","3","4"]


Note the slightly unusual quantification over the collection type. The `map` function must be able to accept a generic function as its transformation function.

== The `filterable` Contract
[[filterableContract]]
The `filterable` contract contains a single function -- `filter` -- that can be used to filter elements from a collection.


\begin{program}[H]
[listing]
contract filterable over t determines e is {
  filter has type ((e)=&gt;boolean,t) =&gt; t
}

.The `filterable` Contract[[filterContractProg]]
\end{program}


=== `filter` -- Apply a predicate to a collection
[[filterFunction]]

The `filter` function applies a predicate to a collection to produce a new collection -- containing only elements that satisfy the predicate. Its type is given by:
[listing]
filter has type for all e,t such that ((e)=&gt;boolean,t) =&gt; t where
  filterable over t determines e

For example, we can use `filter` to eliminate odd numbers from a list of `integer`s:
[listing]
filter(list of [1,2,3,4,5,6],(X)=&gt;X%2=0)

which has value:
[listing]
list of [2,4,6]


== The `foldable` Contract
[[foldableContract]]
The `foldable` contract defines another variant of iterating over collections while aggregating. The `foldable` contract defines two functions: `leftFold` and `rightFold`.

\begin{program}[H]
[listing]
contract foldable over c determines e is {
  leftFold has type for all st such that ((st,e)=&gt;st,st,c)=&gt;st;
  leftFold1 has type ((e,e)=&gt;e,c) =&gt; e;
  rightFold has type for all st such that ((e,st)=&gt;st,st,c)=&gt;st;
  rightFold1 has type ((e,e)=&gt;e,c)=&gt;e;
}

.The `foldable` Contract[[foldableContractProg]]
\end{program}

For example, to add together a collection of `integer`s, one can use a `leftFold` (or equivalently a `rightFold`) expression:
[listing]
leftFold((+),0,list of [1, 2, 3, 4])

which has value `10`.

\begin{aside}
The appropriateness of using `leftFold` or `rightFold` depends on whether the function being applied is left associative or right associative. If the function is left associative, it is normally better (in the sense of being closer to what one might expect) to use `leftFold`.

The `leftFold1` and `rightFold1` variants are used in cases where there is no natural `zero' for the function being applied.

Some functions are commutative -- like `(+)` -- in which case the value returned by `leftFold` is equal to the value returned by `rightFold`.
\end{aside}

=== `leftFold` -- Aggregate from the Left
[[leftFold]]
The `leftFold` function reduces a sequence by successively applying a function from the beginning of the sequence.
[listing]
leftFold has type for all e,c,s such that
    ((s,e)=&gt;s,s,c) =&gt; s where foldable over c determines e

The client function takes the form:
[listing][escapechar=|]
leftClient(|_Acc_|,|_El_|) is |_Acc'_|

where `_Acc_` is the accumulated result so far, `_El_` is successive elements of the collection and `_Acc'_` is the result of applying the client function to the element.

=== `leftFold1` -- Non-zero Aggregate from the Left
[[leftFold1]]
The `leftFold1` function reduces a sequence by successively applying a function from the beginning of the sequence. The first element of the sequence is used as the initial `state':
[listing]
leftFold1 has type for all e,c such that
    ((e,e)=&gt;e,c) =&gt; c where foldable over c determines e

The client function takes the form:
[listing][escapechar=|]
leftClient(|_Acc_|,|_El_|) is |_Acc'_|

where `_Acc_` is the accumulated result so far, `_El_` is successive elements of the collection and `_Acc'_` is the result of applying the client function to the element.

\begin{aside}
The client function has a simpler form of type than that for `leftFold`. In particular, the types of both arguments and the result are identical. This is because `leftFold1` uses the first element of the sequence as the initial seed of the computation -- as opposed to an externally provided zero.
\end{aside}

\begin{aside}
If the sequence is empty then `leftFold1` will raise an exception.
\end{aside}

\begin{aside}
The standard contract for `foldable` includes a _default_ implementation of `leftFold1`. This default implementation is used in cases where a concrete implementation does not include a definition for `leftFold1`.
\end{aside}

=== `rightFold` -- Aggregate from the Right
[[rightFold]]
The `rightFold` function reduces a sequence by successively applying a function from the end of the sequence.
[listing]
rightFold has type for all e,c,s such that
    ((e,s)=&gt;s,s,c) =&gt; s where foldable over c determines e

The client function takes the form:
[listing][escapechar=|]
rightClient(|_El_|,|_Acc_|) is |_Acc'_|

where `_Acc_` is the accumulated result so far, `_El_` is succesive elements of the collection and `_Acc'_` is the result of applying the client function to the element.

\begin{aside}
Note that the order of the arguments in the left client and the right client is different: the right client function has the `element' argument first whereas the left client has the element argument second.

This reflects the difference in expected associativity of the clients.
\end{aside}

=== `rightFold1` -- Non-zero Aggregate from the Right
[[rightFold1]]
The `rightFold1` function reduces a sequence by successively applying a function from the end of the sequence. The last element of the sequence is used as the initial `state':
[listing]
rightFold1 has type for all e,c such that
    ((e,e)=&gt;e,c) =&gt; c where foldable over c determines e


\begin{aside}
The client function has the same form as that for `leftFold1`; in particular its type is the same. However, the order of arguments is different: in particular, the client function should take the form:
[listing][escapechar=|]
rightClient(|_El_|,|_Acc_|) is |_Acc'_|

with successive elements being passed in to the first argument and the accumulated state in the second.
\end{aside}

\begin{aside}
If the sequence is empty then `rightFold1` will raise an exception.
\end{aside}

\begin{aside}
The standard contract for `foldable` includes a _default_ implementation of `rightFold1` -- which is based on the non-default implementation of `rightFold`.
\end{aside}

%== The `iotaC` Sequence Generation Contract
%[[iotaContract]]
%
%The `iota` function -- defined in the `iotaC` contract -- is used to generate sequences typically based on numbers.
%
%\begin{program}[H]
%[listing]
%contract iotaC over (r,t) is \{
%  iota has type (t,t,t) =&gt; r of t
%\}
%
%.The `iotaC` Contract[[iotaContractProg]]
%\end{program}
%The `iotaC` contract has two type parameters -- the first is actually a &lt;&lt;TypeConstructor&gt;&gt;: the name of a generic type. The second type is typically a numeric type that defines the type of the elements in the generated sequence.
%
%=== `iota` -- Sequence Generation
%[listing]
%iota has type iota has type for all r,t (t,t,t) =&gt; r of t
%                            where iotaC over (r, t)
%
%
%A call to `iota` of the form:
%[listing]
%iota(_F_,_T_,_S_)
%
%returns a sequence, starting at _F_, incrementing by _S_ and ending when the next number in the sequence would be `past' _T_.
%
%If the range is ascending, if _S_ is positive, then the sequence is terminated by the first number that is larger than _T_. Conversely, for descending sequences, when _S_ is negative, the sequence is terminated by the last number that is larger than _T_.
%
%For example, the call
%[listing]
%iota(1,12,3)
%
%returns the `list`
%[listing]
%list of [1, 4, 7, 10]
%
%(since the next number in the sequence -- 13 -- is larger than 12) and the call
%[listing]
%iota(10.0,0.0,-1.0)
%
%returns the `list`
%[listing]
%list of [10.0, 9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0, 1.0, 0.0]
%
%
%

== The `updateable` Contract
[[updateableContract]]
(((updateable contract@`updateable` contract)))
(((modifying collections)))
(((contract,updateable@`updateable`)))
The `updateable` contract captures some key functions involved in updating collections. The contract -- which is defined in Program~\vref{updateableContractProg} -- contains definitions for adding elements to a collection, merging two collections, updating a collection and deleting elements from the collection.

\begin{program}[H]
[listing]
contract updateable over r determines t is {
    _extend has type (r,t)=&gt;r;
    _merge has type (r, r) =&gt; r;
    _delete has type (r, ()&lt;=t) =&gt; r;
    _update has type (r, ()&lt;=t, (t)=&gt;t) =&gt; r;
}

.The `updateable` Contract[[updateableContractProg]]
\end{program}

The `updateable` contract is implemented for all the standard collection types: `cons`, `list`, `queue` and `dictionary`.

=== Syntax for Updating Collections
[[updateSyntax]]
Along with the contract, there is a standard notation for describing the updating of collections. This syntax is defined in &lt;&lt;updateSyntaxFig&gt;&gt;.

\begin{figure}[htbp]
\begin{eqnarray*}
[[UpdateAction]]UpdateAction::=`extend`\ &lt;&lt;Target&gt;&gt;\ `with`\ &lt;&lt;Expression&gt;&gt;\\
  | `merge`\ &lt;&lt;Target&gt;&gt;\ `with`\ &lt;&lt;Expression&gt;&gt;\\
  | `update`\ &lt;&lt;Pattern&gt;&gt;\ `in`\ &lt;&lt;Target&gt;&gt;\ `with`\ &lt;&lt;Expression&gt;&gt;\\
  | `delete`\ &lt;&lt;Pattern&gt;&gt;\ `in`\ &lt;&lt;Target&gt;&gt;
\end{eqnarray*}
.Notation for updating collections[[updateSyntaxFig]]
\end{figure}

The first `argument' of many of these actions is a &lt;&lt;Target&gt;&gt;, i.e., they have the same semantics as the left hand side of an assignment action -- see &lt;&lt;assignment&gt;&gt;. In fact, one of the requirements of an &lt;&lt;UpdateAction&gt;&gt; is that the collection being modified is in a re-assignable variable or field.

=== `\_extend` a Collection
[[extend]]
The `\_extend` function is used to `add' an element to a collection:
[listing]
_extend has type for all r,t such that (r,t)=&gt;r
                  where updateable over r determines t


As an example of the use of `\_extend`, consider the &lt;&lt;Action&gt;&gt;:
[listing]
extend R with ("fred",23)

assuming that `R` was defined as a list:
[listing]
var R := list of [ ("peter",20) ]

then after the `extend`, `R` will contain two tuples:
[listing]
list of [ ("fred", 23), ("peter",20) ]


\begin{aside}
Note that there is no implied commitment to preserve order of insertion into a collection. I.e., a sequence of `\_extend`s into a collection may not be visible when the collection is iterated over or searched.
\end{aside}

The relationship between the `extend` action and the `\_extend` function is captured in the macro rule:
[listing]
#extend ?Tgt with ?Exp ==&gt; Tgt := _extend(Tgt,Exp)



=== `\_merge` a Collection
[[merge]]
The `\_merge` function is used to merge a collection with another one.
[listing]
_merge has type for all r,t such that (r,r)=&gt;r
                 where updateable over r determines t


\begin{aside}
Technically a `\_merge` is equivalent to a sequence of `\_extend`s. However, for situations where many elements may be added simultaneously, using `\_merge` offer opportunities for more optimal implementations.
\end{aside}

As an example of the use of `\_merge`, consider the &lt;&lt;Action&gt;&gt;:
[listing]
merge R with list of [("john",2), ("alfred",10)]

then, assuming the same `R` as above, after the `merge`, `R` will contain:
[listing]
list of [("fred", 23), ("john",2), ("alfred",10), ("peter",20)]


The relationship between the `merge` action and the `\_merge` function is captured in the macro rule:
[listing]
#merge ?Tgt with ?Rel ==&gt; Tgt := _merge(Tgt,Rel)


\begin{aside}
One constraint of the `\_merge` function is that the type of the two collections must be the same. This is not necessary if an iteration is hand-coded using separate `\_extend` calls.
\end{aside}

=== `\_update` a Collection
[[update]]
The `\_update` function is used to update one or more elements in a collection simultaneously.
[listing]
_update has type for all r,t such that (r, ()&lt;=t, (t)=&gt;t) =&gt; r
                  where updateable over r determines t

This function takes three arguments: the collection to be updated, a &lt;&lt;Pattern&gt;&gt; to identify which elements of the collection to update and a &lt;&lt;Function&gt;&gt; to transform selected elements.

\begin{aside}
The &lt;&lt;UpdateAction&gt;&gt; notation for `update` hides the existence of the pattern and function by automatically constructing the necessary programs.
\end{aside}

The `\_update` function `tests' each element of the collection to see if it should be updated. If an element is to be updated, then the transform function performs the change.

For example, to double all entries in `R` then we can use the action:
[listing]
update (N,X) in R with (N,X+X)

If we wanted to constrain the update to entries whose first element was less than `"fred"` we could use:
[listing]
update ((N,X) where N&lt;"fred") in R with (N,2*X)

This last action would change `R` to:
[listing]
list of [ ("fred", 23), ("john",2), ("alfred",20), ("peter",20) ]

(since only `"alfred"` is less than `"fred"` in the standard lexicographical ordering).

The macro that defines the `update` notation in terms of `\_update` is:
[listing]
#update ?Ptn in ?Tgt with ?Exp ==&gt; Tgt :=
   _update(Tgt,(() from Ptn), (Ptn) =&gt; Exp)



=== `\_delete` Elements from a Collection
[[delete]]
The `\_delete` function is used to remove selected elements from a collection.
[listing]
_delete has type for all r,t such that (r, ()&lt;=t) =&gt; r
                  where updateable over r determines t

This function takes two arguments: the collection to be updated and a &lt;&lt;Pattern&gt;&gt; to identify which elements of the collection to remove.

\begin{aside}
The &lt;&lt;UpdateAction&gt;&gt; notation for `delete` hides the explicit existence of the pattern abstraction.
\end{aside}

The `\_delete` function `tests' each element of the collection to see if it should be deleted.

For example, to delete all entries in `R`  whose second element is less than 10 we can use the action:
[listing]
delete ((N,X) where X&lt;10) in R

This last action would change `R` to:
[listing]
list of [("fred", 23), ("alfred",20), ("peter",20)]


The macro that defines the `delete` notation in terms of `\_delete` is:
[listing]
#delete ?Ptn in ?Tgt with ?Exp ==&gt; Tgt := _delete(Tgt,(() from Ptn))



== The `explosion` Contract
[[explosionContract]]
The `explosion` contract defines what it means to `pack' or 'unpack' a collection. Many sequences have a dual nature: for example `string`s can be viewed as compact entities that are effectively atomic, or as sequences of characters.

When exploding a `string`, the result is a sequence of `integer`s -- each representing a separate _code point_ in the string. This form is useful when the contents of the `string` needs to be processed and the former is useful when `string`s are processed as a whole.

\begin{aside}
Exploding a string into code points does not guarantee a unique decomposition. Some unicode characters have multiple representations as codepoints. However, alternate decompositions are guaranteed to be semantically equivalent.
\end{aside}

The explosion contract is defined in Program~\vref{explosionContractProg}.

\begin{program}[H]
[listing]
contract explosion over (coll,packed) is {
  implode has type (coll)=&gt;packed;
  explode has type (packed) =&gt; coll;
}

.The `explosion` Contract[[explosionContractProg]]
\end{program}

=== `implode` -- Implode a Collection in packed form
[[implodeFunction]]
(((explosion contract@`explosion` contract,implode`implode`)))
(((pack a collection)))

[listing]
implode has type for all coll, packed such that
  (coll)=&gt;packed where explosion over (coll,packed)


\noindent
The `implode` function takes a collection and packs it into a suitably compressed form -- whose type depends on the implementation.

\begin{aside}
One typical use is to implode a `cons` list of `integer`s (which are interpreted as unicode code points) into a `string`.\end{aside}

=== `explode` -- Explode a Packed Entity into a Collection
[[explodeFunction]]
(((explosion contract@`explosion` contract,explode`explode`)))
(((un a collection)))

[listing]
explode has type has type for all coll, packed such that
  (packed) =&gt; coll of el where explosion over (coll,packed)


\noindent
The `explode` function takes a packed object and expands it into a suitable collection.

\begin{aside}
One typical use is to explode a `string` into a `cons` list of `integer` code points.\end{aside}

== The `list` Type
[[arrayType]]
The `list` type is a standard type that has implementations of several contracts, including the `sequence`, `indexable`, `sizeable`, `iterable` and `foldable` contracts.

The `list` type's implementation is optimized for random access: i.e., for its implementation of the `indexable` contract.

=== List Literal Expressions and Patterns
[[listLiteral]]
(((list@`list`,literal)))
Since the `list` type implements the `sequence` contract, the standard sequence notation can be used to represent list values and patterns (see &lt;&lt;sequenceExpression&gt;&gt; and &lt;&lt;sequencePattern&gt;&gt;). I.e., an expression of the form:
[listing][escapechar=|]
list of [E|\sub1\sequence{,}|E|\subn|]

denotes the `list` of elements `E\sub1` through `E\subn`.

For example:
[listing]
list of [1, 3, -10, 5]

denotes an list[four] `integer` elements. The expression:
[listing]
list of []

denotes the empty `list`. Partial `list` expressions are also permitted:
[listing]
list of [1, 3, -10 ,.. X]

denotes the result of `cons`ing the elements `1`, `3` and `-10` to the front of the list `X`.
\begin{aside}
The `tail' of an `list of` expression must also be an `list` value.
\end{aside}

\begin{aside}
Of course, in most cases the `tail' part of a partial `list` pattern is denoted by a variable. In which case the tail variable is bound to a `list` that denotes the appropriate remainder of the `list`.

For example, if the pattern `list of [X1,X2,..Tl]` is matched against:
[listing]
list of [1, 2, 3, 4, 5]

then the variables `X1` and `X2` will be bound to `1` and `2` respectively, and `Tl` will be bound to:
[listing]
list of [3, 4, 5]

\end{aside}

== The `cons` Type
[[consType]]
The `cons` type is a list type that implements the contracts `sequence`, `indexable`, `sizeable` and `iterable`. It is optimized for sequential processing. Unlike the `list` type, it is defined as a regular &lt;&lt;AlgebraicType&gt;&gt; -- as can be seen in Program~\vref{consTypeProg}.

\begin{program}[H]
[listing]
type cons[t] is nil or cons(t,cons[t])

.The Standard `cons` Type[[consTypeProg]]
\end{program}

The &lt;&lt;SequenceExpression&gt;&gt; and &lt;&lt;SequencePattern&gt;&gt; notations also apply to `cons` terms. So, an expression of the form
[listing]
cons of ["alpha", "beta", "gamma"]

is equivalent to
[listing]
cons("alpha", cons("beta", cons("gamma",Nil)))


\begin{aside}
The `cons` implementation of the `sequence` contract is asymmetric: `\_cons`ing an element to the front of the `cons` sequence if fundamentally a constant-time operation; as is the corresponding match using `\_pair`. However, the `\_apnd` and `\_back` operations are _linear_ on the size of the `cons` list.
\end{aside}

\begin{aside}
The cost of `indexing' an element of a `cons` structure is linear on the size of the `cons` list. Thus `cons` lists are probably not a good choice for representing data that requires such indexed access.
\end{aside}

== The `queue` Type
[[queueType]]
The `queue` type is a sequence type that is symmetric to adding/removing elements from the front or the back. It is defined by the standard definition as shown in Program~\vref{queueTypeProg}.

\begin{program}
[listing]
type queue of t is queue{
  front has type cons[t]; -- The 'front' portion of the queue
  back has type cons[t];  -- The 'back' portion of the queue
}

.The Standard `queue` Type[[queueTypeProg]]
\end{program}
\begin{aside}
The elements in the `front` and `back` portions of the `queue` are stored in insertion order -- that is, they are reversed with respect to each other. This may require occasional reversing of either the `front` or `back` portions of the `queue`.
\end{aside}

\begin{aside}
The amortized cost of reversing the `front`  or `back` portions of the `queue` is linear on the size of the `queue`; and hence is constant for any given element. Indeed, if a `queue` is used exclusively as a queue: inserting elements at one end and removing them from the other end then all insert and deletion operations have constant time.
\end{aside}

\begin{aside}
The cost of `indexing' an element of a `queue` structure is linear on the size of the `queue`. Thus `queue`s are probably not a good choice for representing data that requires such indexed access.
\end{aside}
</Text>
        </Document>
        <Document ID="84601779-AA4E-416D-B795-18875A0B2B0E">
            <Title>Hexadecimal Integers</Title>
            <Text>A hexadecimal number is an integer written using hexadecimal notation. A hexadecimal number consists of a leading 0x followed by a sequence of hex digits. For example,
0x0 0xff 0x34fe
are all hexadecimals.

Hexadecimal::= 0x Hex ... Hex+
Hex::= 0|1|2|3|4|5|6|7|8|9|a|b|c|d|e|f
Hexadecimal numbers</Text>
        </Document>
        <Document ID="0778B444-3F1F-4924-83BA-B2AB7028AC3E">
            <Title>Back Matter</Title>
        </Document>
        <Document ID="BC0DC62B-D666-419C-A37C-870C3C678050">
            <Title>Manuscript Format</Title>
        </Document>
        <Document ID="C4910435-4214-4620-A953-71B0CB21C97E">
            <Title>Semantics of String Interpolation</Title>
            <Text>String variable interpolation expressions may refer to variables that are in scope at the location of the string literal itself.

The meaning of a string interpolation is slightly different for the two forms of interpolation. An expression of the form:
[listing][escapechar=|]
"|_prefix_|$(|_Exp_|)|_suffix_|"

is interpreted as:
[listing][mathescape=true]
"$_prefix_$"++display($_Exp_$)++"$_suffix_$"

whereas the expression:
[listing][mathescape=true]
"$_prefix_$\#($_Exp_$)$_suffix_$"

is interpreted as being equivalent to:
[listing][mathescape=true]
"$_prefix_$"++($_Exp_$ as string)++"$_suffix_$"


\begin{aside}
The difference between `display` and `as` becomes most obviously apparent with `string`s themselves. Assuming that the variable `L` is bound to the `string` `"hello"`, the value of
[listing]
"alpha#(L)beta"

is the string
[listing]
"alphahellobeta"

whereas the value of
[listing]
"alpha$(L)beta"

is
[listing]
"alpha\"hello\"beta"

But in general, there may be many differences between the two forms of displayed value.
\end{aside}

If a &lt;&lt;FormattingSpec&gt;&gt; is present, then the translation takes that into account also. For example, the expression:
[listing][escapechar=|]
"|_prefix_|$(|_Exp_|):|_Format_|;|_suffix_|"

is equivalent to the expression:
[listing][mathescape=true]
"$_prefix_$"++_format($_Exp_$,$_Format_$)++"$_suffix_$"

where `\_format` is part of the `format` contract -- see &lt;&lt;formatContract&gt;&gt;.

\begin{aside}
Note that this translation is the same for either the `\$` or `\#` interpolation form.
\end{aside}</Text>
        </Document>
        <Document ID="5A7591EF-D8CF-43A2-ACCB-4F230F5C8C26">
            <Title>Subsumption of Basic Types</Title>
            <Text>

\begin{itemize}
\item One &lt;&lt;TypeExpression&gt;&gt; subsumes another if they have the same arity, and if their type constructors and type arguments pairwise subsume:
\begin{prooftree}
\AxiomC{\entail{E,\theta\sub0}{t\sub1\subsume u\sub1\leadsto\theta\sub1}\sequence{\ }\entail{E,\theta\sub{n-1}}{t\subn\subsume u\subn\leadsto\theta\subn}}
\AxiomC{\entail{E,\theta\subn}{C\sub1\subsume C\sub2\leadsto\theta}}
\BinaryInfC{\entail{E,\theta\sub0}{C\sub1\ `of`\ (t\sub1\sequence{,}t\subn)\ \subsume\ C\sub2\ `of`\ (u\sub1\sequence{,}u\subn)\leadsto\theta}}
\end{prooftree}
where $t\subi$ and $u\subi$ are &lt;&lt;Type&gt;&gt; expressions  and $C\sub1$ and $C\sub2$ are &lt;&lt;TypeConstructor&gt;&gt;s.

\item If a type variable $v$ is already in the unifier then we look it up:
\begin{prooftree}
\AxiomC{\ensuremath{v/t\sub1\in\theta\subi}}
\AxiomC{\entail{E,\theta\subi}{t\sub1\subsume{}t\sub2\leadsto\theta\sub{o}}}
\BinaryInfC{\entail{E,\theta\subi}{v\subsume{}t\sub2\leadsto\theta\sub{o}}}
\end{prooftree}

\begin{prooftree}
\AxiomC{\ensuremath{v/t\sub2\in\theta\subi}}
\AxiomC{\entail{E,\theta\subi}{t\sub1\subsume{}t\sub2\leadsto\theta\sub{o}}}
\BinaryInfC{\entail{E,\theta\subi}{t\sub1\subsume{}v\leadsto\theta\sub{o}}}
\end{prooftree}

\item A type variable $v$ may be inserted into the unifier:
\begin{prooftree}
\AxiomC{\ensuremath{v/t\notin\theta\subi}}
\AxiomC{\ensuremath{v\notin{}t\sub2}}
\BinaryInfC{\entail{E,\theta}{v\subsume{}t\sub2\leadsto\theta\cup\{v/t\sub2\}}}
\end{prooftree}
where the condition \ensuremath{v\notin{}t} means that $v$ does not occur free in type $t$.
\begin{prooftree}
\AxiomC{\ensuremath{v/t\notin\theta\subi}}
\AxiomC{\ensuremath{v\notin{}t\sub1}}
\BinaryInfC{\entail{E,\theta}{t\sub1\subsume{}v\leadsto\theta\cup\{v/t\sub1\}}}
\end{prooftree}

\end{itemize}

====</Text>
        </Document>
        <Document ID="80605CA4-5E2A-4E8C-819A-7531FC22E6F9">
            <Title> Multi-word Operators</Title>
            <Text>A multi-word operator defines a new MultiWordIdentifier; i.e., a special combination of alpha numeric words that form a single logical identifier.
Multi-word operators are defined like regular operators, except that their names contain spaces. For example, the operator declaration:
#infix(‘no more’,500).
defines the combination of words no followed by more as a single operator of priority 500.
A multi-word operator is only an operator when all of its constituent words are present. If one or more of the constituent words are not present (or have other tokens intervening) then the sequence is not interpreted as a single operator but is parsed separately. For example, in the text:
5 no more 10
is interpreted as the equivalent of:
'no more'(5,10)
but the text
5 no (more) 10
is not, and, in this case, may well be reported as a syntax error.
[TIP] It is permissible to interpose comments between the words of a multi-word operator. Thus:
5 no /* way */ more 10
is legal.
[TIP] A given word can be an operator in its own right, as well as participating in a multi-word operator. The combination may have different priorities to the individual pieces.</Text>
        </Document>
        <Document ID="4872430F-513C-4BA0-81F7-4E88CB75EFC0">
            <Title>Type Definitions</Title>
            <Text>A type definition is a statement that introduces a new type into the current scope. There are two forms of type definition statement: the TypeAlias definition and the AlgebraicType definition. In addition, the TypeWitness is used to declare a type.
TypeDefinition ::= TypeAlias | AlgebraicType | TypeWitness
Type Definition Statements
</Text>
        </Document>
        <Document ID="38B518E0-47FF-47EF-A5B6-38ACAB876DAD">
            <Title>String Interpolation</Title>
            <Text>String interpolation refers to the embedding of variables and expressions in string literals. The actual string value of an interpolated `string` literal requires the evaluation of those variables and expressions.
For example, given a variable X with the value 24, then:
"this has the value of X: \(X)”
“\(X*X) people saw this"
would have values:
"this has the value of X: 24"
and
"576 people saw this"
respectively.
There are two modes of string interpolation: the dollar form corresponds to displaying a value and the hash form corresponds to coercing a value to a string value. The former produces a string which is intended to be parseable as the original value. It is also the form that is universally supported by all non-programmatic types.
[NOTE:] If a string interpolation expression itself contains a string, the various quoting mechanisms for strings apply to that string also. I.e., it is not necessary to double-quote strings within string interpolation expressions.
For example, the string expression in:
logMsg(info,"The price of cheese is \(priceOf("cheese"))")
works as expected: the argument to the priceOf function is the string literal "cheese". An even more nested example is:
logMsg(info,"The price of \(P) is \(priceOf("SKU$(P)”))”)
In this example, we have a `string` interpolation expression embedded within another `string` interpolation expression.
An Interpolation expression may be followed by a FormattingSpec. If present, then this specification is used to guide how values are formatted.
For example, the value of
"--\(120345567):999,999,999,999;--"
is the string:
"--120,345,567--"
Detailed formatting is controlled by the format contract which in turn means that different types of expression will have type appropriate ways of specifying the formatting.</Text>
        </Document>
        <Document ID="085FFC1A-D81C-4205-A0FA-CDBC7C520429">
            <Title>Concurrency</Title>
            <Text>%!TEX root = reference.tex
= Concurrent Execution
[[concurrent]]
(((concurrent execution)))
(((execution,parallel)))

Concurrent and parallel execution of Star programs involves two inter-related concepts: the `task` and the `rendezvous`. A `task` is a form of &lt;&lt;ComputationExpression&gt;&gt; with support for parallel and asynchronous execution.  A `rendezvous` represents a `meeting place' between two or more independent activities. In particular, messages may be exchanged between `task`s at a `rendezvous`.

The concurrency concepts and features are inspired by similar features found in Concurrent ML \cite{reppy:99}; which, in turn, have similar underpinnings as Hoare's Concurrent Sequential Processes \cite{hoare:85}.

== Accessing Concurrency Features

\begin{aside}
In order to access the concurrency features described in this chapter it is required to `import` the `concurrency` package:
[listing]
import concurrency;

\end{aside}

== Tasks
[[tasks]]
The foundation for concurrency is the &lt;&lt;TaskExpression&gt;&gt;. A `task` is a &lt;&lt;ComputationExpression&gt;&gt; that denotes a computation that may be performed in parallel with other computations.

=== Task Expressions
[[taskExpressions]]

A `task` expression consists of a `task`-labeled &lt;&lt;ActionBlock&gt;&gt;.

\begin{figure}[htbp]
\begin{eqnarray*}
_Expression_&amp;\arrowplus&amp;&lt;&lt;TaskExpression&gt;&gt;\\
[[TaskExpression]]TaskExpression::=`task`\ `\{`\ &lt;&lt;Action&gt;&gt;\sequence{;}&lt;&lt;Action&gt;&gt;`\`}
\end{eqnarray*}
.Task Expression
[[taskExpressionFig]]
\end{figure}

&lt;&lt;TaskExpression&gt;&gt;s denote computations that are expected to be performed asynchronously or in parallel.

A `task` is `created' with the `task` notation:
[listing]
def T is task\{ logMsg(info,"This is a task action") \}

\begin{aside}
Apart from `background` tasks (see &lt;&lt;backgroundTask&gt;&gt;), a &lt;&lt;TaskExpression&gt;&gt; is not `started' until it is `perform`ed or `valof` is applied.
\end{aside}
In order to start the task, the task must be `perform`ed:
[listing]
perform T

This is the same as for all &lt;&lt;ComputationExpression&gt;&gt;s.

&lt;&lt;TaskExpression&gt;&gt;s may have values; and may be composed and constructed like other expressions. For example, the function:
[listing]
tt(X) is task\{
  def Y is 2;
  valis X+Y;
\}

represents a rather elaborate way of adding 2 to a number. As with `T` above, the expression:
[listing]
def I is tt(3)

is not an `integer` but an `integer`-valued &lt;&lt;TaskExpression&gt;&gt;. The value returned may be extracted using `valof`:
[listing]
def Five is valof I

As with all &lt;&lt;ComputationExpression&gt;&gt;s, if there is a possibility that the &lt;&lt;TaskExpression&gt;&gt; will fail, then the `on abort` variant of `valof` should be used:
[listing]
Fdef ive is valof I
  on abort \{ E do \{
    logMsg(info,"Was not expecting this");
    valis nonInteger
  \}
\}


=== The `task` type
[[taskType]]
The `task` type is a standard type that is used to represent &lt;&lt;TaskExpression&gt;&gt;s. It also represents the `concurrency Monad'.

[listing]
task has kind type of type


\begin{aside}
Although the `task` type is implemented as a normal type, it's definition is hidden as its internals are not relevant to the programmer. Hence, it is declared using the &lt;&lt;HasKind&gt;&gt; statement rather than with a &lt;&lt;AlgebraicType&gt;&gt; definition.
\end{aside}

== Task-related Functions
[[taskFunctions]]
(((task functions)))

=== Background Task
[[backgroundTask]]
The `background` function takes a `task` and performs it in the background (i.e., in parallel with the invoking call). The value of the `background` task is the same as the value of the backgrounded task.
[listing]
background has type for all t such that (task of t)=&gt;task of t

\begin{aside}
`background` is a standard prefix operator; defined as:
[listing]
\#prefix((background),900);

hence a call to `background` may be written without parentheses.
\end{aside}

== Rendezvous
[[rendezvous]]

A rendezvous is a coordination point between two or more independent tasks. Typically, these represent message communication but can involve time-outs, i/o operations and so on.

=== The `rendezvous` Type
[[rendezvousType]]
The `rendezvous` type is a standard type that denotes a rendezvous.
[listing]
rendezvous has kind type of type;

\begin{aside}
It is an opaque type -- i.e., its existence is public, but its definition is not.
\end{aside}

=== Waiting for a Rendezvous
[[waitfor]]
The `wait for` function is used to wait at a rendezvous until the rendezvous `occurs'.

[listing]
wait for has type for all t such that (rendezvous of t)=&gt;task of t


\begin{aside}
The `wait for` function name is also a multi-word prefix operator defined:
[listing]
\#prefix("wait for",999);

\end{aside}

Waiting for a `rendezvous` is the central mechanism that multiple `task`s may use to coordinate their activities.

The result of waiting for a `rendezvous` is also a `task`. This means, for example, that there can be a distinction between a `coordination point' between `task`s and the computation enabled by that coordination.

=== The `alwaysRv` Rendezvous Function
[[alwaysRendezvous]]
(((rendezvous,alwaysRv@`alwaysRv`)))

The `alwaysRv` returns a `rendezvous` that is always `ready'. It has a single argument which is returned -- wrapped as a `task` -- by `wait for`.

[listing]
alwaysRv has type for all t such that (t)=&gt;rendezvous of t


In effect, the `alwaysRv` rendezvous obeys the law:
\begin{equation*}
`wait for alwaysRv(X)`\ \equiv\ `task\{ valis X\`}
\end{equation*}

=== The `neverRv` Rendezvous
[[neverRendezvous]]
(((rendezvous,never@`never`)))

The `neverRv` `rendezvous` is _never_ `ready'.

[listing]
neverRv has type for all t such that rendezvous of t


\begin{aside}
Waiting for a `neverRv` rendezvous is rarely useful by itself; but is especially useful when combined with `guardRv`.
\end{aside}

=== The `chooseRv` Rendezvous Function
[[chooseRvFun]]
(((rendezvous,choose@`choose`)))
(((multiple rendezvous)))
(((selecting from many rendezvous)))

The `chooseRv` rendezvous function is used to combine a collection of rendezvous into a single non-deterministic disjunction. Waiting for a `chooseRv` rendezvous is successful if one of its `arms' is successful.

[listing]
chooseRv has type for all s,t such that (s)=&gt;rendezvous of t
                  where sequence over s determines rendezvous of t


The argument to `chooseRv` is a `sequence` of `rendezvous` values -- any of which may activate in order to activate the `chooseRv`.

The `chooseRv` rendezvous combinator is important because it allows a one-of selection from multiple alternatives.

\begin{aside}
Waiting on a `chooseRv` rendezvous is successful when one of the `rendezvous` in its argument collection becomes available -- i.e., a call of `wait for` on the `chooseRv` collection completes when `wait for` would complete on one of the elements of that collection.

If more than one element `rendezvous` is ready then one of them will be selected non-deterministically.
\end{aside}

\begin{aside}
The `chooseRv` `rendezvous` is analogous to the Unix-style `select` function; except that rather than being limited to waiting for an I/O descriptor to be ready, the `chooseRv` rendezvous allows many different forms of rendezvous to be selected from.
\end{aside}

For example, the rendezvous expression:
[listing]
chooseRv(list of [sendRv(Ch,"M"), timeoutRv(10)])

can be used to represent a combination of trying to send a message on the `Ch` channel -- see &lt;&lt;sendRvFun&gt;&gt; -- or if no one received the message within 10 milliseconds then giving up on the send.

=== The `guardRv` Rendezvous
[[guardRvFun]]
(((rendezvous,guardRv@`guardRv`)))
(((guarded rendezvous)))

A `guardRv` function is used to dynamically compute a `rendezvous`. Applied just before a rendezvous is waited on, the `quardRv` allows the precise rendezvous to be computed dynamically.

[listing]
guardRv has type for all t such that
                 (task of rendezvous of t) =&gt; rendezvous of t


The argument to `guardRv` is a `task`; the `valof` of which is the actual `rendezvous`. Guards are evaluated -- `valof`'ed -- immediately prior to actually waiting for the `rendezvous`.

A classic use of `guardRv` is to enable a semantic condition to be satisfied before enabling a particular `rendezvous`. For example, if it `did not make sense' to accept a message on a channel unless a particular `queue` was non-empty could be represented with:
[listing]
var Q := queue of [];
...
testQ() is task\{
  if empty(Q) then
    valis neverRv
  else
    valis recvRv(Ch)
\}
...
wait for guardRv(testQ())


=== The `wrapRv` Rendezvous Function
[[wrapRvFun]]
(((wrap rendezvous)))
(((rendezvous,wrap)))

A `wrapRv` can be used to `convert' a `rendezvous` of one type to another form. This is often used to enable one `rendezvous` to `count as' another `rendezvous`.

[listing]
wrapRv has type for all a,b such that
                (rendezvous of a, (a) =&gt; task of b) =&gt; rendezvous of b


The first argument of `wrapRv` is the `rendezvous` that is actually waited on. The second argument is a function that takes the result of that `rendezvous` and returns a new `task` using that return value.

One use for the `wrapRv` function is to perform another `rendezvous` wait. For example:
[listing]
requestReply(SCh,RCh,Msg) is guardRv(sendRv(Ch,Msg),
                                (_) =&gt; wait for recvRv(RCh))

will send a `Msg` on the `send channel' `SCh`; and once that message was successfully sent will wait for a reply on the `RCh` channel.

`requestRepl` is a `rendezvous`-valued function; and so can be used in conjunction with other `rendezvous` expressions. For example, to send a message to two other `task`s but only wait for one result we might use:
[listing]
def R is valof wait for chooseRv\{
  requestReply(S1,RCh);
  requestReply(S2,RCh)
  \}


=== The `withNackRv` Rendezvous
[[nackRvFun]]
The `withNackRv` function can be used to discover if another rendezvous _was not_ triggered.
[listing]
withNackRv has type for all t such that
                    ((rendezvous of ())=&gt;rendezvous of t)=&gt;rendezvous of t


The argument to `withNackRv` is a function which is invoked during synchronization -- analogously to the `guardRv` function -- to construct the `rendezvous` to be monitored. If that `rendezvous` is _not_ selected -- in a call to `wait for` -- then a special _abort_ rendezvous _is_ selected. That abort rendezvous is the one that is passed in to the argument function.

For example, in the expression:
[listing]
withNackRv(F)

`F` should be a function that takes a `rendezvous` and returns a `rendezvous`:
[listing]
F(A) is recvRv(Ch)

The type of `A` is `rendezvous of ()`.

Waiting on `withNackRv(F)` is similar to a `wait for` the `rendezvous`
[listing]
recvRv(Ch)


If this `rendezvous` is selected then nothing further happens.

However, if this `rendezvous` were in a `chooseRv` and a different `rendezvous` were selected then `A` becomes 'available'. In effect, `A` being active means that the `recvRv` was not activated.

A slightly more complex example should illustrate this:
[listing]
showMsg(Ch) is let\{
  F(A) is valof\{
    ignore background task \{
      ignore wait for A; -- will block unless recvRv not active
      logMsg(info,"Did not receive message");
    \}
    valis recvRv(Ch)
  \}
\} in withNackRv(F)

If we used this to `wait for` a message; perhaps with a `timeoutRv`:
[listing]
wait for chooseRv(list of [
  showMsg(Chnl),
  timeoutRv(1000)
])

then, if a timeout occurred the message
[listing]
Did not receive message

would appear in the log.

=== The `timeoutRv` Rendezvous
[[timeoutRvFun]]
(((rendezvous,timeout)))

The `timeoutRv` function returns a `rendezvous` that will be available a certain number of milliseconds after the start of the `wait for`.
[listing]
timeoutRv has type (long)=&gt;rendezvous of ()

The timeout interval starts at some point after the `wait for` function has been entered; and it is guaranteed to be `available' some time _after_ the required number of milliseconds.
\begin{aside}
It is not possible to guarantee a precise timeout interval -- in the sense of some computation proceeding at exactly the right moment.

Thus, any time-sensitive computation triggered by `timeoutRv` should takes its own measurement of the `current' time when it is activated.
\end{aside}

\noindent
The `timeoutRv` is most often used in conjunction with other `rendezvous` functions;  typically a message receive or message send `rendezvous`.

For example, the expression:
[listing]
wait for chooseRv(list of [
  sendRv(Ch,"Hello"),
  timeoutRv(100)
]

represents an attempt to send the `"Hello"` message on the `Ch` channel; but the message send will be abandoned shortly after 100 milliseconds have elapsed.

=== The `atDateRv` Rendezvous Function
[[atDateRvFun]]
(((rendezvous,timeout)))
The `atDateRv` is similar to the `timeoutRv` rendezvous; except that instead of a fixed interval of milliseconds the timeout is expressed as a particular `date` value.
[listing]
atDateRv has type (date)=&gt;rendezvous of ()

The `atDateRv` will be triggered some time after the specified date.

== Channels and Messages
[[channels]]

A channel is a typed communications channel between `task`s. In order for a `task` to `send a message' to another `task`, they would share the channel object itself and then the receiver would use `recvRv` to wait for the message and the sender would use `sendRv` to send the message.

=== The `channel` Type
[[channelType]]

[listing]
channel has kind type of type;


Like the `rendezvous` and `task` types, the `channel` type is _opaque_.

=== The `channel` Function
[[channelFun]]

The `channel` function is used to create channels.
[listing]
channel has type for all t such that ()=&gt;channel of t

Each created channel may be used for sending and receiving multiple messages. However, the channel is typed; i.e., only messages of that type may be communicated.

Channels are multi-writer multi-reader channels: any number of tasks may be reading and writing to a channel. However, any given communication is between two tasks: one sender and one receiver.

If more than one `task` is trying to send a message then it is non-deterministic which message is sent. If more than one `task` is trying to receive a message then only one will get the message.

Message receives and sends may take place in either order. However, message communication is _synchronous_. I.e., both sender and receiver are blocked until a communication occurs.

An immediate implication of synchronous communication is that there is no buffer of messages associated with `channel`s.

=== Receive Message Rendezvous
[[recvRvFun]]
The `recvRv` function takes a `channel` and returns a `rendezvous` that represents a wait for a message on the `channel`.

[listing]
recvRv has type for all t such that (channel of t)=&gt;rendezvous of t


To actually receive a message on a channel, first the `rendezvous` must be created, then it must be `waited for', and then the message itself is extracted from the resulting `task`:
[listing]
Data is valof wait for recvRv(_Channel_)


As noted in &lt;&lt;channelFun&gt;&gt;, if more than one `task` is actively waiting for a message on the same channel then it is non-deterministic which `task` will `get' the first message. All other `task`s will continue to be blocked until a subsequent message is sent.

=== Send Message Rendezvous
[[sendRvFun]]
The `sendRv` function is used to send messages on `channel`s.

[listing]
sendRv has type for all t such that (channel of t,t)=&gt;rendezvous of ()


The result of a `sendRv` function is a `rendezvous`. Waiting on this `rendezvous` amounts to the attempt to send the message on the `channel`.

\begin{aside}
Note that the type of `rendezvous` returned by `sendRv` is
[listing]
rendezvous of ()

I.e., there is no `value' associated with a successful send message.
\end{aside}
</Text>
        </Document>
        <Document ID="D93BB00D-BB81-49A0-AD91-1AAD0DF43811">
            <Title>Alphanumeric Identifiers</Title>
            <Text>Identifiers in Star are based on the Unicode definition of identifier. For the ASCII subset of characters, the definition corresponds to the common form of identifier -- a letter followed by a sequence of digits and letters. However, non-ASCII characters are also permitted in an identifier.
AlphaNumeric::=LeadChar BodyChar...BodyChar
LeadChar::=LetterNumber
  | LowerCase
  | UpperCase
  | TitleCase
  | OtherNumber
  | OtherLetter
  | ConnectorPunctuation
BodyChar::=LeadChar
  | ModifierLetter
  | Digit
Alpha numeric Identifiers
The terms LetterNumber, ModifierLetter and so on; refer to standard character categories defined in Unicode.
[TIP] This definition of Identifier closely follows the standard definition of Identifier as contained in the Unicode specification.</Text>
        </Document>
        <Document ID="0BA10CC2-642B-4AE6-B143-500E667E0947">
            <Title>Expressions-35</Title>
            <Text>
==== Type Safety
The primary safety requirement for a `let` expression is that the statements that are defined within the body are type consistent. This is the same requirement for any theta environment.

The type of a `let` expression is the type of the bound expression.</Text>
        </Document>
        <Document ID="F5F7D09E-F3B0-47A8-B95D-4031666A062F">
            <Title>Scope of Type Variables</Title>
            <Text>All type variables have a scope which generally follows the scoping rules for normal variables.
There are two particular cases that are important: type variables introduced via TypeDefinitions and those introduced via explicitly quantified type expressions.
A variable introduced in the head of an AlgebraicType definition, or in the head of a Contract definition are in scope throughout the definition or contract respectively.
</Text>
        </Document>
        <Document ID="49F058A2-D1F2-4638-B343-F2616D810E32">
            <Title>Actions</Title>
            <Text>%!TEX root = reference.tex
= Actions
[[actions]]
(((action)))

An action is the performance of an operation in a particular context.

\begin{figure}[htbp]
\begin{eqnarray*}
[[Action]]Action::=&lt;&lt;NullAction&gt;&gt;\ |\ &lt;&lt;ActionBlock&gt;&gt;\\
  | &lt;&lt;LocalVariable&gt;&gt;\ |\ &lt;&lt;TypeAnnotation&gt;&gt;\\
  | &lt;&lt;Assignment&gt;&gt;\ |\ &lt;&lt;InvokeAction&gt;&gt;\ |\ &lt;&lt;IgnoreAction&gt;&gt;\\
  | &lt;&lt;ForLoop&gt;&gt;\ |\ &lt;&lt;WhileLoop&gt;&gt;\ |\ &lt;&lt;ConditionAction&gt;&gt;\\
  | &lt;&lt;SwitchAction&gt;&gt;\ |\ &lt;&lt;LetAction&gt;&gt;\\
  | &lt;&lt;ValisAction&gt;&gt;\ |\ &lt;&lt;AssertAction&gt;&gt;\\
  | &lt;&lt;AbortAction&gt;&gt;\ |\ &lt;&lt;TryAction&gt;&gt;
\end{eqnarray*}
.Action
[[actionFig]]
\end{figure}

==== Actions and Type Safety
[[actionTypeSafety]]
The meaning of type safety is somewhat different for actions than for expressions and functions: by definition, actions do not denote values in the way that expressions do.

However, type safety still applies to actions. In particular, different actions have different _type constraints_ that must be satisfied; for example, an assignment action is _type safe_ if the type of the variable is consistent with the expression and if the variable is a re-assignable variable.

We use the meta-predicate \safeinf{} to indicate that a particular action is type safe. An assertion of the form:
\[\typesafe{E}{A}\]
means that the action $A$ is type-consistent given the environment $E$. In fact, this predicate is equivalent to a normal type derivation involving the `()` type:
\[\typesafe{E}{A}\ \iff\ \typeprd{E}{A}{`()`}\]

== Binding Actions
Many actions are operators that change the state of one of more variables. However, some actions may bind variables -- that is, establish a new variable.

The most important binding actions are local variable definitions (&lt;&lt;localVar&gt;&gt;) and assignments (&lt;&lt;assignment&gt;&gt;).

=== Local Variable Definition
[[localVar]]
(((action,local variable)))
(((variables in actions)))

A local variable may be introduced within a block -- see &lt;&lt;blockAction&gt;&gt; -- using the same syntax as a variable declaration statement -- see &lt;&lt;VariableDeclaration&gt;&gt;.
\begin{aside}
It is named a local variable simply because it's scope is limited to the block of actions that contain the declaration.
\end{aside}
\begin{figure}[htbp]
\begin{eqnarray*}
[[LocalVariable]]LocalVariable::=`var`\ &lt;&lt;Identifier&gt;&gt;\ `:=`\ &lt;&lt;Expression&gt;&gt;\\
  | `def`&lt;&lt;Pattern&gt;&gt;\ `is`\ &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.Local Variable
[[localVariableFig]]
\end{figure}

The scope of a local variable declaration is from the local declaration itself to the end of the containing _ActionBlock_.

\begin{aside}
It is an error for a variable to be referenced within its own definition. Recursive definitions are not permitted as &lt;&lt;LocalVariable&gt;&gt;s.
\end{aside}

A local variable declared using the `var`...`:=` form is _re-assignable_; whereas a variable declared using the `def`...`is` form is not. The type of a re-assignable variable is a `ref`erence type (see &lt;&lt;referenceType&gt;&gt;). For example, given the &lt;&lt;LocalVariable&gt;&gt; declaration:
[listing]
X := 3

then the variable `X` has type `ref integer`.

If the left hand side of an `is` local variable definition is an identifier, or is an unterm, then the `var` prefix is not required. However, it is good practice to use `var` in situations that may be confusing.

\begin{aside}
Note that the left hand side of an `is` definition is a `Pattern`, not simply an `Identifier`. One primary use for this form is to allow the `unpacking' of function results. For example, the function `ddivide` returns a pair of values: the quotient and the remainder result of dividing the first argument by the second:
[listing]
ddivide(X,Y) is (X/Y,X%Y)

We can unpack the results of a call to `ddivide` using a &lt;&lt;TuplePattern&gt;&gt; on the left hand side of the declaration:
[listing]
def (Q,R) is ddivide(34,3)

which would have the effect of binding `Q` to 11, and `R` to 1.
\begin{aside}
The reason that we get `integer` division with this call to `ddivide` is that the arguments to `ddivide` -- `34` and `3` -- are `integer`. The slightly different call:
[listing]
def (FQ,FR) is ddivide(34.0,3.0)

relies on `float`int point `arithmetic` and results in binding `FQ` to 11.333333, and `FR` to 1.0.
\end{aside}
\end{aside}

\begin{aside}
Local variables may be reassigned by an assignment action anywhere _in the same_ block as the variable declaration itself. For example, the following, somewhat complex, scenario:
[listing]
valof\{
  var X := 0;
  def inc is (() do { X:=X+1; })
  valis X
\}

the assignment to `X` within the `inc` procedure is permitted; even though it  side-effect a variable not defined directly within the procedure.
\end{aside}

==== Declaring Variables
(((variable,declaration)))
The type of a &lt;&lt;Variable&gt;&gt; can be declared in an action sequence using a &lt;&lt;TypeAnnotation&gt;&gt; statement prior to the declaration itself:
[listing]
X has type ref integer;
var X := 3


==== Type Safety
A variable declaration is type safe if the type of the variable is the same as the type of the expression giving its value.
\begin{aside}
Of course, it is often the case that the type of a variable is determined from its declaration; so type safety is typically more an issue for other references to the variable identifier than for the variable declaration itself.
\end{aside}

\begin{prooftree}
\AxiomC{\typeprd{E}{Ex}{T}}
\AxiomC{\typeprd{E}{P}{T}}
\BinaryInfC{\typesafe{E}{`def` P\ `is`\ Ex}}
\end{prooftree}

\begin{prooftree}
\AxiomC{\typeprd{E}{Ex}{T}}
\AxiomC{\typeprd{E}{V}{`ref`\ T}}
\BinaryInfC{\typesafe{E}{`var`\ V\ `:=`\ Ex}}
\end{prooftree}

=== Assignment
[[assignment]]
(((action,assignment)))
(((assignment)))
The assignment action `:=` replaces the contents of a variable with a new value. For example:
[listing]
Count := Count+3

changes the value associated with the variable `Count` to `Count+3` -- where `Count+3` refers to the `old' value of `Count`.

There are a number of variations on the basic form of assignment; it is possible to `replace' an element of a `list` or an attribute of a record. However, semantically, all the different syntactic forms of assignment have a common root: that of changing a variable to have a different value.

Figures~\vref{assignmentFig}, \vref{recordTargetFig}, and \vref{IndexTargetFig} show the different syntactic forms of an assignment action.

\begin{aside}
Assignment is restricted to replacing the value of a `ref`erence typed variable or record field.
\end{aside}

\begin{figure}[htbp]
\begin{eqnarray*}
[[Assignment]]Assignment::=&lt;&lt;VariableAssignment&gt;&gt;\\
  | &lt;&lt;IndexedAssignment&gt;&gt;\\
  | &lt;&lt;RecordAssignment&gt;&gt;\\
[[VariableAssignment]]VariableAssignment::=&lt;&lt;Variable&gt;&gt;\ `:=`\ &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.Assignment Action
[[assignmentFig]]
\end{figure}

==== Type Safety
A variable assignment is safe iff the type of the variable is a `ref`erence type that is consistent with the expression denoting the variable's new value.

\begin{prooftree}
\AxiomC{\typeprd{E}{V}{`ref`\ T}}
\AxiomC{\typeprd{E}{Vl}{T}}
\BinaryInfC{\typesafe{E}{V` := `Vl}}
\end{prooftree}

=== Updating Records
[[recordUpdate]]
(((record values,update)))
(((update record values)))
An individual field of a record may be updated using the dot-notation on the left hand side of an assignment action -- provided that the type of the field is a `ref` type. In effect, assignment to a record field is permitted only if the field was marked as being updateable.

\begin{figure}[htbp]
\begin{eqnarray*}
[[RecordAssignment]]RecordAssignment::=&lt;&lt;Expression&gt;&gt;`.`&lt;&lt;Identifier&gt;&gt; `:=`\ &lt;&lt;Expression&gt;&gt;\\
\end{eqnarray*}
.Record Assignment[[recordTargetFig]]
\end{figure}


==== Type Safety
For a record update to be type safe, the field being updated must have `ref`erence type.

\begin{prooftree}
\AxiomC{\typeprd{E}{R}{T\sub{R}\ `where `T\sub{R}` implements \{`N` has type ref `T\sub{N}`\`}}}
\AxiomC{\typeprd{E}{V}{T\sub{N}}}
\BinaryInfC{\typesafe{E}{R`.`N\ `:=`\ V}}
\end{prooftree}
\begin{aside}
It is _not_ necessary for a variable holding the record to be itself re-assignable.
\end{aside}

=== Updating Indexable Collections
[[sequenceUpdate]]
(((sequences,update)))
(((update sequences)))
An `indexable` sequence may be updated using the square index notation on the on the left hand side of an assignment action.

\begin{figure}[htbp]
\begin{eqnarray*}
[[IndexedAssignment]IndexedAssignment::=&lt;&lt;Expression&gt;&gt;`[`&lt;&lt;Expression&gt;&gt;`]]``:=`\ &lt;&lt;Expression&gt;&gt;\\
  | `remove`\ &lt;&lt;Expression&gt;&gt;`[`&lt;&lt;Expression&gt;&gt;`]`
\end{eqnarray*}
.Index Assignment[[IndexTargetFig]]
\end{figure}

An assignment of the form:
[listing]
A[ix] := 34

is syntactic short-hand for
[listing]
A := A[with ix-&gt;34]

which, in turn, is shorthand for:
[listing]
A := _set_indexed(A,ix,34)


An assignment of the form:
[listing]
remove C[ix]

means to delete the identified element of the collection and is syntactic shorthand for the assignment:
[listing]
A := A[without ix]

which, in turn, is shorthand for:
[listing]
A := _delete_indexed(A,ix)


\begin{aside}
As noted in &lt;&lt;indexableContract&gt;&gt;, the sequence assignment is not restricted to sequences with `integer` indices. The same assignment statement also applies to `dictionary` updates.
\end{aside}

==== Type Safety
For an indexable update to be type safe, the left hand side of the assignment must refer to a variable with a `ref`erence type -- see &lt;&lt;referenceType&gt;&gt; -- and whose type implements the `indexable` contract -- see Program~\vref{indexableContractDef}.

\begin{prooftree}
\def\defaultHypSeparation{}
\AxiomC{\typeprd{E}{s}{`ref`\ S`where indexable over`\ S\ `determines`\ `(`K`,`V`)`}}
\AxiomC{\typeprd{E}{k}{K}}
\AxiomC{\typeprd{E}{v}{V}}
\TrinaryInfC{\typesafe{E}{s`[`k`]`\ `:=`\ v}}
\end{prooftree}


== Control Flow Actions
[[controlFlow]]

=== Action Block
[[blockAction]]
(((action,block)))
(((block action)))
An action block simply consists of a sequence of actions, separated by semicolons and enclosed within the pair of keywords `\{` and `\`}.

The actions in an action block are executed in sequence.

\begin{figure}[htbp]
\begin{eqnarray*}
[[ActionBlock]]ActionBlock::=`\{`\ &lt;&lt;Action&gt;&gt;\ `;`...`;` &lt;&lt;Action&gt;&gt;\ `\`}
\end{eqnarray*}
.Action Block
[[blockActionFig]]
\end{figure}

==== Scope
An &lt;&lt;ActionBlock&gt;&gt; represents a &lt;&lt;Scope&gt;&gt;. Any &lt;&lt;LocalVariable&gt;&gt;s that are defined within an &lt;&lt;ActionBlock&gt;&gt; are not defined outside the &lt;&lt;ActionBlock&gt;&gt;.

==== Type Safety
An action block is type safe if each of the actions within it are type safe.

\begin{prooftree}
\AxiomC{\typesafe{E}{A\sub1}}
\AxiomC{...}
\AxiomC{\typesafe{E}{A\subn}}
\TrinaryInfC{\typesafe{E}{`\{ `A\sub1;...;A\subn` \`}}}
\end{prooftree}

=== Null Action
[[nullAction]]
(((nothing@`nothing`)))

The `nothing` action does nothing. It is type safe by default.

\begin{figure}[htbp]
\begin{eqnarray*}
[[NullAction]]NullAction::=`nothing`\ |\ `\{\`}
\end{eqnarray*}
.Null Action
[[nullActionFig]]
\end{figure}

=== Let Action
[[letActionion]]
(((actions,let action@`let` action)))
(((let action@`let` action)))

A `let` action allows an action to be defined in terms of  auxiliary definitions.

\begin{figure}[htbp]
\begin{eqnarray*}
[[LetAction]]LetAction::=`let`\ &lt;&lt;thetaEnvironment&gt;&gt;\ `in`\ &lt;&lt;Action&gt;&gt;\\
  | &lt;&lt;Action&gt;&gt;\ `using`\ &lt;&lt;thetaEnvironment&gt;&gt;\\
\end{eqnarray*}
.Let Action
[[letActionFig]]
\end{figure}

(((theta environment)))
A `let` action (or its cousin the `using` action) consists of an action that is performed in the enhanced context of a set of auxiliary definition. It is directly analogous to the &lt;&lt;LetExpression&gt;&gt;.


==== Type Safety
The primary safety requirement for a `let` action is that the statements that are defined within the body are type consistent. This is the same requirement for any theta environment.

=== Procedure Invocation
[[invokeProcedure]]
(((action,invoke procedure)))
(((invoke procedure action)))
A procedure invocation is the invocation of an action procedure -- effectively a sub-routine call.


\begin{figure}[htbp]
\begin{eqnarray*}
[[InvokeAction]]InvokeAction::=&lt;&lt;Expression&gt;&gt;`(`\ &lt;&lt;Expression&gt;&gt;\sequence{,}&lt;&lt;Expression&gt;&gt;\ `)`
\end{eqnarray*}
.Procedure Invocation
[[invokeProcedureFig]]
\end{figure}


==== Type Safety
[[procedureApplyType]]
(((type,procedure invocation)))
An action procedure invocation is type safe if the types of the arguments of the application match the argument types of the action procedure.

\begin{prooftree}
\AxiomC{\typeprd{E}{`P`}{t\sub{P}}}
\AxiomC{\typeprd{E}{`A`}{t\sub{A}}}
\AxiomC{\entail{E}{t\sub{P}\subsume{}t\sub{A}`=&gt;()`}}
\TrinaryInfC{\typesafe{E}{`P A`}}
\end{prooftree}


==== Evaluation Order of Arguments
(((procedure invokation,evaluation order)))

There is _no_ guarantee as to the order of evaluation of arguments to a procedure invocation. In fact, there is no guarantee that a given expression will, in fact, be evaluated. This is similar to the situation with function application.

\begin{aside}
In order to better support parallel execution, it is quite possible that arguments to an procedure invocation are evaluated in parallel; or that their evaluation will be delayed until the value of the argument expression could make a difference to a computation.
\end{aside}

\begin{aside}
In general, the programmer should make the fewest possible assumptions about order of evaluation.
\end{aside}

=== Ignore Action
[[ignore]]
(((ignore,ignore action)))
(((ignore action)))
(((action that ignores result)))
An &lt;&lt;IgnoreAction&gt;&gt; is an action that simply ignores the value of its &lt;&lt;Expression&gt;&gt; argument.

\begin{figure}[htbp]
\begin{eqnarray*}
[[IgnoreAction]]IgnoreAction::=`ignore`\ &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.Ignore Action[[ignoreActionFig]]
\end{figure}

==== Type Safety
An `ignore` action is type safe if its ignore expression has a type.

\begin{prooftree}
\AxiomC{\typeprd{E}{Ex}{Tp}}
\UnaryInfC{\typesafe{E}{`ignore`\ Ex}}
\end{prooftree}

\begin{aside}
Clearly, the purpose of `ignore` is to capture the effect of evaluating an expression. One common purpose of `ignore` is to allow a function to be invoked as a procedure call.
\end{aside}

=== For Loop
[[forLoop]]
(((action,for loop@`for` loop)))
(((for loop action@`for` loop action)))
(((loop,for@`for`)))
A `for` loop is used to iterate over the elements of a collection. The collection may be of any of the standard `collection' types:  `list`, `cons` and `dictionary`.

\begin{figure}[htbp]
\begin{eqnarray*}
[[ForLoop]]ForLoop::=`for`\ &lt;&lt;Condition&gt;&gt;\ `do`\ &lt;&lt;Action&gt;&gt;
\end{eqnarray*}
.For Loop[[forLoopFig]]
\end{figure}
\noindent
For example, the loop:
[listing]
for ("j",X) in list of [ ("j","s"), ("k","t"), ("j","u") ] do
  logMsg(info,X);

results in log messages (see &lt;&lt;logMsg&gt;&gt;) being printed for `"s"` and `"u"` (but not for `"t"` because `("j",X)` does not match against `("k","t")`).

A variant of the `for` loop allows access to the `index' of the element being processed. For example, in the loop:
[listing]
for Ix-&gt;P in array of ["alpha", "beta", "gamma"] do
  logMsg(info,"P=$P, index=$Ix");

the variable `Ix` is successively bound to the index of the element being processed.

A `for` loop implies a _scope extension_: variables declared in the pattern have their scope extend to the body of the loop. In this case the variable `X` introduced in the pattern is available for use in the `logMsg` procedure call.

A particularly common case of for loop is the numeric for loop:
[listing]
for Ix in range(0,10,1) do
  logMsg(info,"$Ix")

This will result in the integers 0 through 9 being displayed on the log.

==== Type Safety
A `for` loop is dependent on the `iterable` contract (see &lt;&lt;iterableContract&gt;&gt;; the type safety rules reflect this:
\begin{prooftree}
%\insertBetweenHyps{\hskip 0pt}
\alwaysNoLine
\AxiomC{\typeprd{E}{C}{T\sub{C}\ `where iterable over `T\sub{C}` determines (`T\sub{ix}, T\sub{P}`)`}}
\def\extraVskip{1ex}
\UnaryInfC{{\typeprd{E}{P}{T\sub{P}} {\hskip 2.5in} \typesafe{E$\cup$varsin(P)}{Body}}}
\alwaysSingleLine
\UnaryInfC{\typesafe{E}{`for `P\ `in`\ C\ ` do `Body}}
\end{prooftree}

`for` loops using the indexed form depend on `indexed\_iterable`:
\begin{prooftree}
\alwaysNoLine
\AxiomC{\typeprd{E}{C}{T\sub{C}\ `where indexed\_iterable over `T\sub{C}` determines (`T\sub{ix}, T\sub{P}`)`}}
\def\extraVskip{1ex}
\UnaryInfC{{\typeprd{E}{P}{T\sub{P}} {\hskip 1in} {\typeprd{E}{Ix}{T\sub{Ix}}}{\hskip 1in}\typesafe{E$\cup$varsin(P)}{Body}}}
\alwaysSingleLine
\UnaryInfC{\typesafe{E}{`for `Ix` -&gt; `\ P\ `in`\ C\ ` do `Body}}
\end{prooftree}


=== While Loop
[[whileLoop]]
(((action,while loop@`while` loop)))
(((while loop action@`while` loop action)))
(((loop,while@`while`)))

The `while` loop is used to repetitively evaluate a condition. The loop continues execution for so long as the governing &lt;&lt;Condition&gt;&gt; is satisfiable.

\begin{figure}[htbp]
\begin{eqnarray*}
[[WhileLoop]]WhileLoop::=`while`\ &lt;&lt;Condition&gt;&gt;\ `do`\ &lt;&lt;Action&gt;&gt;
\end{eqnarray*}
.While Loop
   [[whileLoopFig]]
\end{figure}

A `while` loop only makes sense if there is a possibility of successive iterations of the body causing a change of state that would make the condition unsatisfiable. A common paradigm for this is the class of _relaxation_ algorithms: algorithms that continue until nothing changes:
[listing][escapechar=|]
var done := false;
while not done do{
  done := true;
  if |...| then
    done := false;
}


Like the `for` loop, a `while` loop also implies a scope extension. Variables defined within the governing condition are available for use within the body of the loop.
\begin{aside}
During each iteration of the `while` loop, only the first `solution' to the governing &lt;&lt;Condition&gt;&gt; is `used' and can therefore result in bindings of variables.
\end{aside}

==== Type Safety
The governing condition must be _satisfied_. Other than that, a `while` loop is type safe if the body is type safe.

\begin{prooftree}
\AxiomC{\typesat{E}{C}}
\AxiomC{\typesafe{E$\cup$varsin(C)}{Body}}
\BinaryInfC{\typesafe{E}{`while `C` do `Body}}
\end{prooftree}

=== Conditional Action
[[ifThenElse]]
(((action,conditional action)))
(((conditional action)))
(((if then else@`if` `then` `else` action)))

A conditional action is a straightforward `if`...`then`...`else` action: if the governing condition is satisfied the `then` branch is taken; otherwise the `else` branch is taken. The `else` branch is optional in a conditional action; if not present then no action is taken if the condition is not `true`.

\begin{figure}[htbp]
\begin{eqnarray*}
[[ConditionalAction]ConditionalAction::=`if`\ &lt;&lt;Condition&gt;&gt;\ `then`\ &lt;&lt;Action&gt;&gt;\ [\ `else`\ &lt;&lt;Action&gt;&gt;\ ]]
\end{eqnarray*}
.Conditional Action[[conditionalActionFig]]
\end{figure}

\begin{aside}
The `test' part of a conditional action takes the form of a _Condition_. This implies that the test may bind variables -- those variables are in scope within the `then' action but are not in scope for the `else' action.
\end{aside}
\begin{aside}
In general, a condition may be satisfied in many different ways. The conditional action only looks for the `first' way of satisfying the condition.
\end{aside}

For example, we can use a &lt;&lt;Search&gt;&gt; condition to verify that an element is in a collection. The fragment:
[listing][escapechar=|]
if {name="j"; amount=X} in Scores then
  |&lt;&lt;Action&gt;&gt;|

tests to see if there is an entry that matches `\{name="j"; amount=X\`} in the `Scores` collection; and, if there is, binds the variable `X` appropriately within `_Action_`.

==== Type Safety
A conditional action is type safe if the condition is safe, and if both the branches are type safe.

\begin{prooftree}
\AxiomC{\typesat{E}{C}}
\AxiomC{\typesafe{E$\cup$varsin(C)}{Th}}
\AxiomC{\typesafe{E}{El}}
\TrinaryInfC{\typesafe{E}{`if `C` then `Th` else `El}}
\end{prooftree}


=== Switch Actions
[[SwitchAction]]
(((action,switch@`switch`)))
(((switch action@`switch` action)))

A `switch` action uses a selector expression and a set of action rules to determine which action to perform.
\begin{aside}
As with `switch` expressions (see &lt;&lt;caseExpression&gt;&gt;). `switch` actions are often constructed during the process of compiling other kinds of program.
\end{aside}

\begin{figure}[htbp]
\begin{eqnarray*}
[[SwitchAction]]SwitchAction::=`switch`\ &lt;&lt;Expression&gt;&gt;\ `in`\ &lt;&lt;SwitchActionBody&gt;&gt;\\
[[SwitchActionBody]]SwitchActionBody::=`\{`&lt;&lt;ActionArm&gt;&gt;\sequence{`;`}&lt;&lt;ActionArm&gt;&gt;`\`}\\
[[ActionArm]]ActionArm::=`case`\ &lt;&lt;Pattern&gt;&gt;\ `do`\ &lt;&lt;Action&gt;&gt;\\
  | `case`\ &lt;&lt;Pattern&gt;&gt;\ `default`\ `do`\ &lt;&lt;Action&gt;&gt;
\end{eqnarray*}
.Switch Action
[[SwitchActionFig]]
\end{figure}

The `selector' expression is evaluated, and then, at most one of the &lt;&lt;SwitchAction&gt;&gt;s is selected based on whether the &lt;&lt;Pattern&gt;&gt; matches or not. If one of these does match, then the corresponding &lt;&lt;Action&gt;&gt; on the right hand side is performed.

If none of the &lt;&lt;ActionArm&gt;&gt;'s case patterns match, and if a `default` &lt;&lt;Action&gt;&gt; is specified, then that action is performed. If a `default` is not specified then `nothing` is performed.

Program~\vref{treeWalkProg} shows an example of using a `case` action to walk a tree in left-to-right ordering.
\begin{program}
[listing]
type tree of t is empty or node(tree of t, t, tree of t);

walk has type for all t such that (tree of t, (t)=&gt;())=&gt;()
prc walk(T,P) do {
  switch T in {
    case empty do nothing;
    case node(L,Lb,R) do {
      walk(L,P);
      P(Lb); -- visit the node
      walk(R,P)
    }
  }
};

.A Left-to-Right Tree Walk Program[[treeWalkProg]]
\end{program}


Each &lt;&lt;ActionArm&gt;&gt;'s pattern may introduce variables; these variables are `in scope' only for the corresponding case action.

Optionally, a `case` action may have a `default` clause. If none of the cases in the &lt;&lt;SwitchActionBody&gt;&gt; match then the `default` case is performed. If there is no `default` clause, then if none of the cases match `nothing` is performed -- and execution continues with the next action.


\paragraph{Evaluation Order}
The &lt;&lt;ActionArm&gt;&gt;s in a &lt;&lt;SwitchAction&gt;&gt; are tried in the order that they are written -- with the exception of any `default` &lt;&lt;ActionArm&gt;&gt; -- which is guaranteed to be attempted only if all others do not apply.

==== Type Safety
The type safety requirements of a `case` action are that the types of the patterns of each &lt;&lt;ActionArm&gt;&gt; are the same, and are the same as the selector expression. In addition, the right hand sides of the &lt;&lt;ActionArm&gt;&gt;s should also be consistently typed.

\begin{prooftree}
\AxiomC{\typeprd{E}{S}{T}}
\AxiomC{\typeprd{E}{P\subi}{T}}
\AxiomC{\typesafe{E$\cup{}$varsIn(P\subi)}{A\subi}}
\TrinaryInfC{\typesafe{E}{`switch`\ S\ `in\{``case`P\sub1\ `do`\ A\sub1\sequence{;}`case`P\subn\ `do`\ A\subn\ `\`}}}
\end{prooftree}

In the case that there is a `default` clause, then that too must be type safe:
\begin{prooftree}
\AxiomC{\typeprd{E}{S}{T}}
\AxiomC{\typeprd{E}{P\subi}{T}}
\AxiomC{\typesafe{E$\cup{}$varsIn(P\subi)}{A\subi}}
\TrinaryInfC{\typesafe{E}{`switch`\ S\ `in\{`...`; case` P\subn\ `default do` A\subn`;`...`\`}}}
\end{prooftree}

=== Valis Action
[[valisAction]]
(((action,valis@`valis`)))
(((valis action@`valis` action)))
(((returning value to `valof` expression)))

The `valis` action determines the value of the nearest textually enclosing  &lt;&lt;ValueExpression&gt;&gt;.

\begin{figure}[htbp]
\begin{eqnarray*}
[[ValisAction]]ValisAction::=`valis`\ &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.Valis Action
[[valisActionFig]]
\end{figure}

On executing the `valis` action, the corresponding &lt;&lt;ValueExpression&gt;&gt; `completes' -- no further actions within the &lt;&lt;ValueExpression&gt;&gt; are executed.


\begin{aside}
The `valis` action has special significance within a &lt;&lt;ComputationExpression&gt;&gt;. There the &lt;&lt;ValisAction&gt;&gt; becomes syntactic sugar for an occurrence of the `\_encapsulate` function.
\end{aside}

=== Assert Action
[[assert]]
(((action,assert action)))
(((assert action)))
(((checking code with assertions)))
An _AssertAction_ is an action that simply verifies that a particular condition is satisfied. If the assertion is not satisfiable then execution will terminate.

\begin{figure}[htbp]
\begin{eqnarray*}
[[AssertAction]]AssertAction::=`assert`\ &lt;&lt;Condition&gt;&gt;
\end{eqnarray*}
.Assert Action[[assertActionFig]]
\end{figure}

\begin{aside}
It is possible to control whether or not assertions are actually executed -- without modifying the source of the program.
\end{aside}


==== Type Safety
An assert action is type safe if the condition is satisfiable.

\begin{prooftree}
\AxiomC{\typesat{E}{C}}
\UnaryInfC{\typesafe{E}{`assert`\ C}}
\end{prooftree}

== Exceptions and Recovery
[[exceptions]]
Exceptions represent a way of capturing the non-normal flow of computation. Where a computation may _fail_ this may be denoted by an `exception` being `raise`d during the computation. Raised exceptions may be captured by means of an `on abort` handler.
\begin{aside}
Exceptions and abort handling features are an important tool for expressing non-regular flows of computation. However, excessive use of this feature may result in programs that are hard to read.
\end{aside}

=== The `exception` Type
[[exceptionType]]
(((exception type@`exception` type)))
(((type,exception@`exception`)))
Exceptions and their handling center on the `exception` type. When an exception is `raise`d, there is an opportunity to communicate a value to the handling code; the `exception` is the means by which this is done.

The definition of the `exception` type is given in Program~\vref{exceptionDef}.
\begin{program}
[listing]
type exception is exception(string,any,location)

.The definition of the standard `exception` type[[exceptionDef]]
\end{program}

The first element of the `exception` constructor is intended to be used as a form of code: it is a string that represents the kind of exception. For internally generated errors, the value of this code is the string `"error"`. For user-defined programs, if no value is given to the code then `nonString` is used.

The second element of the `exception` constructor is an arbitrary exception signal. It is of type `any` -- which suggests that it may be any value; however, in most cases, the exception signal is actually a `string`.

The third element of the `exception` constructor is a `location` value. This is typically the source location within the program that gave rise to the exception.

=== Abort Action
[[raiseAction]]
(((raise an exception)))
(((abort computation)))
(((actions,abort with`abort with`)))
The `abort with` action is used to signal that the current computation should terminate abnormally. The form of the `abort with` is given in &lt;&lt;abortWithFig&gt;&gt;.


\begin{figure}[htbp]
\begin{eqnarray*}
[[AbortAction]]AbortAction::=`abort with`\ &lt;&lt;Expression&gt;&gt;\\
\end{eqnarray*}
.Raise Expression Action
[[abortWithFig]]
\end{figure}

The type of the `abort expression' depends on the context. In the case of a computation expression (see &lt;&lt;computation&gt;&gt;), the argument must have a type consistent with the error type of the governing monad.

In the case of an `abort with` occurring outside of computation expressions, the type should be `exception`.

For example, in the context:
[listing]
good computation {
  abort with "A message"
}

The type of the expression associated with the `abort with` should be `string`. This is because the implementation signature for the `good` monad is:

[listing]
implementation (computation) over good determines string is ...


=== Abort Handling Action
[[except]]
(((actions,exception handling)))
(((handling exceptions)))
(((try action@`try` action)))
The `try` ...{} `on abort` action allows recovery from actions and expressions that cause exceptions.
\begin{figure}[htbp]
\begin{eqnarray*}
[[TryAction]]TryAction::=`try`\ &lt;&lt;Action&gt;&gt;\ `on abort`\ &lt;&lt;SwitchActionBody&gt;&gt;
\end{eqnarray*}
.Try Action
[[tryActionFig]]
\end{figure}

If an exception is caused during the execution of the protected &lt;&lt;Action&gt;&gt; then the handler in entered. This handler takes the form of the body of a &lt;&lt;SwitchAction&gt;&gt; -- i.e., is a sequence of recovery clauses, each of which is a &lt;&lt;ActionArm&gt;&gt;. The pattern part of the recovery clause is matched against the exception value; and the first pattern that matches is used to recover from the exception.

Exceptions are caused either by an error condition -- such as when the equations of a function fail to match a call -- or by an explicit invocation of the `raise` action/expression.

For example, in the fragment:
[listing]
try{
  def A is first(nil); -- Will raise an exception
  logMsg(info,"A is $A");
} on abort {
  case E do logMsg(info,"Had exception: $E");
}

the evaluation of `first(nil)` will fail because `nil` is empty. As a result, the rest of the &lt;&lt;Action&gt;&gt; it is embedded in is aborted and execution continues with the recovery clause.

==== Type Safety
An `try` action is type safe if both arms of the action are safe.

\begin{prooftree}
\AxiomC{\typesafe{E}{P}}
\AxiomC{\typesafe{E}{X}}
\BinaryInfC{\typesafe{E}{`try`\ P\ `on abort`\ X}}
\end{prooftree}
</Text>
        </Document>
        <Document ID="BDE0B138-855B-4E18-BEEE-56DB2EF25846">
            <Title>String Literals</Title>
            <Text>The string type is used to denote string values.
String::=StringLiteral
String Expression
The simplest form of string literal is a sequence of characters enclosed in double-quotes.
In addition, quoted strings may include interpolation expressions -- which are embedded expressions whose values are interpolated into the actual string value.</Text>
        </Document>
        <Document ID="70A256C9-FC97-4114-9325-5F7B61F7278B">
            <Title>Grammar</Title>
            <Text>The grammar of Star is based on a notation which makes extensibility easier to achieve. Thus, at the core, the grammar is very simple and straightforward -- it is based on an operator precedence grammar.
[TIP] This choice gives us two key benefits: it is simple to understand and it is simple to extend.
However, it also makes certain other aspects more challenging. In particular, an operator precedence grammar knows less about the program as it is parsed. This means that syntax errors are liable to less informative.</Text>
        </Document>
        <Document ID="9D2B5BA6-E77C-42D4-86FD-CBFF0B23F986">
            <Title>Singleton Tuple Type</Title>
            <Text>A singleton tuple must be written with two parentheses. This is to disambiguate such terms from simple expression parentheses. A type expression of the form:
(integer)
is equivalent to just the integer type; whereas
((integer))
denotes the single element tuple type whose element type is integer.
[NOTE:] This does not apply in all contexts. Especially when the tuple type is part of a function type — it is not necessary to wrap the single argument type in double parentheses:
(string)=&gt;integer
However, if the single argument of a function type is also a singleton tuple, then that needs to be double-parenthesised:
((string))=&gt;integer
This denotes the type of a single argument function — returning an integer from a singleton tuple containing a string.




</Text>
        </Document>
        <Document ID="93C0E12D-83AE-49DE-A12F-BE8141C03EE6">
            <Title>What is a Type?</Title>
            <Text>A Type is an expression that denotes a set of values.
[TIP] Although a type is an expression, type expressions should not be confused with normal expressions. Types play no part in evaluation.
Viewed as sets, types have some particular properties: no value may be a member of more than one type set; all values are members of exactly one type set.
A TypeDefinition introduces a new type and defines what values belong to the type. A TypeAnnotation is an assertion that a particular expression -- usually a variable -- has a certain type.
For many simple cases, a type is denoted by an identifier. For example, the type identifier string denotes the set of all strings. More explicitly, a value has type string iff it belongs to the set denoted by the symbol string.
Many value-sets are effectively infinite in size: the size of the set of strings is essentially unbounded; as is the set of integer values.
In addition to sets of values denoted by identifiers; there are other kinds of value sets that have more complex type expressions. For example, the set of tuples is denoted not by a single type expression but a schema of type expressions -- each taking a form such as:
(t1,..,tn)
For example, the type expression
(integer)=&gt;string
denotes the set of functions that take a unary tuple — containing integer as an argument and produce a string value. Like the set of all integers, this set is also infinite in size.
The language for denoting types is quite expressive. It is possible to have types that are parameterized; that is they are composed from other type expressions. It is also possible to have types that are not explicitly named but are defined by constraints.
A simple example of a parameterized type is the `cons` type: a `cons` type expression always involves the mention of another type -- the type of elements of the list. The type expression
cons[string]
denotes the type expression associated with lists whose elements are all string values. Other examples of cons type include lists of integers:
cons[integer]
and even lists of lists of string valued functions:
cons[cons[(integer)=&gt;string]]
[NOTE] Technically, the `cons` symbol in:
cons[integer]
is a TypeConstructor: it takes a type as an argument and returns another type as result.
Often it is convenient to be able to `talk' about types without being specific about the type itself; for this purpose we use TypeVariables.
A type variable is distinguished by an explicit quantifier -- either a UniversalType or a ExistentialType. The type expression:
all t ~~ cons[t]
denotes a cons list type of some unspecified element type -- identified by the type variable t.
[TIP] The value set associated with this type expression is a little more difficult to visualize than the set of lists of integers (say). cons[t] denotes a set of cons values; but without more information we cannot say what the complete values look like -- it is dependent on the meaning of the type variable t.
In order to properly understand the interpretation of a type variable one must understand how the type variable is bound. In general, there are three possibilities: the type variable may be identified with (equal to) another type; the type variable may be bound by a universal quantifier or by an existential quantifier.
A universally quantified type (see universalType) denotes a type that allows all possible instantiations for the type variable. For example, function types often involve universal types. A universally typed function is expected to work `for all values' of the type variable -- which, in turn, means that the function definition can make no assumptions about the actual type.
Existentially quantified types (see existentialType) are  used to denote abstract types; i.e., the existential quantifier signals that there is a type that should be treated as an opaque black box.</Text>
            <Comments>The term "iff" means "if and only if".</Comments>
        </Document>
        <Document ID="422DFBEE-0A35-4352-881D-1AB4A494CF5A">
            <Title>Type Constraints</Title>
            <Text>A TypeConstraint is a constraint on a Type; usually implying a constraint on the possible binding of a TypeVariable. For example, a Contract refers to a named collection of functions and a TypeVariable constrained by a ContractConstraint means that any concrete instantiation of the TypeVariable must be to a Type that implements the Contract — or more accurately, there must be an implementation of the contract that satsifies the Type.
Similarly, a FieldConstraint constrains the TypeVariable so that any binding must be to a Type that has the named field in its definition.
For example, using arith as a constraint allows us to say `the type can be anything that implements a form of arithmetic'. The type expression:
arith[t] |: t
denotes this kind of constrained type.
[NOTE] It is possible to view a type variable binding itself as a form of constraint: if we bind the type variable t to the type integer then we are constraining the type t to be equal to integer.
TypeConstraint ::= ContractConstraint
  | FieldConstraint
  | InstanceConstraint
  | TupleConstraint
  | TypeConstraint ,.., TypeConstraint
Type Constraints
A type expression of the form:
comparable[t], arith[t] |: (t)=&gt;t
denotes a unary function type for any type that implements both the comparable and the arith contracts.
[NOTE] In many cases type inference will automatically result in constraints being added to type expressions.
It is possible mix different forms of TypeConstraint; for example, if a TypeVariable must be bound to a type that implements the comparable contract as well as having the integer-typed ident attribute, the type expression:
comparable[t], t &lt;~ { ident:integer }
captures this.
[NOTE] If a constrained type variable is unified with another type variable, then the constraints of the two variables are merged. It may be that such a merging of constraints is not possible; in such a case, the unification will fail and the type variables are not compatible.
</Text>
        </Document>
        <Document ID="AB8A74F2-F4AE-405B-A802-4EA4292C55BB">
            <Title>Expressions-13</Title>
            <Text>
=== Constructor Literals
[[positionalConstructor]]
(((expression,positional constructor)))
(((positional constructor literal)))
&lt;&lt;ConstructorLiteral&gt;&gt; expressions denote data constructor values. In particular, it refers to constructors that are introduced in an algebraic &lt;&lt;TypeDefinition&gt;&gt;.
\begin{figure}[htbp]
\begin{eqnarray*}
[[ConstructorLiteral]]ConstructorLiteral::=&lt;&lt;Identifier&gt;&gt;`(`&lt;&lt;Expression&gt;&gt;`,`...`,`&lt;&lt;Expression&gt;&gt;`)`
\end{eqnarray*}
.Constructor Literal Expression
[[positionalConstructorFig]]
\end{figure}
This definition also determines the valid types of the arguments to the constructor. For example, the type definition:
[listing]
type address is noWhere or someWhere(string,integer,string)

defines `someWhere` as the identifier of a &lt;&lt;ConstructorLiteral&gt;&gt; and any instance must have exactly three arguments: a `string`, an `integer` and a `string`.

\paragraph{Accessing Elements of a Constructor Literal}
(((positional constructor literal,accessing elements)))
The only way that elements of a &lt;&lt;ConstructorLiteral&gt;&gt; can be _accessed_ is via a pattern match -- see &lt;&lt;posConPattern&gt;&gt;. For example, given the definition of `address` above, we can `unpack' its argument using a pattern such as in
[listing]
city(someWhere(City,_,_)) is City</Text>
        </Document>
        <Document ID="F6653431-CE4A-4FD4-9C07-1D93E0E3422E">
            <Title>Functional Dependencies</Title>
            <Text>For certain forms of contract, it may be that the type parameters may not all be independent of each other. For example, consider the standard iterable contract which reads:
contract all coll, el ~~ iterable[coll -&gt;&gt; el] ::= {
  iterate: all r ~~
      (coll,(el,IterState[r])=&gt;IterState[r],IterState[r]) =&gt;
        IterState[r];
}
The intention of the iterable contract is to support processing collections of elements in a sequential manner. The type parameter coll identifies the collection to be iterated over; and the type parameter el identifies the type of each element.
However, the collection's type uniquely determines the type of each element: the element type is not independent of the collection. For example, to iterate over a cons[t], each element will be of type t; and to iterate over a string each element will be a integer even though the string type does not mention integer.
[NOTE] Each integer represents a unicode code point in the string.
Using a -&gt;&gt; clause in a contract -- and in corresponding contract implementation statements -- allows the contract designer to signal this relationship.</Text>
        </Document>
        <Document ID="71BD6E9F-56F0-4795-B08D-2045B6D3C05B">
            <Title>Term Constructor</Title>
            <Text>A term constructor expression or pattern is written in the style of a function call. The specification of the term constructor uses types in argument positions to denote the type of the corresponding argument.
TermConstructor ::= Identifier `(` Type ,.., Type `)`
Term Constructor
For example, a type definition for wrapping return values with an error code could have a definition:
all t ~~ returnType[t] ::= error(string) | ok(t)
A function returning a value of type returnType would either return ok(value) or error("message"), where the message explained the error.
TermConstructors are well suited to situations where the number of arguments is limited and fairly obvious.
[NOTE] Any type variables that are referred to within a TermConstructor constructor must be bound by explicit quantifiers.
</Text>
        </Document>
        <Document ID="24F108CD-382E-4B9C-8839-B8FA64415FAA">
            <Title>Expressions-46</Title>
            <Text>
=== Type Coercion Expression
[[typeCoercionExpression]]
[[typeCoercionContract]]
(((expressions,type coercion)))
(((type coercion expression)))
A &lt;&lt;TypeCoercion&gt;&gt; expression denotes a conversion of a value from one type to another.

\begin{figure}[htbp]
\begin{eqnarray*}
[[TypeCoercion]]TypeCoercion::=`(`&lt;&lt;Expression&gt;&gt;\ `as`\ &lt;&lt;Type&gt;&gt;`)`
\end{eqnarray*}
.Type Coercion Expression
[[typeCoercionExpressionFig]]
\end{figure}

The primary difference between _type casting_ and _type coercion_ is that the former can never result in any change in the value under consideration. For example, coercing a `float` value to an `integer` value has the potential to change the value (stripping any fractional part of the value).

Type coercion is supported by a special `coercion` &lt;&lt;Contract&gt;&gt; shown in Program~\vref{typeCoercionContractFig}.

\begin{program}
[listing]
contract coercion over (s,t) is {
  coerce has type (s)=&gt;t
};

[[typeCoercionContractFig]]
.Coercion Contract `coercion`
\end{program}

\begin{aside}
Specifically, an expression of the form:
[listing]
X as integer

is equivalent to the expression:
[listing]
(coerce(X) has type integer)

where the `... has type integer` has the effect of declaring that the expression has type `integer` and the `coerce` function is an overloaded function that references a type-specific implementation -- based on the source type of `X` and `integer`.
\end{aside}

There are many standard coercions available, as listed in &lt;&lt;standardCoercions&gt;&gt;. However, it is also possible for a programmer to define their own type coercion by appropriately implementing the `coercion` contract.


\begin{table}
.Standard Type Coercions[[standardCoercions]]
\begin{center}
\begin{tabular}{|ll|ll|ll|}
\hline
Source Type&amp;Target Type&amp;Source&amp;Target&amp;Source&amp;Target\\
\hline
`string`&amp;`integer`&amp;
`integer`&amp;`string`&amp;
`string`&amp;`long`\\
`long`&amp;`string`&amp;
`string`&amp;`fixed`&amp;
`fixed`&amp;`string`\\
`string`&amp;`float`&amp;
`float`&amp;`string`&amp;
`string`&amp;`decimal`\\
`decimal`&amp;`string`&amp;
`integer`&amp;`long`&amp;
`integer`&amp;`fixed`\\
`integer`&amp;`float`&amp;
`integer`&amp;`decimal`&amp;
`long`&amp;`integer`\\
`long`&amp;`fixed`&amp;
`long`&amp;`float`&amp;
`long`&amp;`decimal`\\
`float`&amp;`integer`&amp;
`float`&amp;`long`&amp;
`float`&amp;`fixed`\\
`float`&amp;`decimal`&amp;
`decimal`&amp;`integer`&amp;
`decimal`&amp;`long`\\
`decimal`&amp;`fixed`&amp;
`decimal`&amp;`float`&amp;&amp;\\
\hline
\end{tabular}
\end{center}
\end{table}
</Text>
        </Document>
        <Document ID="63471DC7-1037-483B-846D-E369D047C708">
            <Title>Expressions-29</Title>
            <Text>
=== Substitutions in a Collection
It is possible to denote the collection obtained by _substituting_ an element -- or deleting an element -- with expressions such as:
[listing]
C[with Kx-&gt;Vx]

and
[listing]
C[without Kx]

which represent
[listing]
_set_indexed(Cx,Kx,Vx)

and
[listing]
_delete_indexed(Cx,Kx)

respectively.

=== Slicing Collections
A more powerful form of accessing single elements from a collection is the _slice_ notation. A slice expression takes the form:
[listing][escapechar=|]
|_C_|[|_From_|:|_To_|]

which denotes the subset of elements `starting' at `_From_` and `ending' (but _not_ including) with `_To_`.

The special variant:
[listing][escapechar=|]
|_C_|[|_From_|:]

denotes all the remaining elements of the collection after `From`.

\begin{aside}
Related to the indexing and slicing expressions are the indexed assignments -- as can be seen in &lt;&lt;sequenceUpdate&gt;&gt;.
\end{aside}

== Function Application Expressions
[[functionApplication]]
(((expressions,function application)))
(((function application expression)))

A function application expression `applies' a function to zero or more arguments.

\begin{figure}[htbp]
\begin{eqnarray*}
[[ApplicativeExpression]]ApplicativeExpression::=&lt;&lt;Expression&gt;&gt;`(`&lt;&lt;Expression&gt;&gt;\sequence{,}&lt;&lt;Expression&gt;&gt;`)`
\end{eqnarray*}
.Function Application Expression
[[applicativeExpressionFig]]
\end{figure}

It is quite normal for the function expression being applied to arguments itself to be the result of a function application. For example, given the function `double`:
[listing]
double has type for all s such that (((s)=&gt;s))=&gt;((s)=&gt;s)
double(F) is (X) =&gt; is F(F(X))

we can apply `double` to `inc`:
[listing]
inc has type (integer)=&gt;integer
inc(X) is X+1;

to get an expression such as:
[listing]
double(inc)(3)

which has value 5.</Text>
        </Document>
        <Document ID="D0250BAA-FB14-430E-B947-FA237E0107AE">
            <Title>Type Variables</Title>
            <Text>A type variable is a variable which may be bound to a type. Depending on whether the scope of a type variable is explicitly determined or implicitly determined, type variables are written as regular identifiers -- they are distinguished from regular named types by virtue of the quantifier they are bound by.
TypeVariable ::= Identifier
Type Variables</Text>
        </Document>
        <Document ID="C0742924-A3E8-4962-8E87-EE987C4B5C99">
            <Title>Expressions-25</Title>
            <Text>
=== Option Field Access -- `?.`
[[optionChaining]]
(((?. operator@`?.` operator)))
(((accessing an optional value)))
(((option chaining)))

The `?.` operator can be used similarly to a normal record field access (see \vref{dotAccess}) except that it takes an `option`al argument and returns an `option` value.

\begin{figure}[htbp]
\begin{eqnarray*}
&lt;&lt;RecordAccess&gt;&gt;&amp;\arrowplus&amp;&lt;&lt;Expression&gt;&gt;\ `?.`\ &lt;&lt;Identifier&gt;&gt;
\end{eqnarray*}
.Optional Record Access Expression[[optionAccessFig]]
\end{figure}

The form of a optional field access is also similar to the field access; an expression of the form:
[listing]
A?.F

will access the `F` field from the wrapped record value in `A`. The result type of a option field access is also an `option`al.

For example, suppose that `R` has the type given by
[listing]
R has type option of Person


Its type can be approximated by (the difference is that field labels are not themselves functions):
[listing]
(?.) has type for all r,s such that
  (option of r,(r=&gt;s))=&gt;option of s

I.e., it has a similar type to the `map` function (see \vref{mapFunction}) in the `mappable` contract.

However, it is actually best understood as a macro form. The macro definition of `?.` can be given in a single line macro:
[listing]
#?R ?. ?F ==&gt; map((RR)=&gt;RR.F,R)

where `map` is the implementation of the `mappable` contract for the `option` type.

=== Default Option Expression -- `or else`
[[optionDefltChain]]
(((or else operator@`or else` operator)))
(((accessing an optional value with default)))
(((option chaining)))

The `or else` operator can be used to unwrap an `option`al value -- giving a default in the case that it is actually `none`

\begin{figure}[htbp]
\begin{eqnarray*}
&lt;&lt;Expression&gt;&gt;&amp;\arrowplus&amp;&lt;&lt;Expression&gt;&gt;\ `or else`\ &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.Optional Chaining with Default[[optionIndexAccessFig]]
\end{figure}

The form of a optional access is:
[listing]
O or else D

where `O` has type `option of t` and `D` has type `t`. If `O` has value `some(X)` then the value is `X`, otherwise it is `D`.

Like `?.`, `or else` can be best understood as a macro:
[listing]
# ?O or else ?D ==&gt; _optionDeflt(O,()=&gt;D)
_optionDeflt(some(X),_) is X
 |  _optionDeflt(none,D) is D()

Notice that the default expression is not evaluated unless the value of `O` is `none`.

The `or else` operator is right associative. This means that they can be chained  together if more than one default is possible:
[listing]
A or else B or else C</Text>
        </Document>
        <Document ID="88C5C62F-96B9-4885-8646-C47A483393C6">
            <Title>Expressions-20</Title>
            <Text>
=== Theta Records
[[thetaRecords]]
(((record literal,theta)))
(((theta record)))

A &lt;&lt;ThetaRecord&gt;&gt; is a record whose contents is specified by means of a &lt;&lt;thetaEnvironment&gt;&gt;. There are variants corresponding to labeled and anonymous records.
\begin{figure}[htbp]
\begin{eqnarray*}
[[ThetaRecord]ThetaRecord::=[&lt;&lt;Expression&gt;&gt;]]`\{`&lt;&lt;Definition&gt;&gt;\sequence{;}&lt;&lt;Definition&gt;&gt;`\`}
\end{eqnarray*}
.Theta Record Literal Expression[[thetaRecordLiteralFig]]
\end{figure}

Externally, a &lt;&lt;ThetaRecord&gt;&gt; is the same as a regular &lt;&lt;Record&gt;&gt;; internally, however, its fields are defined very differently using &lt;&lt;Definition&gt;&gt;s rather than attribute assignments.

If the record is labeled, then, as with all labeled records, the definitions within the &lt;&lt;thetaEnvironment&gt;&gt; must correspond exactly to the type definition.

&lt;&lt;ThetaRecord&gt;&gt;s are especially convenient when the fields of the record are program values. For example, assuming a type definition such as:
[listing]
type onewayQ of t is onewayQ{
  add has type (t)=&gt;();
  take has type ()=&gt;t;
}

the literal:
[listing]
onewayQ{
  private var Q := list of [];
  prc add(X) do {
    Q := list of [Q..,X]
  }
  take() is valof{
    def H is head(Q);
    Q := tail(Q);
    valis H
  }
}

defines a `onewayQ` record with two exposed program values -- `add` and `take`.

\begin{aside}
If there are `extra' definitions, they should be marked `private` which will exclude them from the record's type signature.
\end{aside}

\begin{aside}
A &lt;&lt;ThetaRecord&gt;&gt; has many of the characteristics of an object in OO languages -- except that there is no concept of inheritance; nor is there a direct equivalence of the `self` or `this` keyword.
\end{aside}</Text>
        </Document>
        <Document ID="A7ABB6C0-E87F-4DB8-9022-6F51BC37D516">
            <Title>Algebraic Interface Record</Title>
            <Text>An AlgebraicType definition induces an interface that is composed of all the fields in any of the &lt;&lt;RecordConstructor&gt;&gt;s that are defined within the definition.
This interface -- which takes the form of a RecordType -- contains a TypeAnnotation for every TypeAnnotation that is present in a RecordConstructor.
For example, the interface for the account type above consists of:
{
  balance:ref integer
}
This interface is used when determining the type soundness of a RecordAccess expression.
[NOTE] The condition noted above that two fields of the same name in two RecordConstructors of the same AlgebraicType must have the same type can be formalized by declaring that the interface of an AlgebraicType must be well formed (which is only possible if there is only a single TypeAnnotation for a given field).</Text>
        </Document>
        <Document ID="2C07791C-BA4E-45BC-81E5-ACF6B13F17CB">
            <Title>Expressions-17</Title>
            <Text>
=== Record Literals
[[recordLiteral]]
(((expressions,record literal)))
(((record literal)))
A record literal is a collection of values identified by name.

Like &lt;&lt;ConstructorLiteral&gt;&gt;s, the &lt;&lt;RecordLiteral&gt;&gt; must have been defined with a &lt;&lt;TypeDefinition&gt;&gt; statement. This also constrains the types of the expressions associated with the fields.


\begin{figure}[H]
\begin{eqnarray*}
[[RecordLiteral]]RecordLiteral::=&lt;&lt;Record&gt;&gt;\ |&lt;&lt;ThetaRecord&gt;&gt;\\
[[Record]]Record::=&lt;&lt;Expression&gt;&gt;`\{`&lt;&lt;RecordElement&gt;&gt;\sequence{;}&lt;&lt;RecordElement&gt;&gt;`\`}\\
[[RecordElement]]RecordElement::=&lt;&lt;Identifier&gt;&gt;\ `=`\ &lt;&lt;Expression&gt;&gt;\\
  | &lt;&lt;Identifier&gt;&gt;\ `:=`\ &lt;&lt;Expression&gt;&gt;\\
  | `type`\ &lt;&lt;Identifier&gt;&gt;\ `=`\ &lt;&lt;Type&gt;&gt;
\end{eqnarray*}
.Record Literal Expression[[recordLiteralFig]]
\end{figure}


There are two variants of the &lt;&lt;RecordLiteral&gt;&gt;: the &lt;&lt;Record&gt;&gt; form and the &lt;&lt;ThetaRecord&gt;&gt; form. This section focuses on the former.

For example, given the type definition:
[listing]
type employee is emp{
  name has type string;
  hireDate has type date;
  salary has type ref integer;
  dept has type ref string;
}

A literal `emp` value will look like:
[listing]
def E is emp{
  name = "Fred Nice";
  hireDate = today();
  salary := 23000;
  dept := "mail"
}

\begin{aside}
Fields whose type is a `ref`erence type -- see &lt;&lt;referenceType&gt;&gt; -- are defined within the record using the `:=` operator. All other fields are defined using the `=` operator.
\end{aside}

For any given &lt;&lt;RecordLiteral&gt;&gt; _all_ the fields of the record must be associated with a value. This value is either explicitly given or can be supplied by a `default` declaration within the type definition itself.

Fields within a &lt;&lt;RecordLiteral&gt;&gt; are identified by name; and may be written in any order.

=== Anonymous Records
[[anonRecord]]
(((expression,anonymous records)))
(((anonymous records)))

An anonymous record is one which does not have an explicit label.
\begin{figure}[htbp]
\begin{eqnarray*}
[[AnonymousRecord]]AnonymousRecord::=`\{`&lt;&lt;RecordElement&gt;&gt;`;`...`;`&lt;&lt;RecordElement&gt;&gt;`\`}\\
  | `\{`&lt;&lt;Definition&gt;&gt;\sequence{;}&lt;&lt;Definition&gt;&gt;`\`}
\end{eqnarray*}
.Anonymous Record Literal Expression[[anonRecordLiteralFig]]
\end{figure}

For example, an anonymous record consisting of a `name` and an `address` may be written:
[listing]
{name="Fred; address="1 Main St"}

Anonymous records have, as their type, a &lt;&lt;RecordType&gt;&gt; (see &lt;&lt;recordType&gt;&gt;). The type of this record would be represented by:
[listing]
{ name has type string; address has type string}</Text>
        </Document>
        <Document ID="CB0EEE35-84F6-4D12-9A81-6827BED783B8">
            <Title>Paperback</Title>
        </Document>
        <Document ID="5A2FF431-B575-4358-AF63-FDDC7311C1D1">
            <Title>Expressions-15</Title>
            <Text>
==== Zero-ary Tuples
[[zeroTuple]]
(((tuple,zero-ary)))
Zero-element tuples _are_ permitted. A zero-element tuple, which is written
[listing]
()

is essentially a symbol.</Text>
        </Document>
        <Document ID="E7BE68CA-0A6E-40BE-8CC4-B20046F68A9C">
            <Title>Standard Keywords</Title>
            <Text>There are a number of keywords which are reserved by the language -- these may not be used as identifiers or in any other role.

This table lists the standard keywords:
let
this
ref
import
public
private
open
contract
implementation
type
where
assert
all
exists
Standard Keywords
[TIP] On those occasions where it is important to have an identifier that is a keyword it is possible to achieve this by enclosing the keyword in single quotes.
For example, while type is a keyword in the language; enclosing the word in quotes: ‘type’ has the effect of suppressing the keyword interpretation (and its operator interpretation).
Enclosing a name in parentheses also has the effect of suppressing any operator information about the name.</Text>
        </Document>
        <Document ID="317EFAD0-37E8-479E-B4A2-AF7F9FC41628">
            <Title>Programs</Title>
            <Text>= Programs
[[programs]]

This chapter focuses on the organization of programs using functions, procedures and other computational forms. Apart from program values themselves, a key concept is the &lt;&lt;thetaEnvironment&gt;&gt;. This is where many programs, types etc. are defined. &lt;&lt;thetaEnvironment&gt;&gt;s are also first-class values -- showing up as &lt;&lt;AnonymousRecord&gt;&gt;s.


[[thetaEnvironment]]
== Theta Environment
(((theta environment)))
(((program declaration)))

A &lt;&lt;thetaEnvironment&gt;&gt; consists of a set of definitions of types, programs and variables.

[[statementFig]]
.Theta Environment
:hardbreaks:
****
[[ThetaEnvironment]]ThetaEnvironment ::= `{` &lt;&lt;Definition&gt;&gt; ; ... ; &lt;&lt;Definition&gt;&gt; `}`

[[Definition]]Definition ::= &lt;&lt;TypeDefinition&gt;&gt;
  | &lt;&lt;Annotation&gt;&gt;
  | &lt;&lt;VariableDeclaration&gt;&gt;
  | &lt;&lt;FunctionDefinition&gt;&gt;
  | &lt;&lt;ProcedureDefinition&gt;&gt;
  | &lt;&lt;PatternAbstraction&gt;&gt;
  | &lt;&lt;Contract&gt;&gt;
  | &lt;&lt;Implementation&gt;&gt;
  | &lt;&lt;OpenStatement&gt;&gt;
  | &lt;&lt;ImportStatement&gt;&gt;
  | &lt;&lt;LocalAction&gt;&gt;

[[LocalAction]]LocalAction ::= `{` &lt;&lt;Action&gt;&gt; ; ... ; &lt;&lt;Action&gt;&gt; `}`
  | `assert` &lt;&lt;Condition&gt;&gt;
****

Many of the definitions in a &lt;&lt;thetaEnvironment&gt;&gt; define entities that may be recursive and mutually recursive.

(((type,definition)))
[horizontal]
Type definition:: is the definition of a type. See &lt;&lt;typeDefinitions&gt;&gt;
(((type,declaration)))
Type declaration:: is a statement that defines the type of a variable or program. See &lt;&lt;typeAnnotation&gt;&gt;
(((variable,definition)))
Variable definition:: is a statement that defines a variable and gives it a value. There are two forms of variable definition corresponding to a normal single assignment variable and a re-assignable variable. See &lt;&lt;VariableDeclaration&gt;&gt;
Function definition::
(((function,definition)))is a group of equations that defines a function. See &lt;&lt;equations&gt;&gt;.
Procedure definition::
(((procedure,definition))) is a statement that defines an action procedure. See &lt;&lt;procedures&gt;&gt;.
LocalAction::
(((actions,in a theta environment)))A &lt;&lt;LocalAction&gt;&gt; is an action -- enclosed in braces -- that is performed prior to the bound expression of a &lt;&lt;thetaEnvironment&gt;&gt;.
Contract definition::
(((contract,definition)))is a statement that defines a coherent collection of functions and procedures that may be associated with different types. See &lt;&lt;ContractDefinition&gt;&gt;.
Contract implementation::
(((contract,implementation)))
is a statement that establishes that a particular type _implements_ a contract -- and gives the implementation. See &lt;&lt;ContractImplementation&gt;&gt;.
Macro definition::
(((macro,definition)))is a statement that indicates how source programs should be interpreted. See &lt;&lt;MacroLanguage&gt;&gt;. Macro statements may only appear at the `package`-level: they are not permitted within the body of a `let` expression, for example.


[[functions]]
== Functions and Equations

A function is a program for computing values; organized as a set of equations.

[[functionFig]]
.Functions
****
[[Function]]Function ::= &lt;&lt;Equation&gt;&gt; ... &lt;&lt;Equation&gt;&gt;

[[Equation]]Equation ::= &lt;&lt;RuleHead&gt;&gt; [&lt;&lt;RuleGuard&gt;&gt;]] `\=&gt;` &lt;&lt;Expression&gt;&gt;
  | &lt;&lt;DefltEquation&gt;&gt;

[[DefltEquation]]DefltEquation ::= &lt;&lt;RuleHead&gt;&gt; `default` `\=&gt;` &lt;&lt;Expression&gt;&gt;

[[RuleHead]]RuleHead ::= &lt;&lt;Identifier&gt;&gt;`(`&lt;&lt;Pattern&gt;&gt;,...,&lt;&lt;Pattern&gt;&gt;&gt;`)`

[[RuleGuard]]RuleGuard ::= `default` | &lt;&lt;GuardCondition&gt;&gt;&gt;

[[GuardCondition]]GuardCondition ::= `::` &lt;&lt;Condition&gt;&gt;
****

[TIP]
Functions and other program values are first class values; as a result they may be passed as arguments to other functions as well as being assigned as attributes of records.

[FunctionType]
=== Function Type
The function type takes the form:

****
__TupleType__ \=&gt; _Type_
****

where &lt;&lt;TupleType&gt;&gt; is a type denoting a tuple of values.

Functions can be defined in a &lt;&lt;thetaEnvironment&gt;&gt; -- which case they must be associated with an explicit or implicit &lt;&lt;TypeAnnotation&gt;&gt; -- or they may be _anonymous_ -- i.e., appear as a function literal in an expression.

[[equations]]
=== Equations
An equation is a rule for deciding how to rewrite an expression into a simpler expression. Each equation consists of a &lt;&lt;TuplePattern&gt;&gt; that is used to match the call to the function and a replacement expression. The left hand side of the function may also have a guard associated with it, this guard may use variables introduced in the pattern.

[TIP]
An equation is said to apply iff the patterns in the left hand side of the equation (including any `::` clauses) all match the corresponding actual arguments to the function application.


(((theta environment)))
Functions are defined in the context of a &lt;&lt;thetaEnvironment&gt;&gt; -- for example, in the body of a `let` expression (see &lt;&lt;letExpression&gt;&gt;), or at the top-level of a `package`.

It is not necessary for the equations that define a function to be contiguous within a &lt;&lt;thetaEnvironment&gt;&gt;. However, all the equations for a function must be present in the _same_ &lt;&lt;thetaEnvironment&gt;&gt;.

[TIP]
The equations that define a function must be contiguous. This helps to avoid a certain kind of error where equations seem to `go missing' but are just misplaced.

==== Type Safety
The type safety of a function is addressed in stages. In the first place, we give the rules for individual equations:

****
_E_ |= ``A``:AT /\ _E'_ |= ``R``:RT =&gt; _E_ |= `A\=&gt;R` : AT\=&gt;RT
****

If the equation has a &lt;&lt;GuardCondition&gt;&gt;, that that condition must be type satisfiable:

****
_E_ |= A:AT /\ _E'_ |= sat\(C) /\ _E''_ |= R:RT =&gt; _E_ |= A::C =&gt; R : AT\=&gt;RT
****

where _E'_ is the original environment _E_ extended with the variable definitions found in the pattern `A` and _E''_ is _E'_ extended with the variables found in the condition `C`.

In fact this rule slightly understates the type safety requirement. For any statement in a theta environment we also have:

****
F:T &amp;in; E &amp;iff; E|=F:T
****

I.e, top-level definitions _must_ have a type annotation associated with them; and that actual definitions _must_ be consistent with those annotations.

=== Evaluation Order of Equations
[[functionEvaluation]]
(((equations,evaluation order)))

Using multiple equations to define a function permits a case-base approach to function design -- each equation relates to a single case in the function. When such a function is _applied_ to actual arguments then only one of the equations in the definition may apply.

Equations are applied in the order that they are written -- apart from any equation that is marked `default`. If two equations overlap in their patterns then the first equation to apply is the one used.

=== Default Equations
[[defaultEquation]]
(((default equation@`default` equation)))
(((functions,default@`default` equation)))

It is permitted to assign one of the equations in a function definition to be the `default` equation. An equation marked as `default` is guaranteed _not_ to be used if any of the non-default equations apply. Thus, a `default` equation may be used to capture any remaining cases not covered by other equations.

(((patterns,variable pattern)))A `default` equation may not have a where clause associated with it, and furthermore, the patterns in the left hand-side should be generally be variable patterns (see &lt;&lt;patternVariables&gt;&gt;).

[TIP]
In particular, it _should_ be guaranteed that a `default` equation cannot fail to apply.


=== Evaluation Order of Arguments
(((function application,evaluation order)))

There is _no_ guarantee as to the order of evaluation of arguments to a function application. In fact, there is no guarantee that a given expression will, in fact, be evaluated.

[TIP]
The programmer should also _not_ assume that argument expressions will _not_ be evaluated!

In general, the programmer should make the fewest possible assumptions about order of evaluation.

=== Pattern Coverage
[[patternCoverage]]
(((patterns,coverage of)))

Any given equation in a function definition need not completely cover the possible arguments to the function. For example, in
[listing]
F : (integer)=&gt;integer;
F(0) =&gt; 1
F(X) =&gt; X*F(X-1)

the first equation only applies if the actual argument is the number `0`; which is certainly not all the `integer`s.

The set of equations that define a function also define a coverage of the potential values of the actual arguments. In general, the coverage of a set of equations is smaller than the possible values as determined by the type of the function.

If a function is _partial_ -- i.e., if the coverage implied by the patterns of the function's equations is not complete with respect to the types -- then the compiler may issue an incomplete coverage warning.

[TIP]
The programmer is advised to make functions _total_ by supplying an appropriate `default` equation. In the case of the `F`actorial function above, we can make the `default` case explicit as is shown in &lt;&lt;factorialFun&gt;&gt;.


[[factorialFun]]
.Factorial Function
[listing]
fact : (integer)=&gt;integer
fact(X) :: X&gt;0 =&gt; X*fact(X-1)
fact(X) default =&gt; 1

[[anonymousFunction]]
=== Anonymous Function
(((anonymous function)))
(((expressions,function)))

Anonymous functions are expressions of the form:
[listing]
(X) =&gt; X+Y

Anonymous functions may appear anywhere a function value is permitted.


[[anonymousFunctionFig]]
.Anonymous Function
****
[[AnonymousFunction]]AnonymousFunction ::= &lt;&lt;TuplePattern&gt;&gt; `\=&gt;` &lt;&lt;Expression&gt;&gt;
****

[TIP]
====
If it desired to have a single-argument anonymous function that takes a tuple pattern then use double parentheses:
[listing]
((X,Y)) =&gt; X+Y
====

For example, an anonymous function to add 1 to its single argument would be:
[listing]
(X) =&gt; X+1

Anonymous functions are often used in function-valued functions. For example in:
[listing]
addX:(integer)=&gt;((integer)=&gt;integer);
addX(X) =&gt; ((Y) =&gt; X+Y)

the value returned by `addX` is another function -- a single argument function that adds a fixed number to its argument.

[NOTE]
Note the extra set of parentheses around both the embedded function type and around the returned function value.

[NOTE]
Anonymous functions may reference free variables.


==== Type Safety
The type of an anonymous function is determined by the types of the argument patterns and the return type. Unlike named functions, anonymous functions are not explicitly typed.

****
_E_ |= ``A``:AT /\ _E_ |= ``R``:RT =&gt; _E_ |= `A\=&gt;R` : AT\=&gt;RT
****

=== Overloaded Functions
[[overloadedFunctions]]
The type of an overloaded function has a characteristic signature: it's type is universally quantified but with a constraint on the bound type variables.

For example, given the definition:
[listing]
dble:all t ~~ arithmetic[t] |: (t)=&gt;t
dble(X) =&gt; X+X

the generalized type assigned to the `dble` variable is:
[listing]
all t ~~ arithmetic[t] |: (t)=&gt;t

As noted in &lt;&lt;overloading&gt;&gt;, the `dble` function is converted to a function with an explicit dictionary argument that carries the implementation of the `arithmetic` contract:
[listing]
dble:all t ~~ (arithmetic[t])$=&gt;(t)=&gt;t
dble(A) =&gt; let{
  dble_:(t)=&gt;t
  dble_(X) =&gt; (A.+)(X,X)
} in dble_

In effect, this means that the `dble` has _two_ types assigned to it: the constrained type above that is inferred through type inference and an overloaded type that results from its translation.
[listing]
all t ~~ (arithmetic[t])$=&gt;(t)=&gt;t

[NOTE]
Overloaded types are function types, but we use a different types symbol -- `$\=&gt;` -- to help distinguish the special role that overloaded types have.

[TIP]
The existence of an overloaded type associated with a variable is an important signal: it means that references to the variable must be resolved -- that appropriate `implementation`s of the required contracts are found.

When an overloaded function variable is referenced the normal type of the variable expression is identical to the normal rule for variable expressions: the type of the expression is the refreshed type of the constrained type associated with the variable.

However, the existence of the overloaded type associated with the variable acts as a signal that the overloading must be resolved.

For example, in the function:
[listing]
quad:all t ~~ arithmetic[t] |: (t)=&gt;t
quad(X) =&gt; dble(dble(X))

the type of each `dble` variable expression is determined to be:
[listing]
arithmetic[t] |: (t)=&gt;t

[NOTE]
They are the same type in this case because of the calling pattern for `dble`.

Since `dble` originally had a constrained type -- together with its associated overloaded type -- both references must be resolved by supplying an implementation of `arithmetic`. I.e., both `dble` expressions are interpreted as:
[listing]
dble[A](dble[A](X))

where we use `dble[A]` as a special form function call footnote:[We use this notation for exposition purposes only -- it is not normal `Star syntax'.] that denotes a use of the overloaded function.

The `quad` function is generic, and so its type is also a generalized constrained type:
[listing]
quad:all t ~~ arithmetic[t] |: (t)=&gt;t

and is also transformed into the overloaded definition:
[listing]
quad:all t ~~ (arithmetic[t]) $=&gt; (t)=&gt;t
quad(A) =&gt; let{
  quad_:(t)=&gt;t
  quad_(X) =&gt; dble[A](dble[A](X))
} in quad_

In effect, the resolved dictionary for `arithmetic` is `pulled out' to a larger scope.

In all cases, for overloaded functions to be invoked correctly, there must be some outermost point where an overloaded function is invoked with a concrete implementation value.

If an overloaded variable is not properly resolved, then the compiler will issue a syntax error.

In most cases, the outermost scope of a program is package-level. It is possible for a package to export an overloaded function -- in which case imports of the package must resolve the overloaded function.

=== Open Statement
[[openStatement]]
(((open statement)))
(((opening a record)))
(((record,opening)))

The &lt;&lt;OpenStatement&gt;&gt; takes a &lt;&lt;Record&gt;&gt;-valued expression and `opens its contents' in a &lt;&lt;thetaEnvironment&gt;&gt;. It is analogous to an &lt;&lt;Import&gt;&gt; of the record.

[[openStatementFig]]
.Open Statement
****
[[OpenStatement]]OpenStatement ::= `open` &lt;&lt;Expression&gt;&gt;
****


Any fields and types that are declared within the &lt;&lt;Expression&gt;&gt;'s type become defined within the enclosing &lt;&lt;thetaEnvironment&gt;&gt;.
[TIP]
The existing scope rules continue to apply; in particular, if there is a name that is duplicated already in scope then a duplicate definition error will be signaled.

[TIP]
Normal type inference is not able to infer anything about the type of the ``open``ed &lt;&lt;Expression&gt;&gt;. Hence, this statement requires that the type of the expression is already known.

For example, given the definition:
[listing]
R : { type elem; op:(elem,elem)=&gt;elem; zero:elem}
R = {
  type integer counts as elem
  op(X,Y) =&gt; X+Y
  zero = 0
}

then we can `open` `R` in a &lt;&lt;LetExpression&gt;&gt;:
[listing]
let{
  open R
  Z : elem
  Z = zero
} in Z

[TIP]
====
Although the `open` statement makes available the types and fields embedded in a record; existential abstraction still applies. In particular, in this case the fact that the `elem` type is manifest as `integer` within the record expression `R` is hidden.

The `elem` type (and the `zero` and `op` fields) are available within the `let`; but no information about what `elem` actually is is available.
====

[[localAction]]
=== Local Actions
(((Actions executed within a &lt;&lt;thetaEnvironment&gt;&gt;)))

A local action is a sequence of actions -- enclosed in braces -- that are performed when the theta environment is first entered and before any dependent bound expressions are evaluated.

For example, in:
[listing]
traceF : (integer)=&gt;integer
traceF(X) =&gt;
  let{
    f:(integer)=&gt;integer
    f(0) =&gt; 1
    f(XX) =&gt; XX*f(XX-1)
    {
      logMsg(info,"in theta environment");
    }
  } in f(X)

The action
[listing]
logMsg(info,"in theta environment")

is executed as part of establishing the &lt;&lt;thetaEnvironment&gt;&gt; prior to the function `f` being evaluated.

Local actions are useful for situations where proper initialization of the entries in the theta environment are more extensive than binding a variable to a value.

[TIP]
There is no predetermined order of execution of &lt;&lt;LocalAction&gt;&gt;s -- for example, if there is more than one in a given &lt;&lt;thetaEnvironment&gt;&gt;. The compiler ensures that all the preconditions for the &lt;&lt;LocalAction&gt;&gt; -- specifically definitions that are referenced by the &lt;&lt;LocalAction&gt;&gt; -- are established prior to the execution of the action.

[[procedures]]
== Procedures

An action procedure is an action script -- a program for performing actions. Analogously to functions and other rule types, procedures are written as a set of action rules.

[[procedureSyntaxFig]]
.Procedures and Action Rules
****
[[Procedure]]Procedure ::=  &lt;&lt;ActionRule&gt;&gt; ... &lt;&lt;ActionRule&gt;&gt;

[[ActionRule]]ActionRule::= &lt;&lt;RuleHead&gt;&gt; [&lt;&lt;RuleGuard&gt;&gt;]] `do` &lt;&lt;Action&gt;&gt;
****

Action rules are analogous to the use of equations for defining functions; except that an action is being specified.

The equivalent of `Hello World' as a procedure would be:
[listing]
hello:()=&gt;()
hello() do logMsg(info,"Hello World")

The left hand side of an action rule may contain patterns other than variables, it may also include _guard_ conditions:
[listing]
displaySigned:(integer) =&gt; ()
displaySigned(X) :: X&gt;0 do logMsg(info,"$X is positive")
displaySigned(X) default do logMsg(info,"$X is not positive")

[NOTE]
The type of a procedure looks like a function type -- where the return type is the empty tuple. This is because that is what procedures are: functions that do not return a value.

==== Type Safety

A procedure is type safe if the action(s) in the body are type safe -- in the environment augmented by the variables in the head of the procedure.

****
_E_ |= ``A``:AT /\ E' |= safeAction(XX) =&gt; E |= `A do XX` : AT\=&gt;()
****

If the action rule has a &lt;&lt;GuardCondition&gt;&gt;, that that condition must be type satisfiable:

****
_E_ |= A:AT /\ _E'_ |= sat\(C) /\ _E''_ |= safeAction(XX) =&gt; _E_ |= A::C do XX : AT\=&gt;()
****


=== Anonymous Procedure
[[anonymousAction]]
(((anonymous action procedure)))
(((expressions,procedure)))

A procedure is a "first class value" and can be assigned to variables, passed in functions and so on. In addition, a procedure may be expressed as a _literal expression_ in the form of an _anonymous procedure_ expression. An anonymous action procedure consists of an action procedure -- using `procedure` as the `name' of the procedure.


[[anonymousProcedureFig]]
.Anonymous Action Procedure
****
[[AnonProcedure]]AnonProcedure ::= &lt;&lt;TuplePattern&gt;&gt; `do` &lt;&lt;Action&gt;&gt;
****

For example, to use the tree walk as defined in &lt;&lt;treeWalkProg&gt;&gt; to display all the leaf nodes, we pass in to `walk` an anonymous procedure to display the leaf:
[listing]
walk(Tr,((X) do logMsg(info,"$X")))

Anonymous procedures may access free variables; but may not be directly recursive (see &lt;&lt;anonymousFunction&gt;&gt;).


[[tauPattern]]
== Pattern Abstractions
A *pattern abstraction* allows patterns to be treated as first class values; in an analogous way that lambda abstractions allow expressions to be processed.
(((pattern abstractions)))


[[tauPtnFig]]
.Pattern Abstraction Definitions
****
_Expression_ ::+= &lt;&lt;AnonymousPattern&gt;&gt;

[[AnonymousPattern]]AnonymousPattern ::= &lt;&lt;TupleLiteral&gt;&gt;` \&lt;= ` &lt;&lt;Pattern&gt;&gt;

[[PatternAbstraction]]PatternAbstraction ::=  &lt;&lt;PatternRule&gt;&gt; ... &lt;&lt;PatternRule&gt;&gt;

[[PatternRule]]PatternRule::=&lt;&lt;Identifier&gt;&gt;``(``&lt;&lt;Expression&gt;&gt; ,..., &lt;&lt;Expression&gt;&gt;``) \&lt;=`` &lt;&lt;Pattern&gt;&gt;
****

A pattern of the form
[listing]
$_Ab_$($_Ptn\sub1_\sequence{,}_Ptn_$)

represents an application of the pattern abstraction `_Ab_`; i.e., the pattern matches if the abstracted pattern within the definition `_Ab_` matches _and_ that `_Ptn\subi_` match the `returned' values from the pattern.

For example, the definition:
[listing]
TM(X) &lt;= ("fred",X)

defines `TM` as a pattern that will match binary tuples -- of which the first element is the string `"fred"` and returns the second element of the tuple.

We can use `TM` to match such tuples, as in:
[listing]
for TM(Y) in R do
  ...

assuming that the type of `R` was appropriately a `list` of 2-tuples.

The application argument of a pattern abstraction is also a pattern; so we can look for special forms of `TM` patterns in `R`:
[listing]
if TM(3) in R then
  ...

The pattern application `TM(3)` is equivalent to the pattern
[listing]
("fred",3)

&lt;&lt;filterProg&gt;&gt; is a more elaborate example that uses a pattern abstraction to filter elements of a `list`, removing elements that are less than zero.
(((filtering elements of a `list` with pattern abstractions)))
(((list,filtering with pattern abstractions)))
(((pattern abstractions,using to filtering lists)))

[[filterProg]]
.Filtering ``list``s with Pattern Abstractions
[listing]
----
positive:(integer) &lt;= integer
positive(I) &lt;= I :: I&gt;=0

filter:all s,t ~~ (list[t], (s)&lt;=t) =&gt; list[s]
filter(L,P) =&gt; let{
  flt:(list[t])=&gt;list[s]
  flt([]) =&gt; []
  flt([P(I),..More]) =&gt; [I,..flt(More)]
  flt([_,..More]) default =&gt; flt(More)
} in flt(L)
----

The result of evaluating the expression
[listing]
filter([1,3,-2,0,10,-20],positive)

is

[listing]
----
[1,3,0,10]
----

==== Type Safety
The type of a pattern abstraction is determined by the type of pattern matched by the abstraction:
****
E |= P:PT /\ E' |= XX:XT ⇒ E |= XX \&lt;= P  : XT\&lt;=PT
****
</Text>
        </Document>
        <Document ID="2F7A01BE-F1EF-46DF-9ECF-1327535CBFFC">
            <Title>Algebraic Type Definitions</Title>
            <Text>An algebraic type definition is a statement that introduces a new type; it also defines the possible values associated with the type.
An algebraic type definition introduces the new type and defines one or more Constructors -- separated by the | operator.
A Constructor is a specification of a value of a type; i.e., constructors paint a picture of the shape of potential values of the type.
There are three kinds of Constructor: enumerated symbols, term constructor constructors and labeled record constructors.
AlgebraicType::= TypeQuantifier   [|: TypeConstraint] TypeSpec ::= Constructor | ... | Constructor
TypeSpec ::= Identifier | Identifier [ TypeVariable ,...,TypeVariable]
Constructor::=EnumeratedSymbol
  | TermConstructor
  | RecordConstructor
Algebraic Type Definition Statement
[NOTE] Most standard built-in types have type-specific constructors. For example, lists have a list notation, dictionarys have a dictionary notation and so on. Such constructors may not be defined using the algebraic type definition notation -- for example, the constructors for the integer type are denoted by the normal decimal notation for integers.
As elaborated below, each arm of an algebraic type definition defines a value or set of values that belong to the type. There is a slightly more formal way of expressing this: an algebraic type definition induces a set of free functions.
Free functions are technically bijections -- they are one-to-one -- i.e., they have inverses. In programming languages, free functions are used as data structuring tools; but mathematically they are functions.
For example, the type definition:
person ::= noone | someone(string,integer)
induces the constructor function for someone:
someone : (string,integer) &lt;=&gt; person
The enumerated symbol has a simpler type:
noone : person
The complete set of constructor functions introduced within an algebraic type definition is complete: i.e., they define all the possible values of the type.
[NOTE] A given label, whether it is used as an EnumeratedSymbol, the label of a TermConstructor or a LabeledRecord can be defined only once. I.e., it is not permitted to `share' constructor labels across different types.
</Text>
        </Document>
        <Document ID="07A7EBF9-C810-4AF0-84C2-36CB35585FED">
            <Title>Expressions</Title>
            <Text>An expression is a form that denotes a value. Evaluation is the computational process of realizing the denoted value.

Expression::=Variable
  | ScalarLiteral
  | AlgebraicConstructor
  | ApplicativeExpression
  | ConditionalExpression
  | CaseExpression
  | Condition
  | LetExpression
  | ValueExpression
  | AnonymousFunction
  | MemoFunction
  | TypedExpression
  | QuotedExpression
Expression
[NOTE]: This chapter does not cover all forms of expression. Other chapters that address particular forms of expression include variables, list expressions, string expressions, computation expressions and actors.</Text>
        </Document>
        <Document ID="AD309AB7-2FAB-47A2-846F-2E03D08CFF31">
            <Title>Resolving Overloaded Definitions</Title>
            <Text>When a program refers to a contract-defined function -- i.e., a variable that is declared within a contract -- then that reference must be resolved to an actual program before the program can be said to be executable.
For example, consider the expression:
A+3
The (+) function is part of the arith contract which means that we need to resolve the call to (+) to an actual implemented function.
The type signature for (+) is:
all t ~~ arith[t] |: (t,t)=&gt;t
where the constraint
arith[t]
is satisfied for any t for which there is an implementation of arithmetic.
In this case we know, because 3 is an integer that the type of A must also beinteger -- as is the type of the whole expression. So, the actual constraint after taking type inference into account is:
arith[integer]
which is satisfied because there is a standard implementation of arith for integer.
Implementations can be viewed as functions whose value is a record of all the elements of the defined contract. For example, the implementation function of arith over integer has a definition that is similar to:
‘arith#integer’() =&gt; arith{
  X+Y =&gt; _integer_plus(X,Y)
  ...
  }
Resolving the expression A+3 is achieved by replacing the abstract function (+) with an actual function:
arith#integer().’+’(A,3)
In some cases, there is not sufficient information about the types of variables to fully resolve the appropriate definition to use. In this case, it must be true that the type(s) involved must be variable and that they surface to a point where the type variable(s) are generalized.
Consider the lambda:
(X,Y) =&gt; X+Y*Y
The type of X and Y may not be completely known, and are denoted by the same type variable (t) say; t is, however, a constrained type that is bound by the scope of the function itself.
Ultimately, in some larger scope, either the t type becomes grounded into some specific type, or it must be bound by an explicit quantifier. The quantifier must reflect the contract constraint -- otherwise the compiler will report an error. For example, it might be that we defined a variable in a let:
addSq : all t arith[t] |: (t,t)=&gt;t
addSq = ((X,Y)=&gt;X+X*Y)
The arith contract constraint is surfaced to the same level where the type variable t is bound.
In general, where an overloaded name is used, there are two permitted possibilities: the type constraints implied by the overloaded name are subsumed by an explicit type equality or the type variable is bound in some let environment.
[NOTE] The third possibility -- where the constrained type is a type variable but is not bound by a thetaEnvironment is an error -- an unresolved overloaded identifier error.
In the case of the addSq definition, there is not enough information here to fix an actual implementation to use; and so we resolve this by rewriting the addSq function to take an additional argument -- the arith dictionary represented by the variable D:
‘addSq#’(D) =&gt; let{
  ‘addSq\’’(X,Y) =&gt; D.’+’(X,D.*(Y,Y)).
} in ‘addSq\’’
In addition (sic), we will have to also resolve all calls to addSq as well. A call to addSq such as:
addSq(A,3)
will be rewritten to:
‘addSq#’(‘arith#integer’())(A,3)
because we know from the presence of the literal integer that addSq is being used with integer arguments.
Resolving for contract implementations pushes out from expressions such as A+3 outward until all references to contracts have been resolved by explicit implementations.
[NOTE] It is an error for the top-level of a program -- i.e., package-level -- to contain unresolved references to contracts.</Text>
            <Comments>There is an echo of this in both the form of a contract — using the ::= to define the contract — and the implementation — using the function arrow to define the implementation.</Comments>
        </Document>
        <Document ID="6A2981D0-EE77-461E-BF97-D9ED0D27A5D2">
            <Title>Endnotes</Title>
            <Text>&lt;$--ENDNOTES--&gt;</Text>
            <Notes>The &lt;$--ENDNOTES--&gt; tag will be replaced by the footnotes during Compile. Using this tag allows us to have the footnotes inserted wherever we like, without having a separator placed above them.</Notes>
        </Document>
        <Document ID="6440AF28-4676-43A1-B43A-048EAAED13F5">
            <Title>Variable Type Constructors</Title>
            <Text>A type expression of the form:
c[t1,...,tn]
where c is a
type variable -- i.e., bound by a quantifier -- denotes a rather special form of type: a type constructor expression. Like other parameterized type expressions, this expression does not denote a single type; but a set of types. For example, the type expression:
c[integer]
denotes a type `something of integer'.
A subsequent constraint on c may cause it to be bound to the TypeConstructor cons (say), in which case the type expression becomes ground to the parameterized type expression cons[integer].
Such type expressions are of most use in certain forms of Contract where the contract is about a certain form of parameterized type.
</Text>
        </Document>
        <Document ID="0995D299-54E7-4320-AAF6-5C613D5F130E">
            <Title>Block Comment</Title>
            <Text>A block comment consists of the characters /* followed by any characters and terminated by the characters */.

BlockComment ::= /* Char .. Char */
Block Comment
Each form of comment overrides the other: a /* sequence in a line comment is not the start of a block comment, and a --  sequence in a block comment is similarly not the start of a line comment but the continuation of the block comment.</Text>
            <Comments>Francis McCabe 2/11/18, 9:04 PM
Should we eliminate multi-line comments?</Comments>
        </Document>
        <Document ID="911A8FA6-39E7-4E24-BAE4-5799F8E6BEA8">
            <Title>Expressions-45</Title>
            <Text>
%=== Type Cast Expression
%[[typeCastExpression]]
%(((expressions,type cast)))
%(((type cast,expression)))
%(((as@`as`,expression)))
%A &lt;&lt;TypeCastExpression&gt;&gt; expression marks an explicit declaration of the type of an expression. It also delays actual type checking of the castee to runtime.
%
%\begin{figure}[htbp]
%\begin{eqnarray*}
%[[TypeCastExpression]]TypeCastExpression::=&lt;&lt;Expression&gt;&gt;\ `cast`\ &lt;&lt;Type&gt;&gt;
%\end{eqnarray*}
%.Type Cast Expression
%[[typeCastExpressionFig]]
%\end{figure}
%
%==== Type Safety
%A type cast is an inherently dynamic operation; as far as type consistency is concerned the only constraint on the type of the left hand side is that its value is consistent with the declared type.
%
%In effect, the type consistency check may be delayed until the expression is actually evaluated.
%
%However, the declared type may be assumed to be the type of the cast expression -- a fact that may be used by the type checker.
%
%\begin{prooftree}
%\AxiomC{\typeprd{E}{Ex}{T\sub{Ex}}}
%\AxiomC{\entail{E,\theta\sub0}{T\subsume T\sub{Ex}\leadsto\theta\sub{o}}}
%\BinaryInfC{\typeprd{E}{Ex` cast `T}{T}}
%\end{prooftree}
%
%\begin{aside}
%A type cast expression only `makes sense' in a few situations: for example, if either the cast type is type `any` or the type of the castee expression is of type `any`.
%
%This is because type consistency is based on type equality and the only legitimate form of type casting is where the value already has the correct type.
%
%However, using type casting with type `any` allows so-called _heterogenous_ structures where they would not ordinarily be permitted.
%
%For example, the `list` expression:
%[listing]
%list of [1, "alpha", list of []]
%
%is not valid because the types of the elements of the type are not consistent. But, the expression:
%[listing]
%list of [1 cast any, "alpha" cast any, list of [] cast any]
%
%_is_ valid, is actually of type `list[any]`. However, in order to `unwrap' elements of the list it will generally be required to `cast` the elements back out of the `any` type.
%\end{aside}
%</Text>
        </Document>
        <Document ID="427761AB-26EB-418D-83B4-74B91E896759">
            <Title>Strings and Characters</Title>
            <Text>A string consists of a sequence of characters -- specifically CharRefs. There is no specific type in Star for the characters themselves.
[CAUTION] The reasons for this are due to the fact that Unicode string values cannot be always be represented as a unique sequence.</Text>
        </Document>
        <Document ID="6C073C2B-0171-43EF-A6AA-E34E11EBF7F9">
            <Title>Identifiers</Title>
            <Text>Identifiers are used to denote operators, keywords and variables. There are four main kinds of identifier: regular alpha-numeric identifiers, graphic identifiers, multi-word identifiers and quoted identifiers. However, semantically, all these are essentially equivalent: they all identify some variable or some type.
Identifier::=AlphaNumeric
  | MultiWordIdentifier
  | GraphicIdentifier
  | QuotedIdentifier
Identifier Syntax</Text>
        </Document>
        <Document ID="D558287A-DBD6-419F-AB4A-6E2F97ACE35B">
            <Title>Expressions-24</Title>
            <Text>
== Optional Expressions
[[optionExpression]]
(((option expression@`option` expression)))

An `option` expression is used to handle cases where a value is not always guaranteed. The `option` type is built-in but is defined as though by the algebraic type definition in Program~\vref{optionTypeProg}.

\begin{program}
[listing]
type option of t is none or some(t)

.The `option` Type
[[optionTypeProg]]
\end{program}

The `option` type is intended to convey one of two possibilities: a given value exists -- in which case the `some` constructor is used -- or no value exists -- in which case `none` is used.

For example,
[listing]
some("alpha")

signals the definite `string` value `"alpha"`; whereas
[listing]
none

signals that there is no value.

The `option` type can be used as the return type of functions that must reliably signal whether or not a value exists.
\begin{aside}
The `option` type serves as a normal `replacement' for `null` that one sees in languages like Java.
\end{aside}

In addition to the `someValue` and `?.` operators -- described below in &lt;&lt;someValue&gt;&gt; and &lt;&lt;optionChaining&gt;&gt; -- two conditions are defined specifically for `option` expressions: `present` (see &lt;&lt;presentCond&gt;&gt;) and `has value` (see &lt;&lt;hasValueCond&gt;&gt;).

=== Unwrap Option Value -- `someValue`
[[someValue]]
(((unwrap option value)))

The `someValue` unwraps a `some` value and returns its contents. It is defined by the equation:

[listing]
someValue(some(X)) is X


\begin{aside}
\begin{aside}
The `someValue` function is partial. It is not defined in the case that its argument is not a `some` value. If `someValue` is invoked with q{none} then the program will terminate.

For this reason, the programmer should consider whether the `has value` condition (see &lt;&lt;hasValueCond&gt;&gt;) is a better fit.
\end{aside}
\end{aside}</Text>
        </Document>
        <Document ID="69F0F2C7-9E08-48E2-8726-8C4B0691067A">
            <Title>Expressions-40</Title>
            <Text>
=== Unquoting
Within a `quote`d expression, the `unquote` term -- or, equivalently, the `?` term, can be used to escape the quoting mechanism and insert variable text.

For example, in the expression:
[listing]
&lt;| ?A + 45 |&gt;

the identifier `A` now does refer to a normal variable -- whose type must be `quoted`. If, say, `A` had the value:
[listing]
&lt;| "fred" |&gt;

then the above expression is equivalent to:
[listing]
&lt;| "fred" + 45 |&gt;</Text>
        </Document>
        <Document ID="228C221B-38C3-43F5-A2A4-FB3FAE3CB76A">
            <Title>Expressions-18</Title>
            <Text>
=== Accessing Fields of a Record
[[dotAccess]]
(((record literal,accessing)))
(((expressions,accessing record fields)))

Record access expressions access the value associated with a field of a record value. The result may either be the field value, or a new record with a replaced field value.

\begin{figure}[htbp]
\begin{eqnarray*}
[[RecordAccess]]RecordAccess::=&lt;&lt;Expression&gt;&gt;\ `.`\ &lt;&lt;Identifier&gt;&gt;
\end{eqnarray*}
.Record Access Expression[[recordAccessFig]]
\end{figure}

An expression of the form
[listing]
A.F

where `F` is the name of an attribute of the record `A` denotes the value of that attribute. For example, given the type definition
[listing]
type person is someone{
  name has type string;
  age has type integer;
}

and a `person` value bound to `P`:
[listing]
def P is someone{ name="fred"; age=32 }

then the expression `P.name` has value `"fred"`.

The (`.`) access operator is also used in cases where an anonymous record is used; for example given the record:
[listing]
def R is { alpha = "a"; beta=4}

then `R.alpha` has value `"a"`
\begin{aside}
The binding of the record access operator (`.`) is very strong. Thus, expressions such as
`A.L[ix]` and `A.F(a,b*3)`
are equivalent to
[listing][mathescape=true]
(A.L)[ix] ${\rm and}$ (A.F)(a,b*3)

respectively.
\end{aside}</Text>
        </Document>
        <Document ID="76EFF859-18BD-4329-AB32-962C93362E87">
            <Title>Actors</Title>
            <Text>%!TEX root = reference.tex
= Actors
[[actors]]
(((actors)))

An `actor` is an encapsulation of behavior and state that is capable of interacting with other `actor`s. footnote:[Actors in Star should not be confused with Hewitt actors \cite{agha-hew:87}. Although both Hewitt actors and Star actors are a paradigm for distributed computing; Star actors are somewhat higher-level in that their primary mode of interaction is based on speech actions. Star actors are like actors in a play: they recite lines to each other and are choreographed by the author.] Actors represent a way of expressing multiple loci of computation that can interact and collaborate.

\begin{aside}
From a programming methodology perspective, there is some correspondence between actors and objects in `Object Oriented Programming'.  It is useful to view an actor as being an active entity that is responsible for some aspect of the overall problem being addressed in the application.
\end{aside}

The core of actors in Star is the interaction protocol that they support. This protocol is based on three _speech actions_: `notify` which is used to notify an actor that some event has happened; `request` which is used to request an actor to perform an action; and `query` which is used to ask an actor a question.

== A Chatty actor Example
[[talkers]]
By way of introduction, we first demonstrate `actor`s with a simple scenario -- a `chatty' situation involving two `actor`s talking to each other in an endless cycle footnote:[We shall see that the length of the conversation is limited by the available stack depth.] -- illustrated in &lt;&lt;pingPongProg&gt;&gt;.
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.6\textwidth]{diagrams/PingAndPong.pdf}
.Ping and Pong actors
[[pingPongProg]]
\end{center}
\end{figure}

Each of `ping` and `pong` have an `ear` by which they `hear' events. This is signaled by their type which is an `actor` type that references `ear` as an `occurrence` of `string`s. Program~\vref{chattySchema} shows a `type` `alias` definition that captures this in a `type alias`.
\begin{program}
[listing]
type talker is alias of actor of \{
  ear has type occurrence of string;
\}

.Type Schema Used by Chatty `actor`s
[[chattySchema]]
\end{program}

=== Chatty Actor Generator
[[chattyGenerator]]
Although `actor`s are first class values; in many cases it makes sense to use generator functions to construct `actor`s. This structural device allows encapsulation of the creation of the `actor`. In this scenario the two actors are generated by the generator function shown in Program~\vref{chattyGeneratorProgram}.
\begin{program}
[listing]
chatty has type (()=&gt;talker)=&gt;talker;
chatty(Who) is actor\{
 on Msg on ear do\{
   logMsg(info,"I heard \$Msg");
   notify Who() with "Did you hear [\$Msg]?" on ear;
\};

.The `chatty` Actor Generator
[[chattyGeneratorProgram]]
\end{program}

The `chatty` generator takes the form of a single argument function that returns an actor. The function's argument is the actor that the chatty actor 'knows about'.

The `chatty` actor itself is very simple: it listens to an event on its `ear`; and when it perceives one it logs it -- see &lt;&lt;logMsg&gt;&gt; -- and uses the `notify` &lt;&lt;SpeechAction&gt;&gt; to inform its partner that it `heard' something.

There are three kinds of &lt;&lt;SpeechAction&gt;&gt;; however, in this scenario we only use the `notify` action.

\begin{aside}
In general, an `actor` may learn about other `actor`s in a variety of ways -- they may be told explicitly about them in a speech action, they may search for them in a central repository. In this case, we build in to the actor a reference to the conversational partner.
\begin{aside}
Note that the form of this information itself comes in the form of a function. I.e., the argument to the `chatty` actor is a zero-argument function whose value is the `actor` with whom to continue the conversation. The reason for this shall be explained below.
\end{aside}
\end{aside}

=== Setting up a Scenario
We construct our scenario by defining two actors -- `ping` and `pong` -- in terms of the `chatty` function. The two actors `bounce' off of each other in a circular interdependent structure. In the scenario, we build in the interdependence by passing each `actor` to the other -- in a &lt;&lt;thetaEnvironment&gt;&gt; -- and making use of &lt;&lt;MemoFunction&gt;&gt;s:
[listing]
let\{
  def ping is memo chatty(pong);
  def pong is memo chatty(ping);
\}

\begin{aside}
The use of &lt;&lt;MemoFunction&gt;&gt;s allows us to express the cyclic structure of the two actors in conversation without violating the normal rules of evaluation.
\end{aside}
Of course, each of `ping` and `pong` are functionally identical as they were generated by the same generator function.

=== Starting the Interaction
In order to start the two actors off, we send one of them a `notify` &lt;&lt;SpeechAction&gt;&gt;:
[listing]
let\{
  def ping is memo chatty(pong);
  def pong is memo chatty(ping);
\} in \{ notify ping() with "hello" on ear \}


Once started, the actors `ping` and `pong` will notify each other of events in an endless cycle -- although each communication will be larger than the previous:
[listing]
ping {\rm{}to} pong: hello
pong {\rm{}to} ping: Did you hear [hello]?
ping {\rm{}to} pong: Did you hear [Did you hear [hello]?]?
...


An actor wishing to respond to an event uses an &lt;&lt;EventRule&gt;&gt; to `catch' events it is interested in. In the case of these chatty actors, their response is to log the message and echo a response, using the rule:
[listing]
on Msg on ear do\{
   logMsg(info,"I heard \$Msg");
   notify Who() with "Did you hear [\$Msg]?" on ear;
\};

Speech actions are completed when the `target' `actor` has performed its response to the action. In the case of a `notify` this means that the responding `actor` has triggered all relevant &lt;&lt;EventRule&gt;&gt;s. In this case, that means the log message _and_ the `notify` to the actor's partner.

\begin{aside}
One side-effect of this is that cycles like the one in this scenario are liable to exhaust the system evaluation stack fairly quickly. This program is destined to terminate with a `StackOverflow' exception.
\end{aside}

\begin{program}
[listing]
chatty is package\{
  import speech;

  type talker is alias of actor of \{
    ear has type occurrence of string;
  \}

  chatty has type (()=&gt;talker)=&gt;talker;
  chatty(Who) is actor\{
    on Msg on ear do\{
      logMsg(info,"I heard \$Msg");
      notify Who() with "Did you hear [\$Msg]?" on ear;
    \};
  \}

  prc main() do \{
    let\{
      def ping is memo chatty(pong);
      def pong is memo chatty(ping);
    \} in \{ notify ping() with "hello" on ear \}
  \}
\}

.The Complete `chatty` Actor Scenario
[[chattyProgram]]
\end{program}
The complete scenario is shown in Program~\vref{chattyProgram}. Note that, in order to use `actor`s, it is necessary to import the `speech` package.

There are three aspects of `actor`s that fit together to complete the picture of programming with actors: the architectural structure of actors, the speech action model for how actors interact with each other, and the various kinds of &lt;&lt;ActorRules&gt;&gt; that implement the behavior behind the actors' interactions. &lt;&lt;SpeechAction&gt;&gt;s are described in &lt;&lt;contentLanguage&gt;&gt;; &lt;&lt;ActorRules&gt;&gt; are described in &lt;&lt;actorRules&gt;&gt; and the structure of an `actor` is described in &lt;&lt;actorStructure&gt;&gt;.

== Actors' Speech
[[contentLanguage]]
(((content language)))
(((speech actions)))
(((actor communication)))
(((asking actors to do things)))
(((querying actors)))
(((performatives)))

The interaction between actors is based on the concept of _speech actions_ -- `actions' that involve communication between actors.

\begin{aside}
The somewhat anthropomorphic term `speech action' is a reference to _Speech Act Theory_, first promulgated by John L. Austin in \cite{austin:60}. Here, we use the term to refer to any of a standard range of actions involving the communication between `actor`s.
\end{aside}

\begin{aside}
Although we refer to the different forms of interaction collectively as speech actions; in fact, syntactically some are &lt;&lt;Action&gt;&gt;s and queries are actually &lt;&lt;Expression&gt;&gt;s.
\end{aside}

A speech action consists of a _performative_ and associated _content_. The standard performatives allow one actor to _notify_ another actor of an event, to _request_ that an actor perform an action and to _query_ for the value of an expression.

\begin{figure}[htbp]
\begin{eqnarray*}
_Action_&amp;\arrowplus&amp;&lt;&lt;NotifySA&gt;&gt;|&lt;&lt;RequestSA&gt;&gt;\\
_Expression_&amp;\arrowplus&amp;&lt;&lt;QuerySA&gt;&gt;\\
[[SpeechAction]]SpeechAction::=&lt;&lt;NotifySA&gt;&gt;|&lt;&lt;RequestSA&gt;&gt;|&lt;&lt;QuerySA&gt;&gt;
\end{eqnarray*}
.Speech Actions
[[speechActionFig]]
\end{figure}

The content of a speech action is interpreted relative to a _schema_. Each actor has a schema of the particular kinds of events, actions and queries that the actor is capable of responding to. This schema is represented by a &lt;&lt;TypeInterfaceType&gt;&gt; that is an argument of the &lt;&lt;ActorType&gt;&gt;.

=== Actor Type
[[actorType]]
(((actors,type of)))
(((type,actor@`actor`)))
Every `actor` has an &lt;&lt;ActorType&gt;&gt; -- which exposes elements that can be accessed via the different _speech actions_ as outlined in &lt;&lt;contentLanguage&gt;&gt;. It also exposes elements that the `actor` uses in its speech actions.

As shown in &lt;&lt;actorTypeFig&gt;&gt;, an `actor` type takes an argument type which must be a &lt;&lt;TypeInterfaceType&gt;&gt; which defines the actor's schema.

\begin{figure}[htbp]
\begin{eqnarray*}
_Type_&amp;\arrowplus&amp;&lt;&lt;ActorType&gt;&gt;\\
[[ActorType]]ActorType::=`actor`\ `of`\ &lt;&lt;RecordType&gt;&gt;\\
  | `concurrent actor`\ `of`\ &lt;&lt;RecordType&gt;&gt;
\end{eqnarray*}
.Actor Type
[[actorTypeFig]]
\end{figure}

There are two forms of &lt;&lt;ActorType&gt;&gt; -- the `concurrent` form relates to an actor that executes in an independent task (see &lt;&lt;taskExpressions&gt;&gt; and &lt;&lt;concActor&gt;&gt;)

=== Notifying Actors
[[notify]]
(((speech action,notify)))
(((communicating events to actors)))
(((performatives,notify@`notify`)))

The `notify` speech action `informs' an actor of an event. An event is an occurrence of something that is relevant to someone; in this case the actor being notified.

\begin{figure}[htbp]
\begin{eqnarray*}
[[NotifySA]]NotifySA::=`notify`\ &lt;&lt;Expression&gt;&gt;\ `with`\ &lt;&lt;Expression&gt;&gt;\ `on`\ &lt;&lt;Identifier&gt;&gt;
\end{eqnarray*}
.Notify Speech Action
[[NotifySAFig]]
\end{figure}

\begin{aside}
In terms of speech act theory, a `notify` of the form:
[listing]
notify A with E on C

can be considered to be equivalent to:
[listing]
INFORM(A,Happened(C(E)))

where `INFORM` is the basic action in speech -- of the talker informing the listener of something -- and `Happened` corresponds to a predicate that signifies that some occurrence has happened.
\end{aside}

A `notify` action of the form:
[listing]
notify _Ag_ with _Exp_ on _Id_

has the effect of notifying the specifically identified actor  `_Ag_` that an event has occurred. Specifically, the event is denoted by the value of `_Exp_` and the `channel' it is on is identified by `_Id_`.

\begin{aside}
Since events may be coming from multiple sources it is not possible to constrain absolutely the processing order of events. However, since a &lt;&lt;NotifySA&gt;&gt; is blocked until the responding actor has processed it, it _is_ required that all events from a given source are processed in the order that they are generated. See &lt;&lt;actorTypes&gt;&gt;.
\end{aside}

\paragraph{Stream Type}
[[eventType]]
A `notify` action requires that there be an appropriate `occurrence` type on the responding actor's schema.

(((occurrence,occurrence type@`occurrence` type)))
(((occurrence type@`occurrence` type)))
(((type, occurrence@`occurrence`)))

\begin{figure}[htbp]
\begin{eqnarray*}
_Type_&amp;\arrowplus&amp;_EventType_\\
_EventType_::=`occurrence`\ `of`\ _Type_
\end{eqnarray*}
.Event Type
[[eventTypeFig]]
\end{figure}

\begin{aside}
The `occurrence` type is actually a generic type; its argument refers to the type of the element of the `occurrence`.
\end{aside}

For example, an `actor` that responds to update events about the temperature of a boiler might offer a type signature such as
[listing]
boilerActor has type actor of \{
  temp has type occurrence of float;
\}


\begin{aside}
`occurrence` types are _only_ permitted within an `actor` type structure.
\end{aside}

==== Type Safety

For `notify` to be type safe, the _responding_ actor must declare an appropriate element in its schema; i.e., it must have an `occurrence` of the right type for the identified channel:
\begin{prooftree}
\def\defaultHypSeparation{}
\AxiomC{\typeprd{E}{A}{`actor of`O\ `where`\ O`implements``\{`N`has type occurrence of`\ T`\`}}}
\AxiomC{\typeprd{E}{Evt}{T}}
\BinaryInfC{\typesafe{E}{`notify` A `with `Evt\ `on`\ N}}
\end{prooftree}

=== Querying Actors
[[query]]
(((querying actors)))
(((performatives,query@`query`)))

The `query` speech action is used to ask actors questions. A &lt;&lt;QuerySA&gt;&gt; takes the form of an expression that is evaluated `against' the schema of the responding actor's schema.

\begin{figure}[htbp]
\begin{eqnarray*}
[[QuerySA]QuerySA::=`query`\ &lt;&lt;Expression&gt;&gt;\ [&lt;&lt;ExportSelection&gt;&gt;]]\ `with`\ &lt;&lt;Expression&gt;&gt;\\
[[ExportSelection]ExportSelection::=`'s`\ &lt;&lt;Identifier&gt;&gt;\ [`'n`\ &lt;&lt;Identifier&gt;&gt;\sequence{'n}\ &lt;&lt;Identifier&gt;&gt;\ ]]
\end{eqnarray*}
.Actor Query Speech Action
[[actorQueryFig]]
\end{figure}

Syntactically, a `query` takes the form of an _Expression_ -- rather than an action. This is because queries have values associated with them -- even though they are actions! The value of the `query` expression is the result of evaluating the query in the context of the responding actor.

%\begin{aside}
%In terms of Speech Act Theory, a `query` can either be regarded as a primitive performative, or it can be interpreted as an INFORM of a DESIRE to be INFORMED. A query of the form:
%[listing]
%query A with Exp
%
%has interpretation:
%[listing]
%INFORM(A,DESIRES(self,INFORM(VALUE-OF(Exp))))
%
%where `self` refers to the asking entity.
%
%There is additional semantics in a &lt;&lt;QuerySA&gt;&gt; that reflects the fact that the `answer' comes back as part of the original speech action and not as a subsequent speech action.
%\end{aside}

The elements of the actor's schema that are accessed by the query expression are identified explicitly via the &lt;&lt;ExportSelection&gt;&gt;. For example, if an actor has the type:
[listing]
stocker has type actor of \{
  average has type (eventTime,eventTime)=&gt;float;
  volume has type (eventTime,eventTime)=&gt;float;
\}

then a query of the `stocker`'s `average` and `volume` would look like:
[listing]
query stocker's average 'n volume with average(34,10)*volume(34,10)

\begin{aside}
Only those elements of the actor's schema that are mentioned explicitly in the &lt;&lt;ExportSelection&gt;&gt; will reference the responding actor's schema. All other references are regarded either as local to the query or free -- in effect referencing variables from the caller's context.
\end{aside}

==== Type Safety
An actor's schema is used to validate the type safety of a `query` against the actor:
\begin{prooftree}
\def\defaultHypSeparation{\hskip 0pt}
\AxiomC{\typeprd{E}{A}{O`where`O`implements\{`N\sub1`has type`T\sub1\sequence{;}N\subn`has type`T\subn`\`}}}
\AxiomC{\typeprd{O}{Q}{T\sub{Q}}}
\BinaryInfC{\typeprd{E}{`query`\ A`'s`\ N\sub1\sequence{'n}N\subn\ `with`\ Q}{T\sub{Q}}}
\end{prooftree}


=== Requesting Action from an Actor
[[request]]
(((requesting action from an actor)))
(((performatives,request@`request`)))

A `request` denotes a request that an actor perform an _Action_. The assumption is that an `actor` may modify its internal state as a result of responding to the `request`.

\begin{figure}[htbp]
\begin{eqnarray*}
_RequestSA_::=`request`\ &lt;&lt;Expression&gt;&gt;\ [&lt;&lt;ExportSelection&gt;&gt;]\ `to`\ _Action_\\
\end{eqnarray*}
.Request Speech Action
[[RequestSAFig]]
\end{figure}

Similarly to the &lt;&lt;QuerySA&gt;&gt;, the elements of the actor's schema that are accessed by the &lt;&lt;Action&gt;&gt; -- and any embedded expressions within the &lt;&lt;Action&gt;&gt; -- are identified explicitly via the &lt;&lt;ExportSelection&gt;&gt;. For example, if an actor has the type:
[listing]
bank has type actor of \{
  setBalance has type (float)=&gt;();
  currentBalance has type ()=&gt;float;
\}

then a request to increase the `bank`'s balance by 20\% would look like:
[listing]
request bank's setBalance 'n currentBalance to
    setBalance(currentBalance()*1.2)

\begin{aside}
Again, as with &lt;&lt;QuerySA&gt;&gt;, only those elements of the actor's schema that are mentioned explicitly in the &lt;&lt;ExportSelection&gt;&gt; will reference the responding actor's schema. All other references are regarded either as local to the query or free -- in effect referencing variables from the caller's context.
\end{aside}

==== Type Safety
_RequestSA_s do not have a type but, like other actions, must be type-safe.

\begin{prooftree}
\def\defaultHypSeparation{\hskip 0pt}
\AxiomC{\typeprd{E}{A}{O`where`O`implements\{`N\sub1`has type`T\sub1\sequence{;}N\subn`has type`T\subn`\`}}}
\AxiomC{\typesafe{E}{A}}
\BinaryInfC{\typesafe{E}{`request`\ A`'s`\ N\sub1\sequence{'n}N\subn\ `to`\ A}}
\end{prooftree}

== Actor Structure
[[actorStructure]]
(((actors,structure of)))
An `actor` consists of a set of &lt;&lt;ActorRule&gt;&gt;s -- enclosed in an `actor\{...\`} structure -- that define how the `actor` responds to &lt;&lt;SpeechAction&gt;&gt;s.
\begin{figure}[H]
\begin{eqnarray*}
[[Actor]]Actor::=`actor``\{`&lt;&lt;ActorRule&gt;&gt;\sequence{;}&lt;&lt;ActorRule&gt;&gt;`\`}\\
  | `concurrent actor``\{`&lt;&lt;ActorRule&gt;&gt;\sequence{;}&lt;&lt;ActorRule&gt;&gt;`\`}\\
[[ActorRule]]ActorRule::=&lt;&lt;EventRule&gt;&gt;\ |&lt;&lt;Definition&gt;&gt;
\end{eqnarray*}
.Actor Structure
[[actorStructureFig]]
\end{figure}
Actors are first-class values: they can be bound to variables, passed as arguments to functions and stored in structures. However, as noted in &lt;&lt;chattyGenerator&gt;&gt;, it is often convenient to arrange for actors to be generated via generator functions.

\begin{aside}
Actors are typically structured into a separate communicative `actor` `head' and an active `body' with a `using` or `let` (see &lt;&lt;letExpression&gt;&gt;).
The head contains the rules that support the interactions with other actors, and the body contains functionality that defines what the actor can do.
\end{aside}

An example of this is shown in Program~\vref{stockTicker} which defines an actor that keeps information of recent stock trades. footnote:[This should not be construed as an authoritative example of an actor that handles price updates.]

\begin{program}
[listing]
stocker() is actor\{
  on (Price,When) on tick do extend prices with (Price,When);

  average(Frm,To) is valof\{
    def Prices is all Pr where (Pr,W) in prices and Frm=&lt;W and W&lt;To;
    valis Prices/size(Prices);
  \}

  prc clear(Frm,To) do delete ((Pr,W) where Frm=&lt;W and W&lt;To) in prices;
\} using \{
  prices has type list of ((float,eventTime));
  def prices is list of [];
\}

.A Stock Actor
[[stockTicker]]
\end{program}

An `actor` may contain &lt;&lt;EventRule&gt;&gt;s to allow it to respond to `notify` speech actions; otherwise, any valid &lt;&lt;Definition&gt;&gt; may be present in an `actor`.

=== Event Rules
[[actorRules]]
(((actors,event rules)))
(((events,rules)))
An event rule is a rule that is used to respond to `notify` speech actions. An event is an occurrence of something that is `of interest' to an `actor`.

\begin{figure}[htbp]
\begin{eqnarray*}
[[EventRule]EventRule::=`on`\ &lt;&lt;Pattern&gt;&gt;\ `on`\ &lt;&lt;Identifier&gt;&gt;\ [`where`\ &lt;&lt;Condition&gt;&gt;]]\ `do`\ &lt;&lt;Action&gt;&gt;
\end{eqnarray*}
.Event Rules
[[eventRuleFig]]
\end{figure}

&lt;&lt;EventRule&gt;&gt;s have a two part structure: a pattern that matches an event on a particular occurrence and an &lt;&lt;Action&gt;&gt; body. In addition, an &lt;&lt;EventRule&gt;&gt; may have an optional &lt;&lt;Condition&gt;&gt; that must be satisfied before the rule can `fire'.
(((condition,in event rules)))
(((event rule conditions)))

There may be any number of event rules about a given occurrence. All the &lt;&lt;EventRule&gt;&gt;s that apply will fire on receipt of a given `notify`.


=== Responding to Requests
[[requestResponse]]
(((actor,responding to `requests`)))
(((responding to `actor` `requests`)))

&lt;&lt;RequestSA&gt;&gt;s are handled using &lt;&lt;Procedure&gt;&gt;s. The &lt;&lt;RequestSA&gt;&gt; may refer to more than one &lt;&lt;Procedure&gt;&gt;; and may even refer to other functions and variables that are exposed by the `actor`. Each `call' within the &lt;&lt;RequestSA&gt;&gt; is fielded by directly calling the appropriate &lt;&lt;Procedure&gt;&gt; or &lt;&lt;Function&gt;&gt; within the actor.

(((how a request is handled@how a `request` is handled)))
(((waiting for requests)))

The `stocker` actor in Program~\vref{stockTicker} will respond to a `clear` `request` by removing elements from its memory.


=== Querying an Actor
[[actorQuery]]
(((actor,query an)))
(((query,an actor)))

Queries to actors are handled simply by evaluating an expression in the context of the `actor`. In particular, if the `query` is of a `list`, then the evaluation will often involve the use of `view` definitions.

== The Speech Contract
[[speechContract]]
The foundation of actors in Star is the `speech` contract that is defined in Program~\vref{speechContractProg}. This contract relies on the `result` type -- which is defined in Program~\vref{successTypeProg}.

\begin{program}
[listing]
type result of t is success(t)
  or denied(reason)
  or failed(exception);

type reason is busy or noPermission

.Success Result Type
[[successTypeProg]]
\end{program}


\begin{program}
[listing]
contract speech over t determines (u,a) where execution over a is \{
  _query has type for all s such that
      (t,(u)=&gt;s,()=&gt;quoted,()=&gt;dictionary of (string,quoted))=&gt; a of s;
  _request has type
      (t,(u)=&gt;(),()=&gt;quoted,()=&gt;dictionary of (string,quoted)) =&gt; a of ()
  _notify has type (t,(u)=&gt;()) =&gt; a of ();
\};

.Speech Contract Used by `actor`s
[[speechContractProg]]
\end{program}

This contract is generally not referenced explicitly by `actor`-based programs as Star has syntactic features to support `actor`s and speech actions. Individual &lt;&lt;SpeechAction&gt;&gt;s are mapped to equivalent calls to `\_query`, `\_request` or `\_notify`.

Speech actions are encoded into calls to the three functions in the `speech` contract: a `notify` becomes a call to `\_notify`, specifically the `notify` action:

[listing]
notify _Ag_ with _Event_ on _Channel_

becomes:
[listing]
_notify(_Ag_, (AA)=&gt;_Channel_(_Event_))


A `query` is encoded into a call of `\_query` with four arguments. Specifically, the `query`:
[listing]
query _Ag_ with _Expression_

becomes:
[listing]
\_query(_Ag_, (AA)=&gt;_Expression_, ()=&gt;&lt;|_Expression_|&gt;,
      ()=&gt; dictionary of ["_F\sub1_"-&gt;F\sub1 as quoted\sequence{,}"_F\subn_"-&gt;F\subn as quoted])

where
[listing]
dictionary of ["_F\sub1_"-&gt;F\sub1 as quoted\sequence{,}"_F\subn_"-&gt;F\subn as quoted]

is a dictionary of all the free variables in _Expression_ and the expressions of the form
[listing]
"F\subi"-&gt;F\subi as quoted

are, in effect, a _serialization_ of the value of the free variable as a `quoted` value.

The function:
[listing]
()=&gt;&lt;|_Expression_|&gt;

can be used by the receiver of the `query` if it either does not trust the function or if it needs to transform the query in some way.

A `request` speech action has similar processing to the `query`. The `request`:

[listing]
request _Ag_ to _Act_

is translated to the call:
[listing]
_request(_Ag_, (AA)=&gt;_Act_, ()=&gt;&lt;|_Act_|&gt;,
       ()=&gt;dictionary of ["_F\sub1_"-&gt;F\sub1 as quoted\sequence{,}"_F\subn_"-&gt;F\subn as quoted])

with a similar interpretation of the arguments.

Note that references within the `query` and `request` speech action to elements of the target's interface become dot-references (&lt;&lt;RecordAccess&gt;&gt;) of the form:
[listing]
AA.foo


== Different Types of Actor
[[actorTypes]]
There are two `standard' implementations of actor: a light weight actor that has similar computational characteristics as conventional objects and a concurrent actor which is associated with its own `task`.

=== Light Weight Actors
[[liteActor]]

The simple light weight actor as defined by the `actor` type in Program~\vref{actorTypeProg} is essentially a simple wrapper around a &lt;&lt;RecordType&gt;&gt;.

\begin{program}
[listing]
type actor of t is act0r(t);

.Standard Light Weight `actor` Type
[[actorTypeProg]]
\end{program}

The implementation of the speech contract for `actor` is shown in Program~\vref{actorSpeechProg}.

\begin{program}
[listing]
implementation speech over for all t such that actor of t determines t is \{
  \_query(act0r(Ac),Qf,_,_) is Qf(Ac);
  prc \_request(act0r(Ac),Rf,_,_) do Rf(Ac);
  prc \_notify(act0r(Ac),Np) do Np(Ac);
\};

.Actor's Implementation of the Speech Contract
[[actorSpeechProg]]
\end{program}
\begin{aside}
What is not shown here is how the internals of `actor`s -- in particular  &lt;&lt;EventRule&gt;&gt;s -- are implemented.
\end{aside}

=== Concurrent Actors
[[concActor]]
A concurrent actor is written slightly differently to a light weight actor; and has a different type and different behavior. Its internals are sufficiently complex that we do not expose them and leave the `concurrent actor` type abstract:
[listing]
concurrent actor has kind type of type;

The public type for a `concurrent actor` is
[listing]
concurrent actor of \{ ... \}

which is aliased to the `concActor` type for convenience.

Concurrent actors sequentialize all access to them them -- only one speech action is processed at a given time. If multiple speech actions are attempted simultaneously all but one is blocked while it is processed by the `concurrent actor`.

Concurrent actors execute on an independent background `task` -- see &lt;&lt;backgroundTask&gt;&gt;. The normal operational semantics for speech actions still holds with concurrent actors: except that a `notify` completes as soon as the concurrent actor starts processing it but before it completes processing the `notify`.

Program~\vref{concSieveProg} shows an example using `concurrent actor`s. This is a variation of the famous `Sieve of Erastosthenes' method for finding prime numbers.

\begin{program}
[listing]
filterActor(P) is concurrent actor\{
  private var Nx :=  (_) =&gt; task\{\};

  \{ Nx := newPrime \};

  private newPrime(X) is let\{
    def Fx is filterActor(X);

    filterPrime(XX) is task{ notify Fx with XX on input};
  \} in task \{
      logMsg(info,"new prime $X");
      Nx := filterPrime;
  \};

  on X on input do \{
    perform task \{
      if X\%P!=0 then
        perform Nx(X);
    \}
  \}
\}

.Sieve of Erastosthenes as Concurrent Actors
[[concSieveProg]]
\end{program}


\begin{aside}
Concurrent actors are more complex internally than simple actors. As such they have a higher internal performance penalty. However, the great merit of concurrent actors is that they can exploit parallelism where it is available.
\end{aside}
</Text>
        </Document>
        <Document ID="606E2F6A-318D-44EA-A9BC-81093A72CD2F">
            <Title>About This Reference</Title>
            <Text>This reference is the language definition of the Star language. It is intended to be thorough and as precise as possible in the features discussed. However, where appropriate, we give simple examples as illustrative background to the specification itself.</Text>
        </Document>
        <Document ID="D93D97E1-574B-4CEF-BFA0-53B3270118FD">
            <Title>Expressions-36</Title>
            <Text>
=== Memo Function
[[memoFunction]]
(((memo function)))
(((expressions,memo)))

A `memo` function encapsulates a single expression as a zero arity function that is guaranteed to be evaluated only once.

A `memo` function is a function that `remembers' the value it first returned. Subsequent invocations of the function simply return that first value.

\begin{figure}[htbp]
\begin{eqnarray*}
[[MemoFunction]]MemoFunction::=`memo`\ &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.Memo Function
[[memoFunctionFig]]
\end{figure}

Memo functions have an important role in cases where a group of variables is mutually recursive; a situation that is not normally permitted. For example, consider the pair:
[listing]
def Jack is someone{
    def name is "jack";
    spouse() is Jill
  }
def Jill is someone{
    def name is "jill";
    spouse() is Jack
  }

assuming this type definition:
[listing]
type Person is someone{
  name has type string;
  spouse has type ()=&gt;Person;
}


This pair of definitions is not permitted because the value of `Jack` depends on the variable `Jill`, which in turn depends on `Jack`.
\begin{aside}
The reason it is not permitted is that partially constructed values are not permitted. In fact, any attempt to actually compute this pair of values would simply result in an infinite loop.
\end{aside}

However, the very similar pair of definitions:
[listing]
JackF() is someone{
    def name is "jack";
    spouse() is JillF()
  }
JillF() is someone{
    def name is "jill";
    spouse() is JackF()
  }

is permitted -- because mutually recursive functions are permitted. However, in some cases, especially those involving internal state, a call to normal zero-arity function is not equivalent to the result of the function. In this example, each invocation of `spouse` results in a new value; whose state is independent of other instances.

To permit this, the `memo` function is semantically a function; but since each time it is called it is guaranteed to return the identical result it has the same semantics as a shared variable:
[listing]
def JackM is memo someone{
    def name is "jack";
    spouse() is JillM()
  }
def JillM is memo someone{
    def name is "jill";
    spouse() is JackM()
  }</Text>
        </Document>
        <Document ID="2FFEE8C6-C9EE-43CB-96CE-27E3984C3177">
            <Title>Contract Implementation</Title>
            <Text>A contract implementation is a specification of how a contract may be implemented for a specific type combination.
Implementation::=`implementation` ContractSpec [`default`] `=&gt;` Expression
Contract Implementation Statement
The Types mentioned in ContractSpec must be either TypeExpressions or, in the case of a default implementation, TypeVariables.
[NOTE] In particular, it is not permitted to define an implementation of a contract for FunctionTypes, PatternTypes, nor for UniversalTypes or ExistentialTypes.
It is permissible, however, to implement Contracts for TupleTypes and RecordTypes.
The body of a contract implementation must be an expression that gives a definition for each of the elements of the contract specification.
[NOTE] A contract implementation may either take the form of a regular AnonymousRecord or an anonymous ThetaRecord.
Usually, the implementation of a contract is fairly straightforward. For example, this gives the implementation of the standard sizeable contract for the cons type:
implementation all e ~~ sizeable[cons[e]] =&gt; {
  size(nil) =&gt; 0.
  size(cons(_,T)) =&gt; size(T)+1.
  isEmpty(nil) =&gt; true.
  isEmpty(_) default =&gt; false
}
Implementation of sizeable for cons values</Text>
        </Document>
        <Document ID="9BD61FD4-F6B6-483E-A8BE-64CB7B1ADF90">
            <Title>Contract Constraints</Title>
            <Text>A ContractConstraint is a requirement on a Type -- or tuple of Types -- that whatever type it is, that there must exist an implementation of the Contract for the Type.
For example, the type constraint expression:
comparable[t]
means that the type variable t may only unify with concrete types that implement the comparable contract.
[NOTE] If t is unified with another type variable, then the constraints on both type variables are merged.
[NOTE] Since only named types may implement Contracts, it is also not permissible to unify the constrained variable with an structural type -- such as a function type.
ContractConstraint ::= Identifier [ TypeArgument ]
  | Identifier [ TypeArgument -&gt;&gt; TypeArgument ]
Contract Constraint
It is possible for ContractConstraints to reference more than one type. For example, the standard coercion contract references two types. A coercion ContractConstraint will therefore look like:
coercion[T1,T2]
where T1 represents the source type of the coercion and T2 represents the destination type.
If the -&gt;&gt; clause is used, then the Contract being referenced must have a commensurate functional dependency associated with it.
[NOTE] Conversely, if a Contract has a functional dependency, then any constraint referring to it must also have a -&gt;&gt; clause.
The -&gt;&gt; clause identifies which type(s) are dependent on the type argument(s) of the Contract.</Text>
        </Document>
        <Document ID="53E2465E-4B34-441D-9097-911CAD10A0D6">
            <Title>Type Expressions</Title>
            <Text>TypeExpression ::= TypeConstructor [Type ,..., Type ]
  | Identifier

TypeConstructor ::= Identifier | TypeVar
Type Expressions

A TypeExpression is a term that identifies a class of values by name. The name may or may not have TypeArguments -- in which case, the type is said to be parameterized.</Text>
        </Document>
        <Document ID="46B27619-B0EA-4E99-A9D4-953153A414AF">
            <Title>Lexical Syntax</Title>
            <Text>Star source text is based on the Unicode character set. This means that identifiers and string values may directly use any Unicode characters. However, all the standard operators and keywords fall in the ASCII subset of Unicode.</Text>
        </Document>
        <Document ID="69156C21-96B9-448A-A8C3-204C8EDF80D6">
            <Title>Universally Quantified Types</Title>
            <Text>A universal type denotes a type that is valid for all substitutions of a type variable.
UniversalType::= all BoundType,..,BoundType ~~ Type
BoundType ::= Identifier | Identifier / Decimal
Universal Type Expression
The first form of BoundType introduces a regular type variable -- i.e., a variable of Kind type. The second form is used to introduce a higher-kinded type variable.
For example, the quantification:
all c/1 ~~ ...
denotes a type variable of kind TypeConstructor.
[TIP] Higher kinded type variables are most commonly used in the context of Contract definitions.
Star will infer the type of expressions; including functions and definitions. However, the compiler does not generalize: i.e., it will never infer a universally quantified type (or an existentially quantified one).
One consequence of this is that all definitions of so-called generic programs must have an explicit type annotation. 
[NOTE] The reason for this is that explicit types provide superior documentation to programs -- especially where the actual type is complex.
For example, the  dblFilter function below applies its argument function in two different situations -- one for each element of each pair in the input list.
dblFilter:all u,v ~~
     (all t~~(t)=&gt;t, cons[(u,v)])=&gt;cons[(u,v)]
dblFilter(M,[]) =&gt; []
dblFilter(M,[(A,B),..L]) =&gt;
      [(M(A),M(B)),..dblFilter(M,L)]
A double filter
It is important to note that any actual function argument supplied to dblFilter will itself have to be generic -- i.e., its type will also be universally quantified.</Text>
        </Document>
        <Document ID="41D6A52C-18A4-435D-B8A5-AC64607ECBA3">
            <Title>Type System</Title>
            <Text>The type system consists of a language of type expressions and a set of rules for showing consistency between types and programs.
The foundation of these rules are the rules that relate one type to another; and the primary relationship involved here is subsumption.
In addition there are rules for determining when various constraints are satisfied and there are rules that relate specific expressions to types.</Text>
        </Document>
        <Document ID="52756FB3-FD2A-4653-B334-C3395A168B89">
            <Title>Computation</Title>
            <Text>%!TEX root = reference.tex
= Computation Expressions
[[computation]]
Computation expressions are a special form of expression notation that permits computations to be performed in an augmented fashion. One standard example is the `task` expression -- see &lt;&lt;concurrent&gt;&gt; -- where the computations identified may be performed in parallel or asynchronously.

The core concepts behind &lt;&lt;ComputationExpression&gt;&gt;s are captured in three contracts -- the  `computation` contract (see Program~\vref{computationContractProg}), the `execution` contract (see Program~\vref{executionContractProg}), and the `injection` contract (see Program~\vref{injectionContractProg}).

There is a standard transformation of &lt;&lt;ComputationExpression&gt;&gt;s into uses of these contracts. An expression may be _encapsulated_ as a computation, &lt;&lt;ComputationExpression&gt;&gt;s may be _combined_ and they may be _performed_ in order to access the value computed.

The `augmentation' of a &lt;&lt;ComputationExpression&gt;&gt; depends on the mode of the expression -- its monad type. For example, the `task` expression allows computations to be interleaved and executed in parallel on a suitable processor. `task` expressions and general concurrency are covered in detail in &lt;&lt;concurrent&gt;&gt;.

\begin{aside}
The &lt;&lt;ComputationExpression&gt;&gt; and the `computation` contract have an analogous relationship as Haskell's Monad class and it's `do` notation. However, the `computation` contract is not identical to the Monad class.
\end{aside}

== The `computation` contract
[[computationContract]]
The `computation` contract defines two key concepts: the `encapsulation' of an expression as a computation that leads to the value of that expression; and the `combination' of two computations.


\begin{program}
[listing]
contract (computation) over m determines e is {
  _encapsulate has type for all t such that (t)=&gt;m of t
  _combine has type for all s,t such that
      (m of s,(s)=&gt;m of t)=&gt;m of t
  _abort has type for all t such that (e)=&gt;m of t
  _handle has type for all t such that
      (m of t,(e)=&gt;m of t)=&gt;m of t
  _delay has type for all t such that (()=&gt;m of t)=&gt;m of t
  _delay(F) default is _combine(_encapsulate(()),(_) =&gt; F())
}

.The Standard `computation` Contract[[computationContractProg]]
\end{program}

\begin{aside}
The name of the contract -- `(computation)` -- is parenthesized in Program~\vref{computationContractProg} and in other references to the contract. This is required because `computation` is the operator used to signal a &lt;&lt;ComputationExpression&gt;&gt;.
\end{aside}

\begin{aside}
The `\_encapsulate` function corresponds to the Monad `return`; and the `\_combine` function corresponds to Monad `bind`. `\_abort` corresponds to `fail`. However, the `\_handle` and `\_delay` functions do _not_ typically appear in Monads.
\end{aside}

The higher-kinded type variable `c` mentioned in the `computation` contract denotes the Monad of the &lt;&lt;ComputationExpression&gt;&gt;. The computation type involving `c` has a single argument -- which is used to denote the value associated with the &lt;&lt;ComputationExpression&gt;&gt;s. For example, `task of integer` is the type of a `task` expression whose value is an `integer`.

=== `\_encapsulate` -- encapsulate a computation value
[[encapsulateFunction]]
(((computation contract@`computation` contract,_encapsulate@`\_encapsulate`)))
`\_encapsulate` is part of the standard `computation` contract.
[listing]
\_encapsulate has type for all m,t,e such that (t)=&gt;m of t
                       where (computation) over m determines e

The `\_encapsulate` function is used to encapsulate a value into a computation that has the value as its value. I.e., the `\_encapsulate` function is at the core of providing the additional indirection between values and computations returning those values.

\begin{aside}
If a computation has no value associated with it then `\_encapsulate` should be invoked with the empty tuple -- `()`.
\end{aside}

=== `\_combine` -- combine two computation values
[[combineFunction]]
(((computation contract@`computation` contract,_combine@`\_combine`)))
`\_combine` is part of the standard `computation` contract.
[listing]
\_combine has type for all m,s,t,e such that (m of s, (s)=&gt;m of t)=&gt;m of t
                   where (computation) over m determines e

The `\_combine` function constructs a new computation value by applying a transforming function to an existing computation value. Typically, the transforming function represents the `next step' in the computation.

=== `\_abort` -- abort a computation
[[abortFunction]]
(((computation contract@`computation` contract,_abort@`\_abort`)))
`\_abort` is part of the standard `computation` contract.
[listing]
\_abort has type for all m,t,e such that (e)=&gt;m of t
                 where (computation) over m determines e


The `\_abort` function is used to represent a failed computation. `\_abort` takes a single argument -- of type `e` -- and returns a computation value.

\begin{aside}
Normally, the `\_abort` implementation will wrap the `e` value in a way that a subsequent `\_handle` or `\_perform` can leverage.
\end{aside}

When an `\_abort`ed computation is `\_perform`ed; the abort handler function will be  invoked with the value passed in to `\_abort`.

=== `\_handle` -- handle an aborted computation
[[handleFunction]]
(((computation contract@`computation` contract,_handle@`\_handle`)))
`\_handle` is part of the standard `computation` contract.
[listing]
\_handle has type for all m,t,e such that
                  (m of t, (e)=&gt;m of t) =&gt; m of t
                  where (computation) over m determines e


The `\_handle` function is used to potentially recover from a failed computation -- while continuing the computation. If the first argument to `\_handle` represents an aborted computation, then the second argument -- a handler function -- is invoked with the exception. It is the responsibility of this handler function to either recover from the exception or to propagate the exception.

=== `\_delay` -- construct a delayed computation
[[delayFunction]]
(((computation contract@`computation` contract,_delay@`\_delay`)))
`\_delay` is part of the standard `computation` contract.
[listing]
\_delay has type for all m,t,e such that (()=&gt;m of t)=&gt;m of t
                 where (computation) over m determines e

The `\_delay` function constructs a new `delayed' computation value. It is used in the construction of &lt;&lt;ComputationExpression&gt;&gt;s -- at the top level -- to ensure that &lt;&lt;ComputationExpression&gt;&gt;s are evaluated at the appropriate time.

The `\_delay` function has a default implementation -- which may be used in case that a particular implementation of `computation` does not require a specific implementation. The default implementation is:
[listing]
_delay(F) default is _combine(_encapsulate(()),(_) =&gt; F())


== The `execution` Contract
[[execution]]

The `execution` contract has a single function defined in it -- encapsulating the concept of performing a computation.

\begin{program}
[listing]
contract execution over m is \{
  _perform has type for all t,e such that (m of t) =&gt; t;
\}

.The Standard `execution` Contract[[executionContractProg]]
\end{program}

=== `\_perform` -- dereference a computation value
[[performFunction]]
(((execution contract@`execution` contract,_perform@`\_perform`)))
`\_perform` is part of the standard `execution` contract.
[listing]
\_perform has type for all m,t,e such that (m of t)=&gt;t
                   where (computation) over m

The `\_perform` function is used to `extract' the value of a computation. As such it is the natural inverse to the `\_encapsulate` function.

If the computation fails, then, typically, an exception will be raised -- see &lt;&lt;exceptionType&gt;&gt;.

\begin{aside}
The standard monad does _not_ include the equivalent of a `\_perform`. One reason being that not all encapsulation functions have an inverse.
\end{aside}

== The `injection` Contract
[[injection]]

The `injection` contract refers to the `injection' of one computation into another. This occurs most often when a &lt;&lt;ComputationExpression&gt;&gt; contains a `perform` action. Such an action represents an `injection' of the inner performed monad into the outer monad.

\begin{program}
[listing]
contract injection over (m,n) is \{
  \_inject has type for all t such that (m of t)=&gt;n of t;
\}

.The Standard `injection` Contract[[injectionContractProg]]
\end{program}

The `injection` contract is a multi-type contract. I.e., implementations of the `injection` contract necessarily mention two types: the source Monad and the destination Monad.

=== `\_inject` -- inject one computation into another
[[injectFunction]]
(((injection contract@`injection` contract,_inject@`\_inject`)))
`\_inject` is part of the standard `injection` contract.
[listing]
\_inject has type for all m,n,t such that (m of t)=&gt;n of t
                  where injection over (m,n)

The `\_inject` function is used to migrate a computation from one monad to another.

There are two primary requirements for the `\_inject` function: a normal computation must be migrated as a normal computation in the target monad; and an aborted computation must be represented as an aborted computation.

In addition to implementing injection in a pairwise manner between monads, it is advisable to implement null-ary `self injection' -- i.e., to and from the same monad.

=== Monadic Laws
[[monadicAxioms]]
Additionally to the type signatures of the functions defined in the `computation` contract, &lt;&lt;ComputationExpression&gt;&gt;s depend on some additional properties of any implementations of the contract.
\begin{aside}
These laws are assumed -- they cannot be verified by the compiler. In particular, if the `computation` contract is implemented for a user-defined type, then the `implementation` must respect the laws identified here.
\end{aside}

The first law relates the `\_encapsulate` and the `\_combine` functions. Specifically, if we combine an `\_encapsulate` with a `\_combine` the value is the same as applying the encapsulated value to the combining function:
\[\begin{array}{rcl}
`\_combine(\_encapsulate(X),F)`&amp;=&amp;`F(X)`
\end{array}\]

The second law is the complement, combining with encapsulation itself leaves the result alone:
\[\begin{array}{rcl}
`\_combine(X,\_encapsulate)`&amp;=&amp;`X`
\end{array}\]

The third law expresses the associativity of `\_combine`:
\[\begin{array}{rcl}
`\_combine(X, (U) =&gt; combine(F(U),G))`&amp;=&amp;`\_combine(\_combine(X,F),G)`
\end{array}\]

The abort law expresses the meaning of `\_abort`:
\[\begin{array}{rcl}
`\_combine(\_abort(E),\_)`&amp;=&amp;`\_abort(E)`
\end{array}\]
I.e., once a computation is aborted, then it effectively stops -- unless it is handled.

The handle law expresses how aborted computations may be recovered from:
\[\begin{array}{rcl}
`\_handle(\_abort(E),F)`&amp;=&amp;`F(E)`\\
`\_handle(\_encapsulate(X),\_)`&amp;=&amp;`\_encapsulate(X)`
\end{array}
\]
`Handling' an encapsulated computation -- i.e., a normal non-aborted computation -- has no effect.

== Computation Expression Semantics


== The `action` Monad
[[actionMonad]]

The `action` type may be used to represent normal actions as &lt;&lt;ComputationExpression&gt;&gt;s. The `action` type is defined in Program~\vref{actionTypeProg}.

\begin{program}
[listing]
type action of t is
     _delayed(()=&gt;action of t)
  or _aborted(exception)
  or _done(t);

.The `action` Contract[[actionTypeProg]]
\end{program}

The different constructors in the `action` type are intended to represent the three `phases' of an action computation: `\_done` denotes a completed computation, `\_delayed` represents a suspended computation and `\_aborted` denotes a failed computation.

The standard implementations of the `computation`, `execution` and the nullary implementation of the `injection` contract are shown in Program~\vref{actionImplementationProgram}.

\begin{program}
[listing]
implementation (computation) over action determines exception is {
  _encapsulate(V) is _done(V);
  _abort(E) is _aborted(E);
  _handle(A,H) is runCombo(A,_encapsulate,H)
  _combine(A,C) is _delayed(()=&gt;runCombo(A,C,_abort))
  _delay(F) is _delayed(F);
}
implementation execution over action determines exception is {
  _perform(A,H) is runCombo(A,id,H)
};
implementation injection over (action,action) is {
  _inject(C) is C;
}
private
runCombo(_delayed(D),C,H) is runCombo(D(),C,H)
 |  runCombo(_done(X),C,_) is C(X)
 |  runCombo(_aborted(E),_,H) is H(E)

.Implementation of Standard `execution` Contracts for the `action` Monad[[actionImplementationProgram]]
\end{program}

== Computation Expressions
[[computationExpression]]

A &lt;&lt;ComputationExpression&gt;&gt; is a special syntax for writing expressions involving the various computation contracts. The compiler will automatically translate &lt;&lt;ComputationExpression&gt;&gt;s into appropriate combinations of the functions in the `computation`, `execution` and `injection` contracts.

A &lt;&lt;ComputationExpression&gt;&gt; consists of an &lt;&lt;ActionBlock&gt;&gt;; i.e., a sequence of &lt;&lt;Action&gt;&gt;s preceded by the `computation` keyword and the name of a generic unary type -- as defined in &lt;&lt;computationExpressionFig&gt;&gt;.

\begin{figure}[H]
\begin{eqnarray*}
_Expression_&amp;\arrowplus&amp;&lt;&lt;ComputationExpression&gt;&gt;\\
[[ComputationExpression]]ComputationExpression::=&lt;&lt;Identifier&gt;&gt;\ `computation`\ `\{`\ &lt;&lt;Action&gt;&gt;\sequence{;}&lt;&lt;Action&gt;&gt;`\`}\end{eqnarray*}
.Computation Expression
[[computationExpressionFig]]
\end{figure}

The type identified in the &lt;&lt;ComputationExpression&gt;&gt; must implement the `computation` contract. For example, the `maybe` type:
[listing]
type maybe of \%t is possible(\%t) or impossible(exception)

might have the implementation defined in Program~\vref{maybeProgram} for the `computation` contract.

\begin{program}
[listing]
implementation (computation) over maybe determines exception is {
  _encapsulate(X) is possible(X);
  _combine(possible(S),F) is F(S);
   |  _combine(impossible(R),_) is impossible(R);
  _abort(Reason) is impossible(Reason);
  _handle(M matching possible(_),_) is M;
   |  _handle(impossible(E),F) is F(E);
}

.Implementing the  `computation` contract for `maybe`[[maybeProgram]]
\end{program}

Given such a definition, we can construct `maybe` &lt;&lt;ComputationExpression&gt;&gt;s, such as in the function `find` in:
[listing]
find(K,L) is maybe computation \{
  for (KK,V) in L do\{
    if K=KK then
      valis V;
  \};
  raise "not found";
\};


Note that the `find` function does _not_ directly look for a value in a sequence. The value of a call to `find` is a computation that, when evaluated, will return the result of looking for a value.

=== Accessing the value of a computation expression
Where the &lt;&lt;ComputationExpression&gt;&gt; notation is used to construct a computation; the `valof` form is used to access the value denoted.

There are two variations of `valof` expressions, outlined in &lt;&lt;valofFig&gt;&gt;.

\begin{figure}[hbtp]
\begin{eqnarray*}
_Expression_&amp;\arrowplus&amp;&lt;&lt;ValofComputation&gt;&gt;\\
[[ValofComputation]]ValofComputation::=`valof`\ &lt;&lt;Expression&gt;&gt;\\
  | `valof`\ &lt;&lt;Expression&gt;&gt;\ `on abort`\ &lt;&lt;CaseActionBody&gt;&gt;
\end{eqnarray*}
.Valof computation expression
[[valofFig]]
\end{figure}

The first form simply accesses the value associated with the computation -- and assumes that it was successful. For example, given a list:
[listing]
M is list of [(1,"alpha"), (2,"beta"), (3,"gamma"), (4,"delta")];

then the expression:
[listing]
valof find(2,MM)

will have value
[listing]
"beta"


The second form uses an `on abort` handler to cope with reported failure in the &lt;&lt;ComputationExpression&gt;&gt;. For example, the expression:
[listing]
valof ff(5,MM) on abort \{ exception(_,E cast string,_) do valis E \}

will have value the string `"not found"`.

=== Performing a computation
[[performComputation]]
The &lt;&lt;PerformComputation&gt;&gt; is the analog of &lt;&lt;ValofComputation&gt;&gt; where the computation is an action that does not have a return value.

\begin{figure}[hbtp]
\begin{eqnarray*}
_Action_&amp;\arrowplus&amp;&lt;&lt;PerformComputation&gt;&gt;\\
[[PerformComputation]]PerformComputation::=`perform`\ &lt;&lt;Expression&gt;&gt;\\
  | `perform`\ &lt;&lt;Expression&gt;&gt;\ `on abort`\ &lt;&lt;ActionCaseBody&gt;&gt;
\end{eqnarray*}
.Perform Computation Action
[[performFig]]
\end{figure}

The `perform` action is used when an action -- typically in a sequence of actions -- is the performance of a &lt;&lt;ComputationExpression&gt;&gt;.

\begin{aside}
The type of computation being `perform`ed _does not_ have to be the same as the performing computation. For example, it is permissible to mix `task` computations with `maybe` computations:
[listing]
TT is task\{
  perform ff(5,MM)
\}

Note that, as with all actions, any value returned by the performed computation is discarded.
\end{aside}

\begin{aside}
`perform` within a &lt;&lt;ComputationExpression&gt;&gt; denotes a use of the `\_inject` function. I.e., the `perform`:
[listing]
perform ff(5,MM)
    on abort \{ exception(_,E case string,_) do logMsg(info,E) \}

is represented by the expression:
[listing]
\_inject(ff(5,MM), (E) =&gt; valof\{ logMsg(info,E); valis () \})

The normal overloading rules will ensure that the appropriate implementation of injection between monads is invoked.
\end{aside}

=== Handling Failure
[[failAction]]

When a computation should _fail_ instead of succeeding normally, the &lt;&lt;AbortAction&gt;&gt; is used to signal the failure. The failure itself is handled using an
The &lt;&lt;OnAbort&gt;&gt; action is used to handle a failed (i.e., `\_abort`ed) computation -- while continuing the &lt;&lt;ComputationExpression&gt;&gt; itself.

\begin{figure}[hbtp]
\begin{eqnarray*}
_Action_&amp;\arrowplus&amp;&lt;&lt;OnAbort&gt;&gt;\\
[[OnAbort]]OnAbort::=`try`\ &lt;&lt;Action&gt;&gt;\ `on abort`\ &lt;&lt;ActionCaseBody&gt;&gt;
\end{eqnarray*}
.Abort Handler Action
[[failHandleFig]]
\end{figure}

The `on abort` action is used to recover from a failed computation, specifically from an &lt;&lt;AbortAction&gt;&gt;. The &lt;&lt;ActionCaseBody&gt;&gt; is a rule that matches the failure and performs appropriate recovery action. For example, the action in:
[listing]
task\{
  try P(X) on abort \{ E do logMsg(info,"exceptional \$E") \}
\}

calls the procedure `P`; but if that results in an abort, then the abort handler is entered with the variable `E` being matched against the exception.

The type of the exception variable is the determined type from the `computation` contract.

It is equivalent to a call of the contract function `\_handle`. I.e., the above action is equivalent to:
[listing]
\_handle(P(X),
         (E) =&gt; valof \{ logMsg(info,"exceptional \$E"); valis () \})


=== `action` Expressions
[[actionExpression]]
A basic variant of the &lt;&lt;ComputationExpression&gt;&gt; is the `action` expression. `action` expressions take the form:
[listing]
action\{ &lt;&lt;Action&gt;&gt;\sequence{;}&lt;&lt;Action&gt;&gt; \}

which is shorthand for:
[listing]
action computation \{ &lt;&lt;Action&gt;&gt;\sequence{;}&lt;&lt;Action&gt;&gt; \}


\begin{aside}
There is a strong connection between `action` expressions and &lt;&lt;ValueExpression&gt;&gt;s. In particular, we have the equivalence:
\[\begin{array}{rcl}
`valof\{` &lt;&lt;Action&gt;&gt;\sequence{;}&lt;&lt;Action&gt;&gt;`\`}&amp;=&amp;`valof action\{`&lt;&lt;Action&gt;&gt;\sequence{;}&lt;&lt;Action&gt;&gt;`\`}
\end{array}
\]
However, a crucial distinction between `action` expressions and &lt;&lt;ValueExpression&gt;&gt;s is that the former may be manipulated and combined in addition to the value being determined.
\end{aside}
</Text>
        </Document>
        <Document ID="25696C1E-718A-4E0B-973C-0D0FDA85270D">
            <Title>Expressions-28</Title>
            <Text>
=== Accessing Elements of a Collection
[[indexedAccess]]
(((indexed access to collection)))
(((access list with index)))
An expression of the form:
[listing]
C[ix]

is equivalent to the expression
[listing]
_index(C,ix)

\begin{aside}
The type of the resulting value from an indexed access is `option`al -- see &lt;&lt;optionExpression&gt;&gt;. I.e., since it cannot be guaranteed -- in general -- that the element exists, the resulting type expresses that uncertainty.

You can extract the underlying value by using the `someValue` function -- see &lt;&lt;someValue&gt;&gt; -- but a safer way is to use a `has value` condition (see &lt;&lt;hasValueCond&gt;&gt;.
\end{aside}

The presence of an element can be tested in one of two ways: by using the `present` predicate -- see &lt;&lt;presentCond&gt;&gt;:
[listing]
present C[Ix]

which tests whether `C` has an element at index `Ix` or using the special condition:
[listing]
C[Ix] has value V

which are equivalent to
[listing]
_index(C,Ix) matches some(_)

and
[listing]
_index(C,Ix) matches some(V)

respectively.</Text>
        </Document>
        <Document ID="B0417A1B-D617-4CBD-900A-14A6AB12C289">
            <Title>Ideas</Title>
        </Document>
        <Document ID="C2091E71-0C58-41EA-96D8-B04560EBB008">
            <Title>Type Safety</Title>
            <Text>An enumerated symbol occurring within a type definition has the defined type.
[NOTE] A particular consideration should be made for the case where an enumerated symbol is part of a universally quantified type.</Text>
        </Document>
        <Document ID="2D319D51-FC64-4545-9CE4-45763E4BE291">
            <Title>Quoted Strings</Title>
            <Text>A string is a sequence of character references (CharRef) enclosed in double quotes; alternately a string may take the form of a triple-quoted BlockString. In addition, quoted strings support interpolation — expressions that are embedded in a string and are formatted in place.
StringLiteral ::= " StrChar ... StrChar “ | BlockString
StrChar ::= CharRef | Interpolation
Interpolation ::= [$| #] Identifier [FormattingSpec]]
  |[$| #] ( Expression ) [FormattingSpec ]
FormattingSpec ::= : CharRef ... CharRef;
Quoted String
[TIP] Strings are not permitted to contain the new-line character -- other than as a character reference.
"This string has a \nnew line in the middle"</Text>
            <Comments>Francis McCabe 2/11/18, 8:44 PM
We may remove some of this.</Comments>
        </Document>
        <Document ID="79EA3876-1888-430B-AC41-CB01970EDB1D">
            <Title>Parameterized Types</Title>
            <Text>A parameterized TypeExpression consists of a TypeConstructor applied to one of more Type arguments. For example, the standard cons type constructor has one type argument -- the type of elements of the list.
A parameterized type has a type arity -- the number of type arguments it expects. This is defined when the type itself is defined. It is an error to write a type expression involving an incorrect number of type arguments.
Parameterized types may be defined using a TypeDefinition statement.</Text>
        </Document>
        <Document ID="6E70660C-06CC-4ADD-9B7F-683F8D1EE998">
            <Title>Expressions-42</Title>
            <Text>
=== The Type of Abstract Syntax Terms
The foundation of this is the standard `quoted` type which defines the structure of quoted fragments. The `quoted` type is defined in Program~\vref{quotedProg} and the ancillary type `astLocation` is defined in Program~\vref{locationProg}.
\begin{program}
[listing]
type quoted is nameAst(astLocation,string)
            or boolAst(astLocation,boolean)
            or stringAst(astLocation,string)
            or integerAst(astLocation,integer)
            or longAst(astLocation,long)
            or floatAst(astLocation,float)
            or decimalAst(astLocation,decimal)
            or applyAst(astLocation,quoted,list[quoted])

.The `quoted` Type[[quotedProg]]
\end{program}

=== Locations
The `quoted` forms include an `astLocation` field that indicates where the `quoted` term first appeared in a program. This type is defined in Program~\vref{locationProg}.
\begin{program}[htb]
[listing]
type astLocation is _someWhere{
    source has type uri;
    charCount has type integer;
    lineCount has type integer;
    lineOffset has type integer;
    length has type integer;
  }
  or noWhere;

.The `astLocation` Type[[locationProg]]
\end{program}</Text>
        </Document>
        <Document ID="CC6A1D91-B8E7-4830-B027-83613557B60C">
            <Title>Macros</Title>
            <Text>%!TEX root = reference.tex
= Macro Language
[[MacroLanguage]]
The macro language supports the rewriting of parse tree structures -- prior to type checking.
\begin{aside}
The fact that macro processing applies before type checking implies that it is both possible and required to translate non-native Star program fragments into Star programming constructs.
\end{aside}

\begin{aside}
As a result it is not possible to use the macro  language to construct a program expression that is unparsable -- although it may not be compilable.
\end{aside}

There are two variants of macro program -- macro rules and macro functions.
A macro rule is a rule that applies to a fragment of the text of the program itself. A macro function is a regular Star function whose type signature is
[listing]
(quoted)=&gt;quoted


Macro rules take the form:
\begin{figure}[htbp]
\begin{eqnarray*}
[[MacroRule]]MacroRule::=`\#`&lt;&lt;MacroPattern&gt;&gt;\ `==&gt;`\ &lt;&lt;MacroReplace&gt;&gt;\\
  | `\#` `fun` &lt;&lt;Equation&gt;&gt;\\
\end{eqnarray*}
.Macro Rule
[[macroRuleFig]]
\end{figure}

\noindent
where &lt;&lt;MacroPattern&gt;&gt; is a pattern that is applied to abstract syntax tree fragments and &lt;&lt;MacroReplace&gt;&gt; is a replacement template. The macro pattern can bind macro variables, check for literals, and even search within the term. The &lt;&lt;MacroReplace&gt;&gt; is generally a template term that may have variables which can be instantiated by the variables from the pattern.

\begin{aside}
We use the term `fragment of text' here somewhat carefully. All macro patterns can only match syntactically valid subsections of source text. A macro pattern denotes a match on the abstract syntax tree of a source program, not a match on textual source.
\end{aside}

== Macro Patterns
Macro rules are written using the same operators that `regular' programs use. A macro pattern of the form:
[listing]
# ?A+?B ==&gt; ...

is, in fact, more or less the same as the macro pattern
[listing]
# plus(?A,?B) ==&gt;

but for the fact that `+` is a binary operator and is written in infix form. Of course, `+` is not the same symbol as `plus`; but the pattern `?A+?B` is equivalent to:
[listing]
# #(+)#(?A,?B) ==&gt; ...

See &lt;&lt;macroParentheses&gt;&gt;. In effect,  macro patterns are not sensitive to operator declarations.

\begin{figure}[htbp]
\begin{eqnarray*}
[[MacroPattern]]MacroPattern::=&lt;&lt;Identifier&gt;&gt;\ |\ &lt;&lt;String&gt;&gt;\ |\ &lt;&lt;Integer&gt;&gt;\ |\ &lt;&lt;FloatingPoint&gt;&gt;\ |\ &lt;&lt;CharRef&gt;&gt;\\
  | `integer`\ |\ `long`\ |\ `float`\ |\ `decimal`\\
  | `identifier`\  |\ `string`\\
  | &lt;&lt;MacroPattern&gt;&gt;`(`&lt;&lt;MacroPattern&gt;&gt;\sequence{,}&lt;&lt;MacroPattern&gt;&gt;`)`\\
  | &lt;&lt;MacroPattern&gt;&gt;`\{`&lt;&lt;MacroPattern&gt;&gt;\sequence{,}&lt;&lt;MacroPattern&gt;&gt;`\`}\\
  | &lt;&lt;MacroPattern&gt;&gt;\ `@`\ &lt;&lt;MacroPattern&gt;&gt;\\
  | &lt;&lt;MacroPattern&gt;&gt;\ `@@`\ &lt;&lt;MacroPattern&gt;&gt;\\
  | [\ &lt;&lt;MacroPattern&gt;&gt;\ ]\ `?`\ &lt;&lt;Identifier&gt;&gt;\\
  | `?`&lt;&lt;Identifier&gt;&gt;`./`&lt;&lt;MacroPattern&gt;&gt;\\
  | `\#(`&lt;&lt;MacroPattern&gt;&gt;`)\#`
\end{eqnarray*}
.Macro Patterns
[[macroPatternFig]]
\end{figure}

=== Literal Macro Patterns
[[literalMacroPtn]]
(((macro,pattern!literal)))
Literal identifiers, numbers and strings may act as macro patterns.

A literal number or string matches exactly the same literal value in the abstract syntax tree.
\begin{aside}
Identifiers may act as literal patterns -- provided that they have not previously been marked as a macro variable. If an &lt;&lt;Identifier&gt;&gt; is declared as a macro variable then an occurrence of the variable acts as a test for equality.
\end{aside}
\begin{aside}
A literal number or string _may not_ be the sole pattern of a &lt;&lt;MacroRule&gt;&gt;. I.e., a &lt;&lt;MacroRule&gt;&gt; of the form:
[listing]
# 34 ==&gt; 56

is not legal.
\end{aside}

=== Macro Variable Pattern
A pattern of the form
[listing]
?Var

will match any structure and bind the macro variable `Var` to that structure. If there is more than one occurrence of the macro variable then they must all have the same value. For example, the following macro replaces a redundant sum with a multiplication:
[listing]
#?X + ?X ==&gt; 2*X.

A second variation of the macro variable pattern allows any macro pattern to be applied and the matched result to be bound to a variable:
[listing]
\#(_Ptn_)\#?_Var_

\begin{aside}
The parentheses are good practice: the priority of `?` as an infix operator is 100, which means that most operator expressions will require the parentheses.
\end{aside}

Subsequent references to a macro variable, including on the _right hand side_ of a macro rule do not require the `?` prefix.

=== Application Macro Pattern
[[applicMacroPtn]]
(((macro,pattern|application)))

An `applicative pattern' -- i.e., a pattern that resembles a function call -- matches abstract syntax terms that are similarly applicative. For example, the pattern in the macro rule:
[listing]
\# foo(?X,?Y) ==&gt; bar(Y,X)

will match abstract syntax terms that consist of the identifier `foo` applied to two arguments.
\begin{aside}
This rule will _not_ match `foo` terms involving 0 or 1 arguments, nor more than 2 arguments.
\end{aside}
\begin{aside}
The application macro pattern actually applies (sic) to _any_ application expression regardless of the use of operators or the role of the application. For example, the rule:
[listing]
\# ?X + ?Y ==&gt; plus(X,Y)

involves the use of the binary operator `+`. However, the operator pattern is equivalent to a rule of the form:
[listing]
\# +(?X,?Y) ==&gt; plus(X,Y)

except that the grammar prohibits operators being used as `regular' functions. The binary `+` rule can, however, be written:
[listing]
\# \#(+)\#(?X,?Y) ==&gt; plus(X,Y)

\end{aside}

\noindent
Other bracket pairs also support analogous application syntax; and the macro patterns to suit. For example, the macro rule:
[listing]
\# A[?Ix] ==&gt; B(Ix)

matches `square bracket terms' such as `A[2]` and `A[foo("alpha")]`; replacing them by `B(2)` and `B(foo("alpha"))` respectively.

The macro rule:
[listing]
\# #(?Op)#[?Ix] ==&gt; \_index(Op,Ix)

is based on the standard macros used to provide the traditional array indexing notation in terms of the standard `indexable` contract (see &lt;&lt;indexableContract&gt;&gt;).

=== Nested Search
The pattern
[listing]
?V./_Ptn_

binds the macro variable _V_ to the term being matched, provided that, within the term being matched there is a sub-expression that matches `_Ptn_`. This pattern is especially useful for useful for transformations that are not locally specifiable. The location of the matched sub-pattern can be referenced in the nested replacement (see &lt;&lt;NestedReplacement&gt;&gt;).

\begin{aside}
The left hand side of the `./` operator _must_ be a macro variable.
\end{aside}

=== Number Patterns
The pattern
[listing]
integer

will match a _literal_ integer in the program.
This pattern will only match numeric literals, it will not match an expression whose value is an integer.
\begin{aside}
This pattern would normally be used in conjunction with a macro variable pattern -- as it is not value specific.
\end{aside}
For example, the pattern
[listing]
integer?V

would bind the macro variable `V` to `12` if matching the literal 12, but would not match
[listing]
6*2

The other numeric patterns `long`, `float` and `decimal` similarly match literals of the appropriate type.

=== Identifier Pattern
The pattern
[listing]
identifier

matches any identifier. Note that the `identifier` pattern will _not_ match any keywords of the language.

=== The `string` Macro Pattern
The `string` macro pattern matches any literal string value.
\begin{aside}
A `string` pattern will not match a string literal that includes any &lt;&lt;StringIterpolation&gt;&gt; expressions. Although it could be used to match parts of such a string literal.
\end{aside}


=== Parentheses
(((macro,parentheses)))
The `normal' parentheses -- `()` -- are _not_ ignored by the parser. I.e., a term of the form:
[listing]
(A+B)

is _not_ the same to the macro processor as the term
[listing]
A+B

Thus the macro rule:
[listing]
# (?X) ==&gt; ...

matches terms that have been enclosed in parentheses, and matches `(A+B)` by binding the macro variable `X` to `A+B`. It does _not_ match `A+B`.

=== Macro Parentheses
[[macroParentheses]]
(((macro,parentheses!macro)))
The macro parentheses -- `\#(...)\#` -- _are_ ignored by the parser. I.e., a term of the form
[listing]
\#(A+B)\#

_is_ syntactically equivalent to `A+B`.

Macro parentheses are used in macro rules for cases where the operator priorities of normal expressions interacts with the priorities of macro rules.

For example, the macro rule:
[listing]
# #(select all from ?P in ?S)# ==&gt; list of \{ for P in S do elemis P \}

uses `\#()\#` parentheses to isolate the `select` pattern being matched within the rule.

Another use for `\#()\#` is in matching the function part of an application. For example, the macro rule pattern
[listing]
... \#(?F)\#(?A1,?A2) ...

matches any binary function application and binds the macro variable `F` to the function part of the application and binds macro variables `A1` and `A2` to the first and second arguments.

\begin{aside}
Note that it is _not_ permitted for a macro variable to be the top-level pattern in a macro rule. The rule:
[listing]
# \#(?F)\#(?A1,?A2) ==&gt; bar(A1,A2)

is not permitted because the top-level operator in the rule is a macro variable -- `?F`. This form of pattern is very useful in sub-patterns of the macro rule.
\end{aside}


=== Applicative Pattern

The macro operator `@@` matches any applicative expression. The left hand sub-pattern matches the operator part of the applicative and the right hand side matches the arguments.

For example, the macro pattern:
[listing]
... ?F@@?A ...

matches any applicative expression -- including expressions involving standard symbols such as `=&gt;` or `is`.

\begin{aside}
The `@@` operator may not be the _most significant_ operator in a macro rule.
\end{aside}




== Macro Replacements
Generally, a macro replacement is simply a fragment of program text with macro variable references embedded where input should be carried over.

\begin{figure}[htbp]
\begin{eqnarray*}
[[MacroReplace]]MacroReplace::=&lt;&lt;Identifier&gt;&gt;\ |\ &lt;&lt;String&gt;&gt;\ |\ &lt;&lt;Integer&gt;&gt;\ |\ &lt;&lt;FloatingPoint&gt;&gt;\ |\ &lt;&lt;CharRef&gt;&gt;\\
  | &lt;&lt;MacroReplace&gt;&gt;`(`&lt;&lt;MacroReplace&gt;&gt;\sequence{,}&lt;&lt;MacroReplace&gt;&gt;`)`\\
  | &lt;&lt;MacroReplace&gt;&gt;`\{`&lt;&lt;MacroReplace&gt;&gt;\sequence{,}&lt;&lt;MacroReplace&gt;&gt;`\`}\\
  | &lt;&lt;MacroReplace&gt;&gt;\ `@@`\ &lt;&lt;MacroReplace&gt;&gt;\\
  | `?`\ &lt;&lt;Identifier&gt;&gt;\\
  | &lt;&lt;Identifier&gt;&gt;`./`&lt;&lt;MacroReplace&gt;&gt;\\
  | `\#(`&lt;&lt;MacroReplace&gt;&gt;`)\#`\\
  | &lt;&lt;MacroReplace&gt;&gt; `\#\#` `\{` &lt;&lt;MacroRule&gt;&gt; \sequence{;}&lt;&lt;MacroRule&gt;&gt; `\`}
\end{eqnarray*}
.Macro Replacement Terms
[[macroReplaceFig]]
\end{figure}


=== Macro Variable
An occurrence of a macro variable in the replacement pattern is replaced by the fragment of program that was matched by the corresponding macro variable pattern. For example,
[listing]
# foo(?X) ==&gt; bar(X)

replaces occurrences of the form
[listing]
foo(\{a="alpha"\})

with
[listing]
bar(\{a="alpha"\})


=== Nested Replacement
[[NestedReplacement]]
A replacement expression of the form:
[listing]
?V./_Rep_

can be used to replace a nested sub-expression that was matched by a `./` pattern. The replacement text consists of the whole of the expression matched -- held as the value of the variable `?V` -- except that the part of the original that had been matched by the nested pattern is replaced by `_Rep_`.

=== Generated Symbols
(((macro,generated symbol)))
The macro replacement pattern
[listing]
#\$ _ident_

results in a new identifier of the form
[listing]
_ident1234_

where the number that is added to the `_ident_` argument of `\#\$` is guaranteed to be unique within a single compilation _and_ that multiple occurrences of `\#\$_ident_` within a single macro rule will be replaced by the _same_ identifier.

This is useful for macros that generate new symbols. For example, the macro rule:
[listing]
#unfold(?Ex./Ave(?Tm)) ==&gt; let\{#\$ave=Average(Tm)\} in Ex./#$ave;

would have the effect of `lifting' a call to the `Ave` function and making it into a `let` expression. I.e., it would rewrite
[listing]
10+Ave(foo(X))

to
[listing]
let\{ ave34=Average(foo(X))\} in 10+ave34


=== Interned Strings
(((macro,interning string as symbol)))
The macro replacement expression:
[listing]
#\tlda _Exp_

where _Exp_ is a `string`-valued _macro expression_ is replaced by an identifier whose name is the string value of _Exp_.

For example, the macro rule:
[listing]
#applyOf(?Exp) ==&gt; #\tlda("Apply"#+Exp)

can be used to construct an identifier whose prefix is `Apply`. The variable assigned to in:
[listing]
var applyOf(2) := 34

is `Apply2`.

=== Location
[[locationMacro]]
(((macro,location)))

The replacement pattern
[listing]
#__location__

is replaced by a string that denotes the location of the original term that was matched by this macro rule.

Typically this string indicates the file name and the line number of the term.

=== Macro Let
[[ScopedMacros]]
A replacement pattern of the form:
[listing]
_Rep_ ## \{ &lt;&lt;MacroRule&gt;&gt;\sequence{;}&lt;&lt;MacroRule&gt;&gt; \}

acts as though the replacement were just `_Rep_`. However, in the continued processing of `_Rep_`, there may be additional macro substitution. The locally defined rules take precedence over other rules.

==== Free Variables in Macro Rules
Rules within the sub-scope may reference macro variables defined in outer macro rules. These free variables retain the value that they were given as part of the macro rule pattern matching.

For example, the inner rule in:
[listing]
# foo(?X) ==&gt; bar(given) ## \{
  #given ==&gt; X;
\}

refers to the macro variable `X` that is bound during the match with `foo`. The rule for `given` may reference `X` which is free in the `given` rule but bound by the `foo` rule.

=== Code Macros
[[codeMacros]]
In addition to the macro language defined here, it is also possible to define macro processing rules using `regular' Star. So-called code macros are normal Star programs whose type is
[listing]
(quoted)=&gt;quoted

Code macros use a prefix `\#` to mark them as being macro functions rather than just being normal functions.

For example, the macro definition:
[listing]
\#glom(?AA,?BB) ==&gt; glue(AA,BB) ## \{
    \#glue(X,Y) is glm(X,Y)

    glm(A,&lt;|()|&gt;) is A
     |  glm(&lt;|()|&gt;,A) is A
     |  glm(&lt;|?L;?R|&gt;,A) is &lt;|?L;?glm(R,A)|&gt;
     |  glm(A,B) is &lt;|?A;?B|&gt;
  \};

is part of the standard macro library that `glues' two macro terms together.
\begin{aside}
The `glom` macro is very useful when generating sequences of definitions for example -- because the generation definitions must be separated by semi-colons.
\end{aside}
Notice that in this example we do not mark the `glm` function with a `\#`. This is because `glm` is an internal function that is not intended to be accessible directly. Only macro code functions that are intended to be accessed directly should be marked as code macros. This allows other functions -- whose type signatures may not make them suitable for macro processing -- to be mixed in with code macros.

Another difference between code macros and normal macro rules is that one has to be explicit about using the quoted form. Furthermore, as above, the programmer has to use the `?` form to de-quote variables in the replacement even when they have been mentioned in the left-hand side.

\begin{aside}
Generally, code macros tend to be `lower-level' than normal macro rules. However, expression evaluation is inherently faster than macro replacement; and the ability to use auxiliary structures -- such as `map`s of program fragments -- during macro processing make code macros preferable in cases where substantial transformations are being implemented.
\end{aside}

== Macro Evaluation
[[macroEvaluation]]
During the macro pattern matching process it is quite possible for multiple macro rules to match a given fragment of source text.
\begin{aside}
The `source text' referred to here is actually an abstract syntax tree -- or part of. Abstract syntax trees have a standard type: `quoted` -- see &lt;&lt;quotedText&gt;&gt;.
\end{aside}

Macro evaluation is an `outside-in' process in which rules are applied in the order that they are written -- with local rules overruling imported rules.

\begin{enumerate}
\item Macro replacement is focused on a so-called `current term' -- the fragment of the abstract syntax tree that is the current candidate for replacement.
\item
The set of available macro rules is used to rewrite the current term. A macro rule is applicable to the current term if its pattern matches the term.
\item
If the applicable macro is a code macro then the code macro function is entered and its return value is used as the replacement.
\item
If there are no applicable macros, then -- in the case of an applicative term -- each of the arguments of the term are rewritten.
\item If any of the arguments are successfully rewritten by a macro-rule, or if a rule applied to the current term as a whole, then the macro process is repeated on the rewritten term.
\end{enumerate}

In more detail, the rules for determining which macros may be applied is governed by the following ordering:
\begin{enumerate}
\item
Within a scoped macro -- see &lt;&lt;ScopedMacros&gt;&gt; -- macro rules that are defined within the sub-scope take precedence over other macro rules.
\item
Any macros that are defined at the top-level of a package.
\item
Macros that are part of imported packages.
\item
Macro rules that are defined earlier in a given scope take precedence over rules defined later in the scope.
\end{enumerate}

=== The Most Significant Macro Operator
[[mostSignificant]]
(((macro,most significant operator)))
In any given macro pattern, there is a _most significant operator_ that represents the outermost symbol of the terms that the pattern matches.

For a simple pattern such as `integer`, or simply `34`, the pattern itself is the most significant operator.

For a compound pattern, such as `foo(?A1,?A2)` the most significant operator of the function part of the pattern is the most significant operator (in this case it is the literal identifier `foo`.

The macro language imposes a restriction on macro rules -- the most significant operator of the pattern on the left hand side of the rule _must_ be a literal identifier pattern.
</Text>
        </Document>
        <Document ID="ACE3EEC2-FA97-4AE4-888F-CFB767F8DAD3">
            <Title>Floating Point Numbers</Title>
            <Text>Floating point numbers are written using a notation that is familiar. For example,
234.45  1.0e45
The notation for floating point is:
FloatingPoint::=Decimal . Decimal [e[-]Decimal]]
Floating Point numbers
[TIP] All floating point number are represented to a precision that is at least equal to 64-bit double precision. There is no equivalent of single-precision floating pointer numbers.</Text>
        </Document>
        <Document ID="51A473DD-67F0-4D3B-BBFA-991B798E7B1C">
            <Title>Quoted Identifiers</Title>
            <Text>A quoted identifiers is denoted by a sequence of CharRefs enclosed in single quotes. Recall that strings are enclosed in double quotes.
QuotedIdentifier ::= 'StrChar .. StrChar'
Quoted Identifier
A quoted identifier suppresses any operator or keyword interpretation that the identifier might otherwise have.
[TIP] This can be useful for external facing interfaces where, for example, the name of a field in a structure must have a particular form -- even if that would otherwise be a keyword.</Text>
        </Document>
        <Document ID="7F3B7BCC-530E-4EE8-8509-48FB3F4944B8">
            <Title>Expressions-10</Title>
            <Text>
=== Enumerated Symbols
[[enumeratedSymbol]]
(((expression,enumerated symbol)))
(((enumerated symbol)))
Enumerated symbols are written using regular identifiers (see &lt;&lt;enumSymbolFig&gt;&gt;). Such a symbol must first have been declared within a type definition statement -- see &lt;&lt;enumSymbol&gt;&gt; -- which also determines the type of the symbol.

For example, the `boolean` type definition has two &lt;&lt;EnumeratedSymbol&gt;&gt;s in its definition: `true` and `false`. Thus
[listing]
true

is an expression consisting of an &lt;&lt;EnumeratedSymbol&gt;&gt; from the definition:
[listing]
type boolean is true or false;</Text>
        </Document>
        <Document ID="043CE6FF-0ED6-4F64-BB47-0522EBDF7DE9">
            <Title>Expressions-11</Title>
            <Text>
== Algebraic Constructor Expressions
[[algebraicConstructors]]

The &lt;&lt;AlgebraicConstructor&gt;&gt; expressions are those that refer to constructors that are defined in &lt;&lt;AlgebraicType&gt;&gt; definitions -- _or those that arise from standard type schemas such as tuples and anonymous records_.

There are two primary forms of &lt;&lt;AlgebraicConstructor&gt;&gt;s: positional &lt;&lt;ConstructorLiteral&gt;&gt; terms and &lt;&lt;RecordLiteral&gt;&gt; terms.

Records allow their fields to be addressed individually.

\begin{figure}[htbp]
\begin{eqnarray*}
[[AlgebraicConstructor]]AlgebraicConstructor::=&lt;&lt;EnumeratedSymbol&gt;&gt;\\
  | &lt;&lt;ConstructorLiteral&gt;&gt;\\
  | &lt;&lt;TupleLiteral&gt;&gt;\\
  | &lt;&lt;RecordLiteral&gt;&gt;\\
  | &lt;&lt;AnonymousRecord&gt;&gt;\\
  | &lt;&lt;RecordAccess&gt;&gt;\\
  | &lt;&lt;SequenceExpression&gt;&gt;
\end{eqnarray*}
.Algebraic Constructor Expressions
[[algebraicExpressionFig]]
\end{figure}</Text>
        </Document>
        <Document ID="EF396EE9-E3E7-41DD-B642-097B90152DE7">
            <Title>Number Literals</Title>
            <Text>Star supports integer values, floating point values, and character codes as numeric values.
NumericLiteral ::= Decimal
  | Hexadecimal
  | FloatingPoint
  | CharacterCode
Numeric Literals

[TIP] The lexical syntax for numeric values is for positive values only. The interpretation of negative numeric literals is part of the grammar, not the lexical notation.</Text>
        </Document>
        <Document ID="A8F60E55-92EF-43B8-96A3-535182D8A5E8">
            <Title>Type Annotations</Title>
            <Text>In many cases it is not necessary to explicitly declare the type of a variable. However, it is good practice to declare explicitly the types of programs; especially within thetaEnvironments.
For example, a generic function consLength that takes a `cons` list and returns an integer would have the declaration:
consLength:all t ~~ (cons[t])=&gt;integer
This is an example of a universally quantified type -- see &lt;&lt;universalType&gt;&gt; for more details.</Text>
        </Document>
        <Document ID="EA0BD8D8-C08A-40E2-ABF8-BE66FBA25DE5">
            <Title>Operator Defined Tokens</Title>
            <Text>When a new operator is defined it may be that it takes the form of a normal identifier; as in:
#infix(‘hello’,50)
However, it is also possible to define an operator from special characters:
#prefix(‘|.|’,80)
The operator identifier — |.| — is not a normal alphanumeric identifier.
When such a declaration is processed, the tokenizer extends itself to include the new operator identifier as a valid token. Hence an operator may be constructed out of any characters.
[WARNING] It is not permissible to mix alphanumeric characters with non-alphanumeric characters in an operator.
I.e., the operator declaration:
#postfix(‘alpha%|beta’,90)
will not be processable as a single token. Hence such operators are not permitted.</Text>
        </Document>
        <Document ID="5F2D5633-F60F-4B4B-94B1-5E471E8644DF">
            <Title>Expressions-39</Title>
            <Text>
== Quoted Expressions
[[quotedText]]

The `quote` expression is used to `convert' a fragment of Star source text into a form that can be processed by Star programs.

\begin{figure}[htbp]
\begin{eqnarray*}
[[QuotedExpression]]QuotedExpression::=`quote(`&lt;&lt;QExpression&gt;&gt;`)`\\
  | `&lt;|`&lt;&lt;QExpression&gt;&gt;`|&gt;`\\
[[QExpression]]QExpression::=`unquote(`&lt;&lt;Expression&gt;&gt;`)`\\
  | `?`&lt;&lt;Expression&gt;&gt;\\
  | &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.Quoted Expressions
[[quotedExpressionFig]]
\end{figure}


(((quoted expression notation)))
There are two forms of quoted forms: using the `quote` keyword -- together with the `unquote` keyword -- and special `&lt;| |&gt;` brackets -- with embedded `?` marks. Semantically they are identical; except that the latter is potentially a little easier to use.

The `quote` expression takes the form:
[listing][escapechar=$]
quote($_SyntacticForm_$)

Alternately, the special `&lt;|` brackets `|&gt;` may be used:
[listing][mathescape=true]
&lt;|$_SyntacticForm_$|&gt;

The type of a `quote` expression is `quoted` -- whose description is shown in Program~\vref{quotedProg}.

_SyntacticForm_ may be any valid Star term; it is _not_ checked apart from correct use of operators. It does not have to be syntactically valid -- again, with the exception that operators must balance appropriately.
\begin{aside}
One of the salient differences between the `quote` form of a quoted expression and the `&lt;|` bracketed `|&gt;` form is that the maximum priority of operators in the latter form is 2000 whereas it is 1000 within the `quote` form.
\end{aside}

For example, the expression:
[listing]
&lt;|A+45|&gt;

is equivalent to the expression:
[listing][mathescape=true]
applyAst(L$\sub1$,nameAst(L$\sub2$,"+"),[nameAst(L$\sub3$,"A"), integerAst(L$\sub4$,45)])

Note that the various `L\subi` refer to `astLocation` terms and that no check is made whether the `variable' `A` is defined or of the right type.</Text>
        </Document>
        <Document ID="89C7EBEB-6D52-4A4A-9DE5-1481976ABEE2">
            <Title>Queries</Title>
            <Text>%!TEX root = reference.tex
= Queries
[[queries]]
(((queries)))
A &lt;&lt;Query&gt;&gt; is an expression that denotes a value implicitly -- by operations and constraints on other identified values. Typically, the result of a query is an `list` but it may be of any &lt;&lt;Type&gt;&gt; -- provided that it implements the `sequence` contract.

There are several `flavors' of query: the `all` query (shown in &lt;&lt;allSolutionsFig&gt;&gt;) projects a subset over one or more base collections; the _N_ `of` query extracts a list containing at most _N_ tuples from a collection; and the `any` query extracts a tuple that satisfies the query.

The results of a query may be sorted and may be filtered for uniqueness.

\begin{figure}[htbp]
\begin{eqnarray*}
_Expression_&amp;\arrowplus&amp;&lt;&lt;Query&gt;&gt;\\
[[Query]]Query::=&lt;&lt;SequenceQuery&gt;&gt;\ |\ &lt;&lt;ReductionQuery&gt;&gt;\ |\ &lt;&lt;SatisfactionQuery&gt;&gt;
\end{eqnarray*}
.Query Expression[[relationQueryFig]]
\end{figure}

== Sequence Queries
[[sequenceQueries]]

A &lt;&lt;SequenceQuery&gt;&gt; returns a collection of answers -- either all of them or some subset of them.

\begin{figure}[htbp]
\begin{eqnarray*}
[[SequenceQuery]]SequenceQuery::=&lt;&lt;SequenceType&gt;&gt;\ `of`\ `\{`&lt;&lt;QueryExpression&gt;&gt;\ `\`}\\
[[QueryExpression]]QueryExpression::=&lt;&lt;AllSolutionsQuery&gt;&gt;\\
  | &lt;&lt;BoundedCardinalityQuery&gt;&gt;
\end{eqnarray*}
.Sequence Query Expression[[sequenceQueryFig]]
\end{figure}

\noindent
where the &lt;&lt;SequenceType&gt;&gt; plays a similar role in identifying the type of the result to that in &lt;&lt;SequenceExpression&gt;&gt;s. If the &lt;&lt;SequenceType&gt;&gt; is the keyword `sequence` then the result type is determined by the context of the &lt;&lt;Query&gt;&gt; expression. Otherwise, &lt;&lt;SequenceType&gt;&gt; identifies the name of a &lt;&lt;Type&gt;&gt; -- which must implement the `sequence` contract (see Program~\vref{sequenceContractDef}) -- that denotes the result type of the query.

There are two variants of the &lt;&lt;SequenceQuery&gt;&gt; -- &lt;&lt;AllSolutionsQuery&gt;&gt; which returns a collection of all the answers to a question and &lt;&lt;BoundedCardinalityQuery&gt;&gt; which returns some bounded subset of the query answers.

=== All Solutions Queries
[[allSolutions]]
(((query,all solutions)))
The all solutions query expressions return results corresponding to all the different ways that a condition may be satisfied. There are variants corresponding to finding distinct solutions and having the result sets ordered.

\begin{figure}[htbp]
\begin{eqnarray*}
[[AllSolutionsQuery]AllSolutionsQuery::=[`all`|`unique`]\ &lt;&lt;Expression&gt;&gt;\ `where`\ &lt;&lt;Condition&gt;&gt;\ [&lt;&lt;Modifier&gt;&gt;]]\\
[[Modifier]Modifier::=`order`\ [`descending`]\ `by`\ &lt;&lt;Expression&gt;&gt;\ [`using`\ &lt;&lt;Expression&gt;&gt;]]
\end{eqnarray*}
.All Solutions Query[[allSolutionsFig]]
\end{figure}

For example, given a `list` bound to the variable `Tble`:
[listing]
def Tble is list of [
  ("john",23),
  ("sam",19),
  ("peter",21)
]

the query
[listing]
list of { all Who where (Who,A) in Tble and A&gt;20 }

is a &lt;&lt;SequenceQuery&gt;&gt; over the `Tble` list defined above. Its value is the `list`:
[listing]
list of [
  "john",
  "peter"
]

`"john"` and `"peter"` are in the result because both `("john",23)` and `("peter",21)` are in `Tble` and satisfy the condition that `A` is greater than 20.

(((queries,bound expression)))
In principle, any expression may follow the `all` clause in a query. The `bound expression' may mention variables that are `bound' within the query constraint.

==== Ordered Result Sets
The `order by` modifier is associated with a _path expression_ -- like the bound expression it is evaluated in the context of a successful solution to the condition. The results of an `order`ed query expression are sorted according to the values of this path expression. The type of this expression must be one that admits to being compared -- i.e., the type must implement the `comparable` contract.

For example, to return an ordered `cons` list footnote:[The type of the resulting collection is depends on whether the &lt;&lt;Query&gt;&gt; is governed by an enclosing &lt;&lt;SequenceType&gt;&gt; if available, or of type `array` by default.] of people over the age of 20 we can use the query expression:
[listing]
cons of { all Who where (Who,A) in Tble and A&gt;20
                        order by A}

which would give the result:
[listing]
cons of [
  "peter",
  "john"
]


The `using` modifier may be used in conjunction with the `order by` modifier to override the default concept of less than. If given, the `using` keyword should be followed by a `boolean`-valued function defined over the same type as the `order by` expression.

For example, to override the use of `&lt;` in the `order by` query above, with say `&gt;`, we can use:
[listing]
cons of { all Who where (Who,A) in Tble and A&gt;20
                        order by A using (&gt;)}

which would give the result
[listing]
cons of [
  "john",
  "peter"
]


==== Duplicate Elimination
[[duplicateElim]]
(((eliminating duplicates in queries)))
(((query,eliminating duplicates)))
(((unique@`unique` queries)))

The `unique` keyword is used, instead of the `all` keyword, to signal a query where duplicate elements are eliminated from the answer set.

For example, the query:
[listing]
list of { unique Sib where (P,Who) in parent and
                           (P,Sib) in parent and Who!=Sib }

would have the effect of eliminating duplication caused by the fact that most people have two recorded parents.

The `unique` query requires that the type of the `bound expression' implements the `comparable` contract -- i.e., that `&lt;` is defined for the type.

\begin{aside}
The `unique` query is potentially more expensive than the `all` query -- since it involves post-processing the results as the `all` query to perform the duplicate elimination.
\end{aside}

%==== Type Safety
%By default, the type of an `all` query is an `array` type; it requires that the condition be type safe:
%\begin{prooftree}
%\AxiomC{\typeprd{E}{B}{T}}
%\AxiomC{\typesat{E}{C}}
%\BinaryInfC{\typeprd{E}{`all`\ B\ `where`\ C}{`list of `T}}
%\end{prooftree}
%
%The type safety rule for `unique` queries very similar, except that the bound element must be of a type that implements the `comparable` contract:
%\begin{prooftree}
%\AxiomC{\typeprd{E}{B}{T\ `where comparable over `T}}
%\AxiomC{\typesat{E}{C}}
%\BinaryInfC{\typeprd{E}{`unique`\ B\ `where`\ C}{`list of `T}}
%\end{prooftree}
%
%(((query,sorted)))
%(((sorted queries)))
%(((creating a sorted list from a query)))
%In the case of an `ordered` query, the path expression must implement `comparable` and the result is a `list`:
%\begin{prooftree}
%\AxiomC{\typeprd{E}{B}{T}}
%\AxiomC{\typesat{E}{C}}
%\AxiomC{\typeprd{E}{P}{P\sub{T}\ `where comparable over `P\sub{T}}}
%\TrinaryInfC{\typeprd{E}{`all`\ B\ `where`\ C\ `order by`\ P}{`list of `T}}
%\end{prooftree}
%
=== Bounded Cardinality Queries
The _N_ `of` quantifier delivers _at most_ N solutions to the query. For example, the query:
[listing]
list of { 5 of X where (P,X) in children }

returns an `list` of the first 5 children of `P`.

\begin{figure}[htbp]
\begin{eqnarray*}
[[BoundedCardinalityQuery]BoundedCardinalityQuery::=&lt;&lt;QueryQuantifier&gt;&gt;\ `where`\ &lt;&lt;Condition&gt;&gt;\ [&lt;&lt;Modifier&gt;&gt;]]\\
[[QueryQuantifier]QueryQuantifier::=[`unique`]]\ &lt;&lt;Expression&gt;&gt;\ `of`\ &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.Bounded Cardinality Query[[boundedCardinalityFig]]
\end{figure}

==== Duplicate Elimination
If the `unique` keyword is used with the bounded cardinality then duplication elimination is performed _before_ counting the results. I.e., a query of the form:
[listing]
list of { unique 5 of X where (P,X) in children }

is guaranteed to find 5 unique answers -- assuming that there are at least 5 unique ways of solving the `(P,X) in children` condition.

==== Ordered Result Sets
If the `ordered by` modifier is _not_ present, there is no defined ordering for the answers in the result. In particular, if _N_ answers are requested, they could be any _N_ answers that satisfy the condition.

If an `order by` clause is specified then the result consists of the `smallest' results. I.e., if there are 5 answers to the query:
[listing]
list of { all X where (P,X) in children }

then the query
[listing]
list of { 3 of X where (P,X) in children order by X }

results in an `array` of 3 elements that are guaranteed to be smaller or equal to any remaining answers.

If the `order descending` modifier is used then the `largest' results will be the ones returned.
\begin{aside}
Of course, in order to compute this smallest set, all the answers must first be computed. The result set sorted and only then the first elements picked.
\end{aside}

%==== Type Safety
%The type of a bounded query is a `list` type; it requires that the condition be type safe, and that the bound is an `integer`:
%\begin{prooftree}
%\AxiomC{\typeprd{E}{N}{`integer`}}
%\AxiomC{\typeprd{E}{B}{T}}
%\AxiomC{\typesat{E}{C}}
%\TrinaryInfC{\typeprd{E}{N\ `of`\ B\ `where`\ C}{`list of `T}}
%\end{prooftree}
%
%In the case of an `ordered` bounded query, the path expression must implement `comparable` and the result is a `list`:
%\begin{prooftree}
%\AxiomC{\typeprd{E}{N}{`integer`}\quad\typeprd{E}{B}{T}}
%\AxiomC{\typesat{E}{C}}
%\AxiomC{\typeprd{E}{P}{P\sub{T}`where comparable over `P\sub{T}}}
%\TrinaryInfC{\typeprd{E}{N\ `of`\ B\ `where`\ C\ `order by`\ P}{`list of `T}}
%\end{prooftree}

== Satisfaction Queries
A &lt;&lt;Satisfaction&gt;&gt; is used to find an individual that satisfies the condition. It returns a  _single_ result corresponding to a solution of the query -- as an `option`al value.

\begin{figure}[htbp]
\begin{eqnarray*}
[[SatisfactionQuery]SatisfactionQuery::=`any of`\ &lt;&lt;Expression&gt;&gt;\ `where`\ &lt;&lt;Condition&gt;&gt;\ [&lt;&lt;Modifier&gt;&gt;]]
\end{eqnarray*}
.Satisfaction Query[[satisfactionQueryFig]]
\end{figure}

For example, to find a child of `P` one could use the expression:
[listing]
any of X where (P,X) in children


The `default` clause is used in the case that the &lt;&lt;Condition&gt;&gt; is _not_ satisfiable. For example, assuming that we did not have a record of `"fred"`'s parents, then the query
[listing]
any of P where (P,"fred") in children default "not known"

would result in the answer `"not known"`.

==== A Sorted Satisfaction Query
The `order by` clause can be used to select the `smallest' solution to the query: the result of an `any of` query that is governed by an `order by` clause is effectively the _least_ solution to the query. If the `order descending` modifier is used then the result is the largest solution to the query.

For example, to find the youngest child of `"john"` we can use the query:
[listing]
any of X where ("john",X) in children and (X,A) in ages order by A


==== Type Safety
A satisfaction query's type is `option` of the type of the bound expression. As with other queries, it requires that the condition is safe:
\begin{prooftree}
\AxiomC{\typeprd{E$\cup{}$varsIn(C)}{B}{T}}
\AxiomC{\typesat{E}{C}}
\BinaryInfC{\typeprd{E}{`any of`\ B\ `where`\ C}{`option of `T}}
\end{prooftree}

In the case of an `order`ed satisfaction query, the path expression must implement `comparable`:
\begin{prooftree}
\AxiomC{\typeprd{E$\cup{}$varsIn(C)}{B}{T}}
\AxiomC{\typesat{E}{C}}
\AxiomC{\typeprd{E}{P}{P\sub{T}\ `where comparable over `P\sub{T}}}
\TrinaryInfC{\typeprd{E}{`any of`\ B\ `where`\ C\ `order by`\ P}{`option of `T}}
\end{prooftree}

== Reduction Query
[[reductionQuery]]
(((accumulating over a query)))
(((applying a function to the results of a query)))

A &lt;&lt;ReductionQuery&gt;&gt; differs from other forms of query in that the results of satisfying the &lt;&lt;Condition&gt;&gt; are `fed' to a function rather than being returned as some form of collection.

\begin{figure}[htbp]
\begin{eqnarray*}
[[ReductionQuery]]ReductionQuery::=`reduction`\ &lt;&lt;Expression&gt;&gt;\ `of`\ &lt;&lt;QueryExpression&gt;&gt;
\end{eqnarray*}
.Reduction Query[[reductionQueryFig]]
\end{figure}

The reduction function should have the type:
[listing]
(t\sub{E},t\sub{E})=&gt;t\sub{E}

were `t\sub{E`} is the type of the bound expression in the &lt;&lt;QueryExpression&gt;&gt;.

For example, to add up all the salaries in a department, one could use a query of the form:
[listing]
reduction (+) of { all E.salary where E in employees }


\begin{aside}
The reducing function is only applied if there is more than one solution to the query. In this sense, it is closer in semantics to `leftFold1` than to `leftFold` -- see &lt;&lt;foldableContract&gt;&gt;.
\end{aside}

\begin{aside}
The &lt;&lt;ReductionQuery&gt;&gt; may be used with all the normal variants of &lt;&lt;QueryExpression&gt;&gt;.
\end{aside}
</Text>
        </Document>
        <Document ID="4ACCFCFC-FA75-44E3-AB20-E2309B0EBD98">
            <Title>Empty Tuple Type</Title>
            <Text>The empty tuple type:
()
refers to the empty tuple. It is useful primarily for writing function types where the function has no arguments:
()=&gt;string
When used as the return type of a function, the () type denotes a void result:
(integer)=&gt;()
[TIP] The () type -- sometimes referred to as the unit type -- is also used to denote the return type of some actions.</Text>
        </Document>
        <Document ID="EA878B10-24E8-479B-A91E-34D59EE1DE23">
            <Title>Block String </Title>
            <Text>In addition to the normal notation for strings, there is a block form of string that permits raw character data to be processed as a string.
BlockString::=""" Char ... Char """
Block String Literal
The block form of string allows any characters in the text and performs no interpretation of those characters.
Block strings are written using triple quote characters at either end. Any new-line characters enclosed by the block quotes are considered to be part of the strings.
The normal interpretation of $ and # characters as interpolation markers is suppressed within a block string.
"""This is a block string with $ and
uninterpreted # characters"""
[TIP] This form of string literal can be a convenient method for including block text into a program source.</Text>
        </Document>
        <Document ID="3E12D68B-6495-450C-816B-DE9CBD1D224F">
            <Title>Concepts and Ontologies</Title>
            <Text>%!TEX root = reference.tex
= Concepts and Ontologies
[[ontology]]

Many programs have embedded within them numerous `constant' values that often denote specific concepts. Often these concepts refer to data that the program expects to see in its input at some point, or will produce in its output.

Related to this, an application may need to be _internationalized_ -- that is, be translated for use in different countries by people speaking different languages -- and/or _localized_ -- that is, be programmed to be sensitive to local defaults for things such as how dates are formatted, currencies, and so on.

The `rdf` profile provides facilities for defining _concepts_, _relationships_ between those concepts and _path expressions_ to capture _concept navigation_. In addition, it allows _ontologies_ -- expressed as `N3` files -- to be incorporated into an application.

== RDF and N3
[[rdfN3]]
RDF is a W3C standard for specifying simple ontologies using a very simple language: an RDF graph is a set of _triples_; each triple consists of a subject, a predicate and an object -- all of which are _concepts_. In the standard notation, RDF triples are written using an XML-based notation; however, there is a more convenient notation often used called `N3`.
[listing]
_subject_ _predicate_ _object_.

where `_subject_`, `_predicate_` and `_object_` are all concepts. Such a statement is called a _triple_. N3 supports several shortened forms of triples; for example, a statement such as:
[listing]
person:john family:parent-of person:jim, person:jane.

is equivalent to two triples:
[listing]
person:john family:parent-of person:jim.
person:john family:parent-of person:jim.

and the statement:
[listing]
person:john family:parent-of person:jim;
             dc:has-name "john".

is equivalent to:
[listing]
person:john family:parent-of person:jim.
person:john dc:has-name "john".

The comma allows the same subject and predicate to refer to multiple objects and the semi-colon allows the same subject to have multiple predicate/objects associated with it.

== Star Triple Notation
[[n3Notation]]
(((triple notation)))
(((ontology,triples)))
Star supports a form of N3 notation together with a path notation that facilitates navigation of concept structures.

However, the exact notation is necessarily different to the standard N3 notation -- the Star N3 notation has been `formatted' to fit with the syntactic conventions of the Star language. For convenience, we will continue to refer to the Star `version' of N3 notation as simply N3SR.

\begin{figure}[htbp]
   \includegraphics[width=0.55\textwidth]{diagrams/n3GraphFig}
   .N3SR Graph Structure
   [[n3GraphFig]]
\end{figure}

\begin{figure}[htbp]
   \includegraphics[width=0.75\textwidth]{diagrams/n3TripleFig}
   .Triple Statement
   [[n3TripleFig]]
\end{figure}

\begin{figure}[htbp]
   \includegraphics[width=0.8\textwidth]{diagrams/n3NounPhraseFig}
   .Noun Phrase
   [[n3NounPhraseFig]]
\end{figure}

\begin{figure}[htbp]
   \includegraphics[width=0.7\textwidth]{diagrams/n3ConceptFig}
   .Concept
   [[n3ConceptFig]]
\end{figure}
</Text>
        </Document>
        <Document ID="E8942316-E1EE-47A4-9950-7F92623C5AAC">
            <Title>Expressions-26</Title>
            <Text>
== Collection and Sequence Expressions
[[sequenceExpression]]
(((sequence,expressions)))
(((expressions,sequence)))
(((of@`of`,expression)))

Collection expressions and sequence expressions are a syntactic feature that make it straightforward to represent collective values. The difference between a `collection` and a `sequence` is that the latter embodies a sequential ordering of the elements. A `collection` may have an ordering present; but that is not required by the contract and is not enforced in the notation.


A sequence expression represents a use of the standard `sequence` contract (see Program~\vref{sequenceContractDef}) to construct sequences of values.

\begin{aside}
There is a similar form to &lt;&lt;SequenceExpression&gt;&gt; which is used to denote _queries_ -- the programmer's analog of set abstractions. &lt;&lt;Query&gt;&gt; expressions are defined in Chapter~\ref{queries}.
\end{aside}

\begin{figure}[htbp]
\begin{eqnarray*}
_Expression_&amp;\arrowplus&amp;&lt;&lt;SequenceExp&gt;&gt;\\
[[SequenceExp]SequenceExp::=&lt;&lt;SequenceType&gt;&gt;\ `of``[`&lt;&lt;ExpSequence&gt;&gt;`]]`\\
  | `[`&lt;&lt;ExpSequence&gt;&gt;`]`\\
[[ExpSequence]ExpSequence::=[&lt;&lt;Expression&gt;&gt;`..,`]&lt;&lt;Expression&gt;&gt;\sequence{,}&lt;&lt;Expression&gt;&gt;[`,..`&lt;&lt;Expression&gt;&gt;]]\\
[[SequenceType]]SequenceType::=&lt;&lt;Identifier&gt;&gt;
\end{eqnarray*}
.Sequence Expression
[[sequenceExpressionFig]]
\end{figure}
I.e., a sequence expression consists of a sequence of &lt;&lt;Expression&gt;&gt;s separated by commas. In addition, either -- but not both -- the tail or the front of the sequence may be denoted by an expression. Otherwise the sequence is nil-terminated.

An expression of the form:
[listing][escapechar=|]
|_Label_| of [|_E\sub1_\sequence{,}_E\subn_|]

is equivalent to the expression:
[listing][escapechar=|]
_cons(|_E\sub1_\sequence{,}|_cons(|_E\subn_|,_nil())|\sequence{}|) has type |_Label_| of %t|\sub{new}|

_provided that \emph{Label_ is the label of a &lt;&lt;Type&gt;&gt; that implements the `sequence`  contract} -- see &lt;&lt;sequenceContract&gt;&gt; and where `\%t\sub{new`} is a new type variable not occurring elsewhere. Included in that contract are two functions -- denoting the empty sequence (`\_nil()`) and a non-empty sequence (`\_cons()`) -- that are used to build the true value of a sequence expression.

A sequence can be built up from other sequences by prepending to them. An expression of the form:
[listing][escapechar=|]
|_Label_| of [|_E\sub1_\sequence{,}_E\sub{n-1_}`,..`_E\subn_|]

is equivalent to the expression:
[listing][escapechar=|]
_cons(|_E\sub1_\sequence{,}|_cons(|_E\sub{n-1_}|,|_E\subn_|)|\sequence{}|)


Conversely, a sequence may be `front' loaded and be defined by appending elements to a `front' expression:
[listing][escapechar=|]
|_Label_| of [|_F_`..,`_E\sub1_\sequence{,}_E\subn_|]

is equivalent to the expression:
[listing][escapechar=|]
_apnd(|\sequence{}|_apnd(|_F_|,|_E\sub1_|)|\sequence{}_E\subn_|)


\begin{aside}
It is also possible to have a sequence expression is that is _both_ front-loaded and back-loaded:
[listing][escapechar=|]
|_Label_| of [|_F_|..,|_M_|,..|_T_|]

is equivalent to:
[listing][escapechar=|]
_apnd(_cons(|_F_|,|_M_|),|_T_|)

which, in turn, is equivalent to:
[listing][escapechar=|]
_cons(|_F_|,_apnd(|_M_|,|_T_|))

\end{aside}</Text>
        </Document>
        <Document ID="318DBA1C-0672-4B52-8A2E-71671AA83637">
            <Title>Line Comment </Title>
            <Text>A line comment consists of a --␠ (a double dash followed by a space) or a --\t followed by all characters up to the next new-line. Here,  \t refers to the Horizontal Tab.
LineComment ::= ( --␠  | --\t) Char .. Char \n
Line Comment</Text>
        </Document>
        <Document ID="712C3200-2FBA-40D0-83FB-92BA60586F09">
            <Title>Type Safety</Title>
            <Text>The type associated with a variable expression is derived from the type recorded for the variable in the environment.
\begin{prooftree}
\AxiomC{`( v`,T\sub{v}\ `)`$\in\ $E}
\UnaryInfC{\typeprd{E}{`v`}{T\sub{v}'}}
\end{prooftree}
where `T\sub{v`'} is derived from `T\sub{v`} by means of _refreshing_. I.e., if `T\sub{v`} takes the form:
[listing][mathescape=true]
for all t$\subi{}$ such that T

then `T\sub{v`'} is `T` with all occurrences of type variable `t\subi` replaced with new type variables.</Text>
        </Document>
        <Document ID="47B86715-A8D0-491E-A409-16C634AA264C">
            <Title>Types of Types</Title>
            <Text>There are several different kinds of type expressions that the Star programmer will encounter:
Type::=TypeExpression
  | TypeVariable | ReferenceType
  | TupleType | RecordType
  | FunctionType | PatternType | ConstructorType
  | TypeQuantifier ‘~~’ Type
  | TypeConstraint ‘|:’ Type
  | `(` &lt;&lt;Type&gt;&gt; `)`
  | EncapsulatedType

TypeQuantifier ::= UniversalQuantifier | ExistentialQuantifier
Types of Types

There are two main kinds of type expressions -- so-called structural type expressions and named type expression. A structural type expression encodes by convention the permitted forms of values of that type. By contrast, a named type expression is defined via some form of TypeDefinition.
A classic example of a structural type expression is the function type. A function type expression defines both the types of the arguments and result type of the function. But, more importantly, it signals that the value is a function.
A good example of a named type is the standard integer type. The word integer does not signal by itself that the allowable operations on integer values include arithmetic, comparison and so on. That information must come from additional statements and declarations.
One of the other differences between structural and named type expressions is that the latter may be used to denote recursive types, whereas the former cannot.
[TIP] A recursive type is one whose values may contain elements that are themselves of the same type. For example, in a tree type: the nodes of the tree are typically themselves trees.</Text>
        </Document>
        <Document ID="758594EB-4005-4184-A4B3-3301CB58CF79">
            <Title>Cover</Title>
        </Document>
        <Document ID="6C3BDCCC-F6C3-4AF9-B7CD-475616712EAE">
            <Title>Introduction</Title>
            <Text>Star is a high-level symbolic programming language oriented to the needs of large-scale high performance processing in modern parallel and distributed computing environments.
Star is a functional-first language -- in that functions and other programs are first class values. However, it is explicitly not a pure language: it has support for updatable variables and structures. However, its bias is definitely in favor of functional programming and in order to get the best value from programming in Star, such side-effecting features should be used sparingly.
Star is strongly, statically, typed. What this means is that all programs and all values have a single type that is determined by a combination of type inference and explicit type annotations.
While this definitely increases the initial burden of the programmer; we believe that correctness of programs is a long-term productivity gain -- especially for large programs developed by teams of programmers.
The type language is very rich; including polymorphic types, type constraints and higher-rank and higher kinded types. Furthermore, except in cases where higher-ranked types are required, type inference is used extensively to reduce the burden of type bureaucracy on programmers.
Star is extensible; there are many mechanisms designed to allow extensions to the language to be designed simply and effectively. Using such techniques can significantly ease the burden of writing applications.</Text>
        </Document>
        <Document ID="DC1B44E8-8D55-4CA3-8D20-5BDAA87EECB7">
            <Title>Right Associative Infix Operator</Title>
            <Text>A statement of the form:
#right(‘rgtOp’,730).
defines the operator rgtOp to be a right associate infix operator, with priority 730. Exressions such as
A rgtOp B rgtOp C rgtOp D
will be parsed as though written:
(A rgtOp (B rgtOp (C rgtOp D)))</Text>
        </Document>
        <Document ID="E063A115-E6BE-4068-9989-F3B176CFB6BB">
            <Title>Implementing Contracts with Functional Dependencies</Title>
            <Text>Implementing a contract which has a functional dependency is exactly analogous to implementing a regular contract. The dependent type(s) must be identified in the implementation statement. For example, the initial part of the implementation of the sequence contract over strings and integers is:
implementation sequence[string-&gt;&gt;integer] =&gt; {
Note that this implementation implies that a sequence over a string fixes the element type to integer -- i.e., a unicode CodePoint.</Text>
        </Document>
        <Document ID="5BCBF610-8596-4733-B899-360B27360753">
            <Title>Associative Postfix Operator</Title>
            <Text>A statement of the form:
#postfixAssoc(‘psOp’,730).
defines the operator psOp to be an associative postfix operator, with priority 730. That means that expressions such as:
A psOp psOp psOp
are permitted, and have interpretation:
(((A psOp) psOp) psOp)
</Text>
        </Document>
        <Document ID="D8DA8352-5B30-4406-B068-20FB907C5011">
            <Title>Associative Dictionaries</Title>
            <Text>%!TEX root = reference.tex
= Associative Dictionaries
[[associativeMap]]

(((expressions,associative dictionary)))
(((associative dictionary expression)))
Dictionaries allow the programmer to establish an associative mapping between pairs of elements. They are convenient when it is not known what the actual elements of the association will be at design time.

\begin{aside}
An important property of dictionaries is that there can be at most _one_ value associated with a given key. This is one of the primary differences between dictionaries and lists.
\end{aside}

== Dictionary Type
[[mapTypes]]
(((type,dictionary`dictionary` type)))

The `dictionary` type takes the form of a type expression with two type arguments: the type of the key and the type of the value.
\begin{figure}[htbp]
\begin{eqnarray*}
_Type_&amp;\arrowplus&amp;`dictionary of (`_Type_`,`_Type_`)`
\end{eqnarray*}
.Dictionary Type
[[mapTypeFig]]
\end{figure}
In a `dictionary`, every key must have the same type; as must each value in the `dictionary` -- although the keys' type may be different to the values' type.

For example, the type expression:
[listing]
dictionary of (string,integer)

denotes the type of a dictionary whose keys are `string`s and whose values are `integer`s.

The `dictionary` type's structure is not public. It is defined as though by a &lt;&lt;KindAnnotation&gt;&gt;:
[listing]
dictionary has kind type of (type,type)

\begin{aside}
In addition, there is a constraint on the types of keys: they must implement the `equality` contract. This means that it is not possible to use as keys any value that contains a program value. There is no such restriction on the values -- it is quite possible to have a map from `string`s to functions (say).
\end{aside}


== Dictionary Literals
[[mapLiteral]]
(((dictionary,literal)))
(((dictionary literal@`dictionary` literal)))
(((dictionarys)))
A `dictionary` literal consists of a `dictionary` brace term with each element in the dictionary represented as a pair
[listing]
_Key_ -&gt; _Value_

&lt;&lt;mapLiteralFig&gt;&gt; defines the syntax of dictionary literals.
\begin{figure}[htbp]
\begin{eqnarray*}
_Expression_&amp;\arrowplus&amp;`dictionary of ``[`_MapElement_\sequence{,}_MapElement_`]`\\
_MapElement_::=_Expression_\ `-&gt;`\ _Expression_
\end{eqnarray*}
.Dictionary Literal
[[mapLiteralFig]]
\end{figure}
For example,
[listing]
dictionary of ["alpha" -&gt; 1, "beta"-&gt;2]

is a dictionary consisting of `string` keys to `integer` literals.
An associative `dictionary` literal may not have more than one value associated with any given key.

An empty `dictionary` literal is written:
[listing]
dictionary of []


\begin{aside}
There is no _pattern_ form of a `dictionary` literal: it is not possible to pattern match against a dictionary. However, it is possible to constrain an equation based on a dictionary argument -- using semantic guard:
[listing]
keyPresent(Ky,D) where present D[Ky] is D[Ky];

\end{aside}


== Accessing Elements of a Dictionary
[[associativeMapAccess]]
(((dictionary,accessing elements)))
(((expressions,access elements of dictionary)))

There are implementations of the `indexable` (see Program~\vref{indexableContractDef}), `sizeable` (see Program~\vref{sizeableContract}), `iterable` (see Program~\vref{iterateContractProg}) and `pPrint` contracts (see Program~\vref{ppContractProg}). Thus, the standard notations for accessing indexed elements, and iterating over collects, apply to `dictionary` values also.

Note that the related contracts `sequence` (see Program~\vref{sequenceContractDef}), `sliceable` (see Program~\vref{sliceableContractProg}) are _not_ implemented for `dictionary` values. In the former case the reason is that `dictionary`s are not naturally accessed in a sequential manner, and in the latter case the _key_s used to access `dictionary`s are not limited to `integer`s.

=== `\_index` -- Index Element
[[indexMapFunction]]
(((indexable contract@`indexable` contract,_index@`\_index`)))
The `\_index` function, which is part of the `indexable` contract (see Program~\vref{indexableContractDef}), is used to access elements of a dictionary -- by providing a key.
[listing]
_index has type for all k,v such that (dictionary of (k,v),k)=&gt;option of v
                where equality over k

\begin{aside}
The type of the index is obtained from the `dictionary` type itself: it is the first type argument.
\end{aside}

\begin{aside}
The `\_index` function requires that `equality` is implemented for the key type.
\end{aside}

\noindent
The `\_index` function has special syntax which is reminiscent of array index expressions:
[listing]
C[Ky]

is equivalent to the expression
[listing]
\_index(C,Ky)

For example, given a dictionary:
[listing]
M is dictionary of [ "alpha"-&gt;1, "beta"-&gt;2 ]

we can access the value associated with the key `"alpha"` using:
[listing]
M["alpha"]

Since the values accessed from a `dictionary` are always `option`al, we can unwrap them conditionally using a `has value` condition (see &lt;&lt;hasValueCond&gt;&gt;):
[listing]
get(Key) where M[Key] has value V is V


=== `\_set\_indexed` -- Replace Element of Map
[[mapReplaceFunction]]
(((indexable contract@`indexable` contract,_set_indexed@`\_set\_indexed`)))
(((replace element in collection)))
The `\_set\_indexed` function, which is part of the `indexable` contract, is used to set an element in a `dictionary`.
[listing]
\_set\_indexed has type for all k,v such that
                        (dictionary of (k,v),k,v)=&gt;dictionary of (k,v)
                        where equality over k

The `\_set\_indexed` function returns a `dictionary` in which an element is replaced. If the element as _not_ there beforehand, the `dictionary` is augmented with the new key/value pair. If there was an element with the same key, then the value associated with key is replaced.

The `\_set\_indexed` function has special action syntax which is reminiscent of array update actions:
[listing]
C[Ky] := E

is equivalent to the action
[listing]
C := \_set\_indexed(C,Ky,E)

For example, given the variable declaration:
[listing]
var M := dictionary of [ "alpha"-&gt;1, "beta"-&gt;2 ]

we can add a new key associated with `"gamma"` using the action:
[listing]
M["gamma"] := 3

which is equivalent to:
[listing]
M := _set_indexed(M,"gamma",3)

The `\_set\_indexed` function also has an expression form. The assignment above may also be written:
[listing]
M := M["gamma"-&gt;3]


\begin{aside}
As with other forms of update action, the `\_set\_indexed` function does not side-effect the previous value that was bound to the dictionary variable.
\end{aside}

=== `\_delete\_indexed` -- Remove Element from Map
[[mapDeleteFunction]]
(((indexable contractt@`indexable` contract,_delete_indexed@`\_delete\_indexed`)))
(((remove element from collection)))
`\_delete\_indexed` is part of the `indexable` contract -- see Program~\vref{indexableContractDef}.
[listing]
\_delete\_indexed has type for all k,v such that
                           (dictionary of (k,v),k)=&gt;dictionary of (k,v)
                           where equality over k

The `\_delete\_indexed` function is used to remove an element from a dictionary. The `\_delete\_indexed` function returns a new `dictionary` with the identified element removed. The element to delete is identified by its key, not by the kay/value pair.

The `\_delete\_indexed` function has special action syntax which is reminiscent of array update actions:
[listing]
remove C[Ky]

is equivalent to the action
[listing]
C := C[without Ky]

which, in turn, is equivalent to:
[listing]
C := \_delete\_indexed(C,Ky)

For example, given the `var`-declared variable `M` above, we can remove the entry associated with `"alpha"` using:
[listing]
remove M["alpha"]


The `expression variant' of the `remove` notation -- `C[without ky]` -- is more pleasant for functional programs where the dictionary is not held in an updateable variable.

=== Searching a Dictionary
[[searchMap]]
(((dictionary expression,membership predicate)))

A `dictionary` may be searched within a condition using the &lt;&lt;IndexedSearch&gt;&gt; condition.

There are two primary situations for searching an associative `dictionary`: if the _Key_ part of a &lt;&lt;IndexedSearch&gt;&gt; operator is either a literal or is a previously bound variable then there is at most one way of satisfying a &lt;&lt;IndexedSearch&gt;&gt; condition. On the other hand, if the _Key_ is a pattern containing unbound variables then a &lt;&lt;IndexedSearch&gt;&gt; involves iterating over the entire dictionary looking for entries that match the condition.


== Standard `dictionary` Functions
[[standardMap]]

The `dictionary` type implements the standard `sizeable` contract -- see Program~\vref{sizeableContract}. As such, the functions `size` and `empty` are defined for `dictionary` values.

=== `size` -- length of a dictionary
[[sizeMapFunction]]
(((size function@`size` function)))
`size` is part of the `sizeable` contract.
[listing]
size has type for all k,v such that (dictionary of (k,v))=&gt;integer


The `size` function returns the length of its `dictionary` argument; i.e., the number of elements in the `dictionary`.


=== `isEmpty` -- test for empty dictionary
[[emptyMapFunction]]
(((isEmpty function@`isEmpty` function)))
`empty` is part of the `sizeable` contract.
[listing]
isEmpty has type for all k,v such that (dictionary of (k,v))=&gt;boolean


The `isEmpty` function returns `true` if its argument has no elements.
</Text>
        </Document>
        <Document ID="DAF1D39A-EE62-4A68-9A51-F347A1E9B506">
            <Title>Multi-word Identifiers</Title>
            <Text>A MultiWordIdentifier is an Identifier that is written as a contiguous sequence of alphanumeric words. Although written as multiple words, a MultiWordIdentifier is logically a single identifier. For example, the combination of words:
group by
is logically a single multi-word identifier whose name is ‘group by’.
There are a few standard MultiWordIdentifiers, as outlined below. In addition, MultiWordIdentifiers can be defined as operators.

`any of` | `group by` | `has value` |
`such that` | `counts as` | `for all` | `order by` |
`order descending by` | `has kind` | `instance of` | `descending by` |
`has type` | `bound to` | `or else` | `on abort` |
Parts of a MultiWordIdentifier may be separated by spaces and/or comments.
If a part of a MultiWordIdentifier occurs out of sequence, i.e., not as part of the sequence that defines the identifier, then it is interpreted as a normal identifier.</Text>
        </Document>
        <Document ID="D09392E3-0448-4229-9F66-DF8BE7250409">
            <Title>Threads</Title>
            <Text>%!TEX root = reference.tex
= Concurrent Execution
[[threads]]
(((Concurrent execution)))
(((threads)))

Concurrent execution involves the use of `spawn` (and the related parallel execution operator `//`) to initiate concurrent execution; together with a set of features intended to constrain that concurrent execution.

\begin{figure}[htbp]
\begin{eqnarray*}
[[Action]]Action&amp;\arrowplus&amp;&lt;&lt;ParallelAction&gt;&gt;\\
  | &lt;&lt;SpawnAction&gt;&gt;\\
  | &lt;&lt;WaitAction&gt;&gt;\\
  | &lt;&lt;SyncAction&gt;&gt;%\\
%  | &lt;&lt;AtomicAction&gt;&gt;
\end{eqnarray*}
.Thread and Parallel Action
[[threadActionFig]]
\end{figure}

== Spawning Concurrent Execution
[[threadSpawning]]

There are three `levels' of operator relating to initiating and terminating concurrent execution: the parallel execution operator `//`, the `spawn` action/expression and the `threadStart` and `threadWaitfor` operators.

=== Parallel Execution
[[parallelExecution]]

The `//` operator is used to signal that two actions should proceed in parallel.
\begin{figure}[htbp]
\begin{eqnarray*}
_ParallelAction_::=&lt;&lt;Action&gt;&gt;\ `//`\ &lt;&lt;Action&gt;&gt;
\end{eqnarray*}
.parallel Execution Action
[[parallelExecutionFig]]
\end{figure}

An action of the form:
[listing]
_LeftAction_//_RightAction_

executes both of `_LeftAction_` and `_RightAction_` -- in some indeterminate, possibly interleaved, order. The action itself does not terminate until both `_LeftAction_` and `_RightAction_` have terminated.

For example, to perform a `request` action (see &lt;&lt;request&gt;&gt;) to two different targets in parallel, one might use:
[listing]
...;\{ request A to oneThing() \}//\{request B to otherThing()\};...

It would be also possible to ask the _same_ target to perform operations in parallel but that raises issues relating to accessing shared resources. For one way of managing this, see &lt;&lt;syncAction&gt;&gt;. %and &lt;&lt;transaction&gt;&gt;.

== Thread Spawning
\begin{aside}
The `spawn` action/expression is slightly more low-level than the `//` operator. The `fork` primitive is lower-level still; and gives the finest level of control of initiating a concurrent execution.
\end{aside}

=== The `thread` Type
[[threadType]]
(((threads,type of)))

The `thread` type is a standard type that is used to represent threads of execution. It does not have a standard constructor; and hence cannot be defined using normal type definition notation. However, it is generic; a type expression of the form:
[listing]
thread of integer

denotes the type of a thread which will ultimately yield an `integer` value when it completes.

\begin{aside}
Not all threads yield a value; in which case the type expression is simply `thread`. (i.e., the type expressions `thread of _type_` and `thread` refer to different kinds of threads -- in one case returning a value and in the other not.
\end{aside}

=== Spawn Action
[[spawnAction]]
(((spawn action@`spawn` action)))
(((parallel execution)))

A `spawn` action executes an _Action_ in parallel with the `main' action.
\begin{figure}[htbp]
\begin{eqnarray*}
[[SpawnAction]]SpawnAction::=`spawn`\ &lt;&lt;Action&gt;&gt;
\end{eqnarray*}
.Spawning a thread[[spawnSyntaxFig]]
\end{figure}
When executed, a `spawn` action completes `immediately' -- without waiting for the `spawn`ed action to complete. The `spawn`ed action itself is executed as a separate thread of activity.

==== Variables in a `spawn`ed action
(((spawn action@`spawn` action,variables in a)))
(((variables in a `spawn` action)))

Any variables that are _free_ in a `spawn`ed action are treated as read-only within the `spawn`ed action -- with the exception of `resource` variables (see &lt;&lt;reassignableVars&gt;&gt;). Thus an action of the form:
[listing]
\{
  var X := 1;
  ...
  spawn \{ X := X+1; \}
  ...
\}

is not legal since the variable `X` is not a `resource` variable, and hence it may not be reassigned to within the `spawn`ed action.

The value assigned to reassignable variables within a `spawn` action is `fixed' at the time that the `spawn` is performed.

However, in the fragment:
[listing]
\{
  resource var R := 1;
  ...
  spawn \{ R:=R+1; \}
  ...
\}

the variable `R` is a `resource` variable. Hence `R` may be reassigned to within the `spawn`ed action, and its value always reflects the last assignment to the variable.
\begin{aside}
Of course, this also represents a major risk to the safety of programs. The programmer should ensure that any reference or assignment to shared `resource` variables is in the context of an `atomic` action. Otherwise, there is a high risk of unexpected race conditions and corruption in the values of such variables.
\end{aside}

==== Type Safety

\begin{prooftree}
\AxiomC{\typesafe{E}{_Action_}}
\UnaryInfC{\typesafe{E}{`spawn`\ _Action_}}
\end{prooftree}

=== Spawn Expression
[[spawnExpression]]
The `spawn` expression -- likes its action counterpart (see &lt;&lt;spawnAction&gt;&gt;) -- is used to spawn off an expression evaluation to be evaluated concurrently with the invoking computation.

\begin{figure}[htbp]
\begin{eqnarray*}
_Expression_&amp;\arrowplus&amp;&lt;&lt;SpawnExpression&gt;&gt;\\
[[SpawnExpression]]SpawnExpression::=`spawn`\ &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.Spawning an expression[[spawnExpressionSyntaxFig]]
\end{figure}

==== Type Safety
The type of a `spawn` expression is `thread`. However, the `thread` type is generic, intended to denote the result of the `spawn`ed expression as it is re-captured by the corresponding `wait` expression.

\begin{prooftree}
\AxiomC{\typeprd{E}{Ex}{T}}
\UnaryInfC{\typeprd{E}{`spawn` Ex}{`thread of `T}}
\end{prooftree}

=== Thread Wait Action
[[threadWaitAction]]
(((spawn action@`spawn` action,wait for termination)))
The `waitfor` action blocks until an identified thread has terminated. If the `thread` has a value associated with it, then that value also becomes the value returned by `waitfor`.

\begin{figure}[htbp]
\begin{eqnarray*}
_Action_&amp;\arrowplus&amp;&lt;&lt;WaitAction&gt;&gt;\\
[[WaitAction]]WaitAction::=`waitfor`\ &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.WaitFor action[[waitforActionSyntaxFig]]
\end{figure}

=== `wait` expression
[[waitExpression]]
The `wait` expression takes a `thread` as an argument and has as its value the value returned by the `thread`. The `wait` expression does suspends execution until the `thread` has completed.

\begin{figure}[htbp]
\begin{eqnarray*}
_Expression_&amp;\arrowplus&amp;&lt;&lt;WaitExpression&gt;&gt;\\
[[WaitExpression]]WaitExpression::=`waitfor`\ &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.WaitFor expression[[waitforExpressionSyntaxFig]]
\end{figure}

==== Type Safety
The type of a `spawn` expression is `thread`. The type of a `wait` expression is the type of the value returned by the `thread`.

\begin{prooftree}
\AxiomC{\typeprd{E}{E\sub{spawn}}{`thread of `T}}
\UnaryInfC{\typeprd{E}{`wait`\ E\sub{spawn}}{T}}
\end{prooftree}

=== The `sync`hronized Action
[[syncAction]]
(((sync action@`sync` action)))

The `sync` action is used to manage contention in accessing resources that are potentially shared across `spawn`ed actions. There are two forms of `sync` action -- a standard form and the guarded form. In both cases, `sync` revolves around access to a shared resource.

\begin{figure}[htbp]
\begin{eqnarray*}
[[SyncAction]]SyncAction::=`sync(`&lt;&lt;Expression&gt;&gt;`)\{`&lt;&lt;SyncBody&gt;&gt;`\`}\\
[[SyncBody]]SyncBody::=&lt;&lt;SyncGuard&gt;&gt;\sequence{;}&lt;&lt;SyncGuard&gt;&gt;\\
  | &lt;&lt;Action&gt;&gt;\\
[[SyncGuard]]SyncGuard::=`when`\ &lt;&lt;Condition&gt;&gt;\ `do`\ &lt;&lt;Action&gt;&gt;
\end{eqnarray*}
.Synchronized Action[[syncActionSyntaxFig]]
\end{figure}

The `sync` action's resource _Expression_ may evaluate to any term value; however, we recommend that `something obvious' is used. For example, in the context of a set of actions revolving around a &lt;&lt;ThetaRecord&gt;&gt; the `this` keyword identifies the &lt;&lt;ThetaRecord&gt;&gt; itself.

Only one `sync` action may be executing at any given time on a given resource. If another `spawn`ed action is executing a `sync` action involving the same resource then this action is paused until that action completes.

If the guarded form is used, each &lt;&lt;SyncGuard&gt;&gt; defines a condition that must be satisfied in order for access to the shared resource to be valid. These guards are evaluated in a left-to-right order: the first guard to be satisfied fires its corresponding action.

The process of acquiring exclusive access to a shared resource when using &lt;&lt;SyncGuard&gt;&gt;s can be described:
\begin{enumerate}
\item A lock on the shared resource is acquired.
\item For each &lt;&lt;SyncGuard&gt;&gt;, its guard &lt;&lt;Condition&gt;&gt; is evaluated:
\begin{itemize}
\item  If the guard is satisfied, then the corresponding guarded &lt;&lt;Action&gt;&gt; is performed. At the end of which the lock on the shared resource is released and the &lt;&lt;SyncAction&gt;&gt; is completed.
\item If the guard is not satisfied, then the next &lt;&lt;SyncGuard&gt;&gt; is considered.
\end{itemize}
\item If no remaining &lt;&lt;SyncGuard&gt;&gt; exists; the lock on the shared resource is released, the &lt;&lt;SyncAction&gt;&gt; is suspended, and a new attempt on a lock on the shared resource will be made after another thread has successfully acquired and released the lock. At which point, execution of the &lt;&lt;SyncAction&gt;&gt; will be restarted.
\end{enumerate}

\begin{aside}
This is equivalent to the `monitor' exclusion pattern for controlling access to shared resources.
\end{aside}

\begin{aside}
The `sync` action is a fairly low-level mechanism. It can be difficult to use `sync` actions to achieve high performance. However, it can be used to build higher-level mechanisms such as semaphores and atomic transactions. For example, Program~\vref{semaphoreProg} shows how a semaphore can be implemented in terms of the `sync` action.
%
%We recommend using the `atomic` action (see &lt;&lt;atomicAction&gt;&gt;) as an alternative easier-to-use mechanism for most regular scenarios.
\end{aside}
\begin{program}
[listing]
semaphore(Count) is \{
  private var Lvl := Count;

  grab() do \{
    sync(this)\{
      when Lvl&gt;0 do \{
        Lvl := Lvl-1;
      \}
    \};
  \};

  release() do \{
    sync(this)\{
      Lvl := Lvl+1;
    \}
  \}
\}

.A Semaphore Generating Function[[semaphoreProg]]
\end{program}

==== Type Safety
\begin{prooftree}
\AxiomC{\typeprd{E}{_S_}{_t_}}
\AxiomC{\typesafe{E}{_Action_}}
\BinaryInfC{\typesafe{E}{`sync(`_S_`)\{`_Action_`\`}}}
\end{prooftree}

%== Transactional Isolation of Concurrent Threads
%[[transaction]]



%=== Atomic Actions
%[[atomicAction]]
%(((atomic actions)))
%(((transactions)))
%
%An `atomic` action performs its argument action in a way that is _atomic_ with respect to other parallel activities -- such as those `spawn`ed off. In particular, other threads cannot see any changes to variables, or any speech actions that are performed, until the `atomic` action is completed.
%
%\begin{figure}[htbp]
%\begin{eqnarray*}
%[[AtomicAction]]AtomicAction::=`atomic`\ _Action_
%\end{eqnarray*}
%.Atomic Action[[atomicSyntaxFig]]
%\end{figure}
%
%`atomic` actions denote an equivalent of _transactions_. They are intended to support _isolation_ of side-effects between concurrent activities; and hence enable better management of interactions.
%
%==== Type Safety
%
%\begin{prooftree}
%\AxiomC{\typesafe{E}{_Action_}}
%\UnaryInfC{\typesafe{E}{`atomic`\ _Action_}}
%\end{prooftree}
</Text>
        </Document>
        <Document ID="9C47FE92-A3E7-4D4A-A856-E4CA8C558327">
            <Title>Manuscript Format</Title>
        </Document>
        <Document ID="279ACED4-D331-4910-8390-E71DCB3F9782">
            <Title>Expressions-12</Title>
            <Text>
=== Enumerated Symbol
[[enumeratedSymbol]]
(((expression,enumerated symbol)))
(((enumerated symbol literal)))
&lt;&lt;EnumeratedSymbol&gt;&gt;s denote symbolic values. In particular, it refers to symbols that are introduced in an algebraic &lt;&lt;TypeDefinition&gt;&gt;.
\begin{figure}[htbp]
\begin{eqnarray*}
[[EnumeratedSymbol]]EnumeratedSymbol::=&lt;&lt;Identifier&gt;&gt;
\end{eqnarray*}
.Enumerated Symbol Expression
[[enumeratedSymbolFig]]
\end{figure}
Enumerated symbols have no internal structure; they are often used to define enumerations or for sentinels. For example, the &lt;&lt;Boolean&gt;&gt; standard type can be defined
[listing]
type boolean is false or true

and the standard cons-list type uses `nil` to mark the empty list:
[listing]
type cons[t] is cons(t,cons[t]) or nil</Text>
        </Document>
        <Document ID="BB360289-7F77-4AF1-A155-43057C51131A">
            <Title>Title Page</Title>
            <Synopsis>Title page to the manuscript.</Synopsis>
            <Text>Your Name
Your Address
Your phone number
Your e-mail address

(Your agent’s name)
(Your agent’s address)
&lt;$wc100&gt; words










&lt;$projecttitle&gt;

by &lt;$fullname&gt;</Text>
            <Notes>This is the title page of the manuscript. Note that its “Section Type” is automatically set to “Front Matter” in the Metadata pane of the Inspector, allowing the title page to be formatted differently from body text during Compile.

The &lt;$PROJECTTITLE&gt; and &lt;$fullname&gt; tags get replaced with metadata information you can set when compiling. Other information is taken from Contacts when the project is created.

The &lt;$wc100&gt; words tag will be replaced with the word count rounded to the nearest 100 during Compile (this and other tags can be inserted from the Insert menu).

Feel free to edit the text of the title page as required.</Notes>
        </Document>
        <Document ID="9246A791-286D-4255-9A7C-ECC808D6E20E">
            <Title>Record Constructor</Title>
            <Text>Labeled records denote constructors whose elements are addressed by name rather than by argument position. A labeled record specification consists of a collection TypeAnnotations. In addition, the record specification may include default values for some (or all) of the attributes of the record.
RecordConstructor ::= Identifier `{` ElementType .. ElementType `}`
ElementType ::= TypeAnnotation
  | Identifier `default` `=` Expression
  | Identifier `default` `:=` Expression
  | DefltEquation
  | `assert` Condition
Labeled Record Constructor
If there is more than one record constructor for a type then any attributes that they have in common must have the same type associated with them. For example, the type definition for a two-three tree structure:
all s ~~ twoThree[s] ::=
  three{left:twoThree[s]. 
        label:s.
        right:twoThree[s]
       }
  | two{left:twoThree[s]. right:twoThree[s] }
  | empty;
A twoThree tree type
The left and right attributes in the two constructors are required to have the same type because they are shared by the two records.
[TIP] Notice how the type annotations for the left and right sub-tree uses the same type identifier as in the definition itself. This marks twoThree as a recursive type.
</Text>
        </Document>
        <Document ID="514E6C74-1B1B-4E41-A442-9332B8C586FA">
            <Title>Symbolic Operators</Title>
            <Text>An operator may consist of a single Identifier, a sequence of Identifiers or it may consist of a QuotedIdentifier containing a sequence of so-called symbolic characters. In this form, the first character of the operator may not be a digit or a letter. In addition, none of the characters may be a space or other white-space character.
However, other than these constraints the characters in the operator declaration may be any legal unicode character.
[TIP] For the sake of programmers' sanity we strongly suggest not using characters that overlap with other categories. For example, do not include a parenthesis in the operator name.
For example, the declaration:
#infix(‘**’,700).
declares ** to be a new infix operator.
The lexical analyzer is able to incorporate the newly declared operator as a distinct token. Thus, for example, with the declaration above, ** becomes a distinct token to the normal symbol for multiplication.</Text>
        </Document>
        <Document ID="20D3E8D6-915D-42C3-A0BF-E7FFA5544299">
            <Title>Input Output</Title>
            <Text>%!TEX root = reference.tex
= Input and Output
[[io]]

Input and output features include mechanisms for reading and writing streams of characters, mechanisms for accessing and navigating file directories and mechanisms for the appropriate formatting and parsing of data.

The I/O streaming features are organized into a number of layers:
\begin{itemize}
\item At the `block' layer, an I/O operation is represented as a `task` -- see &lt;&lt;concurrent&gt;&gt; and &lt;&lt;computation&gt;&gt;. The value of an input task is typically some fragment of data from the input. An output task always has `()` as its value.
\item At the data layer, I/O operations are represented via lazily executed `sequence`s of terms. In particular, it is possible to use the sequence notation -- see &lt;&lt;sequenceNotation&gt;&gt; to represent streams of data being consumed or produced.
\end{itemize}

In addition to the layering of lazy streams on top of block data, there is a natural distinction in the handling of input vs output.

For processing input, the dominant metaphor is one of _parsing_: the input occurrence is parsed in order to extract the required data in terms of the application. For example, an application processing a sequence of records of people would prefer the input to be a sequence of `person` records.

For generating output, being able to emit `person` records is important. It is also important to be able to intersperse such records with fragments of canned text. Thus the natural data type for elements of output is the _structured string_ -- see &lt;&lt;ppType&gt;&gt;.
</Text>
        </Document>
        <Document ID="F41A5BAD-2880-4AC7-92C8-7A16C9873894">
            <Title>Regular Expressions</Title>
            <Text>A regular expression may be used to match against string values. Regular expressions are written using a regexp notation that is close to the common formats; with some simplifications and extensions.

RegularExpression::= &lt;&lt;Regex&gt;&gt;```

[[Regex]]Regex ::= `.` | `^` | `$`
  | &lt;&lt;CharRef&gt;&gt;
  | &lt;&lt;DisjunctiveGroup&gt;&gt;
  | &lt;&lt;CharacterClass&gt;&gt;
  | &lt;&lt;Binding&gt;&gt;
  | &lt;&lt;Regex&gt;&gt; &lt;&lt;Cardinality&gt;&gt;
  | &lt;&lt;Regex&gt;&gt; &lt;&lt;Regex&gt;&gt;
****
Regular Expressions

&lt;&lt;regFig&gt;&gt; shows the lexical syntax of regular expressions; however, see &lt;&lt;regularExpressions&gt;&gt; for a more detailed explanations of regular expression syntax and semantics.

[[identifiers]]
==</Text>
        </Document>
        <Document ID="A46C342F-E12E-4CD0-B27D-753026C284C6">
            <Title>Punctuation Symbols and Graphic Identifiers</Title>
            <Text>The standard operators often have a graphic form -- such as +, and =&lt;. &lt;&lt;standardGraphicsTable&gt;&gt; contains a complete listing of all the standard graphic-form identifiers.
GraphicIdentifier ::= SymbolicChar .. SymbolicChar
SymbolicChar ::= Char excepting BodyChar
Graphic Identifiers

`!` | `#&lt;` |`%%` | `--&gt;` | `:!` | `;` | `=&gt;` | `\|` |
`!`=| `#&lt;&gt;` | `*` | `-&gt;` | `:\|` | `;*` | `\|&gt;` | `*` |
`#` | `#@` | `**` | `.` | `:*` | `&lt;` |`&lt;\|` | `&gt;` |
`##` | `+` | `..,` |`:+` |`&lt;=` | `&gt;=` | `~` |
`\`#\$|`\`$|`+`+|`.`/|`:`-|`&lt;`=&gt;|`?`|`\`#*\\
`\`$\$|`,`|`/`|`:`:|`&lt;`||`@`|`\`#+|`\`$=&gt;\\
`,`..|`/`/|`:`=|`=`|`@`@|`\`#:|`\`%|`-`\\
`:`|`:`||`=`=&gt;|`\`_|`?`.|||\\
Standard Graphic-form Identifiers

[TIP] Apart from their graphic form there is no particular semantic distinction between a graphic form identifier and a alphanumeric form identifier. In fact, new graphical tokens may be introduced as a result of declaring an operator.</Text>
        </Document>
        <Document ID="832525CF-6ACE-43C4-9E33-F7F6B433B397">
            <Title>Expressions-41</Title>
            <Text>
=== Automatic Quoting
It is possible to mark a type definition in such a way as to automatically construct coercion between the type and `quoted`. This is done by adding an `implementing` clause to the &lt;&lt;TypeDefinition&gt;&gt;. For example
[listing]
type person is some{
  name has type string;
} or noOne
  implementing quotable

results in an implementation for coercion between `person` values and `quoted` representations of `person`. I.e.,
[listing]
some{name = "who"} as quoted

is enabled by the `implementing quotable` clause.</Text>
        </Document>
        <Document ID="C6BB4AEF-3F3B-436C-925D-4E08EC229AD7">
            <Title>Expressions-27</Title>
            <Text>
==== Type Safety
Since a sequence expression is essentially a macro for the use of the `sequence` contract, its type safety determined by the `sequence` contract in Program~\vref{sequenceContractDef}.

== Index and Slice Notation
[[indexNotation]]
(((index notation)))
(((notation for indexed access)))

In a similar vein to the &lt;&lt;Sequence&gt;&gt; notation, the &lt;&lt;IndexExp&gt;&gt; notation provides a high-level notation for accessing elements and subsets of collections.

\begin{figure}[htbp]
\begin{eqnarray*}
_Expression_&amp;\arrowplus&amp;&lt;&lt;IndexExp&gt;&gt;\\
[[IndexExp]]IndexExp::=&lt;&lt;Index&gt;&gt;\ |\ &lt;&lt;IndexWith&gt;&gt;\ |\ &lt;&lt;Slice&gt;&gt;\\
[[Index]Index::=&lt;&lt;Expression&gt;&gt;\ `[`&lt;&lt;Expression&gt;&gt;`]]`\\
[[IndexWith]IndexWith::=&lt;&lt;Expression&gt;&gt;\ `[``with`\ &lt;&lt;Expression&gt;&gt;`-&gt;`&lt;&lt;Expression&gt;&gt;`]]`\\
  | &lt;&lt;Expression&gt;&gt;\ `[``without`\ &lt;&lt;Expression&gt;&gt;`]`\\
[[Slice]Slice::=&lt;&lt;Expression&gt;&gt;\ `[`&lt;&lt;Expression&gt;&gt;`:`&lt;&lt;Expression&gt;&gt;`]]`\\
  | &lt;&lt;Expression&gt;&gt;\ `[`&lt;&lt;Expression&gt;&gt;`:``]`
\end{eqnarray*}
.Index and Slice Expressions
[[indexExpressionFig]]
\end{figure}

\begin{aside}
There is some subtlety in the interpretation of index expressions; depending on whether the &lt;&lt;IndexExp&gt;&gt; is an expression, or whether it is the left hand side of an assignment:
[listing]
L[Ix] := E


In the sections that follow, and in &lt;&lt;sequenceUpdate&gt;&gt;, we show the different interpretations of an index expression.
\end{aside}</Text>
        </Document>
        <Document ID="1FBB956D-9922-42CE-A1CE-CBE5287982FE">
            <Title>Subsumption of Tuples and Records</Title>
            <Text>
\begin{itemize}

\item One &lt;&lt;TupleType&gt;&gt; subsumes another if they are of the same length and each of their successive elements pairwise subsume.
\begin{prooftree}
\AxiomC{\entail{E,\theta\sub0}{t\sub1\subsume u\sub1\leadsto\theta\sub1}\sequence{\quad}\entail{E,\theta\sub{n-1}}{t\subn\subsume u\subn\leadsto\theta\subn}}
\UnaryInfC{\entail{E,\theta\sub0}{(t\sub1\sequence{,}t\subn)\ \subsume\ (u\sub1\sequence{,}u\subn)\leadsto\theta\subn}}
\end{prooftree}
where $t\subi$ and $u\subi$ are types.


\item One &lt;&lt;RecordType&gt;&gt; subsumes another if every element of the first pairwise subsumes a corresponding element of the second. For the purposes of this exposition we assume that neither type contains any encapsulated types: this case is dealt with below under existential quantification.


\begin{prooftree}
\AxiomC{\entail{E,\theta\sub0}{t\sub0\subsume u\sub1\leadsto\theta\sub1}\sequence{\quad}\entail{E,\theta\sub{n-1}}{t\subn\subsume{} u\subn\leadsto\theta\subn}}
\UnaryInfC{\entail{E,\theta\sub0}{`\{`f\sub1=t\sub1\sequence{;}f\subn=t\subn`\`}\ \subsume\ `\{`f\sub1=u\sub1\sequence{;}f\subn=u\subn`;..\`}\leadsto\theta\subn}}
\end{prooftree}
where the $f\subi$ are distinct labels of fields and the trailing `;..` is intended to signify that there may be additional elements that are not considered.

\end{itemize}

====</Text>
        </Document>
        <Document ID="45770631-D6D6-4530-ACA4-9702DEFF46D1">
            <Title>Expressions-21</Title>
            <Text>
==== `private` fields
[[privateField]]
(((private fields@`private` fields)))
(((fields,private@`private`)))
A definition within a &lt;&lt;ThetaRecord&gt;&gt; that is marked `private` does _not_ `contribute' to the external type of the record; and neither can such an attribute be accessed via the &lt;&lt;RecordAccess&gt;&gt; expression.</Text>
        </Document>
        <Document ID="3ECF6511-EC5A-4B9A-B12F-039C0CDD2CB7">
            <Title>Copyright</Title>
            <Text>
















Copyright © &lt;$year&gt; &lt;$author&gt;
All rights reserved.
ISBN:
ISBN-13:
</Text>
            <Notes>Feel free to delete this document if you don’t need it, or edit it for your needs.</Notes>
        </Document>
        <Document ID="5EE132AD-D003-43F6-95F5-34E5D9F2CC04">
            <Title>Expressions-14</Title>
            <Text>
=== Tuples
[[TupleTerms]]
(((expressions,tuple)))
(((tuples)))
(((informal combinations of elements)))
A tuple consists of a sequence of expressions separated by commas and enclosed in parentheses. In effect, a tuple is a &lt;&lt;ConstructorLiteral&gt;&gt; where the &lt;&lt;Identifier&gt;&gt; is omitted -- and is automatically generated.

\begin{figure}[htbp]
\begin{eqnarray*}
[[TupleLiteral]]TupleLiteral::=`()`\\
  | `((`&lt;&lt;Expression&gt;&gt;`))`\\
  | `(`&lt;&lt;Expression&gt;&gt;\sequence{,}&lt;&lt;Expression&gt;&gt;`)`\plustwo
\end{eqnarray*}
.Tuple Literal Expression
[[tupleLiteralFig]]
\end{figure}

Tuples allow a straightforward of the `casual' grouping of values together without requiring a specific type definition of a data structure.
\begin{aside}
Unlike &lt;&lt;ConstructorLiteral&gt;&gt;s, tuples _cannot_ be defined using a &lt;&lt;TypeDefinition&gt;&gt;. Instead, the tuple types form a _type schema_.
\begin{aside}
Not a single type, because each arity of anonymous tuple type denotes a different type. However, all tuples are related by their tuple-ness.
\end{aside}
\end{aside}

In that tuples can be used to group elements together, they are somewhat similar to arrays. However, unlike arrays, each element of a tuple may be of a different type, and also unlike arrays, tuple elements may not be accessed via an indexing operation: tuples can only be `unwrapped' by some form of pattern matching.

For example, if the `split` function splits a list into a front half and back half, it may be used in a statement of the form:
[listing]
def (F,B) is split(L)

which has the effect of unpacking the result of the `split` function call and binding the variables `F` and `B` to the front half and back half of the list `L`.


The tuple notation is unremarkable except for two cases: the single element tuple and the zero element tuple.</Text>
        </Document>
        <Document ID="DCA55054-A0C0-433E-A65D-295D3F8F47E4">
            <Title>Procedure Type</Title>
            <Text>
====
[[procedureType]]
(((procedure type)))
(((type,procedure)))

A procedure is an abstraction of an action. I.e., a procedure is a function that does not return a value but is executed purely for its side effect(s). This is expressed in the form of procedure types, which take the form of a function type that returns an empty tuple:
TupleType =&gt; ()
For example, a procedure that takes string and integer arguments would have the type signature:
(string,integer)=&gt;()
And the type:
()=&gt;()
denotes the type of a procedure that takes no arguments.
</Text>
        </Document>
        <Document ID="8F8AD2D6-85AD-4DE1-8A23-AEB75174CFC6">
            <Title>Expressions-22</Title>
            <Text>
=== Record Substitution Expression
[[recordOverride]]
(((replacing values in a record)))
(((expressions,substitute@`substitute`)))
(((record values,replacing fields)))
An expression of the form:
[listing][mathescape=true]
A substitute {att$\sub1$=$&lt;&lt;Expression&gt;&gt;\sub1\sequence{;}$att$\subn$=$&lt;&lt;Expression&gt;&gt;\subn$}

denotes the value obtained by replacing the attributes `att`\subi{} in `A` with the expressions &lt;&lt;Expression&gt;&gt;\subi.

\begin{figure}[htbp]
\begin{eqnarray*}
_Expression_&amp;\arrowplus&amp;&lt;&lt;Expression&gt;&gt;\ `substitute`\ &lt;&lt;AnonymousRecord&gt;&gt;
\end{eqnarray*}
.Record Override Expression[[recordOverrideFig]]
\end{figure}

For example, the expression
[listing]
P substitute {age=33}

has value
[listing]
someone{name="fred"; age=33}

\begin{aside}
This expression has a separate value to that of `P` itself; evaluating the `substitute` does not side-effect `P`.
\end{aside}

\noindent
The semantics of `substitute` is based on the notion of a `shallow copy'. The value of the expression:
[listing]
P substitute { age=33 }

is a new term whose fields consist of all the fields of `P` -- with the exception of the `age` field. The `substitute` expression does not imply a `deep' or complete copy of its left hand side.
\begin{aside}
(((expressions,substitute@`substitute`!ref fields@`ref` fields)))
(((record values,replacing ref fields@replacing `ref` fields)))
(((ref field@`ref` field)))
This only has significance if the record contains any `ref` fields. In particular, the resulting expression _contains_ the same `ref` fields as the original; and a subsequent assignment to a `ref` field will affect both the original and the substituted term.

For example, given this type definition:
[listing]
type account is account{
  name has type string;
  balance has type ref float;
}

and given the variable bindings:
[listing]
def A is account{ name = "fred"; balance := 0.0 };
def B is A substitute { name = "peter" }

then `A` and `B` both share the _same_ `ref` field. An assignment to one:
[listing]
A.balance := 5.9

is an assignment to the other. In this case, the value of `B.balance` is also `5.9`
\end{aside}
\begin{aside}
Note that if the _right hand side_ of a `substitute` contains a `ref` field, then the result will have the `ref` field from the right hand side, not the original.

For example, if we have:
[listing]
def C is A substitute { balance := 4.5 }

then `C` _does not_ share a `ref` with `A` and updating either will not affect the other.
\end{aside}</Text>
        </Document>
        <Document ID="7F3FECE6-FC1D-4B7E-B329-2EAD41A75D08">
            <Title>Expressions-16</Title>
            <Text>
==== Singleton Tuples
(((single element tuples)))
(((tuples,single element)))
Some special handling is required to represent tuples of one element.

The principal issue is the potential ambiguity between a tuple with one element and a normal operator override expression.

For example,
[listing]
(a+b)*c

is such a case: the inner term `(a+b)` is not intended to denote a tuple but simply the sum of `a` and `b`.

A singleton tuple _may_ be written; by doubly parenthesizing it. An expression of the form:
[listing]
((34))

denotes a singleton tuple with the integer 34 in it.

\begin{aside}
Fortunately, singleton tuples are not often required in programs.
\end{aside}</Text>
        </Document>
        <Document ID="DB81A0AD-4799-4E06-954F-382BF3A984EB">
            <Title>Type Witness Definition</Title>
            <Text>A TypeWitness definition declares that a given type exists. It is used to assert that a given existential type exists.
TypeWitness ::= `type` Identifier `=` Type
Type Witness Statement
For example, in the expression:
group{
  type elem = integer.
  inv(X) =&gt; -X.
  op(X,Y) =&gt; X+Y.
  zero = 0.
}
the statement:
type elem = integer.
asserts that the type integer is a witness for the existentially quantified type elem.
[NOTE] TypeWitness statements are inherently internal statements: the witness type itself is not exposed by the record that contains the TypeWitness statement.
</Text>
        </Document>
        <Document ID="2EFAA26E-0948-411B-ABD8-C2E571F5DD45">
            <Title>Expressions-19</Title>
            <Text>
==== Type Safety
The type safety of a record access expression is couched in terms of &lt;&lt;AttributeConstraint&gt;&gt;s: i.e., a record access expression implies that a value satisfies the appropriate &lt;&lt;AttributeConstraint&gt;&gt;.

\begin{prooftree}
\AxiomC{\typeprd{E}{R}{T\ `where`\ T\ `implements`\ `\{F has type `T\sub{f}`\`}}}
\UnaryInfC{\typeprd{E}{R.F}{T\sub{f}}}
\end{prooftree}
\begin{aside}
This formulation of the type safety of record access expressions allows for some quite powerful usages. For example, the function:
[listing]
getName(R) is R.name

has type:
[listing]
getName has type for all r,f such that
  (r)=&gt;f where r implements {name has type f}

In effect, we can define programs that depend on particular attributes without having to be concrete about the actual types of the records being accessed.
\end{aside}</Text>
        </Document>
        <Document ID="1B678506-DBB2-4AE8-9375-F1921F91ED1C">
            <Title>Prefix Operator</Title>
            <Text>A statement of the form:
#prefix(‘prOp’,730).
defines the operator prOp to be a prefix operator, with priority 730.</Text>
        </Document>
        <Document ID="B0E4B55F-888A-4738-ABAA-6E46AF909FDC">
            <Title>Packages</Title>
            <Text>%!TEX root = reference.tex
= Packages and Libraries
[[packages]]
(((package@`package` structure)))
A &lt;&lt;Package&gt;&gt; represents a `unit of compilation' -- i.e., the contents of a source file.

(((libraries)))
Star libraries are built using a combination of &lt;&lt;Package&gt;&gt;s and catalogs. A catalog is a mapping from names to locations that is used to inform the Star language system of the physical locations of &lt;&lt;Package&gt;&gt;s.

== Package Structure
[[packageStructure]]
(((what is in a package@what is in a `package`)))

A &lt;&lt;Package&gt;&gt; consists of the identification of the package and a set of &lt;&lt;Definition&gt;&gt;s enclosed in braces. For example, the text:
[listing]
hello is package{
  hello() is "hello";
}

defines a `package` -- called `hello` -- that contains a single function -- also called `hello`.

\begin{aside}
The name of a &lt;&lt;Package&gt;&gt; must be reflected in the name of the physical file that contains the source text. In particular, if a file contains the package `_P_`, then the name of the file should take the form:
[listing][language=bash]
.../Directory/P.star

\end{aside}

The body of the &lt;&lt;Package&gt;&gt; may contain &lt;&lt;Definition&gt;&gt;s which may also include &lt;&lt;ImportStatement&gt;&gt;s.

\begin{figure}[htbp]
\begin{eqnarray*}
[[Package]]Package::=&lt;&lt;Identifier&gt;&gt;\ `is`\ `package\{`&lt;&lt;Definition&gt;&gt;\sequence{;}&lt;&lt;Definition&gt;&gt;\ `\`}
\end{eqnarray*}
.Package Structure[[packageFig]]
\end{figure}

A &lt;&lt;Package&gt;&gt; consists of all the elements that are defined in a package source:
\begin{itemize}
\item The types defined with the source unit
\item The functions and other variables defined
\item Macros and other meta-rules (such as validation rules)
\item Operator definitions
\end{itemize}


=== Top-level Variables
[[packageVariable]]
(((top-level variable)))

Any variable that is defined at the top-level of a &lt;&lt;Package&gt;&gt; is assumed to be _global_ across all uses of the package.

This has implications especially for top-level reassignable variables. If such a variable is changed then all importing packages will `see' the changed value.
\begin{aside}
Such shared global variables should be used sparingly if the programmer is to avoid unnecessary bugs.
\end{aside}


=== Managing Exposed Elements of a Package
By default, all the elements that are defined in a `package` are exported as part of the `package`. However, like other &lt;&lt;thetaEnvironment&gt;&gt;s, elements of the package that are marked `private` are not exported: i.e., they will not be visible when the package is imported.


== Importing
[[packageImport]]
A `package` may use another package by `import`ing it. The `import` statement  denotes a requirement that the types, programs and other elements of the `import`ed package are made available to the importing package.

In addition to the `import` statement, the `java` statement allows access to programs defined in Java -- see &lt;&lt;javaImport&gt;&gt;.

=== The `import` statement
[[import]]
The `import` statement is used to denote that the exported elements of a package should be made available within a package. There are two variants of the &lt;&lt;ImportStatement&gt;&gt;: the `open `import`' and the `named `import`'. In addition, the package to be imported may be specified by name or by URI.

\begin{figure}[htbp]
\begin{eqnarray*}
[[ImportStatement]ImportStatement::=[`private`]]\ `import`\ &lt;&lt;PackageRef&gt;&gt;\\
  | &lt;&lt;Identifier&gt;&gt;\ `is`\ `import`\ &lt;&lt;PackageRef&gt;&gt;\\
[[PackageRef]]PackageRef::=&lt;&lt;Identifier&gt;&gt;\\
  | &lt;&lt;String&gt;&gt;
\end{eqnarray*}
.Import Package Statement
[[importStatementFig]]
\end{figure}

\begin{aside}
The &lt;&lt;String&gt;&gt; variant of the `import` must take the form of a URI string. For example, to import the package located in the file `pkg.star` in the same directory as the referencing package, use the form:
[listing]
import "pkg.star"

\end{aside}

\begin{aside}
Not all installations of the language system are required to support the same set of URI schemes. However, all must support the standard schemes shown in &lt;&lt;standardURISchemes&gt;&gt;. See &lt;&lt;resources&gt;&gt; for a discussion on resources and URIs.
\end{aside}

==== Open Import
[[openImport]]
(((import@`import`,open)))
An &lt;&lt;ImportStatement&gt;&gt; of the form:
[listing]
import Pkg

imports all the definitions that are located with the `Pkg` and declares them as being at the _same_ scope level as other &lt;&lt;Definition&gt;&gt;s within the package.

\begin{aside}
Note that it is possible, this way, for a `package` to implicitly _re-export_ some elements of `package`s that the `package` imports.
\end{aside}

This has two primary implications: all the exported definitions may be used without qualification as though they had been defined locally. However, if a given name is declared twice -- even if in two separate packages -- then the compiler will show an error.

In addition to the regular functions and types defined in the imported package, any contracts, macros and operator definitions that are defined in the imported package are also `in scope'.

\begin{aside}
This form of &lt;&lt;ImportStatement&gt;&gt; also imports operator definitions and macro definitions from the imported package. Hence, the open import is especially important when accessing packages that contain implementations of domain specific language extensions to Star.
\end{aside}

==== Named Import
[[namedImport]]
(((import@`import`,named)))
An &lt;&lt;ImportStatement&gt;&gt; of the form:
[listing]
P is import Pkg

is a _named import_ -- so-called because it establishes a &lt;&lt;Variable&gt;&gt; whose value is the contents of the imported package and whose name is used to access the imported package.

Definitions that are imported as a named import are not immediately defined to be in scope. Instead, they must be accessed via the package variable -- using &lt;&lt;RecordAccess&gt;&gt; expressions.

For example, if `Pkg` exports a type `person` and a function `someone`, then to use the type and function they are referenced from the `P` variable -- much like accessing &lt;&lt;Record&gt;&gt; fields:
[listing]
Joe has type P.person;
def Joe is P.someone("Joe")


Using named imports in this way is a convenient way to establish different name spaces. Since all the definitions within the package must be accessed via the &lt;&lt;RecordAccess&gt;&gt; operator, the name used to import the package effectively becomes a local name space for that package and will not clash with neither other imported packages nor locally defined functions and types.

\begin{aside}
Note that neither macros nor operators are accessible from a named import.
\end{aside}

==== Private Imports
[[privateImport]]
If an open &lt;&lt;ImportStatement&gt;&gt; is marked `private` then the definitions contained within the imported package are _not_ re-exported by the containing package. Conversely, an &lt;&lt;ImportStatement&gt;&gt; that is not `private` will result in all the definitions contained within the imported package are re-exported.

Private imports are useful in the situation where a package needs auxiliary definitions that are not intended to be part of the `published' specification of the package.

\begin{aside}
A named `import` is always `private`.
\end{aside}

=== Importing `java` Code
[[javaImport]]

The `java` statement may be used to import a certain class (sic) of Java\tm{} functions.

\begin{figure}[htbp]
\begin{eqnarray*}
_ImportStatement_&amp;\arrowplus&amp;`java`\ _JavaClass_\\
\end{eqnarray*}
.Java Import Statement
[[javaImportFig]]
\end{figure}

For example, to import the functions defined in
[listing][language=Java]
package com.example;

public class SimpleFuns
{
  public static String javaFoo(Integer x, int y)
  {
    return Integer.toString(x * y);
  }

  public static void doSomething(String s, double d)
  {
    System.out.println("We are supposed to " + s + " to " + d);
  }
}

the programmer uses:
[listing]
useSimple is package{
  java com.example.SimpleFuns;

  main() do
    doSomething(javaFoo(23,45),45.23);
}

which will result in
[listing]
We are supposed to 1035 to 45.22999954223633

appearing on the standard output console.

Due to the semantic `gap' between Java\tm{} and Star there are some restrictions on the functions that can be incorporated using the `java` import. In particular, there is a restricted set of Java\tm{} types that are supported; and only `static` methods are imported from the class.

The supported types are:
\begin{description}
`int` and `Integer`:: A Java\tm{} `int` or `Integer` type is mapped to the Star type `integer`.
`long` and `Long`:: A Java\tm{} `long` or `Long` type is mapped to the Star type `long`.
`float` and `Float`:: A Java\tm{} `float` or `Float` type is mapped to the Star type `float`.
`double` and `Double`:: A Java\tm{} `double` or `Double` type is mapped to the Star type `float`.
`BigDecimal`:: A Java\tm{} `BigDecimal` type is mapped to the Star type `decimal`.
`String`:: A Java\tm{} `String` type is mapped to the Star type `string`
any:: All other Java\tm{} types are mapped to the Star type `any`. This permits a Star program to `carry' any Java\tm{} object, but it cannot be inspected by a Star program.
\begin{aside}
The primary utility of this is to allow the Java object to be passed to another function.
\end{aside}
\end{description}


\begin{aside}
\begin{aside}
The `java` import requires that the Java\tm{} class being imported is accessible on the Java\tm{} CLASSPATH. How this is done is outside the scope of this document.
\end{aside}
\end{aside}

== Libraries
[[libraries]]
(((libraries)))

A library is a collection of packages that forms a coherent whole. Physically, a library takes the form of a normal package. However, typically, a library package simply imports a set of other packages -- the packages in the library.

=== Importing Libraries
[[libraryImport]]
A library is imported in precisely the same way as any individual package -- using an &lt;&lt;ImportStatement&gt;&gt;. From the perspective of a client of the library, the client does not `know' the difference between importing an individual package or a library.

=== Structure of a Library
[[libraryStructure]]
(((libraries,structure)))

The classic structure of a library consists of a directory containing the packages that make up the library, together with a catalog and a library driver package footnote:[In this discussion we refer to the concept of a directory in a metaphorical sense. The actual organization of a library is represented in terms of the URIs of the packages that make up the library; not any physical system of files and directories. A `directory' in URI terms is simply a URI whose path ends with a `/` character -- denoting the potential for further elements in the path.] see &lt;&lt;libraryFig&gt;&gt;.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=\textwidth]{diagrams/library}
.Library Structure
[[libraryFig]]
\end{center}
\end{figure}

The library driver package typically has a standard form: it consists of a series of &lt;&lt;ImportStatement&gt;&gt;s. The library is, in effect, defined by these `import`s.

The normal semantics of an `import` statement imply that the contents of all the `import`ed packages will be `re-exported' by the library driver package. The effect is that when the library driver package is imported, the entire contents of the library will be imported.

The second element of a library structure is the catalog. This typically contains the mapping from the names of packages to their URIs within the library `directory'.

Following the standard process of determining the catalog and URI of an `import`ed package, when the library driver `package` is imported, the library catalog will be accessed in order to interpret the contents of the library driver `package`.

== Resources and Catalogs
[[resources]]

A package is an instance of a resource. A resource is any entity that can be identified. Examples of resources include package files (both source and compiled), and libraries. Resources need not be ‘static’: in principle, a service or a running application may also be viewed as a resource. However, in respect to the Star language, we are mostly concerned with Star package resources.

=== Identifying Resources
(((Unified Resource Identifier)))
The standard for identifying resources is the URI \cite{rfc2396}. Star uses URIs to locate source packages. Specifically, the Star language system _must_ support the URI schemes identified in &lt;&lt;standardURISchemes&gt;&gt;; however, it is free to support other schemes.

Program~\vref{uriProg} gives the Star definition of the standard `uri` type. This structure reflects the standard structure of a so-called hierarchic URI.  In addition to the `unpacked' `uri` structure, the &lt;&lt;TypeCoercion&gt;&gt; expression:

[listing]
"..." as uri

represents a convenient way of writing URIs. The standard notation for URIs for supported schemes is supported by such expressions.

\begin{program}
[listing]
type uri is uri{
  scheme has type string;
  authority has type uriAuthority;
  path has type string;
  query has type string;
  fragment has type string
}

type uriAuthority is authority{
  user has type string;
  host has type string;
  port has type integer
} or noAuthority;

.The Standard `uri` Type Description[[uriProg]]
\end{program}

\begin{aside}
When a `uri` is used to denote an `import`ed package, the last part of the path must reflect the package name. I.e., if a package is called `pkg`, then the `uri` path must terminate in `.star`.
\end{aside}

\paragraph{Query Structure}
The `query` portion of a URI should take the form of a sequence of key=value pairs, separated by semi-colons. For example, a file URI with a VERSION attribute will look like:
[listing]
file:///foo/bar.star?VERSION=1.3;ACCESS=public


==== Standard URI Schemes
[[standardSchemes]]
The compiler recognizes a number of URI schemes as `standard': i.e., the compiler knows how to access the identified resources. In addition, the compiler also supports a technique for extending the set of known schemes with methods for locating the resources.
\begin{aside}
Technically, a URI contains no reliable indication of the physical location of the identified resource. However, for practical purposes it is often convenient to encode assumptions about physical location.
\end{aside}

The standard schemes supported by the compiler are listed in &lt;&lt;standardURISchemes&gt;&gt;.

\begin{table}[H]
.Standard URI Schemes[[standardURISchemes]]
\begin{center}
\begin{tabular}{|lll|}
\hline
Scheme&amp;Type&amp;Physical Location\\
\hline
`file:`&amp;Local file&amp;File path on system\\
`std:`&amp;Built-in&amp;Internal to compiler\\
`http:`&amp;HTTP URL&amp;Web page\\
`\$quoted\$:`&amp;Quoted URI&amp;Within URI's fragment\\
`star:`&amp;Star source&amp;File on local system\\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{description}
`file:`::A `file:` URI takes the form:
[listing]
file://_Computer_/_FilePath_

If the _Computer_ is omitted then the current machine that the compiler is executing on is assumed. If the `Computer` is not omitted, it may not be possible to access the remote computer.
`std:`:: A `std:` URI refers to resources that are properly part of the compiler itself. This are `hard-coded' in the sense that their location is established when the compiler is installed.
`star:`:: A `star:` URI refers to the default location that the compiler uses to find source files. This is often simply the working directory of the compiler; but may be configured with a command-line option.
`http:`:: A `http:` URI refers to a standard WEB URL. The compiler will attempt to access the resource by means of an HTTP request to the identified URL.
`\$quoted\$:`:: A `\$quoted\$` contains the source within the URI itself.

For example, the URI:
[listing]
$quoted$://hello#hello\%20is\%20package\%7b\%0a\%20\%20fun\%20hello
                                \%28\%29\%20is\%20\%22hello\%22\%3b\%0a\%7d

denotes the package:
[listing]
hello is package{
  hello() is "hello";
}

\begin{aside}
The standard notation for URIs requires that all the special characters used in a typical Star source must be encoded as `\%` hex pairs.

This URI is shown on two lines for convenience of display, but must actually be a contiguous sequence of characters.
\end{aside}
\begin{aside}
It is possible, if slightly redundant, to use quoted URIs to import a package:
[listing]
...
import "$quoted$://hello#hello%20is%20package
                 %7b%0a%20%20fun%20hello%28%29%20is%20%22
                 hello%22%3b%0a%7d";
...

However, a more important use of quoted URIs is to support dynamically compilation of Star in cases where the compiler is embedded.
\end{aside}
\end{description}

==== Defining New Resource Schemes
[[newResoureScheme]]
A new resource scheme may be introduced as a command line parameter using the `-DTRANSDUCER=` flag (see &lt;&lt;compileFlags&gt;&gt;).

The value of this flag is special form rule that takes the form:
[listing]
_Ptn_==&gt;_Repl_

The syntax accepted by the pattern of the rule is the same as &lt;&lt;RegularExpression&gt;&gt;; in particular, named groups are supported.

The purpose of this rule to map a new form of URI scheme into a predefined one.

In fact, the normal `star:` scheme can be expressed using a `TRANSDUCER` rule of the form:
[listing]
"star:(.*/)?([^/]+:V)==&gt;file://_tgtDir_/$V"

where `tgtDir` is the directory selected for finding source Star programs.

This particular rule locates the path component of the `star:` URI and translates it to a `file:`-based URI. It does not permit either a query or a fragment specifier; although these could be added they would have to be ignored.


==== Resource Versions
[[uriVersion]]
A resource URI may have a version indicator that identifies a particular version of the resource. The version indicator is a value associated with the `VERSION` keyword in the query portion of the URI.

For example, to specify version 2.1 of a resource, one might use the URI:
[listing]
file:///foo/bar.star?VERSION=2.1


The notation for version number is based on a release-version-update scheme.
\begin{figure}[htbp]
\begin{eqnarray*}
[[Version]Version::=&lt;&lt;Release&gt;&gt;[`.`&lt;&lt;Version&gt;&gt;[`.`&lt;&lt;Update&gt;&gt;]]]\\
[[Release]]Release::=&lt;&lt;Digit&gt;&gt;\sequence{}&lt;&lt;Digit&gt;&gt;\\
[[Version]]Version::=&lt;&lt;Digit&gt;&gt;\sequence{}&lt;&lt;Digit&gt;&gt;\\
[[Update]]Update::=&lt;&lt;Digit&gt;&gt;\sequence{}&lt;&lt;Digit&gt;&gt;
\end{eqnarray*}
.Version Numbering
[[versionNumberScheme]]
\end{figure}
Version numbers are numeric, alphabetic version numbers are not permitted.

The requirement for any transducer that accesses a URI is either:
\begin{itemize}
\item if the URI references a specific version then that version of the resource should be accessed by the transducer;
\item if the URI does not reference a version, and if there are multiple versions of a resource, then the transducer must access the resource with the largest version number associated with it.
\end{itemize}


=== Packages and Paths
[[packagePath]]
The URI used to identify a package must identify the package's name. Specifically, if the path component of a URI takes the form:
[listing]
Dir/Dir\sequence{/}Name._Ext_

then the name of the package -- as identified within the package source -- must be the same as the `Name` part of the package's URI.

This can be expressed more precisely as the substring of the URI's path gotten by removing both any leading folder names (separated by `/` characters) and any trailing extension (denoted as the remaining text following the last occurrence of a `.` character) must be the same as the name identified within the package source.

=== Catalogs
[[catalog]]
A catalog is a mapping from logical names to URIs. The Star language system uses this mapping to locate source files and compiled code when the corresponding resource is `import`ed by name.

Catalogs offer an additional `level of indirection’ between a name and the named entity. This indirection can be used, for example, to implement versioned access to resources. In addition, catalogs serve the role of ‘pulling together’ the resources that a program or application needs into a coherent set.

Thus, when a package is imported by name, as in:
[listing]
world is package\{
  import hello;
  ...
\}

then the Star language system uses the catalog mapping to resolve the name `hello` to a `uri` in order to actually access the package. The Star type of `catalog` is shown in Program~\vref{catalogProg}.

\begin{program}
[listing]
type catalog is catalog\{
  content has type dictionary of (string,uri);
  version has type string;
  version default is nonString;
\}

.The `catalog` Type[[catalogProg]]
\end{program}

For example, the catalog definition:
[listing]
myCatalog is catalog\{
  content is dictionary of \{
    "hello" -&gt; "file:///First/Second/hello.star";
    "stdlib" -&gt;
       "http://www.star-lang.org/extensions/StdLib/stdlib.star";
    "AlpsLib" -&gt;
       "model://example.com/Alps/Libraries/AlpsLib/AlpsLib.star";
    "star" -&gt; "std:star.star"
  \}
\}

is a typical catalog denoting the programs available to a Star application.

==== Accessing Packages Using Catalogs
(((accessing packages with catalogs)))
(((catalog,accessing packages with)))
The process of accessing a package involves:
\begin{enumerate}
\item If the package is identified by name, the URI of the package is looked up within the `current' catalog.
\begin{enumerate}
\item If the name is not present in the catalog, a fall-back catalog is searched if available.
\item If the name is not present, and there is no fall-back, exit with an error.
\end{enumerate}
\item The located URI is resolved against the URI of the current catalog. This allows catalogs themselves to contain relative URIs where possible.  This is the so-called target URI.

\item The target URI is dereferenced -- using a transducer -- and accessed. If the resource does not exist, or is not valid, exit with an error.
\item The catalog uri:
[listing]
"../catalog"

is resolved against the URI of the package containing the reference.
\begin{enumerate}
\item If a catalog exists in this location then that catalog is used to resolve references within the target resource.
\item If there is no catalog, then a catalog _may_ be synthesized by `exploring' the space around the target URI.
\end{enumerate}
\end{enumerate}

==== Multiple Versions of a Package
A code repository may contain multiple versions of a package. A programmer may specify a specific version to import by specifying the version in the package's URI: either directly in the &lt;&lt;ImportStatement&gt;&gt; or in the catalog.

If no version is specified, then importing a package will always reference the package in the repository with the largest version number.

When compiling a package, the version of the package may be specified as a command-line option to the compiler or by defining a non-trivial value for the `version` attribute in the catalog structure.

However specified, the versions that a package is compiled against are fixed during the compilation of the package. I.e., when a package is compiled, it is compiled against specific versions of imported packages. When the package is later executed, the specific versions that were accessed at compile time are also used at run-time.
</Text>
        </Document>
        <Document ID="E7479F95-1BE8-40CC-861A-FAB0A8EAD845">
            <Title>Left Associative Infix Operator</Title>
            <Text>A statement of the form:
#left(‘lftOp’,730).
defines the operator lftOp to be a left-associative infix operator, with priority 730. That means that expression such as
A lftOp B lftOp C lftOp D
will be parsed as though written:
((A lftOp B) lftOp C) lftOp D</Text>
        </Document>
        <Document ID="780947E7-7046-43A3-A9BA-6ED3ACCD9809">
            <Title>Subsumption of Function Types</Title>
            <Text>

The rules for subsumption for function types introduces the concept of _contravariance_.

\begin{itemize}

\item A function type $F\sub1$ subsumes $F\sub2$ if the result types subsume and the argument types contra-subsume:

\begin{prooftree}
\AxiomC{\entail{E,\theta\subi}{r\sub1\subsume{}r\sub2\leadsto\theta\sub0}}
\AxiomC{\entail{E,\theta\sub0}{a\sub2\subsume{}a\sub1\leadsto\theta\sub{o}}}
\BinaryInfC{\entail{E,\theta\subi}{a\sub1`=&gt;`r\sub1\subsume{}a\sub2`=&gt;`r\sub2\leadsto\theta\sub{o}}}
\end{prooftree}

The subsumption relation is inverted for the argument types of the two function types. This reflects the intuition that for one function type to subsume another its result type must subsume the latter but the argument type of the latter should subsume (be more general than) the former.
\begin{aside}
Without contravariance it becomes difficult and awkward to combine functions together.
\end{aside}

\item The subsumption relation for pattern types is similar to that for function types:
\begin{prooftree}
\AxiomC{\entail{E,\theta\subi}{r\sub1\subsume{}r\sub2\leadsto\theta\sub0}}
\AxiomC{\entail{E,\theta\sub0}{a\sub2\subsume{}a\sub1\leadsto\theta\sub{o}}}
\BinaryInfC{\entail{E,\theta\subi}{r\sub1`&lt;=`a\sub1\subsume{}r\sub2`&lt;=`a\sub2\leadsto\theta\sub{o}}}
\end{prooftree}

\item Subsumption for constructor types requires equivalence rather than subsumption. This is because a constructor may be used both as a pattern and as a function. We use the \equivt{} to denote this. We do not need to introduce a completely new definition for \equivt{}, instead we can define it in terms of \subsume:

\begin{prooftree}
\AxiomC{\entail{E,\theta\subi}{t\sub1\subsume{}t\sub2\leadsto\theta\sub0}}
\AxiomC{\entail{E,\theta\sub0}{t\sub2\subsume{}t\sub1\leadsto\theta\sub{o}}}
\BinaryInfC{\entail{E,\theta\subi}{t\sub1\equivt{}t\sub2\leadsto\theta\sub{o}}}
\end{prooftree}

Given this definition of \equivt{}, we can define subsumption for constructor types:
\begin{prooftree}
\AxiomC{\entail{E,\theta\subi}{r\sub1\equivt{}r\sub2\leadsto\theta\sub0}}
\AxiomC{\entail{E,\theta\sub0}{a\sub2\equivt{}a\sub1\leadsto\theta\sub{o}}}
\BinaryInfC{\entail{E,\theta\subi}{r\sub1`&lt;=&gt;`a\sub1\subsume{}r\sub2`&lt;=&gt;`a\sub2\leadsto\theta\sub{o}}}
\end{prooftree}

Clearly, this definition is symmetric wrt the two constructor types, and we can also establish:
\begin{prooftree}
\AxiomC{\entail{E,\theta\subi}{r\sub1\equivt{}r\sub2\leadsto\theta\sub0}}
\AxiomC{\entail{E,\theta\sub0}{a\sub2\equivt{}a\sub1\leadsto\theta\sub{o}}}
\BinaryInfC{\entail{E,\theta\subi}{r\sub2`&lt;=&gt;`a\sub2\subsume{}r\sub1`&lt;=&gt;`a\sub1\leadsto\theta\sub{o}}}
\end{prooftree}

\end{itemize}

====</Text>
        </Document>
        <Document ID="1CCCEF2E-7262-48E1-A4D6-E51E4C4313AD">
            <Title>Contracts</Title>
            <Text>A contract is a specification of a set of functions and action procedures that form a coherent collection of functionality. Associated with a Contract are one or more Types -- the contract is said to be over those types.
</Text>
        </Document>
        <Document ID="6091AFFA-086B-4002-AD94-4B2A948BB3A9">
            <Title>Largest and Smallest floats</Title>
            <Text>The largeSmall contract is implemented for floating point numbers. Its implementation is equivalent to
implementation largeSmall [float] =&gt; {
  argest = __bits_float(0x7fefffffffffffffL)
  smallest = __bits_float(0x1L)
}
where __bits_float is a special function that allows a 64 bit bit string to represent a floating point number (the bit string is the bit representation of the floating point number).

</Text>
        </Document>
        <Document ID="EF2C9384-B200-452E-9F9A-7371CE934F8F">
            <Title>Automatic Synthesis of Contract Implementations</Title>
            <Text>In some cases, the regular implementation of a contract by be predicted by examining the algebraic type definition itself. The Star compiler automatically generates implementations of the equality and the pPrint contracts, for example, by inspecting the type definition itself.
A programmer may extend this system of atomically implementing contracts by implementing a special macro whose name is of the form implement_name. A type definition that is marked:
person ::= some{
  name:string;
} | noOne
  implementing Spec
will result in the macro implement_Spec being invoked on the type definition.
This is used, for example, to allow coercion between types and the standard quoted type to be synthesized, instead of being constructed manually.</Text>
        </Document>
        <Document ID="19A28ADE-01CF-493C-8D0E-257D7645E4F6">
            <Title>Default Values</Title>
            <Text>It is permitted to associate a default value with a field of an record constructor. A default value is simply an expression for an attribute that is used should a particular record literal expression  not contain a value for that field.
For example, for convenience, we might add default annotations in the twoThree type defined above, resulting in the type definition in:
all s ~~ twoThree[s] ::=
  three{ left:twoThree[s].
         left default = empty.
         label:s.
         right:twoThree[s].
         right default = empty.
       }
  or two{ left:twoThree[s].
         left default = empty.
         right:twoThree[s].
         right default = empty.
       }
  or empty.
A twoThree`tree type with defaults
[NOTE] A default value expression for an attribute is evaluated in the scope that is valid for the type definition itself. The default value expression may reference variables that are in scope at the point of type definition. The default value expression may also reference other fields of the record constructor -- as though they were variables -- provided that they themselves do not have defaults associated with them.
For example, in this definition of Person:
Person ::= someone{
  name:string.
  dob:date.
  age:()=&gt;float.
  age() default =&gt; now()-dob.
}
there is a default definition of the age field that is used if a given someone record literal does not mention a value for age. This default`definition makes use of the dob field as though it were a free variable of the age function.
</Text>
        </Document>
        <Document ID="768110F9-E803-4840-BF13-934F52E202FD">
            <Title>Operator Precedence Grammar</Title>
            <Text>An operator grammar allows us to write expressions like:
X * Y + X / Y
and to know that this means the equivalent of:
(X * Y) + (X / Y)
or more specifically:
‘+’(‘*’(X, Y), ‘/‘(X, Y))
Operator precedence grammars are often used to capture arithmetic-style expressions. In Star we extend the concept to cover the entire language.
For example, an equation such as:
double(X) =&gt; X*X
can be interpreted – by treating =&gt; as an operator – as:
'=&gt;'(double(X),’*’(X,X))
Of course, this is merely a parse of the equation. The real task of the compiler is to interpret this abstract syntax as an equation rather than as an attempt to apply the =&gt; function.</Text>
        </Document>
        <Document ID="FA17E9C8-9E5F-4C04-BA4F-DEBAD1F409BD">
            <Title>Patterns</Title>
            <Text>%!TEX root = reference.tex
= Patterns
[[patterns]]
(((patterns)))
Patterns are templates that are used to match against a value; possibly binding one or more variables to components of the matched value. Patterns are used as guards in equations, as filters in query expressions and in `for` loops. Patterns represent one of the fundamental mechanisms that can guide the course of a computation.

\begin{figure}[htbp]
\begin{eqnarray*}
[[Pattern]]Pattern::=&lt;&lt;ScalarPattern&gt;&gt;\\
  | &lt;&lt;Variable&gt;&gt;\\
  | &lt;&lt;ConstructorPattern&gt;&gt;\\
  | &lt;&lt;EnumeratedSymbolPattern&gt;&gt;\\
  | &lt;&lt;RecordPattern&gt;&gt;\\
  | &lt;&lt;GuardedPattern&gt;&gt;\\
  | &lt;&lt;MatchingPattern&gt;&gt;\\
%  | &lt;&lt;TypeCastPattern&gt;&gt;\\
  | &lt;&lt;TypeAnnotatedPattern&gt;&gt;\\
  | &lt;&lt;PatternApplication&gt;&gt;\\
  | &lt;&lt;SequencePattern&gt;&gt;\\
  | &lt;&lt;QuotedPattern&gt;&gt;
\end{eqnarray*}
.Patterns
[[patternsFig]]
\end{figure}

\paragraph{Patterns and Types}
[[patternType]]
(((patterns,type of)))
Every pattern has a type associated with it. This is the type of values that the pattern is valid to match against. In the type safety productions involving patterns, we use the same meta predicate: $\typeprd{E}{P}{T}$ as for expressions.

== Variables in Patterns
[[patternVariables]]
(((pattern,variable pattern)))
(((variables)))
Variables in patterns are used to bind variables to elements of the input being matched against.

Due to the scope hiding rule -- see &lt;&lt;scopeHiding&gt;&gt; -- it is required that all variables occurring in a pattern are not `already in scope'.

\begin{aside}
A repeated occurrence of a variable in a pattern is equivalent to a call to the `=` predicate. For example, the pattern:
[listing]
(X,Y,X)

is equivalent to the &lt;&lt;GuardedPattern&gt;&gt; (see &lt;&lt;guardPattern&gt;&gt;):
[listing]
(X,Y,X1) where X=X1

The `=` predicate is defined in the standard `equality` contract (see &lt;&lt;equalityPredicates&gt;&gt;); and therefore, the call and the pattern may not be valid if `equality` is not implemented for the type of `X`.
\end{aside}

=== Scope of Pattern Variables
(((variables,scope of)))
A pattern always occurs in the context of a _scope extension_ -- a new potential scope for variables. For example, in the equation:
[listing]
fact(N) is N*fact(N-1)

the pattern on the left hand side of the equation:
[listing]
fact(N)

introduces variables that are in scope on the right hand side of the equation:
[listing]
N*fact(N-1)


The actual scope of a pattern variable depends on the syntactic structure in which the pattern occurs:
\begin{description}
equations::
Pattern variables introduced in the left hand side of an equation are in scope on the right hand side of the equation and in any semantic guards associated with the equation. See &lt;&lt;equations&gt;&gt;.
action procedures::
Pattern variables introduced in the head of an action procedure are in scope in the body of the rule. See &lt;&lt;procedures&gt;&gt;.
`for` loop::
Variables introduced in the pattern of a `for` loop extend to the body of the loop. see &lt;&lt;forLoop&gt;&gt;.
query expressions::
(((query,constraint)))
Variables introduced in the body of a query condition -- see &lt;&lt;conditions&gt;&gt; -- are in scope throughout the body of the query and within the bound expression.
event rule::
Variables that are introduced in event patterns and conditions in event rules -- see &lt;&lt;actorRules&gt;&gt; -- are in scope throughout the event rule; including the body of the event rule.
\end{description}

=== Anonymous Variable Pattern
[[anonymousVariable]]
The special identifier -- `\_` -- is used on those occasions where a filler of some kind is needed. _Every_ occurrence of `\_` refers to a different variable. A match with `\_` is always successful, but the value itself is ignored.

==== Type Safety
The type of a variable pattern is automatically _inferred_ from the expected type for the pattern.

== Scalar Literal Patterns
[[scalarPatterns]]

\begin{figure}[htbp]
\begin{eqnarray*}
[[ScalarPattern]]ScalarPattern::=&lt;&lt;StringLiteral&gt;&gt;\\
  | &lt;&lt;NumericLiteral&gt;&gt;
\end{eqnarray*}
.Scalar Literal Patterns
[[scalarLiteralPtnFig]]
\end{figure}


=== Literal String Patterns
[[literalStringPattern]]
(((string@`string`,pattern)))
(((patterns,literal string)))

A literal string as a pattern matches exactly that string; the type of a string pattern is `string`.

\begin{aside}
The operators that are used to denoted string interpolation expressions (see &lt;&lt;StringInterpolation&gt;&gt;) must _not_ be used in string patterns. In particular, the dollar and hash characters _must_ be quoted in a string pattern.

For example, in the function:
[listing]
hasDollar("has$") is true

the string pattern `"has\$"` is not legal. You should use:
[listing]
hasDollar("has\$") is true


On the other hand, regular expression patterns are treated with special semantics (see &lt;&lt;regularExpressions&gt;&gt;).
\end{aside}

=== Literal Numbers
[[literalNumberPattern]]
(((number pattern)))
(((patterns,literal number)))

A literal number as a pattern matches exactly that number.

The type of the pattern depends on the type of the number literal: `integer` literals have type `integer`, `float` literals have type `float` and so on.


== Regular Expression Patterns
[[regularExpressions]]
(((patterns,regexp)))
(((patterns,string)))
A regular expression denotes a pattern that can potentially match a `string`. Regular expressions are written using a notation that is very close to the standard regexp notation; the regular expression itself is enclosed in backquote characters: ```

For example, a regular expression that matches the common ASCII notion of identifier would be:
[listing]
`[a-zA-Z_][a-zA-Z_0-9]*`


Most of the commonly used regular expression operators are supported -- character classes, star iteration and so on. In addition, there is a smooth integration of variables in regular expressions -- it is possible to mark a sub-expression to be bound to a variable.

(((regular expression,character reference)))
The simplest form of a regular expression is simply a character; which is denoted using a character reference. See &lt;&lt;CharacterReference&gt;&gt;.

=== Character Class
[[characterClass]]
(((regular expression,character class)))
A character class denotes a range of characters that will match the regular expression. Character classes may be designated explicitly -- using the `[a-z]` style notation -- or may refer to one of the standard pre-defined character classes.

\begin{figure}[htbp]
\begin{eqnarray*}
[[CharacterClass]CharacterClass::=`[`[`\uphat`]&lt;&lt;RegChar&gt;&gt;...&lt;&lt;RegChar&gt;&gt;`]]`\\
  | `\bsl``d`|`\bsl``D`\\
  | `\bsl``s`|`\bsl``S`\\
  | `\bsl``w`|`\bsl``W`\\
[[RegChar]RegChar::=&lt;&lt;CharRef&gt;&gt;\ [`-`&lt;&lt;CharRef&gt;&gt;]]
\end{eqnarray*}
.Character Class
[[charClassFig]]
\end{figure}

The standard character classes are listed in &lt;&lt;charClassTable&gt;&gt;.

\begin{table}[htbp]
\centering{
.Standard Character Classes[[charClassTable]]
\vspace{0.5ex}
\begin{tabular}{|c|l|}
\hline
Char Class&amp;Meaning\\
\hline
\tt \bsl{}d&amp;Digit character `[0-9]`\\
\tt \bsl{}D&amp;Non-digit character\\
\tt \bsl{}s&amp;Whitespace character\\
\tt \bsl{}S&amp;Non-whitespace character\\
\tt \bsl{}w&amp;Word character `[a-zA-Z\_0-9]`\\
\tt \bsl{}W&amp;Non-Word character `[\uphat{`a-zA-Z\_0-9]}\\
\hline
\end{tabular}
}
\end{table}
If the first character in a character class is the `\uphat` character, then the sense of the class is inverted: it matches all characters _except_ those mentioned in the remaining characters of the class.
\begin{aside}
In order to have a character class that positively looks for a `\uphat` character, it may either be escaped, as in:
[listing]
[\^]

or the class arranged so that `\uphat` is not the first character:
[listing]
[ab^c]


Analogously, in order to positively specify the `-` character in a character class it should either be escaped:
[listing]
[a\-b]

or put at the beginning of the character class (possibly after a leading `\uphat`):
[listing]
[-ab]

\end{aside}

=== Disjunctive Regular Expressions
[[disjunctiveRegexp]]
(((regular expression,disjunctive)))
Two or more regular expressions separated by the `|` character denote _disjunctive groups_.

Disjunctive groups are enclosed in parentheses.

\begin{figure}[htbp]
\begin{eqnarray*}
[[DisjunctiveGroup]]DisjunctiveGroup::=`(`&lt;&lt;Regex&gt;&gt;\sequence{|}&lt;&lt;Regex&gt;&gt;`)`
\end{eqnarray*}
.Disjunctive Regular Expression
[[regexpDisjunctionFig]]
\end{figure}

=== Regular Expression Cardinality
A regular expression can be optional or repeated a number of times.

\begin{figure}[htbp]
\begin{eqnarray*}
[[Cardinality]]Cardinality::=`?`\ |\ `*`\ |\ `+`
\end{eqnarray*}
.Regular Expression Cardinality
[[regexpCardinalityFig]]
\end{figure}

The cardinality operators always refer to the regular expression immediately to the left of the operator. They control how many times that expression should be matched:
\begin{description}
`?`:: A cardinality of `?` means that the regular expression to the left is optional. For example,
[listing]
`[-+]?`

will match a `-` or `+` character if present.
`*`::
A cardinality of `*` means that the regular expression to the left may be matched zero or more times.

For example, the pattern:
[listing]
`[0-9]*`

will match any number of digit characters. footnote:[ASCII digit characters that is. Unicode contains many other digit characters not matched by this regular expression.] The classic regular for an identifier is:
[listing]
`[a-zA-Z_][a-zA-Z0-9_]*`

meaning a letter followed by any number of letters and digits.

\begin{aside}
This is a so-called `greedy match': the pattern matches as many as possible of the pattern. This makes a difference if the pattern immediately following a star pattern may also match or partially match the starred pattern:
[listing]
`[a-f]*[a-z]*`

\end{aside}
`+`:: The `+` cardinality means that the regular expression to the left must be matched at least once, but can be matched any number of times beyond that.

For example, the definition of an `integer` literal in many programming languages looks like:
[listing]
`[-+]?[0-9]+`

I.e., an optional leading sign, followed by at least one decimal digit character.
\end{description}

=== Variables in Regular Expressions
[[variableRegexp]]
(((regular expression,variables)))
(((variables,in regular expressions)))
A variable in a regular expression is denoted by a colon character followed by the identifier. The entire regular expression is enclosed in parentheses.

\begin{figure}[htbp]
\begin{eqnarray*}
[[Binding]]Binding::=`(`&lt;&lt;Regex&gt;&gt;\ `:`\ &lt;&lt;Identifier&gt;&gt;`)`
\end{eqnarray*}
.Variable Binding
[[ergexpBindingFig]]
\end{figure}

If the match is successful, then the variable is bound to the part of the string that corresponds to the regular expression within the parentheses. The type of the variable is `string`.

For example, to pick out the third character of a `string`, and bind it to the variable `T`, we can use the pattern:
[listing]
`..(.:T).*`

Any arbitrary subexpression can be extracted; for example, the regular expression:
[listing]
`.*(a+:T).*`

looks for the first substring consisting of `a` characters.
\begin{aside}
It is not defined if a variable regular expression is itself repeated, or is part of an optional regular expression. For example, the meaning of:
[listing]
`([a-z]+:I)?`

is undefined (since the variable pattern itself is optional, it is possible to match a string against this pattern without binding the variable `I`).
\end{aside}

== Constructor Patterns
[[tuplePattern]]
(((tuple,pattern)))
(((patterns,tuple)))
A constructor pattern denotes an occurrence of a value that has been declared within an algebraic type definition (see &lt;&lt;algebraicTypeDefinitions&gt;&gt;).

A constructor pattern mimics the form of the constructor definition itself: for a &lt;&lt;TermConstructor&gt;&gt; it consists of an identifier followed by a sequence of patterns, enclosed in parentheses and separated by commas, denoting the arguments to the &lt;&lt;TermConstructor&gt;&gt;.

\begin{figure}[htbp]
\begin{eqnarray*}
[[ConstructorPattern]]ConstructorPattern::=&lt;&lt;TuplePattern&gt;&gt;\\
  | &lt;&lt;RecordPattern&gt;&gt;
\end{eqnarray*}
.Constructor Pattern
[[constructorPtnFig]]
\end{figure}

\begin{aside}
Tuple patterns are the only way that a tuple value may be inspected and elements of it extracted. There are no indexing operators over tuples (whether labeled or not) because it is not possible to give a consistent typing to such operators.
\end{aside}

=== Tuple Patterns
[[posConPattern]]
(((patterns,positional constructor)))
(((positional constructor patterns)))
A tuple pattern consists of a constructor label followed by the argument patterns -- as introduced in the appropriate algebraic type definition.

The special, unlabeled, form of tuple pattern omits the label and refers to the `anonymous' tuple type.

\begin{figure}[htbp]
\begin{eqnarray*}
[[TuplePattern]]TuplePattern::=&lt;&lt;Identifier&gt;&gt;`(`&lt;&lt;Pattern&gt;&gt;\sequence{,}&lt;&lt;Pattern&gt;&gt;`)`\\
  | `(`&lt;&lt;Pattern&gt;&gt;\sequence{,}&lt;&lt;Pattern&gt;&gt;`)`
\end{eqnarray*}
.Tuple Pattern
[[tuplePtnFig]]
\end{figure}

==== Type Safety
Positional constructors must be declared in an algebraic type definition (see &lt;&lt;algebraicTypeDefinitions&gt;&gt;). The required arity and types of the arguments of the positional constructor are determined from that type definition.

==== Anonymous Tuple Patterns
[[anonTuplePattern]]

Anonymous tuple patterns can be used to extract values from tuple values (see &lt;&lt;TupleTerms&gt;&gt;). For example, the pattern `(X,Y)` in the query expression:
[listing]
list of {all X where (X,Y) in R}

matches against the elements of `R` -- assuming that it is a `list` --
(((lists)))
and `binds' the local variables `X` and `Y` to the first and second tuple member of each successive elements of `R`.

\begin{aside}
As noted in &lt;&lt;tupleType&gt;&gt;, anonymous tuples are essentially syntactic sugar for automatically defined algebraic types. The above query is equivalent to:
[listing][escapechar=|]
list of { all X where $2(X,Y)| footnote:[Noting, of course, that `\$2` is not a legal Star identifier.}| in R]


\end{aside}

== Enumerated Symbol Patterns
[[enumPattern]]
(((patterns,enumerated symbol)))
(((enumerated symbol pattern)))

An enumerated symbol -- as a pattern -- matches the same symbol only. Enumerated symbol patterns are technically degenerate forms of tuple patterns; the empty parentheses are simply omitted for syntactic convenience.

\begin{figure}[htbp]
\begin{eqnarray*}
[[EnumeratedSymbolPattern]]EnumeratedSymbolPattern::=&lt;&lt;Identifier&gt;&gt;
\end{eqnarray*}
.Enumerated Symbol Pattern
[[enumSumbolPtn]]
\end{figure}

== Record Patterns
[[aggregateConPattern]]
(((patterns,record constructor)))
(((record constructor pattern)))
A record pattern consists of the record label, followed by attribute patterns enclosed in braces.

Each attribute pattern takes the form:
[listing][escapechar=|]
|&lt;&lt;Identifier&gt;&gt;|=|&lt;&lt;Pattern&gt;&gt;|

where _Pattern_ is a pattern that the &lt;&lt;Identifier&gt;&gt; attribute must satisfy.

Unlike positional constructor patterns, it is not required for all of the attributes to be mentioned in a record constructor pattern. At its limit, a pattern of the form:
[listing]
label{}

becomes a test that the `label` record literal is present -- with no constraints on the attributes of the record.

\begin{figure}[htbp]
\begin{eqnarray*}
[[RecordPattern]]RecordPattern::=&lt;&lt;Identifier&gt;&gt;`\{`&lt;&lt;AttributePattern&gt;&gt;\sequence{;}&lt;&lt;AttributePattern&gt;&gt;`\`}\\
  | &lt;&lt;AnonymousRecordPattern&gt;&gt;\\
[[AttributePattern]]AttributePattern::=&lt;&lt;Identifier&gt;&gt;\ `=`\ &lt;&lt;Pattern&gt;&gt;
\end{eqnarray*}
.Record Patterns
[[aggregateConPtnFig]]
\end{figure}

==== Type Safety
A record constructor pattern is type consist if the record has been declared, and if each of the fields in the pattern have been declared to be part of the record -- and the corresponding patterns are type consistent.

=== Anonymous Record Patterns
[[anonAggPtn]]
(((matching anonymous records)))
(((pattern,anonymous record)))
(((anonymous record pattern)))
An anonymous record pattern is written in an analogous form to the regular record pattern, except that there is no label prefixed to it.
\begin{figure}[htbp]
\begin{eqnarray*}
[[AnonymousRecordPattern]]AnonymousRecordPattern::=`\{`&lt;&lt;AttributePattern&gt;&gt;\sequence{;}&lt;&lt;AttributePattern&gt;&gt;`\`}
\end{eqnarray*}
.Anonymous Record Patterns
[[anonAggregateConPtnFig]]
\end{figure}

\noindent
For example,
[listing]
{name=N;address=A} in R

uses an anonymous record pattern to match elements of the list `R`.

\begin{aside}
Unlike with most other patterns, the type checker is generally _not_ able to reliably infer the type of an anonymous record pattern. As a result, it must _always_ be the case that the anonymous record pattern occurs in a context where the type may be inferred. In the above example, the type of the anonymous record pattern:
[listing]
{name=N;address=A}

can be inferred from the context it occurs in, and the type of `R`. However, if `R`'s type is not already known by other means, then a syntax error will result.

\begin{aside}
The reason for this is that, like other record patterns, an anonymous record pattern need not contain an element for every attribute defined.
\end{aside}
\end{aside}


== Guarded Patterns
[[guardPattern]]
(((patterns,guarded)))
(((guarded patterns)))

A guarded pattern attaches a semantic condition on a pattern. It consists of a pattern, followed by the `where` keyword and a predication condition -- all enclosed in parentheses.

Guarded patterns are useful in enhancing the specificity of patterns -- which apart from guarded patterns are purely syntactic in nature.

\begin{figure}[htbp]
\begin{eqnarray*}
[[GuardedPattern]]GuardedPattern::=`(`&lt;&lt;Pattern&gt;&gt;\ `where`\ &lt;&lt;Condition&gt;&gt;\ )
\end{eqnarray*}
.Guarded Patterns
[[guardPtnFig]]
\end{figure}

==== Type Safety
A guarded pattern has a type assignment based on the type of the left hand side, and the type safety of the condition.

\begin{prooftree}
\AxiomC{\typeprd{E}{P}{T}}
\AxiomC{\typesafe{E}{_C_}}
\BinaryInfC{\typeprd{E}{P\ `where`\ C}{T}}
\end{prooftree}

The type safety of conditions is covered in more detail in &lt;&lt;conditions&gt;&gt;.

== Matching Pattern
[[matchingPattern]]
(((patterns,matching)))
(((matching patterns)))

The `matching` pattern allows the same input to be matched against two patterns. This is typically used to combine a variable assignment pattern with a structured pattern.

\begin{figure}[htbp]
\begin{eqnarray*}
[[MatchingPattern]]MatchingPattern::=`(`&lt;&lt;Pattern&gt;&gt;\ `matching`\ &lt;&lt;Pattern&gt;&gt;\ )
\end{eqnarray*}
.Matching Patterns
[[matchingPtnFig]]
\end{figure}

==== Type Safety
The two patterns in a `matching` pattern are used to match the same input -- hence they must be of the same type.
== Type Annotated Pattern
[[typeAnnotatedPattern]]
(((patterns,type annotated)))
(((type annotation,pattern)))
(((cast@`cast`,pattern)))

A type annotated pattern is a form of semantic pattern where the type of the pattern is explicitly annotated.

\begin{figure}[htbp]
\begin{eqnarray*}
[[TypeAnnotatedPattern]]TypeAnnotatedPattern::=`(`&lt;&lt;Pattern&gt;&gt;\ `has type`\ &lt;&lt;Type&gt;&gt;`)`
\end{eqnarray*}
.Type Annotated Pattern
[[typeAnnotatedPtnFig]]
\end{figure}

A pattern of the form:
[listing][escapechar=|]
(|&lt;&lt;Pattern&gt;&gt;| has type |&lt;&lt;Type&gt;&gt;|)

implies that &lt;&lt;Pattern&gt;&gt; has type &lt;&lt;Type&gt;&gt;.

\begin{aside}
One important role for &lt;&lt;TypeAnnotatedPattern&gt;&gt;s is to explicitly declare the type of a pattern variable footnote:[Recall that all variable declarations take the form of a pattern.] This specifically permits a variable to be given a higher-ranked type. For example, in:
[listing]
fn poly((F has type for all t such that (t)=&gt;t)) is
      (F(1),F("alpha"))

would not be well typed without the explicit type annotation on the argument `F` because type inference cannot infer polymorphic types.
\end{aside}
\begin{aside}
The parentheses are necessary for this form of pattern because of the relative priority of `has type` operator which is higher than is usually permitted in the context of patterns.
\end{aside}

==== Type Safety
The type of a type annotated pattern is implicitly determined by the expected type of the pattern. The type of the embedded pattern is set by the type cast itself.

\begin{prooftree}
\AxiomC{\typeprd{E}{P}{T\sub{P}}}
\AxiomC{\entail{E,\theta}{T\sub{P}\equivt{} T}}
\BinaryInfC{\typeprd{E}{P` has type `T}{T}}
\end{prooftree}

This rule states that the type of a type annotated pattern is its annotated type.

== Pattern Abstraction Application
[[patternApplication]]
(((patterns,application)))
(((pattern abstraction application)))

A pattern abstraction application is a pattern where a &lt;&lt;PatternAbstraction&gt;&gt; is being applied.

\begin{figure}[htbp]
\begin{eqnarray*}
[[PatternApplication]]PatternApplication::=&lt;&lt;Expression&gt;&gt;`(`&lt;&lt;Pattern&gt;&gt;\sequence{,}&lt;&lt;Pattern&gt;&gt;`)`
\end{eqnarray*}
.Pattern Application Pattern
[[patternApplicationFig]]
\end{figure}

A pattern of the form:
[listing][escapechar=|]
|_PtnAb_|(|_Ptn\sub1_\sequence{,}_Ptn\subn_|)

denotes the application of a pattern abstraction -- identified by `_PtnAb_` -- to the argument patterns `_Ptn\subi_`

\begin{aside}
The applied pattern abstraction is denoted by _Expression_ in &lt;&lt;patternApplicationFig&gt;&gt;. If the pattern application is in the head of a rule -- such as an equation -- then the pattern abstraction must be a _Variable_: in fact a _free variable_ of the rule.
\end{aside}

\begin{aside}
It is possible for a pattern abstraction to `return' computed values; i.e., values that are not directly in the original data being matched. For example, the pattern abstraction:
[listing]
ptn parent(P) from C where (P,C) in children;

will match anyone that is known to have a parent -- in the `children` collection -- and will return the parent of the child. A match using this:
[listing]
"john" matches parent(PJ)

will result in the variable `PJ` being bound to `"john"`'s parent -- if it is known. Only one of `"john"`'s parents will be found, however.
\end{aside}

The type signature for a pattern abstraction is of the form:
[listing][escapechar=|]
(t|\sub1\sequence{,}|t|\subn|) &lt;= t

where the `t\subi` are return values from the match and `t` is the type of the value being matched.

Where a pattern application is part of a larger pattern the match type refers to a single value being matched. However, in the case of the `matches` condition, it is possible to match against multiple values:
[listing][escapechar=|]
(E|\sub1\sequence{,}|E|\sub{m}|) matches P(V|\sub1\sequence{,}|V|\subn|)

In this case, the type of the pattern abstract `P` would be of the form:
[listing][escapechar=|]
(Vt|\sub1\sequence{,}|Vt|\subn|) &lt;= (Et|\sub1\sequence{,}|Et|\sub{m}|)



==== Type Safety
The type of a application pattern is determined by the type of the applied pattern abstraction.

\begin{prooftree}
\AxiomC{\typeprd{E}{`P`}{`(`t\sub1,...,t\subn`)&lt;=`T}}
\AxiomC{\typeprd{E}{P\sub1}{t\sub1}\sequence{\quad}\typeprd{E}{P\subn}{t\subn}}
\BinaryInfC{\typeprd{E}{`P(P\sub1`\sequence{,}`P\subn)`}{T}}
\end{prooftree}

\begin{aside}
Pattern abstraction applications are also important in the `abstract data type' pattern. In that pattern, a contract is used to define one or more pattern abstractions and programs using that contract are, in effect, shielded from knowing the concrete types involved.
\end{aside}


== Sequence Patterns
[[sequencePattern]]
(((sequence,patterns)))
(((patterns,sequence)))
(((of@`of`,pattern)))

A sequence pattern represents a use of the standard `sequence` contract to match sequences of values.

\begin{figure}[htbp]
\begin{eqnarray*}
[[SequencePattern]SequencePattern::=&lt;&lt;SequenceType&gt;&gt;\ `of``[`&lt;&lt;PtnSequence&gt;&gt;`]` \ |\ `[`&lt;&lt;PtnSequence&gt;&gt;`]]`\\
[[PtnSequence]PtnSequence::=[&lt;&lt;Pattern&gt;&gt;`..,`]&lt;&lt;Pattern&gt;&gt;\sequence{,}&lt;&lt;Pattern&gt;&gt;[`,..`&lt;&lt;Pattern&gt;&gt;]]
\end{eqnarray*}
.Sequence Pattern
[[sequencePatternFig]]
\end{figure}

Like &lt;&lt;SequenceExp&gt;&gt;s, a &lt;&lt;sequencePattern&gt;&gt; is syntactic sugar for terms involving the `sequence` contract -- which is defined in Program~\vref{sequenceContractDef}.

A pattern of the form:
[listing][escapechar=|]
|_Label_| of [|_Ptn\sub1_\sequence{,}_Ptn\subn_|]

is equivalent to the pattern:
[listing][escapechar=|]
_pair(|_Ptn\sub1_|, |...|, _pair(|_Ptn\subn_|,_empty())|...|) has type |_Label_| of %_

_provided that \emph{Label_ is the label of a type that implements the `sequence` contract}. Included in that contract are two pattern abstractions -- denoting the empty sequence (`\_empty()`) and a non-empty sequence (`\_pair()`).


==== Type Safety
Since a sequence pattern is essentially a macro for the use of the `sequence` contract, its type safety is determined by the `sequence` contract.

== Quoted Syntax Patterns
[[quotedPatterns]]

Analogously to quoted expressions -- see &lt;&lt;quotedText&gt;&gt; -- a quoted syntactic form may be used as a pattern.

\begin{figure}[htbp]
\begin{eqnarray*}
[[QuotedPattern]]QuotedPattern::=`quote(`&lt;&lt;Pattern&gt;&gt;`)`\\
  | `&lt;|`&lt;&lt;Pattern&gt;&gt;`|&gt;`
\end{eqnarray*}
.Quoted Patterns
[[quotedPtnFig]]
\end{figure}

A pattern of the form:
`&lt;| _SyntacticForm_ |&gt;`
denotes a pattern of type `quoted` footnote:[The `quoted` type is defined in Program~\vref{quotedProg}.] where the input must match `_SyntacticForm_`.

As with quoted expressions, it is possible to put a `hole' in a quoted pattern by using the `unquote` or `?` forms. For example, the pattern:
[listing]
&lt;| ?A * 45 |&gt;

will match with a quoted form such as:
[listing]
(Alpha+Beta)*45

by binding the unquoted variable `A` with the equivalent of:
[listing]
&lt;| (Alpha+Beta) |&gt;

\begin{aside}
The parentheses used in the original expression remain explicit in the quoted form. This pattern is equivalent to the pattern:
[listing]
applyAst(_, nameAst(_, "\$1"), array of [
  applyAst(_, nameAst(_, "+"),
    array of [nameAst(_,"Alpha"), nameAst(_,"Beta")])
  ])

\begin{aside}
The location of the abstract syntax tree terms is _not_ matched in a quoted pattern. This is denoted by the use of anonymous variables in the location argument.
\end{aside}
\begin{aside}
Anonymous tuples have as their label a name of the form `"\$_arity_"` where _arity_ is the number of elements in the anonymous tuple.
\end{aside}
\end{aside}
The type of the variable `A` must also be `quoted`.
</Text>
        </Document>
        <Document ID="7986CAA2-C501-49C0-B596-AAB52C3D488D">
            <Title>Constructor Type</Title>
            <Text>A constructor is a special function that is introduced in an AlgebraicType definition.
[NOTE] Constructors are special because they can be viewed simultaneously as a function and as a pattern. Hence the form of the constructor reflects that bidirectionality.
ConstructorType::=Type &lt;=&gt; Type
Constructor Type
The left hand side of a constructor type should either be a TupleType or an RecordType -- depending on whether the denoted constructor is a term constructor constructor or a record constructor.
[TIP] ConstructorTypes are most used in the context of the signatures of abstract data types: where a type and its constructors are exported from a record.</Text>
        </Document>
        <Document ID="A1FD8299-D19C-4516-A8E1-8CA6057232AB">
            <Title>Meta Grammar</Title>
            <Text>
MetaGrammar ::= Production .. Production
Production ::= NonTerminal ::=  Body
Production ::+= NonTerminal ::+= Body
Body ::= Quoted | NonTerminal | Choice | Optional | Sequence | ( Body )
Quoted ::= Characters
NonTerminal ::= Identifier
Choice ::= Body |..| Body
Optional ::= [ Body ]
Sequence ::= Body  op .. op Body [+]
Meta-Grammar Used in this Reference
Some grammar combinations are worth explaining as they occur quite frequently and may not be standard in BNF-style grammars. For example the rules for Action contain:
Action ::= { Action ; .. ; Action }
This grammar rule defines an Action as a possibly empty sequence of Actions separated by semi-colons and enclosed in braces -- i.e., the classic definition of a block.
Decimal ::= Digit .. Digit+
denotes a definition in which there must be at least one occurrence of a Digit; in this case there is also no separator between the Digits.
Occasionally, where a non-terminal is not conveniently captured in a single production, later sections will add to the definition of the non-terminal. This is signaled with a ::+= production, as in:
Expression ::+= ListLiteral
which signals that, in addition to previously defined expressions, a ListLiteral is also an Expression.
Finally, we distinguish elements of the meta grammar from the language itself by using the typewriter font when quoting actual fragments of Star syntax. Admittedly, this can be hard to see at times.</Text>
        </Document>
        <Document ID="07B0D7C6-57CE-4D6F-8AD9-11F06A261A5F">
            <Title>Notes</Title>
        </Document>
        <Document ID="0460A2A6-AC1C-4A3F-9672-4C966E32F663">
            <Title>Reference Type</Title>
            <Text>A re-assignable variable is given a reference type.
ReferenceType ::= ref Type
Reference Type
Reference types allow the programmer to distinguish re-assignable variables from other values; in particular they allow one to distinguish between binding to the value of a re-assignable variable or to its name.
[NOTE] The latter is not as common, but is important to support abstractions involving re-assignable variables.
</Text>
        </Document>
        <Document ID="F425A823-CCE9-4D00-93A4-51A45EB5CC57">
            <Title>Expressions-43</Title>
            <Text>
==== The `current' location
[[locationVar]]
(((Accessing source locations)))

The standard keyword `\_\_location\_\_` denotes the source location of each of its occurrences. It is a pseudo-variable: it has a type and value; but its value is based on the text of the program that it is embedded in:
[listing]
__location__ has type astLocation;

\begin{aside}
The related expression -- `\hash{`\_\_location\_\_} -- is used within macro rules to denote the location the term that is reduced by a given macro rule.
\end{aside}

== Typed Expressions
[[typeExpression]]
(((expressions,type)))
(((type expressions)))
A type annotation expression is an explicit declaration of the type of an expression. A type coercion expression denotes a conversion of a value so that it conforms to a particular type.

\begin{figure}[htbp]
\begin{eqnarray*}
[[TypedExpression]]TypedExpression::=&lt;&lt;TypeCoercion&gt;&gt;\\
%  | &lt;&lt;TypeCastExpression&gt;&gt;\\
  | &lt;&lt;TypeAnnotationExpression&gt;&gt;
\end{eqnarray*}
.Type Expression
[[typedExpressionFig]]
\end{figure}</Text>
        </Document>
        <Document ID="DE5D2A2E-2B77-4D40-ADC9-4DF4E4A94C4C">
            <Title>Time and Date</Title>
            <Text>%!TEX root = reference.tex
\chapter{Date and Time}
\label{dateAndTime}

\section{The `date` Type}
Date and time support revolves around the `date` built-in type. The type definition for `date` is straightforward:

[listing]
type date is date(\_long) or never


\begin{aside}
The `\_long` argument to the constructor is a so-called `raw value', not to be confused with the `long` built-in type (see &lt;&lt;longType&gt;&gt;). The `\_long` value is the number of milliseconds since Jan 1, 1970.

Under normal circumstances, programmers will never see the contents of the `date` constructor.
\end{aside}

The `never` enumerated symbol denotes a nonexistent date.

There are standard implementations of the `pPrint` (see &lt;&lt;pPrintContract&gt;&gt;) and `coercion` {see &lt;&lt;typeCoercionExpression&gt;&gt;) contracts for the `date` type. Thus, it is possible to parse a `string` as a `date` using an expression:
[listing]
S as date

In particular, `coercion` is implemented to support conversion between `date`$\leftrightarrow$`string` and `date`$\leftrightarrow$`long`.

\section{Date Functions}

\subsection{`now` -- Current Time}
\index{current time}
\label{nowFun}
Report the current time.
[listing]
now has type ()=&gt;date;


Reports the current system time as a `date`.

\subsection{`today` -- Time at Midnight}

[listing]
today has type ()=&gt;date;


Reports the time at midnight this morning as a `date`.

\subsection{`smallest` -- the earliest legal point in time}
\label{smallestDate}
\index{date@`date`!first date}
The `smallest` `date` is the first legal point in time. It corresponds to midnight Jan 1, 1970.
[listing]
smallest has type date

`smallest` is part of the `largeSmall` contract -- see Program~\vref{largeSmallProg}.

\subsection{`largest` -- the last legal point in time}
\label{largestDate}
\index{date@`date`!last date}

[listing]
largest has type date

`largest` is part of the `largeSmall` contract -- see Program~\vref{largeSmallProg}.

The `largest` `date` is the last legal `date` value. It corresponds to August 16, 292278994 11:12:55 PM PST.


\subsection{`\_format` -- Format a `date` as a `string`}
\label{formatDate}
\index{date!formatting}
\index{formatting a date string}
\index{convert to a date string}

[listing]
\_format has type (date,string)=&gt;pP;


\begin{aside}
`\_format` is part of the `formatting` contract -- see Program~\vref{formatContractProg}.
\end{aside}

The `\_format` function computes a readable string representation of a `date` as a string displaying the date and/or time. The second argument is a format string that guides how to format the string.

The format string consists of letters, spaces and other characters; the letters control the representation of some aspect of the date, other non-letter characters are displayed as is in the result. &lt;&lt;tableFormatTbl&gt;&gt; contains the definitions of the available formatting characters.

\begin{table}[h]
\begin{center}
.Date Formatting Control Letters\label{tableFormatTbl}
\begin{tabular}{|llll|}
\hline
Letter&amp;Date Component&amp;Presentation&amp;Examples\\
\hline
\tt G&amp;Era designator&amp;Text&amp;\tt AD\\
\tt y&amp;Year&amp;Year&amp;\tt 1999; 01\\
\tt M&amp;Month in year&amp;Month&amp;\tt July; Jul; 07\\
\tt w&amp;Week in year&amp;Number&amp;\tt 25\\
\tt W&amp;Week in month&amp;Number&amp;\tt 2\\
\tt D&amp;Day in year&amp;Number&amp;\tt 191\\
\tt d&amp;Day in month&amp;Number&amp;\tt 2\\
\tt F&amp;Day of week in month&amp;Number&amp;\tt 1\\
\tt E&amp;Day in week&amp;Text&amp;\tt Tuesday; Tue\\
\tt a&amp;AM/PM&amp;Text&amp;\tt PM\\
\tt H&amp;Hour in day (0-23)&amp;Number&amp;\tt 0\\
\tt k&amp;Hour in day (1-24)&amp;Number&amp;\tt 24\\
\tt h&amp;Hour in day (1-12)&amp;Number&amp;\tt 11\\
\tt m&amp;Minute in hour&amp;Number&amp;\tt 34\\
\tt s&amp;Second in minute&amp;Number&amp;\tt 56\\
\tt S&amp;Millisecond in second&amp;Number&amp;\tt 543\\
\tt z&amp;General time zone&amp;Text&amp;\tt PDT; GMT-08:00\\
\tt Z&amp;RFC 822 time zone&amp;Text&amp;\tt -0800\\
\hline
\end{tabular}
\end{center}
\end{table}

The `\_format` function may be invoked implicitly in a string &lt;&lt;Interpolation&gt;&gt; expression. For example, the expression:
[listing]
"\$(now()):dd-MMM-yyyy hh:mm:ss;"

is equivalent to the expression:
[listing]
\_format(now(),"dd-MMM-yyyy hh:mm:ss")

\begin{aside}
This makes more of a difference when combined with other formatting and displaying, as in:
[listing]
logMsg(info,"Balance on \$(today()):dd-MMM-yy; is \euro\$Amnt:9,999.00;");

which will result in a line of the form:
[listing]
Balance on 24-Mar-13 is \euro{}23.56

being displayed.
\end{aside}

==== Repeated Date Formatting Control Characters
The repeated pattern control characters sometimes change their meaning when repeated:
\begin{description}
Text:: If the control character is repeated 4 or more times then the _long_ form of display is used when appropriate. Otherwise a short form is used.
Year:: If the control character is repeated 2 times -- i.e., if `yy` is used as the year format -- then the year is truncated to two digits. Otherwise, the year is printed in full.
Month:: If the `M` control is repeated 3 or more times then the text name of the month is used; (full name for 4 or more repetitions, short name for 3 repetitions). Otherwise, a numeric number is displayed.
Number:: The numeric value is displayed, with zero padding to ensure at least as many digits as format control characters.
\end{description}

\subsection{`parse\_date` -- Parse a `string` as a `date`}
\label{parseDate}
\index{date!formatting}
\index{parse a date string}

[listing]
parse\_date has type (string,string)=&gt;date;


The `parse\_date` function parses a `string` into a `date` value. The first argument is the `string` to parse, the second is a format control string used to guide the parsing of the date. The form of the format control string is the same as for `format\_date` (see &lt;&lt;formatDate&gt;&gt;).

If the string cannot be parsed as a valid date using the control string, then the value returned is `never`.


\subsection{`timeDiff` -- Compute difference between two `date`s}
\label{timeDiff}
\index{date!difference between two dates}

[listing]
timeDiff has type (date,date)=&gt;long


The `timeDiff` function `subtracts' one `date` from another returning the difference as a number of milliseconds.

\subsection{`timeDelta` -- Apply a delta to a `date`}
\label{timeDelta}
\index{date!add delta to a date}

[listing]
timeDelta has type (date,long)=&gt;date

The `timeDelta` function adds an increment to a `date` -- expressed as a number of milliseconds -- and returns a new `date`.
\begin{aside}
The increment may be negative; for example, to compute yesterday's `date`, the following expression suffices:
[listing]
timeDelta(today(),-86400000L)

\end{aside}
</Text>
        </Document>
        <Document ID="B6CACC34-5FA6-4174-8F43-AA32312CDE8A">
            <Title>Expressions-32</Title>
            <Text>
=== Conditional Expressions
[[conditionalExpression]]
(((expressions,conditional)))
(((conditional expression)))

A conditional expression applies a predicate &lt;&lt;Condition&gt;&gt; to decide whether or not to `take' the `then' branch or the `else' branch.

\begin{figure}[htbp]
\begin{eqnarray*}
[[ConditionalExpression]]ConditionalExpression::=`(`&lt;&lt;Condition&gt;&gt;`?`&lt;&lt;Expression&gt;&gt;`:`&lt;&lt;Expression&gt;&gt;`)`
\end{eqnarray*}
.Conditional Expression
[[conditionalExpressionFig]]
\end{figure}

The value of a conditional expression depends on whether the &lt;&lt;Condition&gt;&gt; is satisfiable or not. If the &lt;&lt;Condition&gt;&gt; is satisfiable, then the expression is equivalent to the `then' branch of the conditional expression; otherwise it is equivalent to the `else' branch.

For example, the expression:
[listing]
(P in members ? X&gt;Y : X&lt;Y)

is equivalent to one of `X&gt;Y` or `X&lt;Y` depending on whether the &lt;&lt;Condition&gt;&gt;:
[listing]
P in members

is satisfiable -- i.e., has at least one solution.

The condition of a conditional expression may introduce variables, depending on the form of the condition -- for example, if the &lt;&lt;Condition&gt;&gt; is a &lt;&lt;SearchCondition&gt;&gt; condition like that above. These variables are `in scope' within the `then' part of the conditional expression but are _not_ in scope for the `else' part.

\paragraph{Evaluation Order}
The only guarantees as to evaluation of a conditional expression are that
\begin{enumerate}
\item the conditional will be evaluated prior to evaluating either arm of the conditional
\item only one of the arms will be evaluated -- depending on the value of the condition.
\end{enumerate}</Text>
        </Document>
        <Document ID="B9EBCF0B-40AB-49B4-A88C-DEC6F096EF08">
            <Title>Forced Operator Declaration</Title>
            <Text>Normally, any attempt to re-declare an operator will result in a syntax error being raised. However, there may be situations where it is important to be able to change an existing operator declaration.
[TIP] Note that a given identifier may be defined as a prefix operator, an infix operator and a postfix operator. Each of these are treated separately.
The force directive is used in this situation:
#force(infix(‘as’,200)).
has the effect of changing the existing operator priority of the as operator as an infix operator to 200 -- whatever its previous priority was.</Text>
        </Document>
        <Document ID="1E599970-3394-4F07-8A74-42E450183233">
            <Title>Record Type</Title>
            <Text>A RecordType is a type expression that denotes a named association of fields and types. A record type is written as a sequence of type annotations enclosed in braces.
RecordType ::=  {Annotation ; .. ;Annotation }
TypeEquality ::= type Identifier = Type
Record Type
Record types are used as the type of anonymous records (see &lt;&lt;anonRecord&gt;&gt;). They are also the basis of other features of the type language -- including the ConstructorType and Contracts.
Two record types are equivalent if their elements are pair-wise equivalent. Note that the order of elements is not important. For example, given the types:
{a:string . b:integer }
and
{b:integer . a:t }
these types unify -- assuming that t is a bound type variable, provided that t is unifiable with string.
[NOTE] All user-defined types -- i.e., types defined by an AlgebraicType definition -- have a RecordType interface associated with them. This, as is detailed in &lt;&lt;algebraicInterface&gt;&gt;, defines a type for all of the fields in any of the constructors for the type. In turn, this permits a RecordAccess expression to apply to a user-defined type as well as a RecordType.</Text>
        </Document>
        <Document ID="0133ABB9-B885-4F8D-8A9B-59E5B0B2159D">
            <Title>Standard Operators</Title>
            <Text>A key input to the grammar is the table of operators. Star starts with a number of standard operators, but this can be extended via the use of extensions to the language.
The standard operators that are part of the core language and the base extensions are listed below. Operators in this table are listed in order of priority. Together with a priority, operators can also be considered to prefix, infix, postfix, or some combination of the three.
The priority of an operator is the indication of the importance of the operator: the higher the priority the nearer the top of the abstract syntax tree the corresponding structure will be.
Priorities are numbers in the range 1..2000; by convention, priorities in the range 1..899 refer to entities that normally take the role of expressions, priorities in the range 900..1000 refer to predicates and predicate-level connectives and priorities in the range 1001..2000 refer to entries that have a statement or program level interpretation.
`#right(";",2000)` |
`#postfix(";",2000)` |
`\#prefix("#",1350)` |
`#infix(":-",1347)` |
`#infix("--&gt;",1347)` |
`#infix("==&gt;",1347)` |
`#right(":\|",1345)` |
`#right(":",1344)` |
`#prefix(":!",1343)` |
`\#infix("##",1342)` |
`#infix("::",1341)` |
`#infix("\|*",1340)` |
`#infix(":*",1340)` |
`#infix(":+",1340)` |
`#infix(";*",1340)` |
`#prefix("private",1320)` |
`#prefix("java",1300)` |
`#prefix("var",1300)` |
`#prefix("contract",1300)` |
`#prefix("open",1300)` |
`#prefix("on",1300)` |
`#prefix("implementation",1300)` |
`#prefix("case",1290)` |
`#right("\|",1290)` |
`#prefix("type",1250)` |
`#infix("counts as",1200)` |
`#right("else",1200)` |
`#infix("is",1200)` |
`#right("do",1200)` |
`#prefix("remove",1200)` |
`#infix("then",1180)` |
`#prefix("if",1175)` |
`#prefix("while",1175)` |
`#prefix("for",1175)` |
`#infix("to",1130)` |
`#infix("from",1130)` |
`#infix(":=",1120)` |
`#prefix("perform",1120)` |
`#prefix("merge",1100)` |
`#prefix("extend",1100)` |
`#prefix("notify",1100)` |
`#postfix("default",1100)` |
`#prefix("assert",1100)` |
`#prefix("valis",1100)` |
`#prefix("try",1100)` |
`#prefix("update",1100)` |
`#prefix("delete",1100)` |
`#prefix("ignore",1100)` |
`#infix("//",1100)` |
`#infix(",..",1099)` |
`#infix("..,",1098)` |
`#infix("catch",1050)` |
`#prefix("request",1050)` |
`#infix("with",1050)` |
`#prefix("switch",1020)` |
`#infix("has type",1020)` |
`#right("such that",1010)` |
`#assoc("exists",1005)` |
`#assoc("for all",1005)` |
`#right(",",1000)` |
`#infix("default",1000)` |
`#prefix("raise",1000)` |
`#prefix("query",1000)` |
`#prefix("import",1000)` |
`#prefix("memo",999)` |
`#prefix("without",999)` |
`#infix("computation",999)` |
`#infix("./",999)` |
`#prefix("with",999)` |
`#right(":",960)` |
`#postfix(":",960)` |
`#left("group by",960)` |
`#prefix("when",950)` |
`#right("?",950)` |
`#right("~",950)` |
`#infix("order descending by",950)` |
`#prefix("waitfor",950)` |
`#prefix("spawn",950)` |
`#infix("order by",950)` |
`#infix("descending by",950)` |
`#infix("where",940)` |
`#prefix("any of",935)` |
`#prefix("all",935)` |
`#right("otherwise",930)` |
`#right("or",930)` |
`#right("implies",920)` |
`#right("and",920)` |
`#right("=&gt;",910)` |
`#right("$=&gt;",910)` |
`#prefix("not",910)` |
`#right("&lt;=&gt;",910)` |
`#prefix("let",909)` |
`#left("using",908)` |
`#infix("in",908)` |
`#right("or else",900)` |
`#infix("matches",900)` |
`#infix("!=",900)` |
`#infix("&lt;",900)` |
`#infix("=",900)` |
`#infix("&gt;",900)` |
`#infix("substitute",900)` |
`#infix("&lt;=",900)` |
`#prefix("ref",900)` |
`#infix("=&lt;",900)` |
`#prefix("kind",900)` |
`#postfix("is tuple",900)` |
`#infix("-&gt;",900)` |
`#infix("has kind",900)` |
`#infix("bound to",900)` |
`#infix("has value",900)` |
`#infix("&gt;=",900)` |
`#right("implements",900)` |
`#infix("on",900)` |
`#right("over",900)` |
`#infix("instance of",900)` |
`#infix("determines",895)` |
`#right("++",850)` |
`#right("of",840)` |
`#prefix("reduction",830)` |
`#infix("matching",800)` |
`#left("+",720)` |
`#left("-",720)` |
`#left("%",700)` |
`#left("*",700)` |
`#left("/",700)` |
`#infix("**",650)` |
`#prefix("valof",500)` |
`#infix("on abort",475)` |
`#infix("as",420)` |
`#prefix("unique",400)` |
`#infix("@@",200)` |
`#infix("@",200)` |
`\#infix("#@",200)` |
`#left(".",175)` |
`#left("?.",175)` |
`#prefix("!",150)` |
`#prefix("+",100)` |
`#prefix("-",100)` |
`#prefix("$",75)` |
`#prefix("%",75)` |
`#prefix("?",75)` |
`#prefix("%%",75)` |
`\#prefix("#$",50)` |
`\#prefix("#*",50)` |
`\#right("#+",50)` |
`\#prefix("#:",50)` |
`#prefix("$$",50)` |
`#right("$$",50)` |
`\#prefix("#~",50)` |
Standard Operators</Text>
        </Document>
        <Document ID="833DF1C1-C636-4034-9053-01C6641E9578">
            <Title>Contents</Title>
        </Document>
        <Document ID="B2C42D9B-7456-419A-94B5-452AA5BB3277">
            <Title>Variables (In Expressions)</Title>
            <Text>A variable as an expression is simply an occurrence of the variable's identifier.</Text>
        </Document>
        <Document ID="51B6803A-C207-4D58-8154-611CAAC6A4CE">
            <Title>System Functions</Title>
            <Text>%!TEX root = reference.tex
= System Functions
[[systemFunctions]]

== Time Functions
[[timeFunctions]]
(((time functions)))

=== `nanos` -- Time since start
[listing]
nanos has type ()=&gt;long


The `nanos` function returns the number of nanoseconds since the application started.
\begin{aside}
Note that the returned time may not actually be accurate to the nearest nanosecond. The precise accuracy depends on the accuracy of the clock available to the operating system.
\end{aside}
\begin{aside}
For long running applications, the `nanos` clock may `roll-over' after approximately 290 years.
\end{aside}


=== `sleep` -- Sleep for a period of time

[listing]
sleep has type (long)=&gt;()

The `sleep` action procedure causes the current activity to suspend for a specified number of milliseconds.
\begin{aside}
Other activities, in particular other `actor` activities will continue while this activity is suspended.
\end{aside}

== Logging
An application may log output to standard logging facilities using the `logMsg` action procedure.

=== `level` -- type
(((level type@`level` type)))
[[levelType]]

The `level` type defines a set of logging levels that may be used to indicate the severity of the logged message.
[listing]
type level is finest
  or finer
  or fine
  or config
  or info
  or warning
  or severe;


The different logging levels have an intended interpretation designed to facilitate users of applications manage the type and quantity of logging flow:
\begin{description}
finest:: is used for very fine grained logging, typically insDebugging.
finer:: is used for fine grained logging.
fine:: is used for reporting of internally significant events within an application.
config:: is used to report application configuration events.
info:: is used to report important application events.
warning:: is used to report a recoverable error condition.
severe:: is used to report an unrecoverable error.
\end{description}

=== `logMsg` -- log an event
[[logMsg]]
[listing]
logMsg has type (level,string)=&gt;()


`logMsg` is similar to `logger`, except that the category is fixed to `com.starview.starrules`.

For example, to log an `info` level message one can use
[listing]
logMsg(info,"You need a tune-up")


== Shell Commands
[[shellCommand]]

The `exec` function allows a Star program to execute other processes and to access the return code from the sub-process.

=== `exec` -- Execute Sub-Process
[[exec]]
(((exec@`exec`,sub-process)))
(((sub-process execution)))

The `exec` function executes a sub-process and returns the integer return code from running the command.

[listing]
exec has type (string,dictionary of (string,string))=&gt;integer;


The first argument is the command line to execute. The format of this, and the valid commands to execute, is system dependent.

The second argument is a `dictionary` of environment variables and their values. If the dictionary is empty then the environment variables of the current program are inherited by the sub-process.

The return value from executing the command is returned by `exec`. By convention, a return value of zero means that the command succeeded.

\begin{aside}
The `exec`'ed command is executed to completion _before_ the `exec` call returns. If it is desired to execute a sub-process asynchronously then use the `spawn` action:
[listing]
spawn\{ exec("ls -l", dictionary of \{\}) \}

\end{aside}


=== `getenv` -- Get Environment Variable
[[getenv]]
(((environment variable)))
(((getenv@`getenv`,environment variable)))

[listing]
getenv has type (string,string)=&gt;string


Get the value of an environment variable. The first argument is the name of the variable, the second is a default value should the variable not exist.

=== `exit` -- Terminate this Process
[[exit]]
(((exit@`exit` application)))

The `exit` action procedure does not return. Instead, it results in the termination of the process performing the `exit`.


[listing]
exit has type (integer)=&gt;()


The argument of `exit` is used as the value of the process itself. An `exit` value of zero implies that the process terminated successfully.
</Text>
        </Document>
        <Document ID="1F0E37C2-9C31-4F0D-A6A6-3BF70C5D2575">
            <Title>Decimal Literals</Title>
            <Text>An integer is written using the normal decimal notation:
1  34 -99

Decimal::=Digit ... Digit+
Digit::=0|1|2|3|4|5|6|7|8|9
Integer Literals

[TIP] All integers are represented as at least 64 bit values.</Text>
        </Document>
        <Document ID="B30CF555-C4CC-474C-A91E-763FA2B280DC">
            <Title>Tuple Types</Title>
            <Text>A tuple type is a tuple of types; written as a sequence of type expressions enclosed in parentheses.
TupleType ::= ()
  | (( Type ))
  | (Type ,.., Type)+2
Tuple Type
A tuple type denotes a fixed grouping of elements. Each element of the tuple may have a different type.
There are two special cases in TupleTypes: the empty tuple and the singleton tuple type.</Text>
        </Document>
        <Document ID="4B99FAA0-6EC3-4515-A2CA-119E9AF62131">
            <Title>Bracketing pairs</Title>
            <Text>The Star grammar also permits a special feature that may be used to support language extensions -- defined bracket pairs.
A regular bracket pair is a pair of tokens such as ( and ) which are used to 'protect' expressions where there may be an operator precedence clash -- the classic example being
(2+3)*4
which has a different meaning to
2+3*5
Declaring bracket operators allows new forms of syntax. For example, the statement:
#pair(‘begin’,’end’,2000).
can be used to all programmers to use Algol-style begin...end statements.

This kind of bracket pair definition allows us to radically change the appearance of Star. For example, we can support a pascal-style form of procedure definition, such as:
procedure iFact(N)
  var F := 1;
  var Ix := 1;
  while Ix &lt; N do
  begin
    F := F*Ix;
    Ix := Ix+1;
  end;
  return F;
end;
The macros that implement this are not that complicated:
#prefix(‘return’,1200).
#pair(‘procedure’,’end’,2000).
#pair(‘begin’,’end;,2000).

#procedure ?Tmpl ; ?body end :: statement :- body;*action.
#begin ?B end :: action :- B;*action.
#begin end :: action.

#procedure ?Tmpl ; ?body./#(return ?E)# end ==&gt;
  Tmpl =&gt; valof {body./#(valis E)#}.
#procedure ?Tmpl ; ?body end ==&gt; prc Tmpl do body .

#begin ?B end ==&gt; {B}.
#begin end ==&gt; {}.
Macros that implement Pascal-style programs

Left
Right
Priority
Description
(
)
1200
Expression
{
}
2000
Brace Expression
[
]
1000
Index Expression
#(
)#
2000
Meta Parens
&lt;|
|&gt;
2000
Quote
#&lt;
&gt;#
2000
Macro Tupling
Standard Brackets

[TIP] The so-called meta brackets -- #( and )# -- are particularly useful for meta-programming because they mimic conventional parentheses in conventional programming languages. At the meta-level, a term such as
(A)
is not equivalent to
A
whereas
#(A)#
is.</Text>
        </Document>
        <Document ID="757E103E-39D8-4BFA-BADB-2ED898895935">
            <Title>Expressions-31</Title>
            <Text>
== Control Expressions
[[controlExpression]]
The so-called control expressions involve and modify the meaning of other expressions and actions.</Text>
        </Document>
        <Document ID="520C484F-808A-4651-B417-C1CF776CEA07">
            <Title>Title Page</Title>
            <Text>










&lt;$PROJECTTITLE&gt;

&lt;$author&gt;</Text>
            <Notes>These tags get replaced with the information set in the Metadata pane of Compile. Alternatively, you can simply replace this text altogether.</Notes>
        </Document>
        <Document ID="5DEAA84E-8D89-4C77-A785-5AB03312F943">
            <Title>Type Annotations</Title>
            <Text>A TypeAnnotation is a statement that declares a variable to have a certain Type.
For example,
alpha:all t ~~ (t)=&gt;string
is a TypeAnnotation that asserts that the type of alpha is a generic function that returns a string.
TypeAnnotation ::= Identifier : Type
Type Annotations</Text>
        </Document>
        <Document ID="BED9295C-434C-4743-9754-C4FAC031DED1">
            <Title>Existentially Quantified Types</Title>
            <Text>An existential type denotes an abstract type.
ExistentialType ::= exists BoundType,..,BoundType ~~ Type
Existential Type Expression
An existentially quantified type denotes a type within which there is an abstract type: i.e., the type exists but the expression is not explicit about which type.
Existential types are most often used in the type signatures of abstract data types. For example, the term in the statement:
R = {
  type el = integer
  op(X,Y) =&gt; X+Y
}
has type:
exists el ~~ { el :: type; op:(el,el)=&gt;el }
[NOTE] Note that the fact that within the record the type el is identified as integer does not escape the record itself. Externally, the existence of the type is known but not what it is.
It is permissible to refer to the type within the record by a dot reference.
[TIP] Existentially quantified types are generally not inferred for variables: i.e., if a variable has an existential type then that must be explicitly annotated.
Existential types are inferred, however, for Records that contain a TypeDefinition statement.</Text>
        </Document>
        <Document ID="5A9C7073-AC65-4FEA-A765-F8F210AA530F">
            <Title>JSON</Title>
            <Text>%!TEX root = reference.tex
= JSON
(((JSON}\index{Using the JSON type)))

The JSON Infoset type, or just `json` type, allows values to be represented in a way that is easily digestible by many web-based tools -- including browsers. The `json` type is semantically equivalent to the JSON structure defined in \cite{rfc4627}. However, the `json` type represents a statically typed representation of JSON values.

In addition to basic handling of JSON values, Star provides a form of path notation that allows `json` values to be probed and updated.

== The `json` Type
[[infosetType]]
(((json type@`json` type)))

Program~\vref{infosetProg} defines the `json` type.
\begin{program}
[listing]
type json is
      iFalse or
      iTrue or
      iNull or
      iColl(dictionary of (string,json)) or
      iSeq(list[json]) or
      iText(string) or
      iNum(long) or
      iFlt(float);

.The `json` Type[[infosetProg]]
\end{program}

\begin{aside}
JSON values are not strongly typed in the sense that the value associated with the `Width` of the `Thumbnail` is a string even though one might expect widths to be integral. However, JSON values are checked to be consistent with the `json` type -- like all other values.
\end{aside}

For example, the JSON value:
[listing]
\{
  "Image": \{
    "Width":  800,
    "Height": 600,
    "Title":  "View from 15th Floor",
    "Thumbnail": \{
      "Url":    "http://www.example.com/image/481989943",
      "Height": 125,
      "Width":  "100"
    \},
    "IDs": [116, 943, 234, 38793]
  \}
\}

can be represented using the `json` value shown in &lt;&lt;infosetEx&gt;&gt;.

\begin{figure}[hbt]
[listing]
iColl(dictionary of [
  "Image" -&gt; iCol(dictionary of [
    "Width" -&gt; iNum(800l),
    "Height" -&gt; iNum(600l),
    "Title" -&gt; iText("View from 15th Floor"),
    "Thumbnail" -&gt; iColl(dictionary of [
      "Url" -&gt; iText("http://www.example.com/image/481989943"),
      "Height" -&gt; iNum(125l),
      "Width" -&gt; iText("100")
    ]),
    "IDs" -&gt; iSeq(list of [
      iNum(116l), iNum(943l), iNum(234l), iNum(38793)
    ])
  ])])

.An Example `json` Value
[[infosetEx]]
\end{figure}

\begin{aside}
The JSON standard specification is mute on the topic of numeric precision. We choose to represent integers as `long` values and floating point values as `float` (which is equivalent to `double` precision arithmetic).
\end{aside}

== Infoset paths
[[infoPath]]
(((path access to json@path access to `json`)))

Infoset values are typically deeply nested structures involving both accessing dictionary-like collections and arrays. In order to make working with `json` values simpler we introduce the concept of an json path -- an `infoPath`.

An `infoPath` is a list[path] elements -- each of which represents either an index into a sequence of `json` elements or the name of a member of a collection of elements. This is captured in the definition of the `infoPathKey`, as defined in Program~\vref{infoPathProg}.
\begin{program}
[listing]
type infoPathKey is kString(string) or kInt(integer);

type infoPath is alias of list[infoPathKey];

.The `infoPathKey` and `infoPath` Types[[infoPathProg]]
\end{program}

For example, the path expression that denotes the url of the thumbnail in &lt;&lt;infosetEx&gt;&gt; is:
[listing]
list of [kString("Image"), kString("Thumbnail"), kString("Url")]

and the path that denotes the first id from the `IDs` sequence is:
[listing]
list of [kString("Image"), kString("IDs"), kInt(0)]


Infoset paths are used in several of the functions that are defined on `json` values.

== Standard Functions on Infoset Values
(((json@`json`,standard functions)))
Several contracts are implemented for `json` values; including `indexable`, `iterable`, `indexed\_iterable`, `pPrint` and `coercion`.

=== `\_index` access to `json`
(((json@`json`,standard functions!_index@`\_index`)))
(((_index@`\_index`)))

The `\_index` function applies an `infoPath` to an `json` to obtain a portion of the `json` value. It's type is:
[listing]
\_index has type (infoPath,json)=&gt;json

`\_index` is part of the `indexable` contract -- see &lt;&lt;indexableContract&gt;&gt;.

For example, the value of the first element of the value shown in &lt;&lt;infosetEx&gt;&gt; is gotten with the expression (assuming that the value is bound to the variable `I`:
[listing]
I[list of [kString("Image"), kString("IDs"), kInt(0)]]

This has value
[listing]
iNum(116L)


\begin{aside}
The above expression is a synonym of
[listing]
\_index(I,list of [kString("Image"), kString("IDs"), kInt(0)])

\end{aside}

=== `\_set\_indexed` -- Set a Value in an `json`
(((json@`json`,standard functions!_set_indexed@`\_set\_indexed`)))
(((_set_indexed@`\_set\_indexed`)))

The `\_set\_indexed` function updates a value in an `json` -- depending on a path -- and returns the updated `json`.
The type of `\_set\_indexed` is given by:
\begin{spec}
\_set\_indexed has type (json,info path,json)=&gt;json
\end{spec}
`\_set\_indexed` is part of the `indexable` contract.

\begin{aside}
This function does not update the original; it returns a new value.
\end{aside}

To use this function to change the title of the value in &lt;&lt;infosetEx&gt;&gt; (again assuming that it is bound to an updateable variable `I`) one might use the action:
[listing]
I[list of [kString("Image"), kString("Title")]] := iText("A Better One")

which is a synonym for the action:
[listing]
I := I[list of [kString("Image"), kString("Title")]-&gt;iText("A Better One")]

which, in turn, is a synonym for:
[listing]
I := \_set_indexed(I,list of [kString("Image"),kString("Title")],
                  iText("A Better One"))


=== `\_delete\_indexed` -- Remove a Value from an `json`
(((json@`json`,standard functions!_delete_indexed@`\_delete\_indexed`)))
(((_delete_indexed@`\_delete\_indexed`)))

The `\_delete\_indexed` function removes a value in an `json` -- depending on a path -- and returns the modified `json`.
\begin{aside}
This function does not update the original; it returns a new value.
\end{aside}
The type of `\_delete\_indexed` is given by:
[listing]
\_delete\_indexed has type (json,info path)=&gt;json

`\_delete\_indexed` is part of the `indexable` contract.

To use this function to remove the last ID from `IDs` in &lt;&lt;infosetEx&gt;&gt; one might use the action:
[listing]
remove I[list of [kString("Image"), kString("IDs"), kInt(3)]]

which is a synonym for the action:
[listing]
I := I[without list of [kString("Image"),kString("IDs"), kInt(3)]]


=== `\_index\_member` -- Test a Path in an `json`
(((json@`json`,standard functions!_index_member@`\_index\_member`)))
(((_index_member@`\_index\_member`)))

The `\_index\_member` pattern succeeds if there is a designated element of the `json` and matches it against a pattern.

The type of `\_index\_member` is given by:
[listing]
\_index\_member has type (json)&lt;=(json,infopath)

`\_index\_member` is part of the `indexable` contract.

The `\_index\_member` pattern is typically used in query conditions; such as:
[listing]
if I[list of [kString("Image")]] matches L then

This is equivalent to the condition:
[listing]
if (I,list of [kString("Image")]) matches \_index\_member then


=== `\_iterate` -- Over an `json`
(((json@`json`,standard functions!_iterate@`\_iterate`)))
(((_iterate@`\_iterate`)))

The `\_iterate` function is used when iterating over the elements of an `json`.

The type of `\_iterate` is given by:
[listing]
\_iterate has type for all s such that
  (json,(json,IterState of s)=&gt;IterState of s,
   IterState of s) =&gt; IterState of s

The `\_iterate` function is part of the `iterable` contract -- see &lt;&lt;iterableContract&gt;&gt;.

The `json` variant of the `\_iterate` function calls the `client function' for all of the `leaf' elements of an `json` value. For example, in the condition:
[listing]
X in I

where `I` is the `json` value shown in &lt;&lt;infosetEx&gt;&gt;, then the client function will be called successively on the `json` values:
[listing]
iNum(800l)
iNum(600l)
iText("View from 15th Floor")
iText("http://www.example.com/image/481989943")
iNum(125l)
iText("100")
iNum(116l)
iNum(943l)
iNum(234l)
iNum(38793)

The query:
[listing]
list of \{ all X where iText(X) in I \}

will have value:
[listing]
list of [
  "View from 15th Floor",
  "http://www.example.com/image/481989943",
  "100"
]


=== `\_indexed\_iterate` -- Over an `json`
(((json@`json`,standard functions!_indexed_iterate@`\_indexed\_iterate`)))
(((_indexed_iterate@`\_indexed\_iterate`)))

The `\_indexed\_iterate` function is used when iterating over the elements of an `json`. A key difference between this and `\_iterate` is that `\_indexed\_iterate` involves the paths to each of the leaf elements of the JSON value.

The type of `\_indexed\_iterate` is given by:
[listing]
\_indexed\_iterate has type for all s such that
  (json,(infoPath,json,IterState of s)=&gt;IterState of s,
   IterState of s) =&gt; IterState of s

The `\_indexed\_iterate` function is part of the `indexed\_iterable` contract -- see &lt;&lt;iterableContract&gt;&gt;.

The `\_indexed\_iterate` function calls the `client function' for all of the `leaf' elements of an `json` value; providing an `infoPath` expression for each leaf element processed.

The `\_indexed\_iterate` function is typically used in conditions of the form:
[listing]
K -&gt; V in I

where `K` is a pattern that matches the key (`infoPath`), `V` is a pattern that matches the (leaf) value, and `I` is the `json` being queried.

For example, in the condition:
[listing]
K-&gt;V in I

where `I` is the `json` value shown in &lt;&lt;infosetEx&gt;&gt;, then the client function will be called successively on the `infoPath-&gt;json` values:
[listing]
list of [kString("Image"), kString("Width")] -&gt; iNum(800l)
list of [kString("Image"), kString("Height")] -&gt; iNum(600l)
list of [kString("Image"), kString("Title")] -&gt;
       iText("View from 15th Floor")
list of [kString("Image"), kString("Thumbnail"), kString("Url")] -&gt;
       iText("http://www.example.com/image/481989943")
list of [kString("Image"), kString("Thumbnail"), kString("Height")] -&gt;
       iNum(125l)
list of [kString("Image"), kString("Thumbnail"), kString("Width")] -&gt;
       iText("100")
list of [kString("Image"), kString("IDs"), kInt(0)] -&gt; iNum(116l)
list of [kString("Image"), kString("IDs"), kInt(1)] -&gt; iNum(943l)
list of [kString("Image"), kString("IDs"), kInt(2)] -&gt; iNum(234l)
list of [kString("Image"), kString("IDs"), kInt(3)] -&gt; iNum(38793)

The `\_indexed\_iterate` function is therefore useful when you want to both process all the leaves in an `json` but also to know where they are.


== Parsing and Displaying
The standard contract for displaying values -- `pPrint` -- is implemented for the `json` type. In addition, a `string` value may be parsed as a `json` by using the coercion expression:
[listing]
"\{"Id" : 34 \} as json

has value:
[listing]
iColl(dictionary of \{ "Id" -&gt; iNum(34L) \})


=== `ppDisp` -- Display a `json` Value
The `pPrint` contract is implemented for `json` values. The type of `ppDisp` is given by:
[listing]
ppDisp has type (json)=&gt;pP

The `pPrint` contract is described in &lt;&lt;pPrintContract&gt;&gt;. This implementation means that when a `json` value is displayed, it is shown in legal JSON syntax.
</Text>
        </Document>
        <Document ID="00A7C9A0-A210-4CB1-8B08-A0AAEF362C68">
            <Title>Type Safety</Title>
            <Text>The connection between the argument type of a `cons` type expression and the actual elements of lists is denoted by a type inference rule. Type inference rules are rules for relating expressions and statements in the language to the types associated with that statement. For example, the rule:
E |= El1:T .. E |= Eln:T =&gt; E |= cons of [El1,..,Eln] : cons[T]
says that if the expressions El1:T through Eln:T all have type T, then the list expression
cons of [El1,..,Eln]
has type cons[T]. This is the formal way of stating that all elements of a list must have the same type.
The general form of a type inference rule that is determining a type (sometimes called a type judgment) is:
Condition =&gt; E |= X:T
This should be read as
If Condition is satisfied, then we can infer from the context E that X has type T
where the symbol =&gt; can be read as type implication. In general, the type of an expression depends on the context that it is found.</Text>
            <Comments>We should note that this expression is not ‘primitive’ and does not actually have its own type rule.</Comments>
        </Document>
        <Document ID="2A3AB132-4DB8-4497-999C-3C589803DD16">
            <Title>Expressions-23</Title>
            <Text>
==== Type Safety
The type safety of an attribute substitute expression is couched in terms of &lt;&lt;AttributeConstraint&gt;&gt;s.
\begin{prooftree}
\AxiomC{\typeprd{E}{R}{T\sub{R}\ `where`\ T\sub{R}\ `implements`\ T\sub{S}}}
\AxiomC{\typeprd{E}{S}{S\sub{S}\ `where`\ S\sub{S}\ `implements`\ T\sub{S}}}
\BinaryInfC{\typeprd{E}{R\ `substitute`\ S}{T\sub{R}}}
\end{prooftree}
The implication is that the `substitution' record `S` only contains attributes that are also present in the `substitute' expression `R`.</Text>
        </Document>
        <Document ID="ED1D2BEF-2078-4CA8-A2AD-3C26193B9CE4">
            <Title>Conditions</Title>
            <Text>%!TEX root = reference.tex
= Conditions
[[conditions]]
Conditions are used to express constraints. For example, a `where` pattern (see &lt;&lt;guardPattern&gt;&gt;) uses a condition to attach a semantic guard to a pattern. Conditions are also as guards on _equations_ (see &lt;&lt;equations&gt;&gt;) and in other forms of rule.


\begin{aside}
Conditions should not be confused with `boolean`-values expressions; the fundamental semantics of conditions is based on _satisfiability_ -- not _evaluation_ -- see &lt;&lt;querySemantics&gt;&gt;. However, a `boolean`-valued expression _may_ act as a degenerate example of a condition.
\end{aside}

&lt;&lt;conditionFormFig&gt;&gt; illustrates the general forms of condition.

\begin{figure}[htbp]
\begin{eqnarray*}
[[Condition]]Condition::=&lt;&lt;MatchesCondition&gt;&gt;\\
%  | &lt;&lt;MemberCondition&gt;&gt;\\
  | &lt;&lt;SearchCondition&gt;&gt;\\
  | &lt;&lt;IndexedSearch&gt;&gt;\\
  | &lt;&lt;ConjunctionCondition&gt;&gt;\\
  | &lt;&lt;DisjunctionCondition&gt;&gt;\\
  | &lt;&lt;ImpliesCondition&gt;&gt;\\
  | &lt;&lt;OtherwiseCondition&gt;&gt;\\
  | &lt;&lt;NegationCondition&gt;&gt;\\
  | &lt;&lt;ConditionalCondition&gt;&gt;\\
  | &lt;&lt;HasValueCondition&gt;&gt;\\
  | &lt;&lt;PresentCondition&gt;&gt;\\
  | `(`\ &lt;&lt;Condition&gt;&gt;\ `)`\\
  | &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.Condition
[[conditionFormFig]]
\end{figure}

\paragraph{Type Safety}
Unless it appears directly as an expression, the type of a condition is less interesting than whether the condition is _type satisfiable_. In general, a condition is type satisfiable if it is consistent and it is potentially satisfiable. To further this we introduce the \satinf{} meta-predicate. A inference rule of the form:
\begin{prooftree}
\AxiomC{\rm{_Condition_}}
\UnaryInfC{\typesat{E}{F}}
\end{prooftree}
declares that the form _F_ is valid in the context _E_ provided that &lt;&lt;Condition&gt;&gt; is satisfied.

== Membership and Search
[[membershipCondition]]


=== Matches Condition
The `matches` condition is a special condition that applies a pattern to a value. The condition is satisfied (see &lt;&lt;querySemantics&gt;&gt;) if the pattern matches the expression.

\begin{figure}[htbp]
\begin{eqnarray*}
[[MatchesCondition]]MatchesCondition::=&lt;&lt;Expression&gt;&gt;\ `matches`\ &lt;&lt;Pattern&gt;&gt;
\end{eqnarray*}
.`matches` Condition
[[matchesPredicateFig]]
\end{figure}

==== Type Safety
A `matches` condition is type safe if the types of the left hand side and right hand side are the same. Recall that the left hand side is an expression, whereas the right hand side is a pattern.

\begin{prooftree}
\AxiomC{\typeprd{E}{V}{T}}
\AxiomC{\typeprd{E}{P}{T}}
\BinaryInfC{\typesat{E}{V\ `matches`\ P}}
\end{prooftree}


=== Has Value Condition
[[hasValueCond]]
(((has value operator@`has value` operator)))
(((accessing an optional value)))
(((option chaining)))

The `has value` operator can be used as a &lt;&lt;Condition&gt;&gt; to 'unwrap' an `option`al to access its contents in a safe way.

\begin{figure}[htbp]
\begin{eqnarray*}
[[HasValueCondition]]HasValueCondition::=&lt;&lt;Expression&gt;&gt;\ `has value`\ &lt;&lt;Pattern&gt;&gt;
\end{eqnarray*}
.Option Has Value Condition[[optionUnwrapFig]]
\end{figure}

The `has value` condition is satisfied if its right hand side expression is a `some` value and if its left hand pattern matches the contents of the optional value.

One common use of the `has value` condition is to 'bring into scope' a variable which represents the wrapped content of the `option`al value.

For example, suppose that `P` has the type given by
[listing]
P has type option of Person

then the condition in the equation:
[listing]
nameOf(P) where P has value PP is PP.name

unwraps the optional value of `P` into the non-optional `PP`. Note that this particular example can be better written:
[listing]
nameOf(P) is P?.name

since this makes the resulting type also `option`al.

==== Type Safety
A `has value` condition is type safe iff the expression on the left is consistent with the pattern on the right:
\begin{prooftree}
\AxiomC{\typeprd{E}{V}{`option of `T\sub{v}}}
\AxiomC{\typeprd{E}{P}{T\sub{v}}}
\BinaryInfC{\typesat{E}{V\ `has value`\ P}}
\end{prooftree}

=== Present Condition
[[presentCond]]
(((present operator@`present` operator)))
(((accessing an optional value)))
(((option chaining)))

The `present` operator can be used as a &lt;&lt;Condition&gt;&gt; to test an `option`al to see if it has a value.

\begin{figure}[htbp]
\begin{eqnarray*}
[[PresentCondition]]PresentCondition::=`present`\ &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.Option Present Condition[[optionPresentFig]]
\end{figure}

The `present` condition is satisfied if its right hand side expression is a `some` value.

One common use of the `present` condition is to test to see if an entry is present in a `dictionary`.

For example, suppose that `D` has value
[listing]
def D is dictionary of [1 -&gt; "alpha", 2-&gt; "beta"]

then the condition in the equation:
[listing]
isThere(K) is present D[K]

tests the the optional value of `D[K]` and is satisfied if the key `K` is present in the dictionary.

==== Type Safety
A `present` condition is type safe iff the expression on the left is an optional value:
\begin{prooftree}
\AxiomC{\typeprd{E}{V}{`option of `T\sub{v}}}
\UnaryInfC{\typesat{E}{`present`\ V}}
\end{prooftree}

=== Search Condition
[[searchCondition]]
A search condition is satisfied by finding elements of collections that meet some criterion.

\begin{figure}[htbp]
\begin{eqnarray*}
[[SearchCondition]]SearchCondition::=&lt;&lt;Pattern&gt;&gt;\ `in`\ &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.Search Condition
[[searchFormFig]]
\end{figure}

\begin{aside}
The collection being searched must implement the `iterable` contract -- see &lt;&lt;iterableContract&gt;&gt;.
\end{aside}

For example, the search condition:
[listing]
(X,"john") in parent

is satisfied (potentially multiple times) if there is a pair of the form:
[listing][escapechar=|]
(|_Val_|,"john")

`in' the collection identified as `parent`. If `parent` were defined as the list:
[listing]
list of [ ("alpha","john"), ("beta","peter"), ("gamma","john") ]

then the search condition has two solutions: one corresponding to `"alpha"` and the other to `"gamma"`.

==== Type Safety
A search condition is type safe if the type of the pattern corresponds to an element of the type of the collection. This is characterized by means of a  &lt;&lt;DependencyConstraint&gt;&gt;.
\begin{prooftree}
\AxiomC{\typeprd{E}{P}{T\sub{e}}}
\AxiomC{\typeprd{E}{C}{`iterable over `T\ `determines`\ T\sub{e}}}
\BinaryInfC{\typesat{E}{P\ `in`\ C}}
\end{prooftree}
The type judgment of a &lt;&lt;SearchCondition&gt;&gt; depends on the `iterable` contract (see &lt;&lt;iterableContract&gt;&gt;.

=== Indexed Search Condition
[[indexedSearchCondition]]
An &lt;&lt;IndexedSearch&gt;&gt; condition is satisfied by finding elements of collections that match a pattern and where the index of the element within the collection is also matched against.

\begin{figure}[htbp]
\begin{eqnarray*}
[[IndexedSearch]]IndexedSearch::=&lt;&lt;Pattern&gt;&gt;`-&gt;`&lt;&lt;Pattern&gt;&gt;\ `in`\ &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.Indexed Search Condition
[[indexedSearchFormFig]]
\end{figure}

\begin{aside}
The collection being searched must implement the `indexed\_iterable` contract -- see &lt;&lt;indexedIterableContract&gt;&gt;.
\end{aside}

&lt;&lt;IndexedSearch&gt;&gt; conditions allow the programmer to not only access the element of the collection but also its `position' within the collection. For example, the condition:
[listing]
(Ix-&gt;V where V&gt;0 and Ix&lt;10) in L

is satisfied for those elements in `L` which are greater than zero, and whose index is less than 10.

\begin{aside}
One of the important features of the &lt;&lt;IndexedSearch&gt;&gt; is that the &lt;&lt;IndexSearch&gt;&gt; could potentially be satisfied for each element of the collection -- depending, of course, on the patterns involved.
\end{aside}

==== Type Safety
An &lt;&lt;IndexedSearch&gt;&gt; condition is type safe if the type of the pattern corresponds to an element of the type of the collection.
\begin{prooftree}
\def\ScoreOverhang{1pt}
\insertBetweenHyps{\hskip 1ex}
\AxiomC{\typeprd{E}{Ky}{T\sub{k}}}
\AxiomC{\typeprd{E}{Vl}{T\sub{v}}}
\AxiomC{\typeprd{E}{C}{`indexed\_iterable over `T\ `determines`\ (T\sub{k},T\sub{v})}}
\TrinaryInfC{\typesat{E}{Ky`-&gt;`Vl\ `in`\ C}}
\end{prooftree}
The type judgment of a &lt;&lt;IndexedSearch&gt;&gt; condition depends on the `indexed\_iterable` contract (see &lt;&lt;indexedIterableContract&gt;&gt;).

== Logical Combinations

=== Conjunction Condition
A conjunction -- using the `and` operator -- is satisfied iff both the left and right `arms' of the conjunction are satisfied.

\begin{figure}[htbp]
\begin{eqnarray*}
[[ConjunctionCondition]]ConjunctionCondition::=&lt;&lt;Condition&gt;&gt;\ `and`\ &lt;&lt;Condition&gt;&gt;\\
  | &lt;&lt;Condition&gt;&gt;\ `where`\ &lt;&lt;Condition&gt;&gt;\\
\end{eqnarray*}
.Conjunction Condition
[[conjunctionConditionFormFig]]
\end{figure}

\begin{aside}
There is _no_ guarantee as to any order of evaluation of the arms of a condition. In particular, you may assume neither that the left is evaluated before the right, nor that both arms are, or are not, evaluated.
\end{aside}

\begin{aside}
The `where` variant of conjunction is syntactic convenience to allow conditions of the form:
[listing]
foo(rs) is (r in rs where r &gt; 0) ? some(r) : none

which would otherwise be written:
[listing]
foo(rs) is (r in rs and r &gt; 0) ? some(r) : none

or
[listing]
foo(rs) is ((r where r &gt; 0) in rs) ? some(r) : none

\end{aside}

==== Type Safety
A conjunction is type safe iff the two arms of the conjunction are type safe.
\begin{prooftree}
\AxiomC{\typesat{E}{L}}
\AxiomC{\typesat{E}{R}}
\BinaryInfC{\typesat{E}{L\ `and`\ R}}
\end{prooftree}

=== Disjunction Condition
[[disjunction]]
(((disjunctive condition)))
(((or condition@`or` condition)))
A disjunction -- using the `or` operator -- is satisfied iff either the left or the right operands are satisfied.

\begin{figure}[htbp]
\begin{eqnarray*}
[[DisjunctionCondition]]DisjunctionCondition::=&lt;&lt;Condition&gt;&gt;\ `or`\ &lt;&lt;Condition&gt;&gt;
\end{eqnarray*}
.Disjunction Condition
[[disjunctionConditionFormFig]]
\end{figure}

\begin{aside}
There is no guarantee as to the order of evaluation of the left and right operands.
\end{aside}

==== Type Safety
A disjunction is type safe iff the two arms of the disjunction are type safe.
\begin{prooftree}
\AxiomC{\typesat{E}{L}}
\AxiomC{\typesat{E}{R}}
\BinaryInfC{\typesat{E}{L\ `or`\ R}}
\end{prooftree}

=== Negated Condition
A negation is satisfied iff the operand is _not_ satisfied.


\begin{figure}[htbp]
\begin{eqnarray*}
[[NegationCondition]]NegationCondition::=`not`\ &lt;&lt;Condition&gt;&gt;
\end{eqnarray*}
.Negated Condition
[[negationConditionFormFig]]
\end{figure}

\begin{aside}
If the negated query has any unbound variables in it then the meaning of the negated query is undefined.
\end{aside}

==== Type Safety
A negation is type safe iff the negated condition is type safe.
\begin{prooftree}
\AxiomC{\typesat{E}{N}}
\UnaryInfC{\typesat{E}{`not`\ N}}
\end{prooftree}

=== Implies Condition
An _implication_ condition -- using the `implies` operator -- is satisfied iff there is a solution to the right hand side for every solution to the left hand side.


\begin{figure}[htbp]
\begin{eqnarray*}
[[ImpliesCondition]]ImpliesCondition::=&lt;&lt;Condition&gt;&gt;\ `implies`\ &lt;&lt;Condition&gt;&gt;
\end{eqnarray*}
.Implies Condition
[[impliesConditionFormFig]]
\end{figure}

For example, the state of having only sons can be defined as the condition that all ones children are male. This can be expressed using the condition:
[listing]
(P,X) in children implies X in male


\begin{aside}
Like negation, an `implies` condition can never result in binding a variable to a value. It can only be used to verify a condition. Thus, to actually look for people who only have sons, a separate `generator' condition is needed.

A query expression such as:
[listing]
(P,_) in children and (P,X) in children implies X in male

is effectively using the first ``(P,X) in children`' condition to find a person who has children, where the second implies condition verifies that `P `only has sons.
\end{aside}

==== Type Safety
A whenever condition is type safe iff the two arms are type safe.
\begin{prooftree}
\AxiomC{\typesat{E}{L}}
\AxiomC{\typesat{E}{R}}
\BinaryInfC{\typesat{E}{L\ `implies`\ R}}
\end{prooftree}


=== Otherwise Condition
[[otherwiseQuery]]
(((query,otherwise@`otherwise`)))

\begin{figure}[htbp]
\begin{eqnarray*}
[[OtherwiseCondition]]OtherwiseCondition::=&lt;&lt;Condition&gt;&gt;\ `otherwise`\ &lt;&lt;Condition&gt;&gt;
\end{eqnarray*}
.Otherwise Condition
[[otherwiseConditionFormFig]]
\end{figure}

An `otherwise` condition is semantically similar to a disjunction: an `otherwise` condition is satisfied if either the left hand side is satisfied or the right hand side is satisfied. However, it is actually extremely difficult to give a purely declarative semantics for the `otherwise` condition -- the right hand side of an `otherwise` _must not be attempted_ if there is at least one way of satisfying the left hand side.

For example, given a list `childOf`, the query:
[listing]
all Ch where (Ch,"john") in childOf otherwise noone matches Ch

results in an `array` containing all the children of `"john"`; unless `"john"` has no children, in which case the result will contain the singleton `noone`. footnote:[Assuming of course that `noone` is a type safe value for a `person`.]

More precisely, given a condition of the form:
[listing][escapechar=|]
|_Q\sub1_| otherwise |_Q\sub2_|

if there exist _any_ instances that satisfy `_Q\sub1_` condition then that is the _only_ way of satisfying the condition; otherwise the condition is satisfied if `_Q\sub2_` can be satisfied.
\begin{aside}
The `otherwise` query can be used in situations similar to those where a _left outer join_ would be used. If `A` and `B` are two collections, then
[listing]
A otherwise B

(where `A` and `B` have suitable variables in common) is analogous to
[listing]
A left outer join B

assuming a suitable join condition.
\end{aside}

==== Type Safety
An `otherwise` condition is type safe iff the two arms of the condition are type safe.
\begin{prooftree}
\AxiomC{\typesat{E}{L}}
\AxiomC{\typesat{E}{R}}
\BinaryInfC{\typesat{E}{L\ `otherwise`\ R}}
\end{prooftree}

=== Conditional Condition
[[conditionalQuery]]
(((conditional query constraint)))
(((dependent query)))

A conditional condition is used when the actual condition to apply depends on a test.

\begin{figure}[htbp]
\begin{eqnarray*}
[[ConditionalCondition]]ConditionalCondition&amp;`(`\ &lt;&lt;Condition&gt;&gt;\ `?`\ &lt;&lt;Condition&gt;&gt;\ `:`\ &lt;&lt;Condition&gt;&gt;`)`
\end{eqnarray*}
.Conditional Condition
[[conditionalConditionFig]]
\end{figure}

For example, if the salary of an employee may be gotten from two different relations depending on whether the employee was a manager or not, the salary may be retrieved using a query:
[listing]
list of { all S where ( isManager(P) ?
                  (P,S) in manager_salary :
                  (P,S) in employee_salary )
        }


As with conditional expressions (see &lt;&lt;conditionalExpression&gt;&gt;), the test part of the &lt;&lt;ConditionalCondition&gt;&gt; is evaluated and, depending on whether the test is _satisfiable_ or not, the `then' branch or the `else' branch is used in the query constraint.

\begin{aside}
In the case that the `test' is satisfiable; then only solutions from the `then' branch will be considered for the overall query. Conversely, if the `test' is not satisfiable, footnote:[A normal `boolean`-valued expression is considered to be satisfiable iff it evaluates to `true`.] then only solutions from the `else' branch will be used for the overall query.
\end{aside}

\begin{aside}
\begin{aside}
The `test' part of a &lt;&lt;ConditionalCondition&gt;&gt; is only satisfied once -- if there are multiple ways in which the `test' could be satisfied, only the first found is used.

The `test' may _not_ bind variables; if it does, those variables are in _not_ scope for the either the `then' branch or the `else' branch of the conditional.
\end{aside}
\end{aside}
\begin{aside}
\begin{aside}
However, if a variable is defined in _both_ arms of a &lt;&lt;ConditionalCondition&gt;&gt; then the variable `escapes' the conditional itself.

For example, the &lt;&lt;ConditionalCondition&gt;&gt; above `defines' the variable `S` in both the `then' and `else' branch. Depending on the `isManager` test, the result of the query will either contain the value of a `manager\_salary` or an `employee\_salary`.
\end{aside}
\end{aside}

\begin{aside}
As with the &lt;&lt;OtherwiseCondition&gt;&gt;, &lt;&lt;ConditionalCondition&gt;&gt; can be useful in cases where defaults may apply.
\end{aside}

==== Type Safety
A &lt;&lt;ConditionalCondition&gt;&gt; is type safe iff the three arms of the conditional are type safe.
\begin{prooftree}
\AxiomC{\typesat{E}{T}}
\AxiomC{\typesat{E}{L}}
\AxiomC{\typesat{E}{R}}
\TrinaryInfC{\typesat{E}{`(`T\ `?` L\ `:`\ R`)`}}
\end{prooftree}

== Satisfaction Semantics
[[querySemantics]]
(((query,semantics of)))
(((variable,in queries)))

The semantics of conditions is based on _satisfaction_ -- for example, the answer to a query is based on the different ways that the condition part of the query may be satisfied.

The satisfiability of a condition is not identical to the normal concept of evaluating `boolean`-valued expressions. In essence, a &lt;&lt;Condition&gt;&gt; is satisfied if there is a binding for the unbound variables within the &lt;&lt;Condition&gt;&gt; that `makes the &lt;&lt;Condition&gt;&gt; true.

Variables that are bound as a result of satisfying a &lt;&lt;Condition&gt;&gt; are often used to `produce' a value from the &lt;&lt;Condition&gt;&gt;. For example, an `all` query has as value _all_ the tuples that satisfy the &lt;&lt;Condition&gt;&gt; and the `anyof` query has as value any tuple that satisfies the &lt;&lt;Condition&gt;&gt;.

\begin{aside}
Any variables that are defined within the query are assumed to be in scope across the entire query. This means that the types associated with variables' occurrences must all be consistent.

A variable may occur in an outer context as well as within the query. Such a variable is in scope within the query but is not defined by the query. As with repeated occurrences of variables, such `free variables' become constraints on the satisfaction of the query.
\end{aside}

\begin{description}
A &lt;&lt;SearchCondition&gt;&gt;:: of the form:
[listing][escapechar=|]
|&lt;&lt;Pattern&gt;&gt;| in |&lt;&lt;Expression&gt;&gt;|

is considered satisfiable for any value in the collection identified by &lt;&lt;Expression&gt;&gt; that matches the &lt;&lt;Pattern&gt;&gt;.
\end{description}


The result of a query is expressed as the value of an expression. Each element of the result is obtained by evaluating the _bound_ expression in the context of the bindings of the variables arrived at during the satisfaction of the query constraint.

In the case of an `all` query and the `view` definition, the computed result contains the result of evaluating the bound expression for every possible way of satisfying the query.  The `one` query looks for just one way of solving the query constraint and a numerically bounded query looks for that many ways. footnote:[Of course, if the query asks for 10 results (say), there may not be that many answers.]

\begin{aside}
(((conditions,relative order of terms)))
(((order of terms in conditions)))
It is important to note that, in the case of a conjunction or disjunction, the relative order of terms is not relevant. For example the conditions
[listing]
X in male and ("fred",X) in parent

and
[listing]
("fred",X) in parent and X in male

have the same solutions -- are satisfied for the same bindings of the variable `X`.
\end{aside}

==== Type Safety
[[querytypesatty]]
A relational query is type if the type of the pattern is consistent with the type of the elements of the tuple.

== Standard Predicates
[[predicates]]

The standard predicates are based on the `equality` and `comparable` contracts. These contracts define what it means for two values to be equal, or for one value to be lesser than another.

The `equality` contract is automatically implemented for any type that does not reference a program type (i.e., does not contain functions, procedures or other program values). However, the programmer may wish to explicitly implement `equality` for a user-defined type if equality for that type is not based on simple comparison of data structures. Such user-defined implementations override any defined by the language.

=== The `equality` contract
[[equalityPredicates]]
(((equality predicates)))
Equality is based on the `equality` contract -- see Program~\vref{equalityContract}. This defines the `boolean`-valued function: `=`. The complementary function `!=` is not defined as part of the `equality` contract; but is defined in terms of `=`.

(((type,contracts!equality@`equality`)))
(((equality contract@`equality` contract)))
\begin{program}
[listing]
contract equality over t is {
  (=) has type (t,t)=&gt;boolean;
}

.The Standard `equality` Contract[[equalityContract]]
\end{program}

It is not necessary to explicitly implement the `equality` contract. The language processor automatically implements it for types that do not contain program values. However, it is possible to provide an explicit implementation for `equality` for cases where a more semantic definition of equality is desired.

=== `=` -- equals
[[equalsPredicate]]
((("=@`=` predicate)))
(((equality predicate)))
`=` is part of the standard `equality` contract.
[listing]
(=) has type for all t such that (t,t) =&gt; boolean where equality over t

In general, equality is _not_ defined for all values. In particular, equality is not defined for functions, procedures and other program values. footnote:[Whether two expressions that denote functions of the same type denote the same function is, in general, not effectively decidable.]

=== `!=` -- not equals
[[notEqualsPredicate]]
(((",=@`"!=` predicate)))
(((inequality predicate)))
[listing]
(!=) has type for all t such that (t,t) =&gt; boolean where equality over t

The `!=` predicate has a standard definition that makes it equivalent to a negated equality:
[listing]
X != Y is not X=Y


=== The `comparable` contract
[[comparisonPredicates]]

Comparison is based on the standard `comparable` contract -- see Program~\vref{comparableContract}.

Comparison is _not_ automatically implemented for all types -- the standard language provides implementations for the arithmetic types (`integer`s, `float`s etc.) and for the `string` type.


(((type,contracts!comparable@`comparable`)))
(((comparable contract@`comparable` contract)))
\begin{program}
[listing]
contract comparable over t is {
  (&lt;) has type (t,t)=&gt;boolean;
  (=&lt;) has type (t,t)=&gt;boolean;
  (&gt;) has type (t,t)=&gt;boolean;
  (&gt;=) has type (t,t)=&gt;boolean;
}

.The Standard `comparable` Contract[[comparableContract]]
\end{program}

=== `&lt;` -- less than
(((&lt;@`&lt;` predicate)))
[listing]
(&lt;) has type for all t such that (t,t)=&gt;boolean where comparable over t


The `&lt;` predicate is satisfied if the left argument is less than the right argument. The precise definition of less than depends on the actual implementation of the `comparable` contract for the type being compared; however, for arithmetic types, less than is defined as being arithmetic less than. For `string`s, one string is less than another if it is smaller in the standard lexicographic ordering of strings.

=== `=&lt;` -- less than or equal
(((=&lt;@`=&lt;` predicate)))
[listing]
(=&lt;) has type for all t such that (t,t)=&gt;boolean where comparable over t


The `=&lt;` predicate is satisfied if the left argument is less than or equals to the right argument.

=== `&gt;` -- greater than
(((&gt;@`&gt;` predicate)))
[listing]
(&gt;) has type for all t such that (t,t)=&gt;boolean where comparable over t


The `&gt;` predicate is satisfied if the left argument is greater than the right argument.

=== `&gt;=` -- greater then or equal
(((&gt;=@`&gt;=` predicate)))
[listing]
(&gt;=) has type for all t such that (t,t)=&gt;boolean where comparable over t


The `&gt;=` predicate is satisfied if the left argument is greater than or equal to the right argument.
</Text>
        </Document>
        <Document ID="43821251-F2DF-47A8-B2C2-5971EF942CEB">
            <Title>Expressions-38</Title>
            <Text>
==== Type Safety
A `valof` expression is type safe if each of the actions contained within it are type consistent, and its type is the type of the expression referenced in the `valis` actions within the body of the `valor`.

The type of a `valof` expression is the type of the expression associated with the `valis` actions embedded within it.

\begin{prooftree}
\AxiomC{\typesafe{E}{A}}
\AxiomC{\typeprd{E}{V}{T}}
\AxiomC{$`valis`\ E\in A$}
\TrinaryInfC{\typeprd{E}{`valof`\ A}{T}}
\end{prooftree}
\begin{aside}
The \safeinf{} meta-predicate is used of actions; and is true iff the action is consistent in its use of variables and types. See &lt;&lt;actionTypeSafety&gt;&gt;.
\end{aside}</Text>
        </Document>
        <Document ID="B6F16654-A4A9-459E-9FE1-F29E4F9AE7A7">
            <Title>Comments and White Space</Title>
            <Text>
Input is tokenized according to rules that are similar to most modern programming languages: contiguous sequences of characters are assumed to belong to the same token unless the class of character changes -- for example, a punctuation mark separates sequences of letter characters. In addition, white space and comments serve as token boundaries; otherwise white space and comments are ignored by the higher-level semantics of the language.
Ignorable ::= LineComment
 | BlockComment
 | WhiteSpace
Ignorable Characters
There are two forms of comment: line comment and block comment</Text>
        </Document>
        <Document ID="AFFD5F88-3D30-45D8-9946-D3F7D3AF15E4">
            <Title>Floating Point Literals</Title>
            <Text>The float type is used to represent fractional values. Floating point numbers are represented as IEEE double precision -- i.e., 64 bit.
Float::=FloatingPoint
Floating Point Literals</Text>
        </Document>
        <Document ID="B0803CBB-2F1E-41ED-9D6D-F16E1465B0E4">
            <Title>Types</Title>
            <Text>Star is a strongly, statically, typed language. That means that all values and all variables must have a unique well-defined type that is determinable by inspecting the text of the program -- effectively at `compile time'.
The type system of Star consists of a method for declaring new types, for annotating variables (and by extension programs) with their types and a system of verifying the type consistency of programs.</Text>
        </Document>
        <Document ID="113C53F7-8154-4A13-9035-1F54807EF827">
            <Title>Character Codes</Title>
            <Text>The character code notation allows a number to be based on the Unicode CodePoint value of a character. Any Unicode character code point can be entered in this way:
0cX 0c[ 0c\n 0c
For example, 0c\n is the codepoint associated with the new line character, i.e., its value is 10.
[TIP] Unicode has the capability to represent up to one million character code points.
CharacterCode::=0cCharRef
Character Codes
[TIP] A CharacterCode is an integer. This notation allows string processing programs to represent character CodePoint values in a natural way.</Text>
        </Document>
        <Document ID="F5E48B29-06C1-4691-AD91-C891E2B0553B">
            <Title>Expressions-37</Title>
            <Text>
==== Evaluation Semantics
As noted above, the primary guarantee that a `memo` function offers is that it's expression is only evaluated once.

An expression of the form:
[listing][escapechar=|]
memo |&lt;&lt;Expression&gt;&gt;|

denotes a function value. Each time the `memo` expression is evaluated a new function value is `created'. In this regard, a `memo` function is no different to an `ordinary' anonymous function.

\begin{aside}
The only sense in which it makes a material difference how `memo` functions are computed is through the binding of free variables within the`memo`'d expression.

In general, each evaluation of a `memo` function -- or a `function` expression -- may result in different bindings for free variables within the &lt;&lt;Expression&gt;&gt;.

If the function has no free variables then the compiler _may_ simply construct a static entity for the function.
\end{aside}

When a `memo` function is entered then one of three possibilities may occur: either the `memo` function has never been entered, the `memo` function has already returned a value or there is a concurrent activity that is computing `within' the function.

\begin{itemize}
\item If the `memo` function has never been entered before then its expression is evaluated, recorded internally within the function, and the computed value is returned as the value.
\item If the `memo` function has previously returned then the recorded value is returned.
\item If the `memo` function is currently being computed then the call is blocked until the ongoing computation is completed. At which point the call is handled in the same way as a subsequent call to the `memo` function.
\end{itemize}

==== Type Safety
The type of a `memo` function is determined by the type of the memo'd expression:

\begin{prooftree}
\AxiomC{\typeprd{E}{M}{T\sub{M}}}
\UnaryInfC{\typeprd{E}{`memo`\ M}{`()=&gt;`T\sub{M}}}
\end{prooftree}

=== Value Expressions
[[valueExpression]]
(((valof expression@`valof` expression)))
(((expressions,valof@`valof`)))

The `valof` expression computes a result based on the execution of a sequence of actions; the last (executed) action being a `valis` action.

\begin{figure}[htbp]
\begin{eqnarray*}
[[ValueExpression]]ValueExpression::=`valof`\ &lt;&lt;ActionBlock&gt;&gt;\\
  | `valof`\ &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.Valof Expressions
[[valueExpressionFig]]
\end{figure}

There may be a number of actions within the `valof` action; however, when a `valis` action is executed the `valof` is terminated and the value of the `valof` expression is the value associated with the `valis` action.

\begin{aside}
Each `valof` expression must contain at least one `valis` action. The execution of any of the `valis` actions terminates the `valof` itself; it acts much like a `return` in other programming languages.
\end{aside}

The `valof` expression is useful for those occasions where it is necessary to side-effect some variable as part of evaluation of an expression. The classic example of this is the counter, as illustrated in Program~\vref{counterProg}.
\begin{program}
[listing]
var Count := 0;
counter has type ()=&gt;integer;
counter() is valof{
  Count := Count+1;
  valis Count
};

.A Counting Program[[counterProg]]
\end{program}
\begin{aside}
Although the `valof` expression form _allows_ functions to be written in a procedural style, their use should be minimized to those cases where it is essential. In general, procedural programs are harder to debug and maintain and, furthermore, limit the potential for highly parallel execution.
\end{aside}</Text>
        </Document>
        <Document ID="4255C8CA-417E-4C5D-96FF-D5ECBD952E65">
            <Title>Typographical Conventions</Title>
            <Text>Any text on a programming language often has a significant number of examples of programs and program fragments. In this reference, we show these using a typewriter-like font, often broken out in a display form:
...
P : integer
...
We use the ... ellipsis to explicitly indicate a fragment of a program that is embedded in a context.
Occasionally, we have to show a somewhat generic fragment of a program where you, the programmer, are expected to put your own text in. We highlight such areas using an italicized typewriter font:
(Args) =&gt; Expr
This kind of notation is intended to suggest that Args and Expr are a kind of meta-variable which are intended to be replaced by specific text.
TIP: Some parts of the text require more careful reading, or represent comments about potential implications of the main text. These notes are highlighted the way this note is. 
WARNING: Occasionally, there are areas where the programmer may accidentally trip over some feature of the language.
</Text>
            <Comments>Notes which are not really part of the main exposition, but still represent nuggets of wisdom are relegated to footnotes.</Comments>
        </Document>
        <Document ID="3F037397-C1EB-4A21-AB0D-D3621ECC6D53">
            <Title>Largest and Smallest Integers</Title>
            <Text>The largeSmall contract is implemented for integers. This contract defines the largest and the smallest integers; its implementation is equivalent to
implementation largeSmall[integer] =&gt; {
  largest = 0x7fffffffffffffff
  smallest = 0x8000000000000000
}</Text>
        </Document>
        <Document ID="9E4BCB58-AFB3-4A01-A5D6-79A5952E11BF">
            <Title>Scalar Literal Expressions</Title>
            <Text>
There are three forms of scalar literal expression: numeric literals, string literals and enumerated symbols.
ScalarLiteral::=Integer
  | Float
  | String
  | EnumeratedSymbol
Scalar Literals
The integer type is used to denote integral values in the range -9223372036854775808 to 9223372036854775807.
Integers may be written in a variety of styles; the most common form is the simple Decimal notation.
Integer::=Decimal
  | Hexadecimal
  | CharacterCode
Integer Literals
</Text>
        </Document>
        <Document ID="BF84F849-6F09-462F-B0FC-5EB1F05FD05F">
            <Title>Enumerated Symbol</Title>
            <Text>An enumerated symbol is written as an identifier. The fact that an identifier has been mentioned in a type definition is sufficient to `mark' it as a value -- and not as a variable for example.
EnumeratedSymbol::=Identifier
Enumerated Symbols
The standard type boolean is defined in terms of two enumerated symbols: true and false:
boolean ::= true | false
[NOTE] An enumerated symbol must be unique across all types within the scope of the type definition.</Text>
        </Document>
        <Document ID="9FFBA333-8432-41C1-91F5-1302DFE283CA">
            <Title>Non-Fiction Format</Title>
            <Text>GENERAL NON-FICTION

About This Template
When compiled (File &gt; Compile), this project will generate a document in the standard manuscript format used for many types of non-fiction. Settings are also provided to make it easy to compile to a paperback-style PDF for self-publishing or an EPUB or Kindle ebook.

How To Use This Template
	•	Inside the “Manuscript” folder, create a new folder for each chapter and title each folder with the name of the chapter. (You do not need to—and indeed shouldn’t—title the folders “Chapter One” and so on, because chapter numbering will be taken care of automatically during the Compile process.) The first chapter folder has been created for you with the placeholder title “Chapter”.
	⁃	Note: The “Manuscript” folder is what we refer to in the documentation as the “Draft folder”. It’s just been renamed “Manuscript” in this template.
	•	Create a new text document for each section inside the chapter folders. (Upon export, sections will be separated with the “#” character for standard manuscript format, or with a blank line for other formats.)
	•	If you don’t require a foreword, move the “Foreword” document to the Trash folder. Alternatively, rename it “Preface” or “Introduction” if you prefer.
	•	“Notes” and “Ideas” folders have been provided for your convenience, although you can replace them or create different top-level folders for your research materials if necessary (these are just regular folders that have had custom icons assigned to them using the Documents &gt; Change Icon feature).

Tables and Figures
If you need to use tables or figures in your manuscript, you can label them using the following tags, replacing “KEYWORD” with a unique word that identifies your table or figure.

!fig(KEYWORD)
!table(KEYWORD)

These tags will be replaced with numbers in the compiled document, with the numbering stream for figures being separate from the numbering stream for tables.

You can refer to such tags as follows:

#fig(KEYWORD)
#table(KEYWORD)

Here’s an example:

Table !table(sales): Sales 2011
Table !table(dates): Shipment dates
Figure !fig(skeleton): The skeleton of the gnu.
Figure !fig(malcolmreynolds): The second coolest character in Firefly.

… (For sales figures, see table #table(sales))… For shipment dates, see table #table(dates)… where he discovered the skeleton of a gnarled gnu (see figure #fig(skeleton))… Chronicles providing a similar role, albeit without the Castle actor (see figure #fig(malcolmreynolds)).

In the compiled document, the above text would look like this:

Table 1: Sales 2011
Table 2: Shipment dates
Figure 1: The skeleton of the gnu.
Figure 2: The second coolest character in Firefly.

… (For sales figures, see table 1)… For shipment dates, see table 2… where he discovered the skeleton of a gnarled gnu (see figure 1)… Chronicles providing a similar role, albeit without the Castle actor (see figure 2).

Compiling
	•	Title pages and front matter are all provided in the “Front Matter” folder. Different front matter is used for different formats.
	•	A “Back Matter” folder is also provided. Here you can add any back matter hat is specific to each Compile format. Currently this only contains documents for storying endnotes (see below).
	•	Tip: You can open this document in a Quick Reference panel and have it open alongside the Compile panel if you need to refer to these instructions while compiling.

	•	To compile to standard manuscript format:
	◦	Edit the “Title Page” document inside the Front Matter/Manuscript Format folder to ensure that it contains the correct information (by default it will use information from Contacts).
	◦	To create your table of contents:
	⁃	Holding down the Command key, select all the documents you wish to be included in the contents listing. (Usually this will be “Foreword” and all chapter folders, but not the individual sections inside chapter folders. If you have footnotes and wish them to be added to the end of the manuscript as endnotes, you should also include the “Endnotes” document inside “Back Matter”.)
	⁃	Go to Edit &gt; Copy Special &gt; Copy Documents as ToC.
	⁃	Paste into the “Contents” document in the “Manuscript Format” front matter folder. (Tip: Use Format &gt; Font &gt; Underline to change or remove the dotted underline between the chapter names and page numbers.)
	⁃	The resulting linked text and page number tags will be replaced with the final chapter names and page numbers in the compiled document.
	⁃	Note that you don’t need to do this every time you compile, only when chapters have been added, deleted, renamed or moved around. (Note to Microsoft Word users: If you export to Word, you may need to generate a print preview in Word to force the page numbers to show up correctly - they may appear as question marks before doing so.)
	⁃	You don’t have to use “Copy Documents as ToC” to create a table of contents, by the way. You could equally construct one yourself using document links and placeholders - see “List of All Placeholders…” in the Help menu for more information on the latter.
	◦	Go to File &gt; Compile…
	◦	Next to “Compile for”, select “Print”, “PDF” or one of the rich text file formats such as RTF, Word or OpenOffice.
	◦	Select either “Non-Fiction Manuscript (Courier)” or “Non-Fiction Manuscript (Times)” from the list of formats on the left.
	◦	Ensure that the “Add front matter” button is ticked under the contents list on the right and that the “Manuscript Format” folder is selected in the pop-up button next to it. (This has already been set up for you.)
	◦	If you have footnotes in your text, they can either be included at the end of each page (the default) or as endnotes. To have them included as endnotes:
	⁃	Beneath the list of documents on the right side of the Compile pane, tick “Add back matter”. This will include the “Endnotes” document from the Back Matter/Manuscript Format folder.
	⁃	Click on the gear icon in the right-most header bar in Compile.
	⁃	Tick “Export inspector footnotes as endnotes” and “Export inline footnotes as endnotes”.
	◦	Click on “Compile”.

•	To compile to paperback PDF format:
	◦	Edit the front matter pages contained inside the Front Matter/Paperback folder.
	◦	Follow the instructions under compiling for standard manuscript format for creating a table of contents, but this time paste the contents list into the Front Matter/Paperback/Contents document.
	◦	Go to File &gt; Compile…
	◦	Next to “Compile for”, select “PDF”.
	◦	Select “Paperback (5.06” x 7.81”)” from the list of formats on the left.
	◦	Ensure that the “Add front matter” button is ticked under the contents list on the right and that the “Paperback” folder is selected in the pop-up button next to it if it. (This has already been set up for you.)
	◦	If you have footnotes in your text, they can either be included at the end of each page or as endnotes. See the instructions under compiling for standard manuscript format for information on how to include footnotes as endnotes (in this case, however, clicking “Add Back Matter” will include the “Paperback” back matter folder).
	◦	Click on “Compile”.

	•	To compile to ebook format:
	◦	Edit or remove the dedication page contained inside the Front Matter/Ebook folder. Feel free to add any other front matter documents as required.
	◦	Import a cover image (preferably in JPG or PNG format).
	⁃	You can store this anywhere, but it makes sense to place it in the “Ebook” front matter folder. A placeholder cover image is already provided—you will want to delete that once you have imported your own.
	⁃	Be sure to check online for recommended image sizes, because the recommendations are constantly changing. The sample cover image provided is 2,500 x 1,563 pixels, based on Amazon’s recommended size and proportions for a Kindle cover at the time this template was created.
	◦	Go to File &gt; Compile…
	◦	From the “Compile for” menu, select one of the ebook formats.
	⁃	To create an ePub file, choose the “ePub 3” format.
	⁃	To create a Kindle file, choose the “Kindle KF8/Mobi” format.
	⁃	“ePub 2” and “Kindle Mobi” are older versions of the formats. They are mainly provided for supporting projects created in older versions of Scrivener.
	◦	Select “Ebook” from the list of formats on the left.
	◦	If you have front matter documents other than the cover image, ensure that the “Add front matter” button is ticked under the contents list on the right and that the “Ebook” folder is selected in the pop-up button next to it. If you don’t have any front matter documents, you can un-tick “Add front matter”. (Un-ticking this does not affect the cover image.)
	◦	Above the contents list in the rightmost header bar are six buttons. Click on each of them in turn to go through the various available settings, changing what you need. In particular:
	⁃	Fill in the metadata such as author name and book title.
	⁃	Ensure your cover image is selected and shown.
	◦	Click on “Compile”.

Adding Sub-Heads
If you want your chapters divided into sections that each have their own sub-headings, simply use blank file groups for each heading, with each section under that heading a subdocument of the file group, like this:

#

Customising the Ebook Table of Contents
When exporting to ebook format, Scrivener automatically generates a table of contents. If you would like to customise what appears in the contents, follow these instructions:
	1.	Create a document for your table of contents inside the Front Matter/Ebook folder.
	2.	Name the document “Contents”.
	3.	In the binder, select the documents you would like to appear in the table of contents (hold down Command to select more than one document).
	4.	For a simple flat list, hit Cmd-C or use Edit &gt; Copy. Alternatively, if you would like the table of contents indented to match the binder structure, go to Edit &gt; Copy Special &gt; Copy Documents as Structured Link List.
	5.	Click into the text of the “Contents” document and hit Cmd-V or use Edit &gt; Paste. The documents you wish to appear in the table of contents will now appear as a list of links.
	6.	If you intend to export to an older ebook format (ePub 2 or non-KF8 Mobi), select all of the text and change it to use a 12-point font.
	7.	If you wish to centre the table of contents, select the text and centre it.
	8.	In the Inspector, change the “Section Type” of the “Contents” document to “Table of Contents”. Now, when you Compile, your custom “Contents” document will be used instead of the automatically-generated one. The titles in the links of the “Contents” document will automatically be updated to match those of the final compiled ebook.

Sample Document
See the “Sample MS” PDF file in the Research folder for an example of a document that has been created using this template.

Final Note
Scrivener project templates are flexible and are not intended to restrict you to a particular workflow. You can change, delete or move the files and folders contained in the template to suit how you work.

Like all templates in Scrivener, this project was originally created from the “Blank” template. We’ve simply added a few folders and set everything up in ways that should be useful to non-fiction authors. Everything you can do with this project, you could equally do by creating a “Blank” project and setting it up yourself.

You can create your own templates by setting up a skeletal project with the files, folders and settings you would like to use for new projects and using File &gt; Save As Template.</Text>
        </Document>
        <Document ID="801541C3-8A84-4468-AE3B-27F42D933881">
            <Title>Instance Constraint</Title>
            <Text>
[[instanceConstraint]]
(((type,constraints!instance)))

An &lt;&lt;InstanceConstraint&gt;&gt; is a requirement on a variable that any instantiation of the variable is an `instance of' a type -- typically that is a universally quantified type.


[[instanceConstraintFig]]
.Instance Type Constraint
****
[[InstanceConstraint]]InstanceConstraint ::= &lt;&lt;TypeVar&gt;&gt; `instance of` &lt;&lt;Type&gt;&gt;
****

For example, in
[listing]
r instance of (all t ~~ (t)=&gt;t)

we establish a constraint on `r` that any binding of `r` must be some specialization of the function type:
[listing]
all t ~~ (t)=&gt;t

Note that this would permit, for example, `r` to be bound to the `integer` function type:
[listing]
(integer)=&gt;integer

because this type is an instance of the &lt;&lt;UniversalType&gt;&gt;.

</Text>
        </Document>
        <Document ID="E1A79E16-1F2B-4F4D-9FC4-2D33E88858D1">
            <Title>Field Constraints</Title>
            <Text>A FieldConstraint is a requirement on a variable that whatever type it is, it should have particular attributes of particular types defined for it.
FieldConstraint ::= Type &lt;~ { &lt;&lt;TypeAnnotation&gt;&gt; ..  &lt;&lt;Annotation&gt;&gt; }
Field Constraint
For example, in
r &lt;~ { alpha : string. beta : long }

if r is unified against a concrete type then that type's RecordType interface must contain both of alpha and beta. In addition, the fields must be of the right types.
[NOTE] It is also possible to require that an EncapsulatedType exists. For example, the constraint:
s &lt;~ { type elem }
requires that any actual binding for type s must include the embedded type elem.
</Text>
        </Document>
        <Document ID="44F07D10-A101-4EDC-8D42-9C7528048BC2">
            <Title>Standard Contracts</Title>
            <Text>The language defines a few contracts as standard. These cover, for example, the concepts of equality, comparable, and sizeable entities and the arith operations. These contracts are integral to the semantics of the language.

Contract
Description
equality[t]
Definition of semantic equality
comparable[t]
Definition of comparability
arith[t]
Basic arithmetic
math[t]
Misc math functions
trig[t]
Trigonometry functions
bitstring[t]
Bitwise functions
sizeable[t]
Definition of size and empty
sequence[t]
Sequences of values
indexable[t]
Random access
iterable[t]
Iteration over collections
coercion[s,t]
Coerce between types
speech[a]
Actor speech actions
pPrint[t]
Pretty Print Display
computation[c]
Computation Expressions
execution[c]
Computation Expressions
Standard Contracts</Text>
        </Document>
        <Document ID="689098BC-F022-418B-9746-F26E3604F031">
            <Title>Syntax</Title>
            <Text>Given the extensible nature of Star, this description of syntax focuses on the term-level syntax: well formed forms of the language. This is composed of two layers: the lexical syntax which defines legal tokens and the grammar which defines legal combinations of tokens.</Text>
        </Document>
        <Document ID="0AEEC462-0442-4278-9F5E-F9ECDDD9BC4B">
            <Title>Defining new Operators</Title>
            <Text>Operators can be defined using one of the meta-statements listed below:
OperatorDeclaration ::= # [force] ( PrefixOperator | InfixOperator | PostfixOperator
 | BracketDeclaration)
PrefixOperator ::= prefix( OperatorName , Integer) |
    prefixAssoc( OperatorName , Integer )
InfixOperator ::= left( OperatorName , Integer ) |
     infix( OperatorName , Integer ) |
     right( OperatorName , Integer )
PostfixOperator ::= postfix( OperatorName , Integer) |
    postfixAssoc( OperatorName , Integer )
BracketDeclaration ::=pair( OperatorName  , OperatorName , Integer )
OperatorName ::= QuotedIdentifier
Operator Declaration
An operator declaration may only take place in a package body. Its scope is from the declaration statement to the end of the package body. In addition, any operator definitions are also made available to the importing context.
A new operator is defined using an operator definition statements:</Text>
        </Document>
        <Document ID="DB6ED59F-55BF-40FD-9053-625A634A4770">
            <Title>Infix Operator Definition</Title>
            <Text>A statement of the form:
#infix(‘myOp’,730).
defines the operator myOp to be an infix operator, with priority 730.
Defining an operator does not define anything about its semantics -- except that in the case of an infix operator, it has two arguments.</Text>
        </Document>
        <Document ID="E17E8BB7-8E12-4469-AFEE-ACD12A954D33">
            <Title>Paperback</Title>
        </Document>
        <Document ID="3DF77613-D05B-4CFA-8D39-05E51114DC6B">
            <Title>Defaults of ref Fields</Title>
            <Text>To declare a default value for a ref field, the form:
Identifier default := Expression
should be used. For example, in the type:
account ::= account{
  balance:ref integer
  balance default := 0
}
the balance field is a ref field, and its default value is 0.
</Text>
        </Document>
        <Document ID="C417ECD0-DA84-4B07-A81C-3F618C682BF6">
            <Title>Expressions-34</Title>
            <Text>
=== Let Expressions
[[letExpression]]
(((expressions,let expression@`let` expression)))
(((let expression@`let` expression)))

A `let` expression allows an expression to be defined in terms of  auxiliary definitions. There are two forms of the &lt;&lt;LetExpression&gt;&gt; -- allowing the programmer to choose whether the auxiliary definitions should precede the bound expression or follow it.

In addition, it is possible to use a record-valued expression in place of the set of definitions.

\begin{figure}[htbp]
\begin{eqnarray*}
[[LetExpression]]LetExpression::=`let`\ &lt;&lt;thetaEnvironment&gt;&gt;\ `in`\ &lt;&lt;Expression&gt;&gt;\\
  | &lt;&lt;Expression&gt;&gt;\ `using`\ &lt;&lt;thetaEnvironment&gt;&gt;
\end{eqnarray*}
.Let Expression
[[letExpressionFig]]
\end{figure}

(((theta environment)))
A `let` expression consists of a body -- which is a &lt;&lt;thetaEnvironment&gt;&gt; -- and a bound &lt;&lt;Expression&gt;&gt;. Within the &lt;&lt;thetaEnvironment&gt;&gt; may occur any of the permitted forms of definition: function definitions, variable definitions, type definitions, and so on. The scope of these definitions includes the bound expression.

\begin{aside}
`let` expressions are an important program structuring tool for programmers. It is worth emphasizing that `let` expressions are expressions! They can be used in many, perhaps unexpected, places.

For example, a `sort` function may require a comparison predicate in order to operate. This can be supplied as a named function:
[listing]
pComp has type (person,person)=&gt;boolean
pComp(someone{name=N1},someone{name=N2}) is N1&lt;N2

def S is sort(L,myCompare)

Or, the same may be achieved where the call to `sort` is not so conveniently close to a theta environment:
[listing]
sort(L, let{
  pComp has type (person,person)=&gt;boolean
   |  pComp(someone{name=N1},someone{name=N2}) is N1&lt;N2
} in pComp)

The `let` expression has major applications when constructing function-returning functions.
\end{aside}</Text>
        </Document>
        <Document ID="01CB622E-24E1-4CD3-8BD2-4BD76933B382">
            <Title>Type Variables and Safe Algebraic Type Definitions</Title>
            <Text>For an AlgebraicType definition to be safe requires a constraint on type variables within the definition. In particular, it is not permitted to introduce a type variable in any of the constructors in the definition.
[NOTE] Specifically, any unbound type variables mentioned in a type definition must also occur within the TypeSpec or be bound by an enclosing type quantifier.
For example, the type definition:
all t ~~ opaque ::= op(t)
is not valid because the type variable t mentioned in the op constructor is not mentioned in the TypeSpec.
[NOTE] The reason for this is that type safety cannot be guaranteed for such constructors. For example, consider the invalid function:
badOp(op(23)) =&gt; false
The type signature for badOp is
badOp:(opaque)=&gt;boolean
and, according to type inference rules, an expression such as:
badOp(op("alpha"))
would be type safe. However, this expression will lead to a run-time failure when the integer 23 is compared against the string "alpha".
[NOTE] Note that the converse case, where a type variable is mentioned in the TypeSpec is not mentioned in a constructor defined within the type definition is perfectly valid.
It is possible to have type variables mentioned in a constructor that are not defined in the TypeSpec. The constraint is that such type variables must be closed by quantification.
For example, the type definition:
univ ::= univ(all t ~~ t)
is a legally valid AlgebraicType definition; albeit one that is quite restricted. Locally quantified types are usually associated with function types:
uniFun ::= uniFun(all t ~~ (t,t)=&gt;t)
which describes a term constructor `uniFun` that expects a generic function as an argument.
</Text>
        </Document>
        <Document ID="420F9CDB-0A67-4964-923F-07FDD0FC0E3F">
            <Title>Variables</Title>
            <Text>%!TEX root = reference.tex
= Variables
[[variables]]

(((variable)))
(((expressions,variable)))

A &lt;&lt;Variable&gt;&gt; is a placeholder that denotes a value. Variables may be used to denote many kinds of values -- arithmetic values, complex data structures and programs.

\begin{figure}[htbp]
\begin{eqnarray*}
[[Variable]]Variable::=&lt;&lt;Identifier&gt;&gt;
\end{eqnarray*}
\vskip-1.5ex.Variables[[variableFig]]
\end{figure}

\begin{aside}
Any given variable has a single type associated with it and may only be bound to values of that type. footnote:[We sometimes informally refer to a variable being `bound' to a value X (say). This means that the value associated with the variable is X.]
\end{aside}

Variables have a `scope' -- a syntactic range over which they are defined. Variables can be said to be `free' in a given scope -- including functions that they are referenced within.

Variables can be classified into `single-assignment' variables (variables that denote values and are therefore not reassignable) and `re-assignable' variables. The latter have a different type signature that signals the re-assignable property.

== Variable Declaration
[[VariableDeclaration]]
(((variable,declaration of)))

A &lt;&lt;VariableDeclaration&gt;&gt; is a &lt;&lt;Definition&gt;&gt; or an &lt;&lt;Action&gt;&gt; that explicitly denotes the declaration of a variable. &lt;&lt;VariableDeclaration&gt;&gt;s may appear in &lt;&lt;thetaEnvironment&gt;&gt;s and &lt;&lt;Action&gt;&gt;s.
\begin{figure}[htbp]
\begin{eqnarray*}
[[VariableDeclaration]]VariableDeclaration::=`def`&lt;&lt;Pattern&gt;&gt;\ `is`\ &lt;&lt;Expression&gt;&gt;\\
  | `var`\ &lt;&lt;Identifier&gt;&gt;\ `:=`\ &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.Variable Declaration[[variableDeclarationFig]]
\end{figure}

(((single assignment variable)))
The left-hand side of a single assignment declaration may be a _Pattern_. This permits multiple variables to be declared in a single statement. This, in turn, facilitates the handling of functions that return more than one value.

For example, assuming that `split` partitions a `list` into a front half and a back half, returning both in a 2-tuple, the declaration:
[listing]
def (L,R) is split(Lst)

will bind the variables `L` and `R` to the front and back halves respectively.

(((reassignable variable)))
A re-assignable variable is declared using the form:
[listing][mathescape=true]
var $&lt;&lt;Variable&gt;&gt;$ := $&lt;&lt;Expression&gt;&gt;$


\begin{aside}
Unlike single assignment variable declarations, the re-assignable variable declaration is restricted to defining individual variables.
\end{aside}

\begin{aside}
It is not possible to declare a variable without also giving it a value.
\end{aside}

=== Variable Scope
[[scope]]
\hypertarget{Scope}{}
(((scope,variables, of)))
(((variable scope)))

In general, the scope of a variable extends to include the entire context in which it is declared. In the case of a variable declaration in a &lt;&lt;thetaEnvironment&gt;&gt;, the scope includes the entire &lt;&lt;thetaEnvironment&gt;&gt; and any associated bound element. In the case of an &lt;&lt;ActionBlock&gt;&gt; the scope extends from the action following the declaration through to the end of the enclosing &lt;&lt;ActionBlock&gt;&gt;.

The precise rules for the scope of a variable are slightly complex but result in a natural interpretation for the scopes of variables:

\begin{itemize}
(((pattern)))
\item Variables that are defined in patterns are limited to the element that is `naturally' associated with that pattern:
\begin{itemize}
\item Variables declared in the head pattern of an equation or other rule are scoped to that equation or rule.
(((conditional expression)))
(((expressions,conditional)))
(((loop,for@`for`)))
\item If a pattern governs a conditional expression or statement, variables declared in the pattern extend to the `then' part of the conditional but not to any `else' part.
\item If a pattern governs a `for` loop, or a `while` loop, then variables declared in the pattern extend to the body of the loop. (See &lt;&lt;forLoop&gt;&gt; and &lt;&lt;whileLoop&gt;&gt;).
\end{itemize}
\item Variables that are defined in a &lt;&lt;Condition&gt;&gt; are bound by the scope of the &lt;&lt;Condition&gt;&gt;.
\item Variables that are declared in a &lt;&lt;thetaEnvironment&gt;&gt; extend to all the  definitions in the &lt;&lt;thetaEnvironment&gt;&gt; and to any bound expression or action.
\begin{aside}
In particular, variables defined within a &lt;&lt;thetaEnvironment&gt;&gt; may be _mutually recursive_.
\begin{aside}
Note that it is _not_ permissible for a non-program variable to be involved in a mutually recursive group of variables. I.e., if a group of mutually recursive of variables occurs in a &lt;&lt;thetaEnvironment&gt;&gt; then all the variables must be bound to functions or other program elements.
\end{aside}
\end{aside}
\item Variables that are `import`ed into a package body from another package extend to the entire body of the importing `package`.
\item Variables that are declared in an &lt;&lt;ActionBlock&gt;&gt; extend from the end of their &lt;&lt;VarDeclaration&gt;&gt; to the end of the block that they are defined in. The scope of a variable does not include its &lt;&lt;VarDeclaration&gt;&gt;.

It is not permitted for a variable to be declared more than once in a given action block.
\end{itemize}

=== Scope Hiding
[[scopeHiding]]
(((scope,hiding)))
(((variable scope,hiding)))
It is not permitted to define a variable with the same name as another variable that is already in scope. This applies to variables declared in patterns as well as variables declared in &lt;&lt;thetaEnvironment&gt;&gt;s.

For example, the function:
[listing]
hider(X) is let{
  def X is 1;
} in X

is _not_ permitted because there would be two `X` variables with overlapping scope.
\begin{aside}
The reason for this rule is that scope hiding can be extremely confusing. The meaning of `X` in the `hider` function is very likely to be misunderstood by programmers and by others reading the program. There could be long distances between a local declaration of a variable and the same variable occurring in an outer scope.
\end{aside}

== Re-assignable Variables
[[reassignableVars]]

(((variable,re-assignable)))
Re-assignable variables serve two primary roles within programs: to hold and represent state and to facilitate several classes of algorithms that rely on the manipulation of temporary state in order to compute a result.

In order to facilitate program combinations -- including procedural abstraction involving re-assignable variables -- there are additional differences between re-assignable variables and single-assignment variables.

=== The `ref` Type
[[refType]]
(((ref type@`ref` type)))
(((type,ref@`ref`)))
Re-assignable variables have a distinguished type compared to single-valued variables. The type of a re-assignable variable takes the form:
[listing][mathescape=true]
ref $&lt;&lt;Type&gt;&gt;$

rather than simply &lt;&lt;Type&gt;&gt;. For example, given the declaration:
[listing]
var Ix := 0

the variable `Ix` has type `ref integer`; whereas the declaration:
[listing]
def Jx is 0

results in the variable `Jx` having type `integer`.

In addition to the different type, there are two operators that are associated with re-assignable variables: `ref` and `!` (pronounced _shriek_). The former is used in situations where a variable's name is intended to mean the variable itself -- rather than its value. The latter is the converse: where an expression denotes a reference value that must be `dereferenced'.

=== Re-assignable Variables in Expressions
[[referRef]]
(((referring to re-assignable variables,in expressions)))
There are two modes of referring to re-assignable variables footnote:[Here we automatically include local variables, theta variables and record fields in this discussion.] in expressions: to access the value of the variable and to access the variable itself. The primary reason for the latter may be to assign to the variable, or to permit a later assignment.

By default, an undecorated occurrence of a variable denotes access to the variable's value. Thus, given a variable declaration:
[listing]
var Cx := 0

then the reference to `Cx` in the expression:
[listing]
Cx+3

is understood to refer to the value of the variable:
[listing]
!Cx+3

This is formalized in the inference rule:
\begin{prooftree}
\AxiomC{\typeprd{E}{V}{`ref `T}}
\UnaryInfC{\typeprd{E}{V}{T}}
\end{prooftree}

If an expression is prefixed by the `ref` operator then this value interpretation is suppressed. I.e., if the expression has a `ref`erence type, then prefixing the expression with a `ref` suppresses this default `dereferencing' semantics:

\begin{prooftree}
\AxiomC{\typeprd{E}{V}{`ref `T}}
\UnaryInfC{\typeprd{E}{`ref `V}{`ref `T}}
\end{prooftree}

In the case that it is necessary to manually dereference an expression, the `!` operator may be used to achieve that:
\begin{prooftree}
\AxiomC{\typeprd{E}{Ex}{`ref `T}}
\UnaryInfC{\typeprd{E}{`!`Ex}{T}}
\end{prooftree}

=== Re-assignable Variables in Patterns
[[reVarInPattern]]
(((referring to re-assignable variables,in patterns)))
Patterns are used to introduce variables as well as to denote an implicit equality test. The semantics of re-assignable variables in patterns mirrors that of expressions: an undecorated reference to a re-assignable variable footnote:[It must be the case that there is a prior declaration or introduction of the variable that denotes it as re-assignable.] it understood to refer to the value of the variable.

A pattern of the form:
[listing][mathescape=true]
ref $&lt;&lt;Identifier&gt;&gt;$

is understood to refer to the introduction of a re-assignable variable.

For example, the procedure definition head:
[listing]
prc assign(ref X,V) do X:=V

introduces the variable `X` as a re-assignable variable.
\begin{aside}
When used in patterns of procedures (or other program rules), `ref`erence arguments _must_ be accompanied by `ref` expressions when the procedure is called. Thus, the `assign` procedure can be called only by explicitly `ref`erring to a variable:
[listing]
assign(ref X,34)

\begin{aside}
This example shows that it is straightforward to abstract over assignment when designing procedures.
\end{aside}
\end{aside}
The type of a `ref` pattern is also a `ref` type:
\begin{prooftree}
\AxiomC{\typeprd{E}{V}{T}}
\UnaryInfC{\typeprd{E}{`ref `V}{`ref `T}}
\end{prooftree}
\begin{aside}
The type of the `assign` procedure above is:
[listing]
for all t such that (ref t,t)=&gt;()

\end{aside}

== Variable Assignment
[[variableAssignment]]
(((assignment to variables)))
(((variables,assignment to)))

Assignment is an action that replaces the value of a re-assignable variable with another value. The variable being re-assigned must have a `ref` type -- there is no `implicit' assignability of a variable or field.

Assignment is defined in &lt;&lt;assignment&gt;&gt;.

=== Modifying Fields of Records
[[fieldModify]]
Assignability of variables does _not_ automatically imply that the value of the variable is itself modifiable. Thus, given a variable declaration such as:
[listing]
var P := someone{ name="fred"; age=23 }

the assignment:
[listing]
P.age := 24

is not valid -- because, while we can assign a new value to `P`, that does not confer an ability to modify the value that `P` has.

However, by marking a _field_ of a record type as a `ref` type, then we _can_ change that field of the record. Thus, for example, if the type of `person` were:
[listing]
type person is person{
  name has type string;
  age has type ref integer;
}

then the assignment:
[listing]
P.age := 24

is valid.
\begin{aside}
Note that one may change a suitably declared field of a record even when the variable 'holding' the record it not itself re-assignable.
[listing]
P is someone{ name="fred"; age := 23 }

I.e., re-assignability depends only on whether the target is re-assignable.
\end{aside}
</Text>
        </Document>
        <Document ID="8CC8804C-5B5C-45CC-86CC-CAA7BB4896A7">
            <Title>Default Contract Implementation</Title>
            <Text>A default implementation for a contract denotes an implementation to use for a contract when there is no known implementation. This can occur in two common situations: where a contract function is used that references a type that does not have an implementation for the contract, and where there is no type information.
[TIP] It is strongly recommended that the default implementation is generic; i.e., that the definition of the individual functions are generic. The contract type should be denoted by a variable and all the contract functions should be generic.
For example, the implementation statement:
implementation all r ~~ equality[r] default =&gt; {
  L=R =&gt; __equal(L,R)
}
uses a generic internal definition of __equal.
As noted above, a default implementation is only used in restricted circumstances:
	•	No available implementation. If a contract is referenced for a type that does not implement the contract then the `default` implementation will be used. For example, given a contract:
contract all t ~~ foo[t] ::= {
  bar:(t)=&gt;boolean
}
and the functional expression:
bar("fred")
then, if foo is not implemented for strings then the default implementation will be used for this expression. Of course, if there is no default implementation then a compile error will be flagged.
	•	Variable type. In a few circumstances a reference may be made to a contract involving no known types. For example, in the condition:
XX = nil
there is a hidden type variable associated with the enumerated symbol nil.
The symbol nil is from the standard definition of cons:
all t ~~ cons[t] ::= nil | cons(t,cons[t])
Since the type of nil is under-constrained -- i.e., the type of nil as an expression involves a type variable that is not constrained at all by the nil symbol -- even if equality is implemented for many types there is no way of knowing which implementation to use in this situation. In this case, a default implementation will be used if provided.</Text>
            <Comments>Whichever implementation is used in this case does not actually matter: it will never be invoked.</Comments>
        </Document>
        <Document ID="3D707F9E-6E7B-4A2B-BF04-64BD98EC07A8">
            <Title>Notes</Title>
            <Text>&lt;$--ENDNOTES--&gt;</Text>
            <Notes>The &lt;$--ENDNOTES--&gt; tag will be replaced by the footnotes during Compile. Using this tag allows us to have the footnotes inserted wherever we like, without having a separator placed above them.</Notes>
        </Document>
        <Document ID="29CBBE76-EE59-4B74-A4A4-5C261E59772C">
            <Title>Subsumption of Quantified Types</Title>
            <Text>
Subsumption of quantified types must take into account the implied semantics of the quantifiers: a &lt;&lt;UniversalType&gt;&gt; is less general than its bound type and so on.

For simplicity of presentation we assume that all quantified types have been alpha-renamed so that no two quantified terms have the same bound variable.

\begin{itemize}
\item Any type subsumes its universally quantified variant if its subsumes a `refreshed' variant of the latter:

\begin{prooftree}
\AxiomC{\entail{E,\theta\subi}{t\sub1\subsume{}t'\sub2\leadsto\theta\sub{o}}}
\AxiomC{\ensuremath{t'\sub2=t\sub2[x/x']}}
\BinaryInfC{\entail{E,\theta\subi}{t\sub1\subsume`for all x such that `t\sub2\leadsto\theta\sub{o}}}
\end{prooftree}
where $x'$ is a variable not occurring elsewhere and $t[x/u]$ refers to the result of replacing occurrences of $x$ in $t$ with $u$.


\item A universally quantified type subsumes a type if the bound type of the former subsumes the latter without binding the bound variable.

\begin{prooftree}
\AxiomC{\entail{E,\theta\subi}{t\sub1\subsume{}t\sub2\leadsto\theta\sub{o}}}
\AxiomC{\ensuremath{x/t\notin\theta\sub{o}}}
\BinaryInfC{\entail{E,\theta\subi}{`for all x such that `t\sub1\subsume{}t\sub2\leadsto\theta\sub{o}}}
\end{prooftree}

\item An existentially quantified type subsumes a type if a `refreshed' variant of the
former subsumes the latter:

\begin{prooftree}
\AxiomC{\entail{E,\theta\subi}{t'\sub1\subsume{}t\sub2\leadsto\theta\sub{o}}}
\AxiomC{\ensuremath{t'\sub1=t\sub1[x/x']}}
\BinaryInfC{\entail{E,\theta\subi}{`exists x such that `t\sub1\subsume{}t\sub2\leadsto\theta\sub{o}}}
\end{prooftree}

\item A type subsumes its existentially quantified variant if
the former subsumes the bound type of the latter without affecting the bound variable.

\begin{prooftree}
\AxiomC{\entail{E,\theta\subi}{t\sub1\subsume{}t\sub2\leadsto\theta\sub{o}}}
\AxiomC{\ensuremath{x/t\notin\theta\sub{o}}}
\BinaryInfC{\entail{E,\theta\subi}{t\sub1\subsume{}`exists x such that `t\sub2\leadsto\theta\sub{o}}}
\end{prooftree}

\end{itemize}


</Text>
        </Document>
        <Document ID="0EB16FF9-6C9D-4FA9-B47D-F8902B6AD165">
            <Title>Sample MS</Title>
            <Text>Amy Nonomusse
Your manuscript should have your address
and contact details
on the first page only.
If you have an agent, your agent’s address can be included beneath.
900 words
Non-Fiction Standard Manuscript Format by A. Nonomusse
Contents
Foreword 1 Chapter One - Folder Names Become Subtitles 2 Chapter Two - Another Chapter Folder 4
Foreword
Non-fiction works often feature a foreword or preface. This usually comes after the table of contents, but not always—sometimes the foreword precedes the table of contents. If you need your foreword to come before the table of contents, place the “Contents” document after “Foreword” in the Manuscript folder. You can also rename “Foreword” to "Preface" or "Introduction", or delete it entirely, depending on your requirements.
The table of contents is generated using Scrivener's Edit &gt; Copy Special &gt; Copy Documents as ToC feature. Simply select the documents in the binder that you want to include in your table of contents, select "Copy Documents as ToC" from the Edit &gt; Copy Special menu, and then hit Edit &gt; Paste (cmd-V) in the "Contents" document. The results won't look much in Scrivener's editor—a bunch of linked text with "&lt;$p&gt;" page number tags after it—but when compiled this will become a proper table of contents using the correct chapter titles. Remember to update your table of contents if you move, add, delete or rename any chapters.
Nonomusse / NON-FICTION MS / 1
Chapter One
Folder Names Become Subtitles
Standard manuscript format is often required for novels so that work can easily be read by editors. It allows editors to estimate word count and determine roughly how many pages will be required to produce a book using the page size, style and font used by their house.1 This PDF file was generated using Scrivener's Compile feature and was created using the “General Non-Fiction” project template.
Manuscripts for full-length novels require a separate title page. The author's name, address, telephone number and e-mail address should be shown in the upper-left corner of the title page, single-spaced. The title of the work should appear about half-way down the page. The author's name follows the title on the by-line as the author wants it to appear when published. A real name or pseudonym may be used and may include initials, actual given name or professional designation.
A table of contents and foreword, preface or introduction may follow the title page, preceding the main text.
All text should be double-spaced and left-justified with a ragged right margin.
Nonomusse / NON-FICTION MS / 2
Paragraphs should be indented by about five spaces (half an inch) and not separated by an additional blank line. (It used to be traditional to separate each sentence with two spaces, but in these days of word processors this is now less common.) A 12-point font such as Courier, Times New Roman or Arial should be used throughout. In Scrivener, however, you can write using any font and formatting you choose —the Compile options can be used to change the formatting in the final document. In the “General Non-Fiction” project template, the Compile settings will deal with changing the font and formatting to those required for standard manuscript format.
Top, bottom, left and right margins should all be approximately one inch, not allowing for the page header. Each page except for the title page should include a header comprising the author's real surname, the title of the work (or a key word from the title) in capitals, and the page number. In Scrivener, all of this is handled by the Compile settings.
#
Section breaks are indicated with the hash character. Do not simply add an extra line space as this can be missed by the typesetter. In general, this will be handled by Compile in Scrivener,
however, so that you can either leave empty lines in the text (and Scrivener will insert the hash character during Compile) or use different documents for different sections (and Scrivener will add the hash between them).
Some editors and publishers prefer emphasis to be indicated by underlining rather than italics. In Scrivener, this conversion can be handled by Compile. The “General Non- Fiction (Courier)” Compile format will convert italics to underlines, whereas the “General Non-Fiction (Times)” format will not.
Nonomusse / NON-FICTION MS / 3
Chapter Two Another Chapter Folder
Begin each new chapter on a new page like this with the chapter number about a third of the way down the page. In Scrivener, all of this is handled automatically by the “General Non- Fiction” compile formats.
Although it is often said that writers should not use the word-count features of their computers to determine the number of words in a manuscript, most publishers and editors will happily accept a word processor word count these days. In Scrivener, you can insert a word count of your manuscript by using Edit &gt; Insert &gt; Draft Word Count (for a manuscript, you may wish to have the word count rounded to the nearest 100, in which case select Edit &gt; Insert &gt; Draft Word Count &gt; Rounded To Nearest 100—this feature is used on the title page of this manuscript, in fact). Note that the actual word count will not be inserted, but a tag that will be substituted for the word count upon export.
#
Footnotes should generally be numbered sequentially throughout the manuscript and appear
as endnotes at the very end.2 However, different editors and publishers have different
Nonomusse / NON-FICTION MS / 4
requirements when it comes to footnotes, so you should always check the submission guidelines.3
In reality, the formatting of a manuscript is often only really crucial when submitting directly to a publisher—first time authors will usually submit to an agent first, and agents are often less picky about format and will point you in the right direction before submitting your work to a publisher.
Nonomusse / NON-FICTION MS / 5
Endnotes
1. Much of the information contained in this document is based on a description of novel manuscript format by Matt Carless for the BBC Writers' Room website (http:// www.bbc.co.uk/writersroom), along with various web resources describing non-fiction manuscript format (the basics of standard manuscript format is commonly used for both fiction and non-fiction).
2. Useful information about non-fiction manuscript formatting was also taken from this web page: http://calemccaskey.blogspot.com/2011/05/how-to-prepare-non-fiction- manuscript.html
3. Note that if you require more advanced footnote and endnote layout, or if you require indexes, you should compile to RTF or Word format and open the generated file in your word processor of choice for a final pass.
Nonomusse / NON-FICTION MS / 6
</Text>
        </Document>
        <Document ID="B5BAD6CD-B8F5-469F-9D65-288D1D5001DD">
            <Title>Dedication</Title>
            <Text>




Your dedication here.</Text>
            <Notes>Feel free to delete this document if you don’t need it.</Notes>
        </Document>
        <Document ID="EB17E018-D0BF-4966-84EB-62D88FFF2D36">
            <Title>Pattern Abstraction Type</Title>
            <Text>A PatternAbstraction is an abstraction of a pattern. Pattern abstractions allow patterns to be treated as first class values -- i.e., passed in as arguments to programs and bound to variables -- and they may be applied in contexts where patterns are valid.
PatternType ::= TupleType &lt;= Type
Pattern Type
Pattern abstractions match a pattern, and extract values from that pattern; values that, in turn, may be matched against where the pattern abstraction is applied.
For example, a PatternAbstraction that matches strings that are intended to denote integer literals, and extracts such an integer would have the type
(integer) &lt;= string
</Text>
        </Document>
        <Document ID="6F790C24-8718-4C82-BCFD-EF27C519E50B">
            <Title>Associative Prefix Operator</Title>
            <Text>A statement of the form:
#prefixAssoc(‘prOp’,730).
defines the operator prOp to be an _associative_ prefix operator, with priority 730. That means that expressions such as:
prOp prOp prOp A
are permitted, and have interpretation:
(prOp (prOp (prOp A)))</Text>
        </Document>
        <Document ID="ABE31060-DFF4-48AB-A7F2-3A9590F36D05">
            <Title>Type Subsumption</Title>
            <Text>The type system is based on the concept of type _subsumption_. One type subsumes another if either it is already equivalent under some substitution or it is `more general' than the other.

The intuition is that if a function expects a certain kind of argument then either a value of exactly that type or one that is more general may be supplied.

We express this formally in terms of a subsumption relation `subsume`:
\[
T\sub1\subsume{}T\sub2
\]
is read as
\begin{quote}
$T\sub1$ subsumes, or is more general than, $T\sub2$.
\end{quote}
In general, type checking takes place in a certain context. For subsumption, this context defines available implementations of contracts as well as recording the types of variables. Furthermore, subsumption is likely to lead to the instantiation of type variables. Hence, in general, the predicate that we establish takes the form:
\[\entail{E,\theta\sub{in}}{T\sub1\subsume{}T\sub2}\leadsto\theta\sub{out}\]
where \ensuremath{\theta}
takes the form \ensuremath{\{x\sub1/t\sub1\sequence{,}x\subn/t\subn}\}
and defines a substitution of types t\subi{} for type variables x\subi{} where a given variable occurs at most once in the left hand side of a $x\subi/t\subi$ pair.

\begin{aside}
We do not take account of constraints at this time.
\end{aside}

====</Text>
        </Document>
        <Document ID="A222CE33-2038-4E34-B5B0-A172353DD2AE">
            <Title>Expressions-33</Title>
            <Text>
==== Type Safety
The type safety requirements of a conditional expression are that the types of the two arms of the conditional are the same, and that the condition itself is \safeinf{}:

\begin{prooftree}
\AxiomC{\typesat{E}{C}}
\AxiomC{\typeprd{E}{Th}{t}}
\AxiomC{\typeprd{E}{El}{t}}
\TrinaryInfC{\typeprd{E}{`(`C`?`Th`:`El`)`}{t}}
\end{prooftree}


=== Switch Expressions
[[caseExpression]]
(((expressions,case@`case`)))
(((case expression@`case` expression)))

A `switch` expression uses a selector expression and a set of equations to determine which value to return.
\begin{aside}

\begin{figure}[htbp]
\begin{eqnarray*}
[[CaseExpression]]CaseExpression::=`switch`\ &lt;&lt;Expression&gt;&gt;\ `in`\ &lt;&lt;CaseBody&gt;&gt;\\
[[CaseBody]]CaseBody::=`\{`&lt;&lt;CaseArm&gt;&gt;\sequence{`;`}&lt;&lt;CaseArm&gt;&gt;`\`}\\
[[CaseArm]]CaseArm::=`case`\ &lt;&lt;Pattern&gt;&gt;\ `is`\ &lt;&lt;Expression&gt;&gt;\\
  | `case`\ &lt;&lt;Pattern&gt;&gt;\ `default`\ `is`\ &lt;&lt;Expression&gt;&gt;
\end{eqnarray*}
.Case Expression
[[caseExpressionFig]]
\end{figure}

The `selector' expression is evaluated, and then, at most one of the &lt;&lt;CaseArm&gt;&gt;s is selected based on whether the &lt;&lt;Pattern&gt;&gt; matches or not. If one of these does match, then the corresponding &lt;&lt;Expression&gt;&gt; on the right hand side is evaluated as the value of the `switch`.

Program~\vref{dogCaseProg} shows a simple example of a `switch` expression, in this mapping `string`s to `integer`s.
\begin{program}
[listing]
switch Alpha in {
  case "dog" is 1;
  case "pup" is 2;
  case _ default is -1
}

.A `case` of Dogs Program[[dogCaseProg]]
\end{program}


Each &lt;&lt;CaseArm&gt;&gt;'s pattern may introduce variables; these variables are `in scope' only for the corresponding right hand side expression.

Optionally, a `switch` expression may have a `default` clause. This clause determines the value of the expression if none of the other &lt;&lt;CaseArm&gt;&gt;s match.

\begin{aside}
The &lt;&lt;Pattern&gt;&gt; associated with a `default` should always apply. If the `default` clause does not match then an exception will be raised.
\end{aside}

\paragraph{Evaluation Order}
Other than handling of the `default` case, the different &lt;&lt;CaseArm&gt;&gt;s are attempted in the order of appearance in the text.

I.e., the `default` &lt;&lt;CaseArm&gt;&gt; is tried only if all other &lt;&lt;CaseArm&gt;&gt;s do not apply.

==== Type Safety
The type safety requirements of a `case` expression are that the types of the patterns of each &lt;&lt;CaseArm&gt;&gt; are the same, and are the same as the selector expression. In addition, the right hand sides of the &lt;&lt;CaseArm&gt;&gt;s should also be consistently typed.

\begin{prooftree}
\AxiomC{\typeprd{E}{S}{T}}
\AxiomC{\typeprd{E}{P\subi}{T}}
\AxiomC{\typeprd{E$\cup{}$varsIn(P\subi)}{E\subi}{T\sub{e}}}
\TrinaryInfC{\typeprd{E}{`switch`\ S\ `in\{`\sequence{}`;``case`\ P\subi\ `is`\ E\subi`;`\sequence{}`\`}}{T\sub{e}}}
\end{prooftree}

In the case that there is a `default` clause, then that too must agree:
\begin{prooftree}
\AxiomC{\typeprd{E}{S}{T}}
\AxiomC{\typeprd{E}{P\subi}{T}}
\AxiomC{\typeprd{E$\cup{}$varsIn(P\subi)}{E\subi}{T\sub{e}}}
\TrinaryInfC{\typeprd{E}{`switch`\ S\ `in\{`\sequence{}`;``case`\ P\subi\ `is`\ E\subi`;`\sequence{}`case`\ P\subn\ `default`\ `is`\ E\subn`\`}}{T\sub{e}}}
\end{prooftree}

`switch` expressions may not be used that often explicitly. However, the compiler will often construct them during the process of compiling functions.
\end{aside}</Text>
        </Document>
        <Document ID="A4648FB0-2C68-4B37-A4BB-C8908A25BAA9">
            <Title>Strings</Title>
            <Text>%!TEX root = reference.tex
= Strings
[[strings]]
A string is a sequence of Unicode characters that denotes a fragment of text. This chapter focuses on the built-in functions that are based on the `string` type.

== The Structured String `pP` Type
[[ppType]]
(((pP type)))
(((type,pP@`pP`)))
The `pP` type -- as defined in Program~\vref{ppTypeProg} -- denotes a `structured `string`' value where the structure may be used to represent lines, sub sequences and so on.
\begin{aside}
A primary purpose of the `pP` type is to permit simple formatting policies to be applied after the generation of the displayed form of a value.
\end{aside}

\begin{program}
[listing]
type pP is
     ppStr(string)
  or ppSequence(integer,cons[pP])
  or ppNl
  or ppSpace;

.The Structured String `pP` type[[ppTypeProg]]
\end{program}

The intended semantics of the constructors are:
\begin{description}
`ppStr`:: A literal string. Whenever a literal string is to be generated, the `ppStr` constructor is used to `hold' that string. For example, if the display of a value calls for an opening parenthesis, then the term:
[listing]
ppStr("(")

may be used to denote that.
`ppSequence`::
The `ppSequence` constructor signals a subsequence in the display. It has two arguments: the first is an indentation amount, and the second is a `cons` list[sub]-elements.

The indentation is used if a newline is generated within the subsequence. In that case, the new lines will be indented by the amount requested.
`ppNl`::
Signal a new line in the displayed sequence.
\begin{aside}
Simply signaling a new line does actually imply that a new line will be generated. New lines are generated depending on whether the client of the pretty print requires one in the actual displayed output.
\end{aside}
`ppSpace`::
The `ppSpace` symbol denotes a `line-breakable' space. Multiple `ppSpace`s in sequence are equivalent to a single one.
\end{description}

== The `pPrint` contract
[[pPrintContract]]
(((pPrint contract@`pPrint` contract)))
(((pretty print contract)))

The standard contract `pPrint`, shown in Program~\vref{ppContractProg} together with the `pP` type shown in Program~\vref{ppTypeProg}, is at the core of the standard method for displaying arbitrary values.
\begin{program}
[listing]
contract pPrint over t is {
  ppDisp has type (t)=&gt;pP
};

.The Standard `pPrint` Contract[[ppContractProg]]
\end{program}
The Star compiler will automatically generate implementations of the `pPrint` contract for all user-defined types. However, it will not override any implementations defined by the user.
\begin{aside}
It is not guaranteed that _all_ user-introduced types will be detected. In particular, some anonymous types are implicitly introduced by the programmer and these are not guaranteed to be detected.

However, if the compiler cannot find an implementation of `pPrint` then a default implementation will be used.
\end{aside}

The purpose of the `pPrint` contract is to support the standard `display` function -- see &lt;&lt;displayFunction&gt;&gt;. This, in turn, is used whenever a string &lt;&lt;Interpolation&gt;&gt; expression is used.

\begin{aside}
One of the primary benefits of allowing programmers to define their own implementation of `pPrint` is to enable higher quality display of values. By defining `pPrint` for yourself, you can use application oriented display of your values.
\end{aside}


=== Implementing the `pPrint` Contract
As noted above, the `pPrint` contract is automatically implemented for standard types and for user-introduced types. However, it is quite possible to define one's own implementation. For example, supposing that values of the `tree` type:
[listing]
type tree of t is empty or node(tree of t,t,tree of t)

were intended to be display:
[listing]
{ "alpha" "beta" "gamma" }

instead of the default form:
[listing]
node(node(empty,"alpha",empty),"beta",node(empty,"gamma",empty))

then the following implementation of `pPrint` would ensure that such trees were displayed more conveniently:
[listing]
implementation for all t such that
    pPrint over tree of t where pPrint over t is {
  ppDisp(T) is ppSequence(2,cons of [ppStr("{"),
                                         treeDisplay(T),
                                         ppStr("}")])
} using {
  treeDisplay(empty) is ppSpace
   |  treeDisplay(node(L,Lb,R)) is
        ppSequence(0,cons of [treeDisplay(L),
                              ppDisp(Lb),
                              treeDisplay(R)]);
}

\begin{aside}
Note how the use of `ppDisp` within the definition of `treeDisplay` will ensure that the display of tree labels may also be overridden with user-defined implementations of `pPrint`.
\end{aside}

=== `display` -- display a value as a string
[[displayFunction]]
[listing]
display has type for all s such that
                 (s)=&gt;string where pPrint over s

The `display` function returns a `string` representation of its value.

The `display` function is defined in terms of the `pPrint` contract defined in Program~\vref{ppContractProg}.
\begin{aside}
Although the system attempts to format the result in a way that can be parsed back; this is not guaranteed. In particular, this is not possible for any values that represent programs -- such as functions and procedures. Furthermore, user-defined implementations of `pPrint` may result in non-parseable output.
\end{aside}

== The `formatting` Contract
[[formatContract]]
The `formatting` contract specifies the single `\_format` function which is intended to represent how values should be formatted.

The `formatting` contract itself is defined in Program~\vref{formatContractProg}. The result of a call to `\_format` is a structured `string`.

\begin{program}
[listing]
contract formatting over t is {
  _format has type (t,string)=&gt;pP;
}

.The `formatting` Contract[[formatContractProg]]
\end{program}



\begin{aside}
Normally, like `display`, calls to `\_format` are represented implicitly in string &lt;&lt;Interpolation&gt;&gt; expressions.
\end{aside}
=== Formatting Codes
[[formattingCodes]]
A formatting code is a description of how a numeric or `string` valued expression should be displayed. Formatting codes allow more detailed control of the representation of the format in terms of minimum and maximum widths of output, the number of decimal places to show and the style of representing numbers -- including how negative numbers are displayed and the display of currencies.

A formatting code is introduced with a `:` character immediately after the `\$` form and is terminated by a `;` character. An invalid formatting code is ignored, and treated as though it were part of the quoted string proper.

Each type of value to be formatted may have different formatting codes; reflecting the natural variations in the type. For example formatting integral values may involve ways of managing the display of the sign of the number and formatting `date` values involves ways of show dates and times.

For example, to show a dollar value -- represented as pennies -- in _accounting style_ we can use:
[listing]
"Balance: $Amnt:P999900.00P; remaining"

This format spec displays at least the four least significant digits of the variable `Amnt`. If the value of that variable is greater than 9999 then the leading digits are displayed also -- up to a maximum of eight digits. If the value of `Amnt` is negative then the number is displayed enclosed in parentheses.

For example, if `Amnt` had value -100000, then the value of the expression would be:
[listing]
Balance: (1000.00) remaining

If `Amnt` were 10000:
[listing]
Balance:  1000.00  remaining

\begin{aside}
Note the additional spaces: if the  `P` mode is used for representing sign, a white space character is generated for positive numbers. This facilitate straightforward alignment of columnar reports.
\end{aside}
If `Amnt` had value 45, then the result would be:
[listing]
Balance:  00.45  remaining

The `'0'` in the format will result in leading zeros being printed.
\begin{aside}
If a value cannot be represented in the delimited number of characters then the string:
[listing]
*Error*

is displayed; at least, as much of `*Error*` as is possible in the allocated space.\end{aside}


=== `format` -- format a string for display
[[formatStringFunction]]
[listing]
format has type (string,string)=&gt;string


\begin{aside}
The `format` function for `string` values is normally invoked implicitly within a `string` &lt;&lt;Interpolation&gt;&gt; expression. For example,
[listing]
"--$Msg:C13;--"

is equivalent to the expression:
[listing]
"--"++format(Msg,"C13")++"--"

and has value:
[listing]
"--   freddie   --"

assuming that the value of the `Msg` variable is `"freddie"`.
\end{aside}

The format specification for `string` values is given in the regular expression:
[listing]
`[LCR][0-9]+`

where each control code is defined:
\begin{description}
`L`::
The value is shown left-aligned in the text.

The decimal value immediately after the `L` character is the size of the field.

If the displayed length of the number or string is less than that permitted; then the value is shown left-aligned. If the length of the value is greater than the size of the field then the text is truncated -- i.e., the first N characters of the value are used.

`R`:: The value is shown right-aligned in the text -- if the length of the value is less than the size of the field.

If the length of the value is greater than the size of the field then the text is truncated.

`C`:: The value is shown centered in the field.
\end{description}

\begin{aside}
The `format` function is defined in terms of the `\_format` function and the `formatting` contract -- see Program~\vref{formatContractProg}.
\end{aside}

== Standard String Functions
[[simpleString]]
In addition to certain specific string functions -- such as string concatenation -- the `string` type implements the `comparable` contract which enables `string` values to be compared. The `indexable` contract -- see Program~\vref{sizeableContract} -- is also implemented for `string`s, which means that the normal `[]` notation may be used to access the characters of a string.

=== `isEmpty` -- test for empty string
[[stringEmptyFunction]]
`isEmpty` is part of the standard `sizeable` contract (see Program~\vref{sizeableContract}):
[listing]
isEmpty has type (string)=&gt;boolean

The `isEmpty` function returns true if its argument is the empty string. It's definition is equivalent to:
[listing]
isEmpty(X) is X="";


=== `size` -- size of the string
[[stringSizeFunction]]
`size` is part of the standard `sizeable` contract (see Program~\vref{sizeableContract}):
[listing]
size has type (string)=&gt;integer

The `size` function returns the number of Unicode characters in the `string`. Note that this is not generally the same as the number of bytes in the string.

=== `flattenPP` -- Flatten a Structured String
(((flattenPP@`flattenPP`)))
[listing]
flattenPP has type (pP)=&gt;string;

The `flattenPP` function takes a structured string and `flattens it' into a regular `string`.

\begin{aside}
This function is used by the standard functions `display` and `format` to convert the result of displaying or formatting a value into a `string`.
\end{aside}

=== `&lt;` -- less than
(((&lt;@`&lt;` predicate)))
[listing]
(&lt;) has type (string,string)=&gt;boolean

`(&lt;)` is part of the standard `comparable` contract -- see Program~\vref{comparableContract}.

String comparison is based on a lexicographic comparison: one `string` is less than another if its first character is less than the first character of the second -- irrespective of the actual lengths of the strings. Thus
[listing]
Abbbbbbb &lt; B

because `A` is less than `B`. Characters are compared based on their _code point_ within the Unicode encoding. footnote:[This is the same concept of string ordering as that within Java\tm.]

=== `=&lt;` -- less than or equal
(((=&lt;@`=&lt;` predicate)))
[listing]
(=&lt;) has type (string,string)=&gt;boolean

`(=&lt;)` is part of the standard `comparable` contract -- see Program~\vref{comparableContract}.

The `=&lt;` predicate for `string` values is satisfied if the left argument is less than or equals to the right argument under the lexicographic ordering.

=== `&gt;` -- greater than
(((&gt;@`&gt;` predicate)))
[listing]
(&gt;) has type (string,string)=&gt;boolean

`(&gt;)` is part of the standard `comparable` contract -- see Program~\vref{comparableContract}.
The `&gt;` predicate is satisfied if the left argument is lexicographically greater than the right argument.

=== `&gt;=` -- greater then or equal
(((&gt;=@`&gt;=` predicate)))
[listing]
(&gt;=) has type (string,string)=&gt;boolean

`(&gt;=)` is part of the standard `comparable` contract -- see Program~\vref{comparableContract}.
The `&gt;=` predicate is satisfied if the left argument is lexicographically greater than or equal to the right argument.

=== `\_index` -- Index Codepoint from String
[[indexString]]
`\_index` is part of the standard `indexable` contract -- see Program~\vref{indexableContractDef}.
[listing]
_index has type (string,integer)=&gt;option of integer

The `\_index` function returns a CodePoint from a `string` value at a particular position.

One can use the the normal indexing notation to access CodePoints from a `string` -- as with other kinds of `indexable` types:
[listing]
S[ix]

instead of
[listing]
_index(S,ix)


=== `\_slice` -- Substring
[[sliceString]]
`\_slice` is part of the `sliceable` contract -- see Program~\vref{sliceableContractProg}.
[listing]
_slice(string,integer,integer)=&gt;string

The `\_slice` function extracts a substring from its first argument. The first character of the extracted substring is identified by the second argument; and the end point of the substring is identified by the third argument. An expression of the form:
[listing]
_slice("this is a string",5,7)

returns the substring `"is"` -- corresponding to the two characters located at positions 5 and 6 in the source string.

There is a special notation for this functionality: the slice notation (see &lt;&lt;sliceFunction&gt;&gt;. For example, if the variable `S` is bound to the string `"this is a string"`, then the above expression may be written:
[listing]
S[5:7]


=== `\_splice` -- Replace Substring
[[spliceString]]
`\_splice` is part of the `sliceable` contract -- see Program~\vref{sliceableContractProg}.
[listing]
_splice has type (string,integer,integer,string) =&gt; string

The `\_splice` function replaces a substring within its first argument. For example, the expression:
[listing]
_splice("this is a string",5,7,"was")

has, as its value:
[listing]
"this was a string"


Like the `\_slice` notation, there is special syntax for this function -- when used as an action. The action:
[listing]
S[ix:tx] := U

is equivalent to the assignment:
[listing]
S := _splice(S,ix,cx,U)


=== `++` -- string concatenation
[[stringConcatFunction]]
`++` is the standard string concatenation function. It is part of the `concatenate` contract (see Program~\vref{concatenateContractDef})
[listing]
(++) has type (string,string)=&gt;string;


(((string,interpolation)))
Use of the `++` function over strings is implied by the _string interpolation expression_ (see &lt;&lt;StringInterpolation&gt;&gt;). For example, the string expression:
[listing]
"Count = $count, Sum=$sum"

is shorthand for
[listing]
"Count ="++display(count)++", Sum="++display(sum)


=== `explode` -- Explode a string to code points
[[stringExplodeFunction]]
The `explode` function is part of the `explosion` contract.
[listing]
explode has type (string)=&gt;cons[integer];

\begin{aside}
This version of the `explode` function is useful when performing complex operations over `string` values. For example, it can be more efficient to first of all `explode` a `string` before tokenizing the string.
\end{aside}

=== `implode` -- Implode a cons list[code] points to a string
[[stringImplodeFunction]]
The `implode` function is part of the `explosion` contract.
[listing]
implode has type (cons[integer])=&gt;string;

The `implode` function takes a `cons` list of `integer` code points and constructs a `string` value from it.

=== `reverse` -- Reverse the characters in a string
[[stringReverseFunction]]
The `reverse` function is part of the `reversible` contract -- see Program~\vref{reversibleContractDef}.
[listing]
reverse has type (string)=&gt;string


=== `findstring` -- string search
[[findStringFunction]]
`findstring` is used to determine the (next) location of a search token within a `string`.
[listing]
findstring has type (string,string,integer)=&gt;integer;


(((string,search within)))
(((finding substrings)))
The `findstring` function searches a string for an occurrence of another string. The first argument is the string to search, the second is the search token, and the third is the integer offset where to start the search.

For example, the result of the expression:
[listing]
findstring("the lazy dog jumped over the quick brown fox","the",5)

is `25`.

If the search token is not present then `findstring` returns -1;

=== `gensym` -- Generate Unique String
[[gensym]]
(((gensym standard function@`gensym` standard function)))
[listing]
gensym has type (string)=&gt;string

The `gensym` function is used to generate unique strings that have an arbitrarily high probability of being unique.

The generated string has a prefix consisting of the single argument, a middle which is a unique string generated based on a globally unique identifier identifying the current process and a counter.

The result is a string that has a high probability of being unique. It is guaranteed to be unique within the current processor.

=== `spaces` -- Generate a string of spaces
[[spaces]]
(((spaces standard function@`spaces` standard function)))
[listing]
spaces has type (integer)=&gt;string


The `spaces` function generates a `string` containing only the space character -- `'\spce'`. For example, the value of
[listing]
spaces(3)

is the `string`
[listing]
"   "

</Text>
        </Document>
        <Document ID="4DAE20E1-E8B4-402B-BA96-7067A8A89451">
            <Title>Ebook</Title>
        </Document>
        <Document ID="7FC10B6D-A5BA-43D9-A93B-76AAC206E4F9">
            <Title>Numeric Expressions</Title>
            <Text>%!TEX root = reference.tex
= Numeric Expressions
[[numbers]]
(((expressions,arithmetic)))

The basis of artithmetic expressions are several contracts: the `arithmetic` contract which provides definitions of the familiar `calculator' functions of `+`, `-`, `*` and `/`; the `math` contract which defines the extended set of mathematical functions; the `trig` contract which defines standard trigonometric functions; and the `bitstring` contract which gives definitions for bitwise manipulation of integer values.

== The `arithmetic` Contract
(((contract,arithmetic@`arithmetic` contract)))
[[arithmeticContract]]

The `arithmetic` contract -- in Program~\vref{arithmeticContractProg} -- defines a minimum set of functions that should be supported by any arithmetic type.

(((type,contracts! arithmetic@`arithmetic`)))
(((arithmetic contract@`arithmetic` contract)))
\begin{program}
[listing]
contract arithmetic over t is {
  (+) has type (t,t)=&gt;t;
  (-) has type (t,t)=&gt;t;
  (*) has type (t,t)=&gt;t;
  (/) has type (t,t)=&gt;t;
  (%) has type (t,t) =&gt; t;
  abs has type (t)=&gt;t;
  __uminus has type (t)=&gt;t;
  zero has type t;
  one has type t;
}

.The Standard `arithmetic` Contract[[arithmeticContractProg]]
\end{program}

In addition to the `arithmetic` contract, the `math` contract -- defined in Program~\vref{mathContract} -- defines additional functions that go beyond the standard `calculator' functions.

\begin{aside}
In the standard system, the `arithmetic` contract is implemented for `integer`s, `long`s, `float`s and `decimal`s. However, it is possible for the programmer to implement `arithmetic` for other types.
\end{aside}

=== `+` -- addition
[[plusFunction]]
(((arithmetic contract@`arithmetic` contract,+@`+`)))
`+` is part of the standard `arithmetic` contract.
[listing]
(+) has type for all t such that (t,t)=&gt;t where arithmetic over t


The `+` function adds its two arguments together and returns the result.

Depending on the type of the argument, different arithmetic will be invoked. For example
[listing]
X+4

denotes an `integer` addition (and `X` must be an `integer` variable); whereas
[listing]
Y+5.6

denotes a `float` addition.

=== `-` -- subtraction
[[minusFunction]]
(((arithmetic contract@`arithmetic` contract,-@`-`)))
`-` is part of the standard `arithmetic` contract.
[listing]
(-) has type for all t such that (t,t)=&gt;t where arithmetic over t


The `-` function subtracts the second argument from the first and returns the result.

=== `*` -- multiplication
[[timesFunction]]
(((arithmetic contract@`arithmetic` contract,*@`*`)))
`*` is part of the standard `arithmetic` contract.
[listing]
(*) has type for all t such that (t,t)=&gt;t where arithmetic over t

The `*` multiplies its two arguments together and returns the result.

=== `/` -- division
[[divideFunction]]
(((arithmetic contract@`arithmetic` contract,/@`/`)))
`/` is part of the standard `arithmetic` contract.
[listing]
(/) has type for all t such that (t,t)=&gt;t where arithmetic over t

The `/` function divides the first argument by the second and returns the result.


=== `abs` -- absolute value
[[abdFunction]]
(((arithmetic contract@`arithmetic` contract,abs@`abs`)))
`abs` is part of the standard `arithmetic` contract.
[listing]
abs has type for all t such that (t)=&gt;t where arithmetic over t


The `abs` function returns the absolute value of its argument.

=== `\_\_uminus` -- unary minus
[[unaryMinus]]
(((arithmetic contract@`arithmetic` contract,uminus@`\_\_uminus`)))
`\_\_uminus` is part of the standard `arithmetic` contract.
[listing]
(__uminus) has type for all t such that (t)=&gt;t where arithmetic over t

The `\_\_uminus` function negates its argument. This function is rarely invoked explicitly by the programmer; it is automatically generated by the compiler with unary-minus expressions. I.e., the expression
[listing]
-X

is interpreted as a call to `\_\_uminus`:
[listing]
__uminus(X)


=== `zero` -- arithmetic zero
[[zero]]
(((arithmetic contract@`arithmetic` contract,zero`zero`)))
`zero` is part of the standard `arithmetic` contract.
[listing]
zero has type for all t such that t where arithmetic over t


The `zero` value returns the `additive zero' for the arithmetic type. It must obey the following axiom:

[listing][escapechar=|]
|_X_|+zero=|_X_|

for all `_X_` of type `t`.

The primary advantage of `zero` is that it makes it easier to write generic arithmetic functions; for example:

[listing]
fact(N) where N=zero is one
 |  fact(N) default is N*fact(N-one)



=== `one` -- arithmetic unit
[[one]]
(((arithmetic contract@`arithmetic` contract,one`one`)))
`one` is part of the standard `arithmetic` contract.
[listing]
one has type for all t such that t where arithmetic over t


The `one` value returns the `additive unit' for the arithmetic type.  It must obey the following axiom:

[listing][escapechar=|]
|_X_|*one=|_X_|

for all `_X_` of type `t`.

Like `zero`, the primary advantage of `one` is that it makes it easier to write generic arithmetic functions.

== The `largeSmall` Contract
[[largeSmall]]
The `largeSmall` contract defines two values that are supposed to represent the largest and smallest legal values respectively of a type. The contract itself is very simple:
\begin{program}
[listing]
contract largeSmall over t is {
  largest has type t;
  smallest has type t;
}

.The `largeSmall` Contract[[largeSmallProg]]
\end{program}

The `largeSmall` contract is implemented for `integer`s, `long` integers, and `float` by default.

=== `smallest` -- smallest value
[listing]
smallest has type for all t such that t where largeSmall over t


The `smallest`  value is the smallest legal value of the type. For example, the smallest `long` value corresponds to $-2^{63}-1$.

\begin{aside}
It is not always possible to explicitly write down the smallest value of a type. In particular, it is not possible to write the smallest `long` value in decimal numbers.
\begin{aside}
It is possible, however, to write it in hexadecimal:
[listing]
0x8000000000L

\end{aside}
\end{aside}

=== `largest` -- largest value
[listing]
largest has type for all t such that t where largeSmall over t


The `largest`  value is the largest legal value of the type. For example, the largest `float` value is `1.7976931348623157E308`.

\begin{aside}
As with the `smallest` value; it is not necessarily the case that it is possible to explicitly write the `largest` value of a type.
\end{aside}

== Bit Manipulation Functions
[[bitString]]

The `bitstring` contract defines a set of bit manipulation functions.

\begin{aside}
In the standard system, the `bitstring` functions are only implemented by the `integer` and `long` types.
\end{aside}

\begin{aside}
The bitstring functions require an explicit `import` before using them:
[listing]
import bitstring;
myPk is package { ...

\end{aside}

(((type,contracts!bitstring@`bitstring`)))
(((bitstring contract@`bitstring` contract)))
\begin{program}
[listing]
contract bitstring over t is {
    (.&amp;.) has type (t,t)=&gt;t;
    (.^.) has type (t,t)=&gt;t;
    (.|.) has type (t,t)=&gt;t;
    (.&lt;&lt;.) has type (t,t)=&gt;t;
    (.&gt;&gt;.) has type (t,t)=&gt;t;
    (.&gt;&gt;&gt;.) has type (t,t)=&gt;t;
    (.~.) has type (t)=&gt;t;
    (.#.) has type (t)=&gt;integer;
}

.The Standard `bitstring` Contract[[bitstringContractDef]]
\end{program}

=== `.\&amp;.` Bit-wise Conjunction
[[bitAnd]]
[listing]
(.&amp;.) has type for all t such that (t,t)=&gt;t where bitstring over t


The `.\&amp;.` operator returns the bit-wise conjunction of two values.

=== `.|.` Bit-wise Disjunction
[[bitOr]]
[listing]
(.|.) has type for all t such that (t,t)=&gt;t where bitstring over t


The `.|.` operator returns the bit-wise disjunction of two values.

=== `.\^{`.} Bit-wise Exclusive-or
[[bitXor]]
[listing]
(.^.) has type for all t such that (t,t)=&gt;t where bitstring over t


The `.\^{`.} operator returns the bit-wise exclusive of two values.

=== `.&lt;&lt;.` Bit-wise Left Shift
[[bitLeft]]
[listing]
(.&lt;&lt;.) has type for all t such that (t,t)=&gt;t where bitstring over t


The `.&lt;&lt;.` operator left-shifts the left hand argument by the number of bits indicated in the right argument. It is effectively multiplication by a power of 2.

=== `.&gt;&gt;.` Bit-wise Arithmetic Right Shift
[[bitRight]]
[listing]
(.&gt;&gt;.) has type for all t such that (t,t)=&gt;t where bitstring over t


The `.&gt;&gt;.` operator right-shifts the left hand argument by the number of bits indicated in the right argument. The most significant bit is replicated in the shift. It is effectively division by a power of 2.

=== `.&gt;&gt;&gt;.` Bit-wise Logical Right Shift
[[bitRightLogic]]
[listing]
(.&gt;&gt;&gt;.) has type for all t such that (t,t)=&gt;t where bitstring over t


The `.&gt;&gt;&gt;.` operator right-shifts the left hand argument by the number of bits indicated in the right argument. The most significant bits of the result are replaced by zero. This operator is sometimes known as logical right shift.

=== `.\~\xspace.` Bit-wise Logical Complement
[[bitComplement]]
[listing]
(.~.) has type for all t such that (t)=&gt;t where bitstring over t


The `.\tlda.` operator forms the logical or 1's complement of its argument.

=== `.\#.` Bit Count
[[bitCount]]
[listing]
(.#.) has type for all t such that (t,t)=&gt;t where bitstring over t


The `.\#.` operator computes the number of non-zero bits in its argument.


== Trigonometry Functions
[[trigContract]]
The `trig` contract -- see Program~\vref{trigContractDef} -- defines standard trigonometry functions.

\begin{aside}
By default, the `trig` contract is only implemented over `float`ing point numbers.
\end{aside}

\begin{aside}
All the `trig` functions assume that the angles that they accept (or return) are expressed in radians.
\end{aside}

(((type,contracts! trig@`trig`)))
(((trig contract@`trig` contract)))
\begin{program}
[listing]
contract trig over t is {
  sin has type (t)=&gt;t;
  asin has type (t)=&gt;t;
  sinh has type (t)=&gt;t;
  cos has type (t)=&gt;t;
  acos has type (t)=&gt;t;
  cosh has type (t)=&gt;t;
  tan has type (t)=&gt;t;
  atan has type (t)=&gt;t;
  tanh has type (t)=&gt;t;
}

.The Standard `trig` Contract[[trigContractDef]]
\end{program}

=== `sin` -- Sine Function
[listing]
sin has type for all t such that (t)=&gt;t where trig over t


The `sin` function returns the Sine of its argument -- expressed in radians.

=== `asin` -- Arc Sine Function
[listing]
asin has type for all t such that (t)=&gt;t where trig over t


The `asin` function returns the Arc Sine of its argument -- expressed in radians.

=== `sinh` -- Hyperbolic Sine Function
[listing]
sinh has type for all t such that (t)=&gt;t where trig over t


The `sinh` function returns the hyperbolic sine of its argument -- expressed in radians.

The hyperbolic sine of X is defined to be $(e^X - e^{-X})/2$.

=== `cos` -- Cosine Function
[listing]
cos has type for all t such that (t)=&gt;t where trig over t


The `cos` function returns the cosine of its argument -- expressed in radians.

=== `acos` -- Arc Cosine Function
[listing]
acos has type for all t such that (t)=&gt;t where trig over t


The `acos` function returns the arc cosine of its argument -- expressed in radians.

=== `cosh` -- Hyperbolic Cosine Function
[listing]
cosh has type for all t such that (t)=&gt;t where trig over t


The `cosh` function returns the hyperbolic cosine of its argument -- expressed in radians.

The hyperbolic cosine of X is defined to be $(e^X + e^{-X})/2$.

=== `tan` -- Tangent Function
[listing]
tan has type for all t such that (t)=&gt;t where trig over t


The `tan` function returns the tangent of its argument -- expressed in radians.

=== `atan` -- Arc Tangent Function
[listing]
atan has type for all t such that (t)=&gt;t where trig over t


The `atan` function returns the Arc Tangent of its argument -- expressed in radians.

=== `tanh` -- Hyperbolic Tangent Function
[listing]
tanh has type for all t such that (t)=&gt;t where trig over t


The `tanh` function returns the hyperbolic tangent of its argument -- expressed in radians.

The hyperbolic tangent of X is defined to be $sinh(X)/cosh(X)$.

== Numeric Display Functions
[[numberDisplay]]

The numeric display functions allow the representation of numbers as `string` values.

=== `display` -- Display a number
[[displayNumFun]]

The `display` function can be used to display a numeric value.
[listing][escapechar=|]
display has type (|&lt;&lt;Type&gt;&gt;|)=&gt;string

The `display` function relies on the `ppDisp` function which is part of the `pPrint` contract -- see Program~\vref{ppContractProg}.

=== `\_format` -- Format a number as a string
[[formatNumber]]
[listing][escapechar=|]
_format has type (|&lt;&lt;Type&gt;&gt;|,string)=&gt;pP

where `_Type_` is one of `integer`, `long` or `float`.

The `\_format` function is part of the `formatting` contract -- see Program~\vref{formatContractProg}.

The format string for integral values determines how the number is formatted. For example, the result of
[listing]
"--$(-15):-   0;--"

is
[listing]
"--  -15--"


The grammar for legal formatting codes for integral values may be given in the regular expression:
[listing]
`[P+-]?([09 ,.])+[P+-]`

I.e., a sign specification, followed by digit specifications optionally mixed with thousands markers and periods, terminated by an optional sign specification.

The grammar for legal formatting codes for `float` values is a little more complex:
[listing]
`[P+-]?[09 ,.]+([eE][+-]?[09 ]+)?[P+-]?

I.e., the format string for `float` values permits the exponent to be printed as well as the mantissa. If the exponent part is missing and if the `float` value cannot be represented in the available precision without an exponent then an exception will be `raised`.

The complete list[formatting] codes for formatting numeric values is:

\begin{description}
`9`:: A digit is displayed if it is significant. I.e., if it is non-zero or there is a non-zero digit to the left of the digit.
`0`:: A zero character is used for numeric values. It always results in a digit being displayed. For example, the value of
[listing]
"--$(5):00;--"

is the string
[listing]
"--05--"


`\spce{`}:: A space character is similar to the `0` code; except that a leading space is displayed instead of a leading zero.

For example, the value of
[listing]
"--$(5):00;--"

is the string
[listing]
"-- 5--"


\begin{aside}
Signs are treated specially with the `\spce{`} code: any produced sign character is migrated past leading spaces -- with the result that the sign character is always abutted to the digits.

For example, the result of
[listing]
"--$(-15):-   0;--"

is
[listing]
"--  -15--"

The `\spce{`} code is especially useful for lining up columns of figures where a leading space is preferred over leading zeroes.
\end{aside}

`.`:: A period is displayed if there is a digit to the left.

This is used for showing currency values -- when they are represented internally as pennies but should be displayed as dollar values -- and for floating point numbers.
`,`:: A comma is displayed if there is a digit to the left.

This is used for displaying values in the `thousands' notation. For example, the value of
[listing]
"--$(120345567):999,999,999,999;--"

is the string:
[listing]
"--120,345,567--"


`-`:: Is used to control how signed values are presented. If the value is negative then a `-` character is displayed; if the value is positive then a space is displayed.

\begin{aside}
The `-` &lt;&lt;FormatCode&gt;&gt; may appear at either end of the display. A leading `-` results in the sign being displayed at the beginning -- before any digits -- and a trailing `-` results in the sign appended to the end.
\end{aside}

\begin{aside}
\begin{aside}
If no `sign' code is present in the &lt;&lt;FormattingSpec&gt;&gt; then nothing is displayed if the value is positive or negative.
\end{aside}
\end{aside}

`+`:: Always results in a sign being displayed. If the value is negative then a `-` character is displayed; otherwise a `+` character is displayed.

Like the `-` code, the `+` may appear at either end of the display format.

`P`:: The `P` code uses parentheses on either end of the value to indicate a negative value. If the value is positive then spaces are appended to either end; otherwise the number is enclosed in `()`'s.

\begin{aside}
The `P` code should be placed at _both_ ends of the &lt;&lt;FormattingSpec&gt;&gt;.
For example, the expression:
[listing]
"Balance: $Amnt:P999900.00P; remaining"

where `Amnt` had value -563 would result in
[listing]
"Balance: (05.63) remaining"

\end{aside}
`X`:: Causes the integer to be formatted as a hexadecimal number; and a hexadecimal digit is displayed if it is significant. I.e., if it is non-zero or there is a non-zero digit to the left of the digit.

For example, this can be used to display the Unicode equivalent of a character:
[listing]
"Unicode: $C/$(C as integer):XXXXX;"


\end{description}

== Additional Arithmetic Functions
[[mathContract]]
The `math` contract -- see Program~\vref{mathContractDef} -- defines additional functions.

\begin{aside}
The `math` contract is not implemented by all number types; in particular, it is implemented by `integer`, `long` and `float`; but is not implemented by `decimal`.
\end{aside}

(((type,contracts! math@`math`)))
(((math contract@`math` contract)))
\begin{program}
[listing]
contract math over t is {
  min has type (t,t)=&gt;t;
  max has type (t,t)=&gt;t;
  random has type (t)=&gt;t;
  sqrt has type (t)=&gt;t;
  cbrt has type (t)=&gt;t;
  ceil has type (t)=&gt;t;
  floor has type (t)=&gt;t;
  round has type (t)=&gt;t;
  log has type (t)=&gt;t;
  log10 has type (t)=&gt;t;
  exp has type (t)=&gt;t
  (**) has type (t,t) =&gt; t;
}

.The Standard `math` Contract[[mathContractDef]]
\end{program}

=== `min` -- minimum value
[listing]
min has type for all t such that (t,t)=&gt;t where math over t


The `min` function returns the smaller of its two arguments.

=== `max` -- maximum value
[listing]
max has type for all t such that (t,t)=&gt;t where math over t


The `max` function returns the larger of its two arguments.

=== `sqrt` -- square root
[listing]
sqrt has type for all t such that (t)=&gt;t where math over t


The `sqrt` function returns the square root of its argument. If the argument is negative, the returned value is undefined.

=== `cbrt` -- cube root
[listing]
cbrt has type for all t such that (t)=&gt;t where math over t


The `cbrt` function returns the cube root of its argument. Note that $-cbrt(X)=cbrt(-X)$.

=== `ceil` -- ceiling
[listing]
ceil has type for all t such that (t)=&gt;t where math over t


The `ceil` function returns the nearest integral value that is equal to or larger than X.
\begin{aside}
For integral types,
[listing]
ceil(X)=X

\end{aside}

=== `floor` -- floor
[listing]
floor has type for all t such that (t)=&gt;t where math over t


The `floor` function returns the nearest integral value that is equal to or smaller than X.
\begin{aside}
For integral types,
[listing]
floor(X)=X

\end{aside}

=== `round` -- round to closest integral
[listing]
round has type for all t such that (t)=&gt;t where math over t


The `round` function returns the nearest integral value to its argument.
\begin{aside}
For all values,
[listing]
round(X)=floor(X + 0.5)

\end{aside}


=== `log` -- Natural Logarithm
[listing]
log has type for all t such that (t)=&gt;t where math over t


The `log` function returns the natural logarithm of its argument.

=== `log10` -- Logarithm Base 10
[listing]
log10 has type for all t such that (t)=&gt;t where math over t


The `log10` function returns the base 10 logarithm of its argument.


=== `exp` -- Natural Exponentiation
[listing]
exp has type for all t such that (t)=&gt;t where math over t


The `exp` function returns the value $e^X$.

=== `random` -- random number generation
(((random number generation)))
[listing]
random has type for all t such that (t)=&gt;t where math over t


The `random` function returns a number in the half-open range [0,X) where X is the argument of the function.
\begin{aside}
The argument of the `random` function must be a positive number. However, it can be any `normal' kind of arithmetic value.
\end{aside}
The number generated is the next in a sequence of numbers that is typically _pseudo-random_: i.e., not actually random but statistically indistinguishable from random.

The type of the returned result is the same as the type of its argument.

=== `**` -- exponentiation
[[powerFunction]]
(((math contract@`math` contract,**@`**`)))
`**` is part of the standard `math` contract.
[listing]
(**) has type for all t such that (t,t)=&gt;t where math over t

The `**` function raises the first argument to the power of the second.

For example, the expression
[listing]
X**3

denotes the cube of `X`.

== Numeric Ranges
[[numericRange]]
The `range` type defines a numeric range. It is useful primarily in loops; for example:
[listing]
X is list of {all Ix where Ix in range(0,10,1) }

has, as its value:
[listing]
list of [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


\begin{aside}
Ranges are half-open: they include their beginning value but do not include their terminator value. This permits simpler merging of ranges:
[listing][escapechar=|]
range(0,10,1)++range(10,20,1) |\ensuremath{\equiv}| range(0,20,1)

\end{aside}

=== The `range` Type
The `range` type is defined in Program~\vref{rangeTypeProg}.
\begin{program}
[listing]
type range of t where arithmetic over t and comparable over t
  is range(t,t,t);

.The Standard `range` Type[[rangeTypeProg]]
\end{program}

Note that this is a constrained type. It is a generic type but is only defined for type arguments that are `comparable` and which are defined over `arithmetic`.

The `range` type implements the `sizeable` contract (see &lt;&lt;sizeableContract&gt;&gt;), the `iterable` contract (see Section~\ref{iterableContract}) and the `concatenate` (see &lt;&lt;concatenateContract&gt;&gt;) contracts. This means that `range` is suitable for controlling for loops:
[listing]
for Ix in range(0,10,1) do
  logMsg(info,"$Ix")

as well as for using in queries such as above.
</Text>
        </Document>
        <Document ID="00EAC16E-3851-4110-A36D-29CC26BC0F49">
            <Title>Encapsulated Types</Title>
            <Text>An EncapsulatedType is a reference to a type that is embedded within a record.
EncapsulatedType::=Expression . Identifier
Encapsulated Type
As noted above, record literals may have types embedded within them. Such a record type is existentially quantified.
It is possible to access the type embedded within such a record -- albeit with some restrictions:
The form of an EncapsulatedType reference is limited to terms of the form:
R.t
where R is a Variable whose type interface contains the type t.
More generally, an EncapsulatedType reference may involve a sequence of field names where each intermediate field name refers to a sub-record:
R.f1.f2.t
An encapsulated type is strictly opaque: it is assumed to be different to all other types. Which means that effectively only the other fields of the record variable R contain functions and values that can be used in conjunction.
For example, consider the group type defined in:
group ::= group{
  el :: quality[el] |: type

  zero : el
  op : (el,el)=&gt;el
  inv : (el)=&gt;el
}
The group Type

[TIP] A group literal is analogous to a mathematical group: a set which is closed under a binary operation and whose elements have an inverse.
The contents of a group literal contain the definitions of the elements, the binary operation, the zero element and the inverse function.
The qualification of the el type that it supports equality allows convenient access to equality of group elements. Without such a qualification, equality would not be possible for programs using group values.
An additional requirement for a group is that its operation is associative. Such a property cannot be expressed in terms of type constraints.
A group literal that implements the group for integers is shown in:
IG = group{
  type el = integer.
  zero = 0.
  op = (+).
  inv(X) =&gt; -X.
}
The integer group Record
The IG value contains the elements of a group value. We can, for example, access the zero of IG using the statement:
IZ : IG.el
IZ = IG.zero
This asserts that IZ's type is whatever the encapsulated type within IG is -- without being explicit about what that type is.
It is possible to construct functions over groups that refer to encapsulated types. For example, the invertGroup function below constructs a new group by inverting the operation.
invertGroup(G) =&gt; group{
  type el = G.el.
  zero = G.zero.
  op(X,Y) =&gt; G.op(G.inv(X),G.inv(Y)).
  inv(X) =&gt; G.inv(X).
}
A group Inverting Function</Text>
        </Document>
        <Document ID="8F400754-B19B-4481-90C7-0D060E8FB380">
            <Title>Recursive Contract Implementations</Title>
            <Text>More complex contract implementations may require the use of auxiliary function definitions; and hence may involve the use of let expressions.
For example, this is an implementation of the comparable contract for cons values.
implementation all t ~~ comparable[t], equality[t] |: comparable[cons[t]] =&gt;
  let{
    consLess([],[_ ,.. _]) =&gt; true
    consLess([X,..L1],[X,..L2]) =&gt; consLess(L1,L2)
    consLess([X,.._], [Y,.._]) where X&lt;Y =&gt; true
    consLess(_,_) default =&gt; false

    consLessEq([],_) =&gt; true
    consLessEq([X,..L1],[Y,..L2]) :: X=&lt;Y =&gt;
          consLessEq(L1,L2)
    consLessEq(_,_) default =&gt; false
  } in {
    X &lt; Y =&gt; consLess(X,Y)
    X =&lt; Y =&gt; consLessEq(X,Y)
    X &gt; Y =&gt; consLess(Y,X)
    X &gt;= Y =&gt; consLessEq(Y,X)
  }
Implementation of  comparable contract for cons values
[NOTE] The implementation of  comparable contract for cons types is based on a requirement that the individual elements of lists must also be compared. Hence the clause
comparable[t], equality[t] |: comparable[cons[t]]
in the head of the contract implementation statement. The primary job of the definition of `&lt;`  is to show how cons values may be compared. Our definition of inequality for cons values assumes that:
	•	empty lists are less than any non-empty list;
	•	one non-empty list is less than another if the first element is less than the first element of the second; and finally
	•	if the first elements of the two lists are identical then we consider the tails of each list.
[TIP] The curious reader may wonder why we introduce a new name consLessEq in order to define =&lt; (and, by extension consLess for &lt; etc.). The reason for this has to do with limitations on type inference in the context of recursive programs: within the equations that define a function, any use of the function symbol must represent a recursive use.
For example, in the equation:
consLessEq([X,..L1],[Y,..L2]) where X=&lt;Y =&gt;
      consLessEq(L1,L2)
the occurrence of consLessEq in the right hand side of the equation represents a recursive call.
However, if we tried to define =&lt; without the use of the auxiliary name we would get two occurrences of =&lt; which really represent different functions:
[X,..L1] =&lt; [Y,..L2] where X=&lt;Y =&gt; L1 =&lt; L2
The two occurrences of =&lt; refer to different kinds of use: one is as a normal overloaded occurrence of =&lt; and once as a recursive call to the function being defined.
Normally, outside of the definition of the function, it is permitted to allow a given function to be used in different uses -- always assuming that the types are consistent. However, within the definition of a function, all occurrences of the function symbol must refer to the same function.
In the case of the =&lt; equation above, the type inference system would not be able to distinguish a recursive call from a call to a different overloaded function of the same name; and would assume that both uses of =&lt; are intended to be part of the definition. This, in turn, would result in a type error being generated.
In summary, when defining an overloaded function like =&lt;, we often have to introduce an auxiliary function to carry the recursion.
In defining the implementation of a contract, each of the variables that are part of the contract must either be defined or have a default definition within the contract specification itself.</Text>
        </Document>
    </Documents>
</SearchIndexes>