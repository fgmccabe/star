= Numbers

(((expressions,arithmetic)))
The basis of arithmetic expressions are several contracts: the `arith` contract
which provides definitions of the familiar _calculator_ functions of `+`, `-`,
`*` and `/`.

In addition, there are extended sets of mathematical functions for
trigonometry, bit string manipulation and so on.

== Numeric Types

There are three standard numeric types: `integer`, `bigint` and `float`.

[#integerType]
=== Integer Type

Integers are 62 bits in precision. However, there are also arbitrary
precision integers if needed.

NOTE: The restriction to 62 bits facilitates improved space representation
in the engine. If more precision is required, arbitrary precision
arithmetic is a good choice.

[#bigintType]
=== Arbitrary Precision Integers

As the name suggests, `bigint` numbers have no fixed
precision. They can be used to represent large values -- up to the
limits of available memory.

NOTE: Operations on `bigint` numbers may be significantly more
expensive than operations on fixed size integers.

In addition, the range of operators supported for `bigint`
numbers is smaller than that for `integer` values.

[#floatType]
=== Float Type

Floating point numbers are based on IEEE 754 double values. 

== Implemented Arithmetic Contracts
(((contract, implemented for `integer` and `float`)))

In addition to the standard contracts for `equality`, 

=== Arithmetic for Integers

The `arith` contract is implemented for `integer`
values (see <<arithContract>>).

=== Arithmetic for Floating Points

The `arith` contract is implemented for `float` values (see <<arithContract>>).

=== Display for `integer`

The `display` contract is implemented for `integer` values (see <<displayContract>>).

=== Format for `integer`

The `format` contract is implemented for `integer` values (see
<<formatContract>>). The format string determines how the number is
formatted. For example, the result of [source,star]
----
"--$(-15):-   0;--"
----
is
[source,star]
----
"--  -15--"
----

The grammar for legal formatting codes for integral values is given in the
regular expression:

[source,star]
----
[P+-]?([09 ,.])+[P+-]
----

I.e., a sign specification, followed by digit specifications
optionally mixed with thousands markers and periods, terminated by an
optional sign specification.

The complete set of formatting codes for formatting numeric values are:

[cols="1,10"]
|===
| `9`
| A digit is displayed if it is significant. I.e., if it is non-zero
or there is a non-zero digit to the left of the digit.

| `0`
a| A zero character is used for numeric values. It always results in a
digit being displayed. For example, the value of
[source,star]
----
"--$(5):00;--"
----
is the string
[source,star]
----
"--05--"
----

| space
a| A space character is similar to the `0` code; except that a
leading space is displayed instead of a leading zero.

For example, the value of
[source,star]
----
"--$(5): 0;--"
----
is the string
[source,star]
----
"-- 5--"
----

NOTE: Signs are treated specially with the space code: any produced sign
character is migrated past leading spaces -- with the result that the
sign character is always abutted to the digits.
For example, the result of
[source,star]
----
"--$(-15):-   0;--"
----
is
[source,star]
----
"--  -15--"
----
The space code is especially useful for lining up columns of figures
where a leading space is preferred over leading zeroes.

| `.`
| A period is displayed if there is a digit to the left.

This is used for showing currency values -- when they are represented
internally as pennies but should be displayed as dollar values -- and
for floating point numbers.

| `,`
a| A comma is displayed if there is a digit to the left.

This is used for displaying values in the _thousands_
notation. For example, the value of
[source,star]
----
"--$(120345567):999,999,999,999;--"
----
is the string:
[source,star]
----
"--120,345,567--"
----
| `-`
a| Is used to control how signed values are presented. If the value is negative
then a `-` character is displayed; if the value is positive then a space is
displayed.

NOTE: The `-` format code may appear at either end of the display. A
leading `-` results in the sign being displayed at the beginning
-- before any digits -- and a trailing `-` results in the sign
appended to the end.
WARNING: If no _sign_ code is present in the format specification then
nothing is displayed if the value is positive or negative.

| `+`
a| Always results in a sign being displayed. If the value is negative
then a `-` character is displayed; otherwise a `+` character
is displayed.

Like the `-` code, the `+` may appear at either end of the
display format.

| `P`
a| The `P` code uses parentheses on either end of the value to
indicate a negative value. If the value is positive then spaces are
appended to either end; otherwise the number is enclosed in
`()`s.

NOTE: The `P` code should be placed at _both_ ends of the format
specification.  For example, the expression:
[source,star]
----
"Balance: $(Amnt):P999900.00P; remaining"
----
where `Amnt` had value -563 would result in
[source,star]
----
"Balance: (05.63) remaining"
----

| `X`
a| Causes the integer to be formatted as a hexadecimal number; and a
hexadecimal digit is displayed if it is significant. I.e., if it is
non-zero or there is a non-zero digit to the left of the digit.

For example, this can be used to display the Unicode equivalent of a character:
[source,star]
----
"Unicode: $(C)/$(C::integer):XXXXX;"
----
|===

=== Display for `float`

The `display` contract for `float` values is implemented. Floating point numbers
are displayed in the so-called `g` format:

[source,star]
----
23.45e-99
----

=== Format for `float`

The grammar for legal formatting codes for `float` values is a little more
complex than that for `integer`:
[source,star]
----
[P+-]?[09 ,.]+([eE][+-]?[09 ]+)?[P+-]?
----

I.e., the format string for `float` values permits the exponent
to be printed as well as the mantissa. If the exponent part is missing
and if the `float` value cannot be represented in the available
precision without an exponent then an exception will be thrown.

[#bitString]
== Bit Manipulation Functions

The bit manipulation functions treat `integer` values as 62-bit bit strings. The
`bits` contract is implemented for both `integer` values and `bigint` values
(see <<bitArithmeticContract>>).

== Trigonometry Functions

NOTE: All the trig functions assume that the angles that they accept (or
return) are expressed in radians.

Unlike other arithmetic functions, trigonometric functions are only supported
for `float` values -- hence there is no contract for them.

===  `sin` -- Sine Function
[source,star]
----
sin : (float) => float.
----

The `sin` function returns the Sine of its argument -- expressed
in radians.

=== `asin` -- Arc Sine Function
[source,star]
----
asin : (float) => float.
----

The `asin` function returns the Arc Sine of its argument --
expressed in radians.

=== `cos` -- Cosine Function
[source,star]
----
cos : (float) => float.
----

The `cos` function returns the cosine of its argument --
expressed in radians.

=== `acos` -- Arc Cosine Function
[source,star]
----
acos : (float) => float.
----

The `acos` function returns the arc cosine of its argument --
expressed in radians.

=== `tan` -- Tangent Function
[source,star]
----
tan : (float) => float.
----

The `tan` function returns the tangent of its argument --
expressed in radians.

=== `atan` -- Arc Tangent Function
[source,star]
----
atan : (float) => float.
----

The `atan` function returns the Arc Tangent of its argument --
expressed in radians.

=== `pi` -- Pi function

[source,star]
----
pi:()=>float
----

The `pi` function returns Ï€ -- as accurately representable as a floating point
number.

== Misc Arithmetic Functions

In addition to the standard arithmetic contract (see <<arithContract>>), there
are some additional numeric functions:

===  `abs` -- absolute value

[source,star]
----
abs : all t ~~ arith[t],comp[t] |= (t)=>t.
----

The `abs` function returns the absolute value of its argument. It
depends on both teh `arith` and the `comp` contracts, hence
is implemented for both `integer` and `float` values.

=== `max` -- maximum value
[source,star]
----
max: all t ~~ comp[t] |= (t,t)=>t.
----

The `max` function returns the larger of its two arguments.

=== `min` -- minimum value
[source,star]
----
min: all t ~~ comp[t] |= (t,t)=>t.
----

The `min` function returns the smaller of its two arguments. It
is defined on top of the `comp` contract.

=== `sqrt` -- square root
[source,star]
----
sqrt : (float)=>float
----

The `sqrt` function returns the square root of its argument. If
the argument is negative, the returned value is undefined.

===  `ceil` -- ceiling
[source,star]
----
ceil : (float)=>float
----

The `ceil` function returns the nearest integral value that is
equal to or larger than X.

=== `floor` -- floor
[source,star]
----
floor : (float)=>float
----

The `floor` function returns the nearest integral value that is
equal to or smaller than X.

=== `trunc` -- round to closest integral
[source,star]
----
trunc : (float)=>float
----

The `trunc` function returns the nearest integral value to its argument.
NOTE: The value returned by `trunc` is integral, but still of type `float`.

=== `integral` -- test for integral flot
[source,star]
----
integral: (float) => boolean
----

The `integral` predicate is true when the argument floating point number is
integral.

NOTE: This does not mean that the number can be coerced to an `integer` value:
the number may be integral and also larger than can be represented as a 61 bit
integer.

=== `ln` -- Natural Logarithm
[source,star]
----
ln : (float)=>float
----

The `log` function returns the natural logarithm of its argument.

===  `lg10` -- Logarithm Base 10
[source,star]
----
lg10 : (float)=>float
----

The `lg10` function returns the base 10 logarithm of its argument.

=== `irand` -- random integer generation

(((random number generation)))
[source,star]
----
irand : (integer)=>integer
----

The `irand` function returns an integer in the half-open range
[0,X) where X is the argument of the function.

The argument of the `irand` function must be a positive integer.

The number generated is the next in a sequence of numbers that is
typically pseudo-random: i.e., not actually random but statistically
indistinguishable from random.

=== `random` -- random number generation

(((random number generation)))
[source,star]
----
random : ()=>float
----

The `random` function returns a number in the half-open range
[0,1).

The number generated is the next in a sequence of numbers that is
typically pseudo-random: i.e., not actually random but statistically
indistinguishable from random.

=== `seed` -- seed random number generation

(((random number seed)))
[source,star]
----
seed : (integer){}
----

The `seed` procedure is used to seed the random number generation. One of the
primary motivations of `seed` is to ensure a repeatable random number sequence.

The argument of `seed` function must be a positive integer.

=== `**` -- exponentiation
[source,star]
----
(**) : (float,float) => float
----

The `**` function raises the first argument to the power of the second.

For example, the expression
[source,star]
----
X**3.0
----

denotes the cube of `X`.

== Standard Arithmetic Contracts

(((contracts,standard,arithmetic))) The contracts in this section are expecially
oriented towards arithmetic operations. We do not generally expect them to be
implemented for non-numeric types.

[#arithContract]
=== The `arith` Contract

The `arith` contract encodes the basic -- so-called calculator --
functions.

[#arithContractProg]
.The Standard `arith` Contract
[source,star]
----
public contract all x ~~ arith[x] ::= {
  (+): (x,x)=>x.
  (-): (x,x)=>x.
  __minus: (x)=>x.
  zero: x.
  (*): (x,x)=>x.
  (/): (x,x)=>x throws exception.
  (%): (x,x)=>x throws exception.
  one:x.
}.
----

==== The `+` Function

The `+` function defines the addition of two elements:

[#plusFunctionProg]
.The `+` Function
[source,star]
----
(+) : all t ~~ arith[t] |= (t,t) => t.
----

NOTEL The `(+)` function takes two arguments of the same type and
returns a value of the same type as its arguments.

In fact, it is _this_ specification that ensures that there is no
implicit coercion between different kinds of numeric value.

==== The `-` Function

The `-` function defines the subtraction of one element from another.

[#minusFunctionProg]
.The `-` Function
[source,star]
----
(-) : all t ~~ arith[t] |= (t,t) => t.
----

NOTE: The `(-)` is a binary function. A separate function -- `_uminus` -- is
used to denote unary negation.

==== The `_uminus` Function

The `_uminus` function defines the unary negation of a number.

[#uminusFunctionProg]
.The `_uminus` Function
[source,star]
----
_uminus : all t ~~ arith[t] |= (t) => t.
----

NOTE:  The `_uminus` function is automatically substituted for
occurrences of unary minus in source programs. There is rarely a need
to explicitly refer to this function.

==== The `zero` Value

The `zero` value denotes the 0 value of the arithmetic type.

[#zeroProg]
.The `zero` Value
[source,star]
----
zero : all t ~~ arith[t] |= t. 
----

NOTE: The `zero` value is particularly useful when defining arithmetic
functions that should be neutral with respect to the actual type of
numeric value. Literal decimal numbers have a fixed type --
`integer`.

==== The `*` Function

The `*` function defines the multiplication of one element by another.

[#timesFunctionProg]
.The `*` Function
[source,star]
----
(*) : all t ~~ arith[t] |= (t,t) => t.
----

==== The `/` Function

The `/` function defines the division of one element by another.

[#divideFunctionProg]
.The `/` Function
[source,star]
----
(/) : all t ~~ arith[t] |= (t,t) => t throws exception.
----

NOTE: The `/` function (and the `%` function) are defined to throw an
`exception` if the divisor is zero.

==== The `%` Function

The `%` function defines the modulus of one element with respect
to another.

[#modFunctionProg]
.The `%` Function
[source,star]
----
(%) : all t ~~ arith[t] |= (t,t) => t throws exception.
----

====  The `one` Value

The `one` value denotes the 1 value of the arithmetic type; i.e.,
the _unit_ of multiplication.

[#oneProg]
.The `one` Value
[source,star]
----
one : all t ~~ arith[t] |= t. 
----

NOTE: Like the `zero`, the `one` value is particularly useful when
defining arithmetic functions that should be neutral with respect to
the actual type of numeric value.

[#bitArithmeticContract]
=== The `bits` Contract

The `bits` contract encodes a suite of bitwise arithmetic.

[#bitsContractProg]
.The Standard `bits` Contract
[source,star]
----
public contract all x ~~ bits[x] ::= {
  (.|.):(x,x)=>x.
  (.&.):(x,x)=>x.
  (.^.):(x,x)=>x.
  (.~.):(x)=>x.
}
----

The various operations focus on a bitstring interpretation of numeric
values.

The `bits` contract has been implemented for ``integer``s.

==== The `.|.` bitwise or Function

The `.|.` function embodies bitwise union:

[#bitorFunctionProg]
.The `.|.` Function
[source,star]
----
(.|.) : all x ~~ bits[x] |= (x,x) => x.
----

==== The `.&.` bitwise and Function

The `.&.` function embodies bitwise union:

[#bitandFunctionProg]
.The `.&.` Function
[source,star]
----
(.&.) : all x ~~ bits[x] |= (x,x) => x.
----

==== The `.^.` bitwise exclusive or Function

The `.^.` function embodies bitwise union:

[#bitxorFunctionProg]
.The `.^.` Function
[source,star]
----
(.^.) : all x ~~ bits[x] |= (x,x) => x.
----

==== The `.~.` bitwise negation Function

The `.~.` function embodies unary negation:

[#bitnotFunctionProg]
.The `.~.` Function
[source,star]
----
(.~.) : all x ~~ bits[x] |= (x) => x.
----

[#pwrContract]
=== The `pwr` contract

The `pwr` contract defines a single function: `**` for exponentiation.

[#pwrContractProg]
.The `pwr` Contract
[source,star]
----
public contract all e ~~ pwr[e] ::= {
  (**) : (e,e)=>e
}
----

There is a single standard implementation of `pwr` for ``float``ing point values.

==== The `**` Function

The `**` function denotes the exponentiation function:

[#exponentFunctionProg]
.The `**` Function
[source,star]
----
(**) : all x ~~ pwr[x] |= (x,x) => x.
----

NOTE: The `**` symbol is an infix operator, so a normal use would look like:
[source,star]
----
X**2.3
----


