%!TEX root = reference.tex
= Numeric Expressions
[[numbers]]
(((expressions,arithmetic)))

The basis of artithmetic expressions are several contracts: the `arithmetic` contract which provides definitions of the familiar `calculator' functions of `+`, `-`, `*` and `/`; the `math` contract which defines the extended set of mathematical functions; the `trig` contract which defines standard trigonometric functions; and the `bitstring` contract which gives definitions for bitwise manipulation of integer values.

== The `arithmetic` Contract
(((contract,arithmetic@`arithmetic` contract)))
[[arithmeticContract]]

The `arithmetic` contract -- in Program~\vref{arithmeticContractProg} -- defines a minimum set of functions that should be supported by any arithmetic type.

(((type,contracts! arithmetic@`arithmetic`)))
(((arithmetic contract@`arithmetic` contract)))
\begin{program}
[listing]
contract arithmetic over t is {
  (+) has type (t,t)=>t;
  (-) has type (t,t)=>t;
  (*) has type (t,t)=>t;
  (/) has type (t,t)=>t;
  (%) has type (t,t) => t;
  abs has type (t)=>t;
  __uminus has type (t)=>t;
  zero has type t;
  one has type t;
}

.The Standard `arithmetic` Contract[[arithmeticContractProg]]
\end{program}

In addition to the `arithmetic` contract, the `math` contract -- defined in Program~\vref{mathContract} -- defines additional functions that go beyond the standard `calculator' functions.

\begin{aside}
In the standard system, the `arithmetic` contract is implemented for `integer`s, `long`s, `float`s and `decimal`s. However, it is possible for the programmer to implement `arithmetic` for other types.
\end{aside}

=== `+` -- addition
[[plusFunction]]
(((arithmetic contract@`arithmetic` contract,+@`+`)))
`+` is part of the standard `arithmetic` contract.
[listing]
(+) has type for all t such that (t,t)=>t where arithmetic over t


The `+` function adds its two arguments together and returns the result.

Depending on the type of the argument, different arithmetic will be invoked. For example
[listing]
X+4

denotes an `integer` addition (and `X` must be an `integer` variable); whereas
[listing]
Y+5.6

denotes a `float` addition.

=== `-` -- subtraction
[[minusFunction]]
(((arithmetic contract@`arithmetic` contract,-@`-`)))
`-` is part of the standard `arithmetic` contract.
[listing]
(-) has type for all t such that (t,t)=>t where arithmetic over t


The `-` function subtracts the second argument from the first and returns the result.

=== `*` -- multiplication
[[timesFunction]]
(((arithmetic contract@`arithmetic` contract,*@`*`)))
`*` is part of the standard `arithmetic` contract.
[listing]
(*) has type for all t such that (t,t)=>t where arithmetic over t

The `*` multiplies its two arguments together and returns the result.

=== `/` -- division
[[divideFunction]]
(((arithmetic contract@`arithmetic` contract,/@`/`)))
`/` is part of the standard `arithmetic` contract.
[listing]
(/) has type for all t such that (t,t)=>t where arithmetic over t

The `/` function divides the first argument by the second and returns the result.


=== `abs` -- absolute value
[[abdFunction]]
(((arithmetic contract@`arithmetic` contract,abs@`abs`)))
`abs` is part of the standard `arithmetic` contract.
[listing]
abs has type for all t such that (t)=>t where arithmetic over t


The `abs` function returns the absolute value of its argument.

=== `\_\_uminus` -- unary minus
[[unaryMinus]]
(((arithmetic contract@`arithmetic` contract,uminus@`\_\_uminus`)))
`\_\_uminus` is part of the standard `arithmetic` contract.
[listing]
(__uminus) has type for all t such that (t)=>t where arithmetic over t

The `\_\_uminus` function negates its argument. This function is rarely invoked explicitly by the programmer; it is automatically generated by the compiler with unary-minus expressions. I.e., the expression
[listing]
-X

is interpreted as a call to `\_\_uminus`:
[listing]
__uminus(X)


=== `zero` -- arithmetic zero
[[zero]]
(((arithmetic contract@`arithmetic` contract,zero`zero`)))
`zero` is part of the standard `arithmetic` contract.
[listing]
zero has type for all t such that t where arithmetic over t


The `zero` value returns the `additive zero' for the arithmetic type. It must obey the following axiom:

[listing][escapechar=|]
|_X_|+zero=|_X_|

for all `_X_` of type `t`.

The primary advantage of `zero` is that it makes it easier to write generic arithmetic functions; for example:

[listing]
fact(N) where N=zero is one
 |  fact(N) default is N*fact(N-one)



=== `one` -- arithmetic unit
[[one]]
(((arithmetic contract@`arithmetic` contract,one`one`)))
`one` is part of the standard `arithmetic` contract.
[listing]
one has type for all t such that t where arithmetic over t


The `one` value returns the `additive unit' for the arithmetic type.  It must obey the following axiom:

[listing][escapechar=|]
|_X_|*one=|_X_|

for all `_X_` of type `t`.

Like `zero`, the primary advantage of `one` is that it makes it easier to write generic arithmetic functions.

== The `largeSmall` Contract
[[largeSmall]]
The `largeSmall` contract defines two values that are supposed to represent the largest and smallest legal values respectively of a type. The contract itself is very simple:
\begin{program}
[listing]
contract largeSmall over t is {
  largest has type t;
  smallest has type t;
}

.The `largeSmall` Contract[[largeSmallProg]]
\end{program}

The `largeSmall` contract is implemented for `integer`s, `long` integers, and `float` by default.

=== `smallest` -- smallest value
[listing]
smallest has type for all t such that t where largeSmall over t


The `smallest`  value is the smallest legal value of the type. For example, the smallest `long` value corresponds to $-2^{63}-1$.

\begin{aside}
It is not always possible to explicitly write down the smallest value of a type. In particular, it is not possible to write the smallest `long` value in decimal numbers.
\begin{aside}
It is possible, however, to write it in hexadecimal:
[listing]
0x8000000000L

\end{aside}
\end{aside}

=== `largest` -- largest value
[listing]
largest has type for all t such that t where largeSmall over t


The `largest`  value is the largest legal value of the type. For example, the largest `float` value is `1.7976931348623157E308`.

\begin{aside}
As with the `smallest` value; it is not necessarily the case that it is possible to explicitly write the `largest` value of a type.
\end{aside}

== Bit Manipulation Functions
[[bitString]]

The `bitstring` contract defines a set of bit manipulation functions.

\begin{aside}
In the standard system, the `bitstring` functions are only implemented by the `integer` and `long` types.
\end{aside}

\begin{aside}
The bitstring functions require an explicit `import` before using them:
[listing]
import bitstring;
myPk is package { ...

\end{aside}

(((type,contracts!bitstring@`bitstring`)))
(((bitstring contract@`bitstring` contract)))
\begin{program}
[listing]
contract bitstring over t is {
    (.&.) has type (t,t)=>t;
    (.^.) has type (t,t)=>t;
    (.|.) has type (t,t)=>t;
    (.<<.) has type (t,t)=>t;
    (.>>.) has type (t,t)=>t;
    (.>>>.) has type (t,t)=>t;
    (.~.) has type (t)=>t;
    (.#.) has type (t)=>integer;
}

.The Standard `bitstring` Contract[[bitstringContractDef]]
\end{program}

=== `.\&.` Bit-wise Conjunction
[[bitAnd]]
[listing]
(.&.) has type for all t such that (t,t)=>t where bitstring over t


The `.\&.` operator returns the bit-wise conjunction of two values.

=== `.|.` Bit-wise Disjunction
[[bitOr]]
[listing]
(.|.) has type for all t such that (t,t)=>t where bitstring over t


The `.|.` operator returns the bit-wise disjunction of two values.

=== `.\^{`.} Bit-wise Exclusive-or
[[bitXor]]
[listing]
(.^.) has type for all t such that (t,t)=>t where bitstring over t


The `.\^{`.} operator returns the bit-wise exclusive of two values.

=== `.<<.` Bit-wise Left Shift
[[bitLeft]]
[listing]
(.<<.) has type for all t such that (t,t)=>t where bitstring over t


The `.<<.` operator left-shifts the left hand argument by the number of bits indicated in the right argument. It is effectively multiplication by a power of 2.

=== `.>>.` Bit-wise Arithmetic Right Shift
[[bitRight]]
[listing]
(.>>.) has type for all t such that (t,t)=>t where bitstring over t


The `.>>.` operator right-shifts the left hand argument by the number of bits indicated in the right argument. The most significant bit is replicated in the shift. It is effectively division by a power of 2.

=== `.>>>.` Bit-wise Logical Right Shift
[[bitRightLogic]]
[listing]
(.>>>.) has type for all t such that (t,t)=>t where bitstring over t


The `.>>>.` operator right-shifts the left hand argument by the number of bits indicated in the right argument. The most significant bits of the result are replaced by zero. This operator is sometimes known as logical right shift.

=== `.\~\xspace.` Bit-wise Logical Complement
[[bitComplement]]
[listing]
(.~.) has type for all t such that (t)=>t where bitstring over t


The `.\tlda.` operator forms the logical or 1's complement of its argument.

=== `.\#.` Bit Count
[[bitCount]]
[listing]
(.#.) has type for all t such that (t,t)=>t where bitstring over t


The `.\#.` operator computes the number of non-zero bits in its argument.


== Trigonometry Functions
[[trigContract]]
The `trig` contract -- see Program~\vref{trigContractDef} -- defines standard trigonometry functions.

\begin{aside}
By default, the `trig` contract is only implemented over `float`ing point numbers.
\end{aside}

\begin{aside}
All the `trig` functions assume that the angles that they accept (or return) are expressed in radians.
\end{aside}

(((type,contracts! trig@`trig`)))
(((trig contract@`trig` contract)))
\begin{program}
[listing]
contract trig over t is {
  sin has type (t)=>t;
  asin has type (t)=>t;
  sinh has type (t)=>t;
  cos has type (t)=>t;
  acos has type (t)=>t;
  cosh has type (t)=>t;
  tan has type (t)=>t;
  atan has type (t)=>t;
  tanh has type (t)=>t;
}

.The Standard `trig` Contract[[trigContractDef]]
\end{program}

=== `sin` -- Sine Function
[listing]
sin has type for all t such that (t)=>t where trig over t


The `sin` function returns the Sine of its argument -- expressed in radians.

=== `asin` -- Arc Sine Function
[listing]
asin has type for all t such that (t)=>t where trig over t


The `asin` function returns the Arc Sine of its argument -- expressed in radians.

=== `sinh` -- Hyperbolic Sine Function
[listing]
sinh has type for all t such that (t)=>t where trig over t


The `sinh` function returns the hyperbolic sine of its argument -- expressed in radians.

The hyperbolic sine of X is defined to be $(e^X - e^{-X})/2$.

=== `cos` -- Cosine Function
[listing]
cos has type for all t such that (t)=>t where trig over t


The `cos` function returns the cosine of its argument -- expressed in radians.

=== `acos` -- Arc Cosine Function
[listing]
acos has type for all t such that (t)=>t where trig over t


The `acos` function returns the arc cosine of its argument -- expressed in radians.

=== `cosh` -- Hyperbolic Cosine Function
[listing]
cosh has type for all t such that (t)=>t where trig over t


The `cosh` function returns the hyperbolic cosine of its argument -- expressed in radians.

The hyperbolic cosine of X is defined to be $(e^X + e^{-X})/2$.

=== `tan` -- Tangent Function
[listing]
tan has type for all t such that (t)=>t where trig over t


The `tan` function returns the tangent of its argument -- expressed in radians.

=== `atan` -- Arc Tangent Function
[listing]
atan has type for all t such that (t)=>t where trig over t


The `atan` function returns the Arc Tangent of its argument -- expressed in radians.

=== `tanh` -- Hyperbolic Tangent Function
[listing]
tanh has type for all t such that (t)=>t where trig over t


The `tanh` function returns the hyperbolic tangent of its argument -- expressed in radians.

The hyperbolic tangent of X is defined to be $sinh(X)/cosh(X)$.

== Numeric Display Functions
[[numberDisplay]]

The numeric display functions allow the representation of numbers as `string` values.

=== `display` -- Display a number
[[displayNumFun]]

The `display` function can be used to display a numeric value.
[listing][escapechar=|]
display has type (|<<Type>>|)=>string

The `display` function relies on the `ppDisp` function which is part of the `pPrint` contract -- see Program~\vref{ppContractProg}.

=== `\_format` -- Format a number as a string
[[formatNumber]]
[listing][escapechar=|]
_format has type (|<<Type>>|,string)=>pP

where `_Type_` is one of `integer`, `long` or `float`.

The `\_format` function is part of the `formatting` contract -- see Program~\vref{formatContractProg}.

The format string for integral values determines how the number is formatted. For example, the result of
[listing]
"--$(-15):-   0;--"

is
[listing]
"--  -15--"


The grammar for legal formatting codes for integral values may be given in the regular expression:
[listing]
`[P+-]?([09 ,.])+[P+-]`

I.e., a sign specification, followed by digit specifications optionally mixed with thousands markers and periods, terminated by an optional sign specification.

The grammar for legal formatting codes for `float` values is a little more complex:
[listing]
`[P+-]?[09 ,.]+([eE][+-]?[09 ]+)?[P+-]?

I.e., the format string for `float` values permits the exponent to be printed as well as the mantissa. If the exponent part is missing and if the `float` value cannot be represented in the available precision without an exponent then an exception will be `raised`.

The complete list[formatting] codes for formatting numeric values is:

\begin{description}
`9`:: A digit is displayed if it is significant. I.e., if it is non-zero or there is a non-zero digit to the left of the digit.
`0`:: A zero character is used for numeric values. It always results in a digit being displayed. For example, the value of
[listing]
"--$(5):00;--"

is the string
[listing]
"--05--"


`\spce{`}:: A space character is similar to the `0` code; except that a leading space is displayed instead of a leading zero.

For example, the value of
[listing]
"--$(5):00;--"

is the string
[listing]
"-- 5--"


\begin{aside}
Signs are treated specially with the `\spce{`} code: any produced sign character is migrated past leading spaces -- with the result that the sign character is always abutted to the digits.

For example, the result of
[listing]
"--$(-15):-   0;--"

is
[listing]
"--  -15--"

The `\spce{`} code is especially useful for lining up columns of figures where a leading space is preferred over leading zeroes.
\end{aside}

`.`:: A period is displayed if there is a digit to the left.

This is used for showing currency values -- when they are represented internally as pennies but should be displayed as dollar values -- and for floating point numbers.
`,`:: A comma is displayed if there is a digit to the left.

This is used for displaying values in the `thousands' notation. For example, the value of
[listing]
"--$(120345567):999,999,999,999;--"

is the string:
[listing]
"--120,345,567--"


`-`:: Is used to control how signed values are presented. If the value is negative then a `-` character is displayed; if the value is positive then a space is displayed.

\begin{aside}
The `-` <<FormatCode>> may appear at either end of the display. A leading `-` results in the sign being displayed at the beginning -- before any digits -- and a trailing `-` results in the sign appended to the end.
\end{aside}

\begin{aside}
\begin{aside}
If no `sign' code is present in the <<FormattingSpec>> then nothing is displayed if the value is positive or negative.
\end{aside}
\end{aside}

`+`:: Always results in a sign being displayed. If the value is negative then a `-` character is displayed; otherwise a `+` character is displayed.

Like the `-` code, the `+` may appear at either end of the display format.

`P`:: The `P` code uses parentheses on either end of the value to indicate a negative value. If the value is positive then spaces are appended to either end; otherwise the number is enclosed in `()`'s.

\begin{aside}
The `P` code should be placed at _both_ ends of the <<FormattingSpec>>.
For example, the expression:
[listing]
"Balance: $Amnt:P999900.00P; remaining"

where `Amnt` had value -563 would result in
[listing]
"Balance: (05.63) remaining"

\end{aside}
`X`:: Causes the integer to be formatted as a hexadecimal number; and a hexadecimal digit is displayed if it is significant. I.e., if it is non-zero or there is a non-zero digit to the left of the digit.

For example, this can be used to display the Unicode equivalent of a character:
[listing]
"Unicode: $C/$(C as integer):XXXXX;"


\end{description}

== Additional Arithmetic Functions
[[mathContract]]
The `math` contract -- see Program~\vref{mathContractDef} -- defines additional functions.

\begin{aside}
The `math` contract is not implemented by all number types; in particular, it is implemented by `integer`, `long` and `float`; but is not implemented by `decimal`.
\end{aside}

(((type,contracts! math@`math`)))
(((math contract@`math` contract)))
\begin{program}
[listing]
contract math over t is {
  min has type (t,t)=>t;
  max has type (t,t)=>t;
  random has type (t)=>t;
  sqrt has type (t)=>t;
  cbrt has type (t)=>t;
  ceil has type (t)=>t;
  floor has type (t)=>t;
  round has type (t)=>t;
  log has type (t)=>t;
  log10 has type (t)=>t;
  exp has type (t)=>t
  (**) has type (t,t) => t;
}

.The Standard `math` Contract[[mathContractDef]]
\end{program}

=== `min` -- minimum value
[listing]
min has type for all t such that (t,t)=>t where math over t


The `min` function returns the smaller of its two arguments.

=== `max` -- maximum value
[listing]
max has type for all t such that (t,t)=>t where math over t


The `max` function returns the larger of its two arguments.

=== `sqrt` -- square root
[listing]
sqrt has type for all t such that (t)=>t where math over t


The `sqrt` function returns the square root of its argument. If the argument is negative, the returned value is undefined.

=== `cbrt` -- cube root
[listing]
cbrt has type for all t such that (t)=>t where math over t


The `cbrt` function returns the cube root of its argument. Note that $-cbrt(X)=cbrt(-X)$.

=== `ceil` -- ceiling
[listing]
ceil has type for all t such that (t)=>t where math over t


The `ceil` function returns the nearest integral value that is equal to or larger than X.
\begin{aside}
For integral types,
[listing]
ceil(X)=X

\end{aside}

=== `floor` -- floor
[listing]
floor has type for all t such that (t)=>t where math over t


The `floor` function returns the nearest integral value that is equal to or smaller than X.
\begin{aside}
For integral types,
[listing]
floor(X)=X

\end{aside}

=== `round` -- round to closest integral
[listing]
round has type for all t such that (t)=>t where math over t


The `round` function returns the nearest integral value to its argument.
\begin{aside}
For all values,
[listing]
round(X)=floor(X + 0.5)

\end{aside}


=== `log` -- Natural Logarithm
[listing]
log has type for all t such that (t)=>t where math over t


The `log` function returns the natural logarithm of its argument.

=== `log10` -- Logarithm Base 10
[listing]
log10 has type for all t such that (t)=>t where math over t


The `log10` function returns the base 10 logarithm of its argument.


=== `exp` -- Natural Exponentiation
[listing]
exp has type for all t such that (t)=>t where math over t


The `exp` function returns the value $e^X$.

=== `random` -- random number generation
(((random number generation)))
[listing]
random has type for all t such that (t)=>t where math over t


The `random` function returns a number in the half-open range [0,X) where X is the argument of the function.
\begin{aside}
The argument of the `random` function must be a positive number. However, it can be any `normal' kind of arithmetic value.
\end{aside}
The number generated is the next in a sequence of numbers that is typically _pseudo-random_: i.e., not actually random but statistically indistinguishable from random.

The type of the returned result is the same as the type of its argument.

=== `**` -- exponentiation
[[powerFunction]]
(((math contract@`math` contract,**@`**`)))
`**` is part of the standard `math` contract.
[listing]
(**) has type for all t such that (t,t)=>t where math over t

The `**` function raises the first argument to the power of the second.

For example, the expression
[listing]
X**3

denotes the cube of `X`.

== Numeric Ranges
[[numericRange]]
The `range` type defines a numeric range. It is useful primarily in loops; for example:
[listing]
X is list of {all Ix where Ix in range(0,10,1) }

has, as its value:
[listing]
list of [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


\begin{aside}
Ranges are half-open: they include their beginning value but do not include their terminator value. This permits simpler merging of ranges:
[listing][escapechar=|]
range(0,10,1)++range(10,20,1) |\ensuremath{\equiv}| range(0,20,1)

\end{aside}

=== The `range` Type
The `range` type is defined in Program~\vref{rangeTypeProg}.
\begin{program}
[listing]
type range of t where arithmetic over t and comparable over t
  is range(t,t,t);

.The Standard `range` Type[[rangeTypeProg]]
\end{program}

Note that this is a constrained type. It is a generic type but is only defined for type arguments that are `comparable` and which are defined over `arithmetic`.

The `range` type implements the `sizeable` contract (see <<sizeableContract>>), the `iterable` contract (see Section~\ref{iterableContract}) and the `concatenate` (see <<concatenateContract>>) contracts. This means that `range` is suitable for controlling for loops:
[listing]
for Ix in range(0,10,1) do
  logMsg(info,"$Ix")

as well as for using in queries such as above.
