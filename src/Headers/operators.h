/*
  This is where you define a new operator
  Copyright (c) 2023 and beyond. Francis G. McCabe
 */

/* Declare standard operators */

infixOp("::=",1549,1550,1549,"algebraic type definition",True)
infixOp("|",1548,1548,1547,"type union, case union, abstraction",True)
prefixOp("|",1548,1547,"type union, case union",True)
infixOp(":",1249,1250,1249,"type annotation",True)
infixOp("~~",1239,1240,1240,"quantifier",True)
infixOp("|:",1234,1235,1234,"constrained type",True)
infixOp("<~",998,999,998,"type interface rule",True)
infixOp("|=",998,999,998,"implicit variable",True)
prefixOp("raises",999,998,"can raise an exception",True)
infixOp("~>",1230,1231,1230,"type function",True)
infixOp("-->",1248,1249,1248,"grammar rule arrow",True)
infixOp("<-",904,905,904,"variable bind",True)
prefixOp("if",1175,1174,"if ... then ... else",True)
infixOp("then",1179,1180,1179,"if ... then ... else",True)
infixOp("else",1199,1200,1200,"if ... then ... else",True)
infixOp("do",1199,1200,1199,"while T do {}",True)
prefixOp("do",200,199,"do {}",True)
prefixOp("while",1175,1174,"while ... do {}",True)
prefixOp("for",1175,1174,"for ... do {}",True)
prefixOp("try",1200,1199,"try {...} catch {...}",True)
infixOp("catch",1198,1199,1198,"try {...} catch {...}",True)
infixOp(";",1250,1251,1251,"sequencing operator",True)
postfixOp(";",1250,1251,"sequencing operator",True)
prefixOp("valof",300,299,"evaluate an action expression",True)
prefixOp("generator",300,299,"define a generator expression",True)
prefixOp("yield",300,299,"yield in a generator expression",True)
infixOp("->>",1199,1200,1199,"dependent type marker",True)
infixOp(",",999,1000,1000,"tupling operator",True)
infixOp(",..",999,1000,999,"list cons",True)
infixOp("=",974,975,974,"definition",True)
infixOp(":=",974,975,974,"assignment",False)
// prefixOp("async", 951,950, "async prefix to function type",True)
infixOp("=>",949,950,950,"function arrow",True)
infixOp("=>>",949,950,950,"continuation arrow",True)
infixOp(">>=",949,950,950,"monadic bind",False)
infixOp(">>",949,950,950,"grammar produce value",True)
prefixOp("*>",905,904,"grammar skip",True)
infixOp("<=>",949,950,949,"constructor arrow",True)
infixOp("where",910,911,910,"semantic guard",True)
infixOp("||",919,920,920,"disjunction",True)
infixOp("??",919,920,920,"conditional operator",True)
infixOp("&&",909,910,910,"conjunction",True)
infixOp("*>",904,905,904,"for all",True)
infixOp("->",889,890,889,"map entry",False)
infixOp("==",899,900,899,"equality predicate",False)
infixOp("~=",899,900,899,"not equals",False)
infixOp(".=",899,900,899,"pattern match",True)
infixOp("^=",899,900,899,"optional decomposition match",True)
infixOp("?=",899,900,899,"optional decomposition match",True)
prefixOp("?",820,819,"mark expression as optionally there",True)
prefixOp("ref",899,898,"reference type/cell",True)
infixOp("^",99,100,99,"Apply optional function and match result",True)
prefixOp("^",100,99,"Optional propagation",True)
prefixOp("case",901,900,"case expression",True)
infixOp("<",899,900,899,"less than",False)
infixOp("=<",899,900,899,"less than or equal",False)
infixOp(">",899,900,899,"greater than",False)
infixOp(">=",899,900,899,"greater than or equal",False)
infixOp("in",899,900,900,"list membership",True)
prefixOp("let",899,898,"part of let def",True)
infixOp("//",960,960,959,"map over",False)
infixOp("///",960,960,959,"indexed map over",False)
infixOp("^/",960,960,959,"filter",False)
infixOp("^//",800,800,799,"filter map",False)
infixOp("^?",800,800,799,"option propagate",False)
infixOp("#",759,760,759,"package separator",True)
infixOp("++",719,720,720,"concatenate",False)
infixOp("+++",719,720,720,"choice",False)
infixOp("+",720,720,719,"addition",False)
infixOp("-",720,720,719,"subtraction",False)
infixOp(".|.",720,720,719,"bitwise or",False)
infixOp(".^.",720,720,719,"bitwise xor",False)
infixOp("⊕",720,720,719,"addition",False)
infixOp("<$",719,720,720,"constant replace",False)
infixOp("*",700,700,699,"multiplication",False)
infixOp("/",700,700,699,"division",False)
infixOp("\\/",720,720,719,"union",False)
infixOp("/\\",700,700,699,"intersection",False)
infixOp("\\",700,700,699,"difference",False)
infixOp("\\+",700,700,699,"add element to set",False)
infixOp("\\-",700,700,699,"remove element from set",False)
infixOp(".<.",699,700,699,"set membership",False)
infixOp(".&.",700,700,699,"bitwise and",False)
prefixOp(".+.",700,699,"count of number of bits",False)
infixOp("%",700,700,699,"modulo",False)
infixOp("**",600,600,599,"exponentiation",False)
infixOp("<*",600,600,599,"left fold",False)
infixOp(".<<.",600,600,599,"left shift",False)
infixOp(".>>.",600,600,599,"logical shift right",False)
infixOp(".>>>.",600,600,599,"arithmetic shift right",False)
infixOp(".#.",600,600,599,"test nth bit",False)
infixOp("•",450,450,449,"function composition",False)
infixOp("••",450,450,449,"binary function composition",False)
infixOp("@",399,400,400,"meta annotation",True)
infixOp("::",399,400,399,"type coercion",True)
infixOp(":?",399,400,399,"fallable type coercion",True)
infixOp(".",100,100,99,"object access",True)
prefixOp(".",10,9,"identify enumerator",True)
prefixOp("#",1750,1749,"Macro statement marker",True)
prefixOp("private",1700,1699,"private visibility",True)
prefixOp("public",1700,1699,"public visibility",True)
prefixOp("assert",1240,1239,"assert condition",False)
prefixOp("show",1240,1239,"display debug message",False)
prefixOp("trace",140,139,"display tracing message",False)
prefixOp("contract",1560,1559,"contract definition",True)
prefixOp("implementation",1260,1259,"contract implementation",True)
prefixOp("type",1251,1250,"type marker",True)
prefixOp("all",1010,1009,"universal quantifier",True)
prefixOp("exists",1010,1009,"existential quantifier",True)
prefixOp("~",905,904,"logical negation",True)
prefixOp("open",900,899,"import object",True)
prefixOp("import",900,899,"import module",True)
prefixOp(".~.",650,649,"bitwise 1's complement",False)
prefixOp("@",400,399,"meta annotation",True)
prefixOp("return",930,929,"wrap value in monad",False)
prefixOp("valis",930,929,"return value from execution",True)
prefixOp("raise",930,929,"raise an exception",True)
infixOp("spawn",929,930,929,"spawn a coroutine",True)
infixOp("resume",829,830,829,"resume coroutine",True)
infixOp("suspend",829,830,829,"suspend coroutine",True)
infixOp("retire",829,830,829,"retire a coroutine",True)
prefixOp("break",10,9,"break out of an action (loop or block)",True)
prefixOp("-",300,299,"arithmetic negation",False)
postfixOp("*",699,700,"multicat",False)
postfixOp("+",699,700,"one or more repetitions",False)
postfixOp("default",939,940,"default value marker",True)
infixOp("!",99,100,99,"pick up value from a ref cell",True)
postfixOp("!",99,100,"pick up value from a ref cell",True)
prefixOp("$$",305,304,"thunk expression",True)
postfixOp("!!",99,100,"pick up value from a thunk",True)
token(". ","statement terminator",True)
bracket("()","(",")",",",2000,"parentheses")
bracket("[]","[","]",",",2000,"square brackets")
bracket("[||]","[|","|]","",2000,"measure brackets")
bracket("{!!}","{!","!}","",2000,"iota comprehension")
bracket("{??}","{?","?}","",2000,"test comprehension")
bracket("{}","{","}",".\n",2000,"non-recursive braces")
bracket("{..}","{.",".}",".\n",2000,"recursive braces")
bracket("<||>","<|","|>","",2000,"meta quote")
bracket("/../","/.","./","",2000,"dfa expression")
