/*
  This is where you define a new operator so that the compiler and
  the run-time system can see it
  Copyright (c) 2016, 2017. Francis G. McCabe
 */

infixOp(". ",1899,1900,1900,"statement separator")
infixOp("::=",1249,1250,1249,"algebraic type definition")
infixOp("|",1248,1249,1249,"type union and conditional")
infixOp("?|",1248,1249,1249,"option or-else operator")
infixOp(":",1249,1250,1249,"type annotation")
infixOp("~~",1239,1240,1240,"quantifier")
infixOp("|:",1234,1235,1234,"constrained type")
infixOp("<~",1230,1231,1230,"type rule")
infixOp("~>",1230,1231,1230,"type alias definition")
infixOp("?",1199,1200,1199,"conditional operator")
infixOp("-->",1199,1200,1199,"grammar rule")
infixOp("->>",1199,1200,1199,"dependent type marker")
infixOp(",",999,1000,1000,"tupling operator")
infixOp(",..",999,1000,1000,"list cons")
infixOp("=>",949,950,949,"function arrow")
infixOp("==>",949,950,949,"macro arrow")
infixOp("<=",949,950,949,"pattern arrow")
infixOp("<=>",949,950,949,"constructor arrow")
infixOp("=",949,950,949,"definition")
infixOp(":=",949,950,949,"reassignable variable definition")
infixOp("where",929,930,929,"semantic guard")
infixOp("||",920,920,919,"disjunction")
infixOp("&&",910,910,909,"conjunction")
infixOp(">>=",899,900,900,"monadic bind")
infixOp("->",899,900,899,"map entry")
infixOp("==",899,900,899,"equality predicate")
infixOp("=!=",899,900,899,"not equals")
infixOp(".=",899,900,899,"pattern match")
infixOp("?.=",899,900,899,"optional decomposition match")
infixOp("<",899,900,899,"less than")
infixOp("=<",899,900,899,"less than or equal")
infixOp(">",899,900,899,"greater than")
infixOp(">=",899,900,899,"greater than or equal")
infixOp("in",899,900,899,"list membership")
infixOp("//",800,800,799,"map over")
infixOp("///",800,800,799,"indexed map over")
infixOp("^/",800,800,799,"filter")
infixOp("^//",800,800,799,"filter map")
infixOp("#",759,760,759,"package separator")
infixOp("++",719,720,720,"concatenate")
infixOp("+",720,720,719,"addition")
infixOp("-",720,720,719,"subtraction")
infixOp(".|.",720,720,719,"bitwise or")
infixOp(".^.",720,720,719,"bitwise xor")
infixOp("*",700,700,699,"multiplication")
infixOp("/",700,700,699,"division")
infixOp(".&.",700,700,699,"bitwise and")
infixOp("%",700,700,699,"modulo")
infixOp("**",600,600,599,"exponentiation")
infixOp(".<<.",600,600,599,"shift left")
infixOp(".>>.",600,600,599,"logical shift right")
infixOp(".>>>.",600,600,599,"arithmetic shift right")
infixOp(".#.",600,600,599,"test nth bit")
infixOp("<<",499,500,499,"string formatting")
infixOp(".~",499,500,499,"grammar parse")
infixOp("~",489,499,489,"grammar remainder")
infixOp("â€¢",450,450,449,"function composition")
infixOp("?.",450,450,449,"optional object access")
infixOp("@",399,400,400,"meta annotation")
infixOp("::",399,400,399,"type coercion")
lastInfOp
infixOp(".",100,100,99,"object access")

prefixOp("#",1750,1749,"Macro statement marker")
prefixOp("private",1700,1699,"private program")
prefixOp("public",1700,1699,"public program")
prefixOp("assert", 1260,1259,"assert condition")
prefixOp("show", 1260,1259,"display debug message")
prefixOp("contract",1260,1259,"contract definition")
prefixOp("implementation",1260,1259,"contract implementation")
prefixOp("type",1251,1250,"type marker")
prefixOp("all",1010,1009,"universal quantifier")
prefixOp("exists",1010,1009,"existential quantifier")
prefixOp("\\+",905,904,"logical negation")
prefixOp("ref",900,899,"reference type")
prefixOp("open",900,899,"import object")
prefixOp("import",900,899,"import module")
prefixOp("return",899,890,"wrap value in monad")
prefixOp("raise",899,890,"error return in monad")
prefixOp("+",760,759,"lookahead in grammar rule")
prefixOp(".~.",650,649,"bitwise 1's complement")
prefixOp("@",400,399,"meta annotation")
lastPreOp
prefixOp("-",300,299,"arithmetic negation")

postfixOp(". ",1899,1900,"statement terminator")
postfixOp("default",939,940,"default value marker")
lastPostOp
postfixOp("!",99,100,"pick up a value from a ref cell")

token("$","Used for curried functions and types")
