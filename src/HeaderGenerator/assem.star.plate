star.compiler.assem{
  -- Automatically Generated Assembler -- Do NOT Edit
  import star.
  import star.multi.
  import star.sort.

  import star.compiler.errors.
  import star.compiler.escapes.
  import star.compiler.location.
  import star.compiler.data.
  import star.compiler.types.
  import star.compiler.types.encode.
  import star.compiler.ltipe.

  public codePolicy ::= .hardDefinition | .softDefinition.

  public implementation display[codePolicy] => {
    disp(.hardDefinition) => "hard".
    disp(.softDefinition) => "soft".
  }

  public codeSegment ::= .func(termLbl,codePolicy,tipe,integer,cons[assemOp]) |
    .global(termLbl,tipe,integer,cons[assemOp]) |
    .struct(termLbl,tipe,integer) |
    .tipe(tipe,typeRule,cons[(termLbl,tipe,integer)]).

  public assemOp ::=
#(OpCodes)
    .iLbl(string, assemOp).

  public assemLbl ::= .bo(string) | .bp(string).

  public assem:(codeSegment) => data.
  assem(Df) => case Df in {
    | .func(Nm,H,Sig,Lx,Ins) => valof{
      (Lt0,_) = findLit([],.symb(Nm));
      (Code,Lts,Lcs) = assemBlock(Ins,[],[],Lt0,[]);
      valis mkCons("func",
          [.symb(Nm),encPolicy(H),.strg(encodeSignature(Sig)),.intgr(Lx),mkTpl(Code::cons[data]),litTbl(Lts),mkTpl(Lcs::cons[data])])
    }
    | .global(Nm,Sig,Lx,Ins) => valof{
      (Lt0,_) = findLit([],.symb(Nm));
      (Code,Lts,Lcs) = assemBlock(Ins,[],[],Lt0,[]);
      valis mkCons("global",
         [.symb(Nm),.strg(encodeSignature(Sig)),.intgr(Lx),mkTpl(Code::cons[data]),litTbl(Lts),mkTpl({Lcl|Lcl in Lcs})])
    }
    | .struct(Lbl,Tp,Ix) =>
      mkCons("struct",[.symb(Lbl),.strg(encodeSignature(Tp)),.intgr(Ix)])
    | .tipe(Tp,TpRl,Map) =>
      mkCons("type",[.strg(tpName(Tp)),.strg(encodeTpRlSignature(TpRl)),encodeMap(Map)])
  }.

  encodeMap(Entries) => mkTpl(Entries//((Lbl,_,Ix))=>mkTpl([.symb(Lbl),.intgr(Ix)])).

  encPolicy(.hardDefinition) => mkTpl([]).
  encPolicy(.softDefinition) => mkTpl([.strg("soft")]).

  private assemBlock:(cons[assemOp],multi[data],cons[string],map[data,integer],set[data]) =>
                                        (multi[data],map[data,integer],set[data]).
  assemBlock([],Code,Lbls,Lts,Lcx) => (Code,Lts,Lcx).
  assemBlock([I,..Ins],SoFar,Lbs,Lts,Lcx) => valof{
    (Code,Lt0,Lc0) = mnem(I,Lbs,Lts,Lcx);
    valis assemBlock(Ins,SoFar++Code,Lbs,Lt0,Lc0)
  }

  private mnem:(assemOp,cons[string],map[data,integer],set[data]) =>
    (multi[data],map[data,integer],set[data]).
  mnem(.iLbl(Lb,I),Lbls,Lts,Lcs) => mnem(I,[Lb,..Lbls],Lts,Lcs).
#(Mnem)
  mnem(I,Lbls,Lts,Lcs) => valof{
    reportTrap("Cannot assemble instruction $(I)");
    valis ([],Lts,Lcs)
  }.

  findLit:(map[data,integer],data) => (map[data,integer],integer).
  findLit(Lts,T) where O ?= Lts[T] => (Lts,O).
  findLit(Lts,T) where O .= size(Lts) => (Lts[T->O],O).

  findLevel:(cons[string],assemLbl) => option[integer].
  findLevel(Lbs,Lb) => let{.
    findLvl([],_) => .none.
    findLvl([LL,.._], Lvl) where .bo(LL) .= Lb => .some(Lvl).
    findLvl([LL,.._], Lvl) where .bp(LL) .= Lb => .some(-Lvl).
    findLvl(["",..Ls],Lvl) => findLvl(Ls,Lvl+1).
    findLvl([_,..Ls],Lvl) => findLvl(Ls,Lvl).
  .} in findLvl(Lbs,0).

  litTbl:(map[data,integer]) => data.
  litTbl(Lts) => mkTpl(sort(Lts::cons[(data,integer)],((T1,Ix1), (T2,Ix2)) => Ix1<Ix2)//fst).

  public implementation display[assemLbl] => {
    disp(.bo(L)) => "→\\#(L)".
    disp(.bp(L)) => "←\\#(L)".
  }

  public implementation display[codeSegment] => {
    disp(.func(Nm,_,Tp,_,Ins)) => "fun $(Nm)\:$(Tp)\n"++showMnem(Ins).
    disp(.global(Nm,Tp,_,Ins)) => "glb $(Nm)\:$(Tp)\n"++showMnem(Ins).
    disp(.struct(Lbl,Tp,Ix)) => "struct $(Lbl)\:$(Tp) @ $(Ix)".
    disp(.tipe(_Tp,TpRl,Map)) => "type $(TpRl), map = $(Map)".
  }

  public implementation display[assemOp] => {
    disp(Op) => showIns(Op,[]).
  }

  showMnem:(cons[assemOp]) => string.
  showMnem(Ops) => showBlock(Ops,[0]).

  showBlock:(cons[assemOp],cons[integer]) => string.
  showBlock(Ins,Pc) => interleave(showCode(Ins,Pc),"\n")*.

  showCode([],_) => [].
  showCode([Ins,..Cde],Pc) => ["\\#(showPc(Pc)\: \\#(showIns(Ins,Pc))",..showCode(Cde,bumpPc(Pc))].

  showIns:(assemOp,cons[integer]) => string.
  showIns(.iLbl(Lb,I),Pc) => "\#(Lb): \\#(showIns(I,Pc))".
#(Show)

  showPc:(cons[integer]) => string.
  showPc(Pcs) => interleave(Pcs//disp,":")*.

  bumpPc:(cons[integer]) => cons[integer].
  bumpPc([Pc,..Rest]) => [Pc+1,..Rest].

  public opcodeHash = #(Hash).
}
