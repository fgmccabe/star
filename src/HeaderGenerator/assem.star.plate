star.compiler.assem{
  -- Automatically Generated Assembler -- Do NOT Edit
  import star.
  import star.sort.

  import star.compiler.location.
  import star.compiler.terms.
  import star.compiler.types.

  public codeSegment ::= method(termLbl,tipe,integer,list[assemOp]) |
    global(termLbl,tipe,integer,list[assemOp]) |
    struct(termLbl,tipe,tipe).

  public assemOp ::=
#(OpCodes)
    iLbl(string) |
    iLocal(string,string,string,integer) |
    iLine(term).

  public assemLbl ::= al(string).

  public assem:(codeSegment) => term.
  assem(method(Nm,Sig,Max,Ins)) where
    (Lt0,_) .= findLit([],enum(Nm)) &&
    (Code,Lts,Lns,Lcs) .= mnem(Ins,genLblTbl(Ins,0,[]),Lt0,[],[],0,[]) =>
    term(tLbl("method",7),
      [strg(encodeLbl(Nm)),strg(encodeSignature(Sig)),intgr(Max),mkTpl(Code),litTbl(Lts),mkTpl(Lcs),
            mkTpl(sortLines(Lns))]).
  assem(global(Nm,Sig,Max,Ins)) where
    (Lt0,_) .= findLit([],enum(Nm)) &&
    (Code,Lts,Lns,Lcs) .= mnem(Ins,genLblTbl(Ins,0,[]),Lt0,[],[],0,[]) =>
    term(tLbl("global",7),
       [strg(encodeLbl(Nm)),strg(encodeSignature(Sig)),intgr(Max),mkTpl(Code),litTbl(Lts),mkTpl(Lcs),
            mkTpl(sortLines(Lns))]).
  assem(struct(Lbl,Tp,Flds)) =>
    term(tLbl("struct",3),[enum(Lbl),strg(encodeSignature(Tp)),strg(encodeSignature(Flds))]).

  mnem:(list[assemOp],map[string,integer],map[term,integer],map[term,integer],set[term],integer,list[term]) =>
    (list[term],map[term,integer],map[term,integer],list[term]).
  mnem([],Lbls,Lts,Lns,Lcs,Pc,Code) => (Code,Lts,Lns,[Lcl|Lcl in Lcs]).
  mnem([iLbl(_),..Ins],Lbls,Lts,Lns,Lcs,Pc,Code) => mnem(Ins,Lbls,Lts,Lns,Lcs,Pc,Code).
  mnem([iLocal(Nm,Frm,End,Off),..Ins],Lbls,Lts,Lns,Lcs,Pc,Code) where
    F ^= Lbls[Frm] &&
    T ^= Lbls[End] =>
    mnem(Ins,Lbls,Lts,Lns,_addMem(mkTpl([strg(Nm),intgr(F),intgr(T),intgr(Off)]),Lcs),Pc,Code).
  mnem([iLine(Lc),..Ins],Lbs,Lts,Lns,Lcs,Pc,Code) => mnem([idLine(Lc),..Ins],Lbs,Lts,Lns[mkTpl([Lc,intgr(Pc)])->Pc],Lcs,Pc,Code).
#(Mnem)

  genLblTbl:(list[assemOp],integer,map[string,integer]) => map[string,integer].
  genLblTbl([],_,Lbls) => Lbls.
  genLblTbl([iLbl(Lbl),..Ins],Pc,Lbls) =>
    genLblTbl(Ins,Pc,Lbls[Lbl->Pc]).
  genLblTbl([iLocal(_,_,_,_),..Ins],Pc,Lbls) =>
    genLblTbl(Ins,Pc,Lbls).
  genLblTbl([iLine(T),..Ins],Pc,Lbs) => genLblTbl([idLine(T),..Ins],Pc,Lbs).
#(Lbls)

  findLit:(map[term,integer],term) => (map[term,integer],integer).
  findLit(Lts,T) where O ^= Lts[T] => (Lts,O).
  findLit(Lts,T) where O .= size(Lts) => (Lts[T->O],O).

  litTbl:(map[term,integer]) => term.
  litTbl(Lts) => mkTpl(sort(Lts::list[keyval[term,integer]],((T1->Ix1), (T2->Ix2)) => Ix1<Ix2)//(K->_)=>K).

  sortLines:(map[term,integer]) => list[term].
  sortLines(Lns) => (sort(Lns::list[keyval[term,integer]],compLine)//(K->_)=>K).

  compLine:(keyval[term,integer],keyval[term,integer])=>boolean.
  compLine(T1->P1,T2->P2) => P1<P2.


  public implementation display[codeSegment] => {.
    disp(method(Nm,Sig,Mx,Ins)) => ssSeq([disp(Nm),ss(":"),disp(Sig),ss("\n"),..showMnem(Ins,0,[])]).
    disp(global(Nm,Sig,Max,Ins)) => ssSeq([ss("global "),disp(Nm),ss(":"),disp(Sig),ss("\n"),..showMnem(Ins,0,[])]).
  .}

  implementation display[assemLbl] => {.
    disp(al(Nm)) => ss(Nm).
  .}

  showMnem:(list[assemOp],integer,list[ss]) => list[ss].
  showMnem([],_,Out) => Out.
  showMnem([iLbl(Lb),..Ins],Pc,Out) => showMnem(Ins,Pc,[Out..,ss(Lb),ss(":\n")]).
  showMnem([iLocal(Nm,Frm,End,_Off),..Ins],Pc,Out) => showMnem(Ins,Pc,[Out..,ss(Nm),ss("::"),disp(Frm),ss("-"),disp(End),ss("\n")]).
#(Show)
}
