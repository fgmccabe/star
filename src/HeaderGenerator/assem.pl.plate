/* Automatically generated, do not edit */

:- module(assemble,[assem/2, dispIns/1, opcodeHash/1]).
:- use_module(misc).
:- use_module(lterms).
:- use_module(types).
:- use_module(encode).
:- use_module(display).
:- use_module(escapes).

assem(func(Nm,H,Sig,Lx,Ins),MTpl) :-
    findLit([],Nm,_,Ls0),
    assemBlock(Ins,[],Ls0,Lts,[],Lcs,Cde,[]),
    mkInsTpl(Cde,Code),
    mkLitTpl(Lts,LtTpl),
    mkTpl(Lcs,LcsTpl),
    encPolicy(H,HP),
    mkCons("func",[Nm,HP,strg(Sig),intgr(Lx),Code,LtTpl,LcsTpl],MTpl).
assem(struct(Lbl,Sig,Ix),Tpl) :-
    mkCons("cons",[Lbl,Sig,intgr(Ix)],Tpl).
assem(tipe(Tp,Rl,Map),Tpl) :-
    encMap(Map,MapEls),
    tpName(Tp,TpNm),
    encType(Rl,RlSig),
    mkTpl(MapEls,MapTpl),
    mkCons("type",[strg(TpNm),strg(RlSig),MapTpl],Tpl).

encPolicy(hard,T) :-
  mkTpl([],T).
encPolicy(soft,T) :-
  mkTpl([strg("soft")],T).

encMap([],[]).
encMap([(Lbl,Ix)|Map],[E|MM]) :-
  mkTpl([Lbl,intgr(Ix)],E),
  encMap(Map,MM).

assemBlock(Ins,Lbs,Lt,Lts,Lc,Lcx,Code,Cdx) :-
    mnem(Ins,[none|Lbs],Lt,Lts,Lc,Lcx,Code,Cdx).

mnem([],_,Lt,Lt,Lc,Lc,Cdx,Cdx).
mnem([iLbl(Lb,Inner)|Ins],Lbs,Lt,Lts,Lc,Lcx,Code,Cdx) :-
  mnem(Inner,[Lb|Lbs],Lt,Lt0,Lc,Lc0,Code,Cd0),
  mnem(Ins,Lbs,Lt0,Lts,Lc0,Lcx,Cd0,Cdx).
mnem([iLocal(Nm,Scope,Off)|Ins],Lbs,Lt,Lts,Lc,Lcx,Code,Cdx) :-
    findLevel(0,Lbs,bp(Scope),Lvl),
    mkTpl([strg(Nm),intgr(Lvl),intgr(Off)],Entry),
    (is_member(Entry,Lc)->Lc0=Lc;Lc0=[Entry|Lc]),
    mnem(Ins,Lbs,Lt,Lts,Lc0,Lcx,Code,Cdx).
#(Mnem)

findLevel(Lvl,[Tgt|_],bo(Tgt),Lvl) :-!.
findLevel(Lvl,[Tgt|_],bp(Tgt),MLvl) :-!, MLvl is -Lvl.
findLevel(L,[none|Ends],Tgt,Lo) :-
  L1 is L+1,
  findLevel(L1,Ends,Tgt,Lo).
findLevel(L,[_|Ends],Tgt,Lo) :-
  findLevel(L,Ends,Tgt,Lo).

findLit(Lits,V,LtNo,Lits) :- is_member((V,LtNo),Lits),!.
findLit(Lits,V,LtNo,[(V,LtNo)|Lits]) :- length(Lits,LtNo).

mkLitTpl(Lits,Tpl) :-
    reverse(Lits,RLit),
    project0(RLit,Els),
    mkTpl(Els,Tpl).

mkInsTpl(Is,Tpl) :-
    map(Is,assemble:mkIns,Ins),
    mkTpl(Ins,Tpl).

mkIns(O,intgr(O)) :- number(O).
mkIns(S,strg(S)) :- string(S).
mkIns(C,Tpl) :- length(C,_),
  mkInsTpl(C,Args),
  mkTpl(Args,Tpl).

dispIns(Prog) :-
  showMnem(Prog,O),
  displayln(O).

showIns(func(Nm,H,Sig,_Lx,Ins),sq([HH,ss(" "),NN,ss(":"),ss(Sig),nl(0),iv(nl(0),II)])) :-
  ssTrm(Nm,0,NN),
  showMnem(Ins,[0],_,[],II),
  ssPolicy(H,HH),!.

ssPolicy(soft,ss("soft")).
ssPolicy(hard,ss("hard")).

showBlock(Ins,Prefix,iv(nl(K),II)) :-
  K is length(Prefix)*2,
  showMnem(Ins,[0|Prefix],II).

showMnem([],_,[ss("end")]).
showMnem([iLbl(Lb)|Ins],Pc,[sq([ss(Lb),ss(":")])|II]) :-
  showMnem(Ins,Pc,II).
showMnem([iLocal(Nm,Scope,Off)|Ins],Pc,[sq([ss(Nm),ss("::"),ss(Scope),ss(":"),ix(Off)])|II]) :-
  showMnem(Ins,Pc,II).
#(Show)

opcodeHash(#(Hash)).

bumpPc([Pc|Rest],Dl,[Pc1|Rest]) :- Pc1 is Pc+Dl.

showPc(Pc,iv(ss(":"),Pcs)) :-
  map(Pc,assemble:shPc,Pcs).

shPc(I,ix(I)).

