-- Sieve of erastosthenes

type int#list is nil or cons(#int, int#list);

procedure display(io:#file, L:int#list){
  __#outStr(io,"[");
  var sep:#string := "";
  var Ls:int#list := L;
  LL :: loop {
    switch Ls in {
      nil -> leave LL;
      cons(H:#int,Tl:int#list) -> {
        __#outStr(io,sep);
        sep := ", ";
        __#outInt(io,H);
        Ls := Tl;
      }
    }
  };
  __#outStr(io,"]");
};

function filter(L:int#list,P:#int):int#list => 
  switch L in {
    nil -> nil;
    cons(Hd:#int,Tl:int#list) -> valof{
      var Mod:#int is Hd%P;
      var Rest:int#list is filter(Tl,P);
      if Mod=0 then
        valis Rest
      else
        valis cons(Hd,Rest)
  }
};

function sieve(L:int#list):int#list =>
  switch L in {
    nil -> nil;
    cons(P:#int,Tl:int#list) -> valof{
      var Filtered:int#list is filter(Tl,P);
      var Primes:int#list is sieve(Filtered);
      valis cons(P,Primes);
    }
  };

function iota(Mn:#int, Mx:#int, St:#int):int#list =>
  valof{
    if Mn>Mx then
      valis nil
    else{
      var Nx:#int is Mn+St;
      var Rest:int#list is iota(Nx,Mx,St);
      valis cons(Mn,Rest)
    }
  };

procedure main(X:#int){
  var I:int#list is iota(3,X,2);
  var Start:#long is __#nanos();
  var R:int#list is sieve(I);
  var Stop:#long is __#nanos();
  display(__#logFile,R);
  __#outStr(__#logFile,"\n");
  var Tm:#long is Stop-Start;
  __#outLong(__#logFile,Tm);
  __#outStr(__#logFile," nanos\n");
}
