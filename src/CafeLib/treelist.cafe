--
-- Tree implementation of lists.
--

type balTree(%t) is emTr
                 or tr(#int,balTree(%t),%t,#int,balTree(%t));

type found(%t) is notFound or found(%t);

trGet(Ix:#int,Tr:balTree(%t)):found(%t) => valof{
  switch Tr in {
    tr(Lc:#int,Lt:balTree(%t),Nd,Rc:#int,Rt:balTree(%t)) -> {
      if Lc==Ix then
        valis found(Nd)
      else if Lc>Ix then
        valis trGet(Ix,Lt)
      else
        valis trGet(Ix-Lc-1,Rt)
    };
    emTr -> valis notFound
  }
};

trSet(Ix:#int,El:%t,Tr:balTree(%t)):balTree(%t) => valof{
  switch Tr in {
    tr(Lc:#int,Lt:balTree(%t),Nd,Rc:#int,Rt:balTree(%t)) -> {
      if Lc==Ix then
        valis tr(Lc,Lt,El,Rc,Rt)
      else if Lc>Ix then
        valis tr(Lc,trSet(Ix,Lt),Nd,Rc,Rt)
      else
        valis tr(Lc,Lt,Nd,Rc,trSet(Ix-Lc-1,El,Rt))
    };
    rmTr -> throw "not found";
  }
};

trInsert(Ix:#int,El:%t,Tr:balTree(%t)):balTree(%t) => valof{
  switch Tr in {
    emTr -> tr(0,emTr,El,0,emTr);
    tr(Lc:#int,Lt:balTree(%t),Nd,Rc:#int,Rt:balTree(%t)) -> {
      if Lc>Ix then {
        if Lc+1>2*Rc then
          valis trInsert(Ix,El,rotateRight(Tr))
        else
          valis tr(Lc+1,trInsert(Ix,El,Lt),Nd,Rc,Rt)
      }
      else{
        if Rc+1>2*Lc then
          valis trInsert(Ix,El,rotateLeft(Tr))
        else
          valis tr(Lc,Lt,Nd,Rc+1,trInsert(Ix-Lc-1,El,Rt))
      }
    }
  }
}

/*
 * rotate left:
 *               (  A  )
 *                /   \
 *               B  (  C  )
 *                   /   \
 *                  D     E
 *
 * becomes
 *
 *               (  C  )
 *                /   \
 *            (  A  )  E
 *             /   \
 *            B     D
 */
 
rotateLeft(A:balTree(%t)):balTree(%t) => valof{
  switch Tr in {
    tr(Bc:#int,B:balTree(%t),An:%t,Cc:#int,Ct:balTree(%t)) -> {
      switch Ct in {
        tr(Dc:#int,D:balTree(%t),Cn:%t,Ec:#int,E:balTree(%t)) -> {
          XX:balTree(%t) is tr(Bc,B,An,Dc,D);
          valis tr(Bc+Dc+1,XX,Cn,Ec,E)
        }
      }
    }
  }
};

/*
 * rotate right:
 *               (  A  )
 *                /   \
 *            (  B  )  E
 *             /   \
 *            C     D
 *
 * becomes
 *
 *               (  B  )
 *                /   \
 *               C  (  A  )
 *                   /   \
 *                  D     E
 */
 
rotateRight(A:balTree(%t)):balTree(%t) => valof{
  switch Tr in {
    tr(Bc:#int,Bt:balTree(%t),An:%t,Ec:#int,E:balTree(%t)) -> {
      switch Bt in {
        tr(Cc:#int,C:balTree(%t),Bn:%t,Dc:#int,D:balTree(%t)) -> {
          XX:balTree(%t) is tr(Dc,D,An,Ec,E);
          valis tr(Cc,C,Bn,Dc+Ec+1,XX)
        }
      }
    }
  }
};
        