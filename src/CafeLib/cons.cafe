import "cafe:foundation.cafe";
import "cafe:list.cafe";

type cons<%t> is nil or cons(%t,cons<%t>);

type display#contract<%t> is display#{
  (#file,%t)=>void; -- display
};

type cons#pkg is cons#{
  display#cons:(display#contract<%t>)=>display#contract<cons<%t>>;
  list#cons:()=>list#contract<cons<%t>>;
};

function list$package() is cons#{

  function display#cons(D:display#contract(%t)):display#contract(cons(%t)) =>
    display#{
      procedure display#cons(io:#file,L:cons(%t)){
        __#outStr(io,"[");
        var sep:#string := "";
        var Ls:cons(%t) := L;
        LL :: loop {
          switch Ls in {
            nil do leave LL;
            cons(H:%t,Tl:cons(%t)) do {
              __#outStr(io,sep);
              sep := ", ";
              D.display(io,H);
              Ls := Tl;
            }
          }
      };
      __#outStr(io,"]");
    }
  };

  function list#cons():list#contract(cons(%t)) =>
    list#{
      function empty#cons(L:cons(%t)):logical => 
        switch L in {
          nil -> true;
          default -> false;
        };

      function head#cons(L:cons(%t)):maybe(%t) => 
        switch L in {
          cons(H:%t,Tl:cons(%t)) -> just(H);
          default -> impossible
        };

      function tail#cons(L:cons(%t)):maybe(cons(%t)) =>
        switch L in {
          cons(H:%t,Tl:cons(%t)) -> just(Tl);
          default -> impossible
        };

      function match#cons(L:cons(%t)):maybe($2(%t,cons(%t))) =>
        switch L in {
          cons(H:%t,Tl:cons(%t)) -> just($2(H,Tl));
          default -> impossible
        };

      function cons#cons(H:%t,Tl:cons(%t)):cons(%t) =>
        cons(H,Tl);
    };
}
