/* Automatically generated, do not edit */

star.compiler.escapes{
  import star.
  import star.compiler.types.

  public escapeType:(string)=>option[tipe].
  escapeType(Es) => case Es in {
    | "_exit" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer")])),.tupleType([])))
    | "_abort" => .some(.allType(.kVar("a"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.kVar("a"),.nomnal("star*string")])),.tupleType([]))))
    | "_definedLbl" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*integer")])),.nomnal("star*boolean")))
    | "_globalIsSet" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.nomnal("star*boolean")))
    | "_int_plus" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*integer")))
    | "_int_minus" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*integer")))
    | "_int_times" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*integer")))
    | "_int_div" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*integer")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_int_mod" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*integer")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_int_hash" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer")])),.nomnal("star*integer")))
    | "_int_gcd" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*integer")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_int_lg2" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer")])),.nomnal("star*integer")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_flt_plus" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float"),.nomnal("star*float")])),.nomnal("star*float")))
    | "_flt_minus" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float"),.nomnal("star*float")])),.nomnal("star*float")))
    | "_flt_times" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float"),.nomnal("star*float")])),.nomnal("star*float")))
    | "_flt_div" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float"),.nomnal("star*float")])),.nomnal("star*float")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_flt_mod" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float"),.nomnal("star*float")])),.nomnal("star*float")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_int_abs" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer")])),.nomnal("star*integer")))
    | "_flt_abs" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*float")))
    | "_int_eq" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*boolean")))
    | "_int_lt" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*boolean")))
    | "_int_ge" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*boolean")))
    | "_int_pow" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*integer")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_flt_eq" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float"),.nomnal("star*float")])),.nomnal("star*boolean")))
    | "_flt_lt" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float"),.nomnal("star*float")])),.nomnal("star*boolean")))
    | "_flt_ge" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float"),.nomnal("star*float")])),.nomnal("star*boolean")))
    | "_int2flt" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer")])),.nomnal("star*float")))
    | "_flt2int" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*integer")))
    | "_bits_float" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer")])),.nomnal("star*float")))
    | "_float_bits" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*integer")))
    | "_flt_hash" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*integer")))
    | "_flt_pwr" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float"),.nomnal("star*float")])),.nomnal("star*float")))
    | "_big_plus" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint"),.nomnal("star*bigint")])),.nomnal("star*bigint")))
    | "_big_minus" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint"),.nomnal("star*bigint")])),.nomnal("star*bigint")))
    | "_big_times" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint"),.nomnal("star*bigint")])),.nomnal("star*bigint")))
    | "_big_div" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint"),.nomnal("star*bigint")])),.tupleType([.nomnal("star*bigint"),.nomnal("star*bigint")])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_big_bitand" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint"),.nomnal("star*bigint")])),.nomnal("star*bigint")))
    | "_big_bitor" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint"),.nomnal("star*bigint")])),.nomnal("star*bigint")))
    | "_big_bitxor" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint"),.nomnal("star*bigint")])),.nomnal("star*bigint")))
    | "_big_bitnot" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint")])),.nomnal("star*bigint")))
    | "_big_gcd" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint"),.nomnal("star*bigint")])),.nomnal("star*bigint")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_big_hash" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint")])),.nomnal("star*integer")))
    | "_big_eq" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint"),.nomnal("star*bigint")])),.nomnal("star*boolean")))
    | "_big_lt" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint"),.nomnal("star*bigint")])),.nomnal("star*boolean")))
    | "_big_ge" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint"),.nomnal("star*bigint")])),.nomnal("star*boolean")))
    | "_int2big" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer")])),.nomnal("star*bigint")))
    | "_big2int" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint")])),.tpExp(.tpFun("star.core*option",1),.nomnal("star*integer"))))
    | "_ints2big" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpFun("star.core*cons",1),.nomnal("star*integer"))])),.nomnal("star*bigint")))
    | "_big2ints" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint")])),.tpExp(.tpFun("star.core*cons",1),.nomnal("star*integer"))))
    | "_str2big" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.tpExp(.tpFun("star.core*option",1),.nomnal("star*bigint"))))
    | "_big2str" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint")])),.nomnal("star*string")))
    | "_big_format" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*bigint"),.nomnal("star*string")])),.nomnal("star*string")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_fiber_eq" => .some(.allType(.kVar("r"),.allType(.kVar("s"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s")),.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s"))])),.nomnal("star*boolean")))))
    | "_fiber" => .some(.allType(.kVar("r"),.allType(.kVar("s"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s")),.kVar("r")])),.kVar("s"))])),.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s"))))))
    | "_suspend" => .some(.allType(.kVar("r"),.allType(.kVar("s"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s")),.kVar("s")])),.kVar("r")))))
    | "_retire" => .some(.allType(.kVar("r"),.allType(.kVar("s"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s")),.kVar("s")])),.tupleType([])))))
    | "_resume" => .some(.allType(.kVar("r"),.allType(.kVar("s"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s")),.kVar("r")])),.kVar("s")))))
    | "sqrt" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*float")),.raisEs(.nomnal("star.core*errorCode"))))
    | "exp" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*float")),.raisEs(.nomnal("star.core*errorCode"))))
    | "log" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*float")))
    | "log10" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*float")))
    | "pi" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("star*float")))
    | "sin" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*float")))
    | "cos" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*float")))
    | "tan" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*float")))
    | "asin" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*float")))
    | "acos" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*float")))
    | "atan" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*float")))
    | "trunc" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*float")))
    | "floor" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*float")))
    | "ceil" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*float")))
    | "integral" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.nomnal("star*boolean")))
    | "_irand" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer")])),.nomnal("star*integer")))
    | "_random" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("star*float")))
    | "_seed" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer")])),.tupleType([])))
    | "_ldexp" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float"),.nomnal("star*integer")])),.nomnal("star*float")))
    | "_frexp" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.tupleType([.nomnal("star*float"),.nomnal("star*integer")])))
    | "_modf" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.tupleType([.nomnal("star*float"),.nomnal("star*integer")])))
    | "_band" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*integer")))
    | "_bor" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*integer")))
    | "_bxor" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*integer")))
    | "_blsl" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*integer")))
    | "_blsr" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*integer")))
    | "_basr" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*integer")))
    | "_bnot" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer")])),.nomnal("star*integer")))
    | "_cell" => .some(.allType(.kVar("t"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.kVar("t")])),.tpExp(.tpFun("ref",1),.kVar("t")))))
    | "_get" => .some(.allType(.kVar("t"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpFun("ref",1),.kVar("t"))])),.kVar("t"))))
    | "_assign" => .some(.allType(.kVar("t"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpFun("ref",1),.kVar("t")),.kVar("t")])),.tupleType([]))))
    | "_cell_future" => .some(.allType(.kVar("s"),.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpFun("ref",1),.tpExp(.tpExp(.tpFun("star.either*either",2),.kVar("s")),.kVar("e")))])),.tpExp(.tpExp(.tpFun("future",2),.kVar("s")),.kVar("e"))))))
    | "_futureIsResolved" => .some(.allType(.kVar("f"),.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("future",2),.kVar("f")),.kVar("e"))])),.nomnal("star*boolean")))))
    | "_futureIsAccepted" => .some(.allType(.kVar("f"),.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("future",2),.kVar("f")),.kVar("e"))])),.nomnal("star*boolean")))))
    | "_futureIsRejected" => .some(.allType(.kVar("f"),.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("future",2),.kVar("f")),.kVar("e"))])),.nomnal("star*boolean")))))
    | "_futureVal" => .some(.allType(.kVar("f"),.allType(.kVar("e"),.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("future",2),.kVar("f")),.kVar("e"))])),.kVar("f")),.raisEs(.kVar("e"))))))
    | "_tuple_nth" => .some(.allType(.kVar("t"),.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.kVar("t"),.nomnal("star*integer")])),.kVar("e")))))
    | "_tuple_set_nth" => .some(.allType(.kVar("t"),.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.kVar("t"),.nomnal("star*integer"),.kVar("e")])),.kVar("t")))))
    | "_cwd" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("star*string")))
    | "_cd" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_rm" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_mv" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*string")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_mkdir" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*integer")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_rmdir" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_isdir" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.nomnal("star*boolean")))
    | "_file_chmod" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*integer")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_ls" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.tpExp(.tpFun("star.core*cons",1),.nomnal("star*string"))),.raisEs(.nomnal("star.core*errorCode"))))
    | "_repo" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("star*string")))
    | "_file_mode" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.nomnal("star*integer")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_file_present" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.nomnal("star*boolean")))
    | "_file_type" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.nomnal("star*integer")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_file_size" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.nomnal("star*integer")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_file_modified" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.nomnal("star*integer")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_file_date" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.tupleType([.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer")])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_openInFile" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*integer")])),.nomnal("ioHandle")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_openOutFile" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*integer")])),.nomnal("ioHandle")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_openAppendFile" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*integer")])),.nomnal("ioHandle")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_openAppendIOFile" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*integer")])),.nomnal("ioHandle")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_popen" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.tpExp(.tpFun("star.core*cons",1),.nomnal("star*string")),.tpExp(.tpFun("star.core*cons",1),.tupleType([.nomnal("star*string"),.nomnal("star*string")]))])),.tupleType([.nomnal("ioHandle"),.nomnal("ioHandle"),.nomnal("ioHandle")])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_close" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_end_of_file" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.nomnal("star*boolean")))
    | "_inchars" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("star*integer")])),.nomnal("star*string")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_inchars_async" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("star*integer")])),.tpExp(.tpExp(.tpFun("future",2),.nomnal("star*string")),.nomnal("star.core*errorCode"))),.raisEs(.nomnal("star.core*errorCode"))))
    | "_inchar" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.nomnal("star*char")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_inchar_async" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.tpExp(.tpExp(.tpFun("future",2),.nomnal("star*char")),.nomnal("star.core*errorCode"))),.raisEs(.nomnal("star.core*errorCode"))))
    | "_inbyte" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.nomnal("star*integer")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_inbyte_async" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.tpExp(.tpExp(.tpFun("future",2),.nomnal("star*integer")),.nomnal("star.core*errorCode"))),.raisEs(.nomnal("star.core*errorCode"))))
    | "_inbytes" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("star*integer")])),.tpExp(.tpFun("star.vector*vect",1),.nomnal("star*integer"))),.raisEs(.nomnal("star.core*errorCode"))))
    | "_inbytes_async" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("star*integer")])),.tpExp(.tpExp(.tpFun("future",2),.tpExp(.tpFun("star.vector*vect",1),.nomnal("star*integer"))),.nomnal("star.core*errorCode"))),.raisEs(.nomnal("star.core*errorCode"))))
    | "_inline" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.nomnal("star*string")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_inline_async" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.tpExp(.tpExp(.tpFun("future",2),.nomnal("star*string")),.nomnal("star.core*errorCode"))),.raisEs(.nomnal("star.core*errorCode"))))
    | "_outchar" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("star*char")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_outchar_async" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("star*char")])),.tpExp(.tpExp(.tpFun("future",2),.tupleType([])),.nomnal("star.core*errorCode"))),.raisEs(.nomnal("star.core*errorCode"))))
    | "_outbyte" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("star*integer")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_outbyte_async" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("star*integer")])),.tpExp(.tpExp(.tpFun("future",2),.tupleType([])),.nomnal("star.core*errorCode"))),.raisEs(.nomnal("star.core*errorCode"))))
    | "_outbytes" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.tpExp(.tpFun("star.core*cons",1),.nomnal("star*integer"))])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_outtext" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("star*string")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_outtext_async" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("star*string")])),.tpExp(.tpExp(.tpFun("future",2),.tupleType([])),.nomnal("star.core*errorCode"))),.raisEs(.nomnal("star.core*errorCode"))))
    | "_stdfile" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer")])),.nomnal("ioHandle")))
    | "_fposition" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.nomnal("star*integer")))
    | "_fseek" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("star*integer")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_flush" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_flushall" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.tupleType([])))
    | "_fname" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.nomnal("star*string")))
    | "_waitIo" => .some(.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpFun("star.core*cons",1),.tupleType([.nomnal("ioHandle"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("star*boolean")),.kVar("e")])),.nomnal("star*integer")])),.nomnal("star*boolean"))))
    | "_setfileencoding" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("star*integer")])),.tupleType([])))
    | "_get_file" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.nomnal("star*string")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_put_file" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*string")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_show" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.tupleType([])))
    | "_install_pkg" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.tpExp(.tpFun("star.core*cons",1),.tupleType([.nomnal("star*string"),.nomnal("star*string")]))),.raisEs(.nomnal("star.core*errorCode"))))
    | "_pkg_is_present" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*string")])),.nomnal("star*boolean")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_in_manifest" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*string"),.nomnal("star*string")])),.nomnal("star*boolean")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_locate_in_manifest" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*string"),.nomnal("star*string")])),.nomnal("star*string")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_logmsg" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.tupleType([])))
    | "_display_depth" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("star*integer")))
    | "_connect" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*integer"),.nomnal("star*integer")])),.tupleType([.nomnal("ioHandle"),.nomnal("ioHandle")])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_listen" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer")])),.nomnal("ioHandle")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_accept" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.tupleType([.nomnal("ioHandle"),.nomnal("ioHandle"),.nomnal("star*string"),.nomnal("star*integer"),.nomnal("star*string")])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_hosttoip" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.tpExp(.tpFun("star.core*cons",1),.nomnal("star*string"))))
    | "_iptohost" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.nomnal("star*string")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_delay" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_sleep" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_now" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("star*float")))
    | "_today" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("star*float")))
    | "_ticks" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("star*integer")))
    | "_time2date" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.tupleType([.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*float"),.nomnal("star*integer")])))
    | "_time2utc" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float")])),.tupleType([.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*float"),.nomnal("star*integer")])))
    | "_date2time" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*float"),.nomnal("star*integer")])),.nomnal("star*float")))
    | "_utc2time" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*float"),.nomnal("star*integer")])),.nomnal("star*float")))
    | "_formattime" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float"),.nomnal("star*string")])),.nomnal("star*string")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_parsetime" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*string")])),.tpExp(.tpFun("star.core*option",1),.nomnal("star*float"))))
    | "_uniCodeCategory" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*integer")))
    | "_isCcChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isCfChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isCnChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isCoChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isCsChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isLlChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isLmChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isLoChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isLtChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isLuChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isMcChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isMeChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isMnChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isNdChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isNlChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isNoChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isPcChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isPdChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isPeChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isPfChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isPiChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isPoChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isPsChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isScChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isSkChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isSmChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isSoChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isZlChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isZpChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isZsChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isLetterChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_digitCode" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*integer")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_codePoint" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*integer")))
    | "_char" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer")])),.nomnal("star*char")))
    | "_isIDStart" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_isIDContinue" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_int2str" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*string")))
    | "_flt2str" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float"),.nomnal("star*integer"),.nomnal("star*char"),.nomnal("star*boolean")])),.nomnal("star*string")))
    | "_int_format" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*integer"),.nomnal("star*string")])),.nomnal("star*string")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_flt_format" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*float"),.nomnal("star*string")])),.nomnal("star*string")))
    | "_str2flt" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.tpExp(.tpFun("star.core*option",1),.nomnal("star*float"))))
    | "_str2int" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.tpExp(.tpFun("star.core*option",1),.nomnal("star*integer"))))
    | "_chr_eq" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char"),.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_chr_lt" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char"),.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_chr_ge" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char"),.nomnal("star*char")])),.nomnal("star*boolean")))
    | "_chr_hash" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*integer")))
    | "_chr_quote" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*string")))
    | "_chr_format" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char"),.nomnal("star*string")])),.nomnal("star*string")))
    | "_str_eq" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*string")])),.nomnal("star*boolean")))
    | "_str_lt" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*string")])),.nomnal("star*boolean")))
    | "_str_ge" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*string")])),.nomnal("star*boolean")))
    | "_str_hash" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.nomnal("star*integer")))
    | "_str_len" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.nomnal("star*integer")))
    | "_str_gen" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.nomnal("star*string")))
    | "_stringOf" => .some(.allType(.kVar("t"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.kVar("t"),.nomnal("star*integer")])),.nomnal("star*string"))))
    | "_explode" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.tpExp(.tpFun("star.core*cons",1),.nomnal("star*char"))))
    | "_implode" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpFun("star.core*cons",1),.nomnal("star*char"))])),.nomnal("star*string")))
    | "_str_find" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*string"),.nomnal("star*integer")])),.nomnal("star*integer")))
    | "_sub_str" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*integer"),.nomnal("star*integer")])),.nomnal("star*string")))
    | "_str_split" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*integer")])),.tupleType([.nomnal("star*string"),.nomnal("star*string")])))
    | "_str_concat" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*string")])),.nomnal("star*string")))
    | "_str_reverse" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.nomnal("star*string")))
    | "_str_start" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*string")])),.nomnal("star*boolean")))
    | "_str_end" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*string")])),.nomnal("star*boolean")))
    | "_str_splice" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*integer"),.nomnal("star*integer"),.nomnal("star*string")])),.nomnal("star*string")))
    | "_str_multicat" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpFun("star.core*cons",1),.nomnal("star*string"))])),.nomnal("star*string")))
    | "_str_hdtl" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.tpExp(.tpFun("star.core*option",1),.tupleType([.nomnal("star*char"),.nomnal("star*string")]))))
    | "_str_back" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.tupleType([.nomnal("star*string"),.nomnal("star*char")])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_str_cons" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char"),.nomnal("star*string")])),.nomnal("star*string")))
    | "_code2str" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*char")])),.nomnal("star*string")))
    | "_str_apnd" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*char")])),.nomnal("star*string")))
    | "_str_charat" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*integer")])),.tpExp(.tpFun("star.core*option",1),.nomnal("star*char"))))
    | "_str_quote" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.nomnal("star*string")))
    | "_str_format" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*string")])),.nomnal("star*string")))
    | "_getenv" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string")])),.tpExp(.tpFun("star.core*option",1),.nomnal("star*string"))))
    | "_setenv" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.nomnal("star*string")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_envir" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.tpExp(.tpFun("star.core*cons",1),.tupleType([.nomnal("star*string"),.nomnal("star*string")]))))
    | "_fork" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.tupleType([]))])),.nomnal("star.thread*thread")))
    | "_thread" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("star.thread*thread")))
    | "_kill" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star.thread*thread")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_thread_state" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star.thread*thread")])),.nomnal("star.thread*threadState")))
    | "_waitfor" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star.thread*thread")])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))
    | "_shell" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star*string"),.tpExp(.tpFun("star.core*cons",1),.nomnal("star*string")),.tpExp(.tpFun("star.core*cons",1),.tupleType([.nomnal("star*string"),.nomnal("star*string")]))])),.nomnal("star*integer")),.raisEs(.nomnal("star.core*errorCode"))))
    | "_ins_debug" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.tupleType([])))
    | "_stackTrace" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("star*string")))
    | "_jit_compile" => .some(.allType(.kVar("a"),.allType(.kVar("b"),.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.kVar("a")])),.kVar("b"))])),.tupleType([])),.raisEs(.nomnal("star.core*errorCode"))))))
    | _ default => .none
  }

  public isEscape:(string)=>boolean.
  isEscape(Es) => case Es in {
    | "_exit" => .true
    | "_abort" => .true
    | "_definedLbl" => .true
    | "_globalIsSet" => .true
    | "_int_plus" => .true
    | "_int_minus" => .true
    | "_int_times" => .true
    | "_int_div" => .true
    | "_int_mod" => .true
    | "_int_hash" => .true
    | "_int_gcd" => .true
    | "_int_lg2" => .true
    | "_flt_plus" => .true
    | "_flt_minus" => .true
    | "_flt_times" => .true
    | "_flt_div" => .true
    | "_flt_mod" => .true
    | "_int_abs" => .true
    | "_flt_abs" => .true
    | "_int_eq" => .true
    | "_int_lt" => .true
    | "_int_ge" => .true
    | "_int_pow" => .true
    | "_flt_eq" => .true
    | "_flt_lt" => .true
    | "_flt_ge" => .true
    | "_int2flt" => .true
    | "_flt2int" => .true
    | "_bits_float" => .true
    | "_float_bits" => .true
    | "_flt_hash" => .true
    | "_flt_pwr" => .true
    | "_big_plus" => .true
    | "_big_minus" => .true
    | "_big_times" => .true
    | "_big_div" => .true
    | "_big_bitand" => .true
    | "_big_bitor" => .true
    | "_big_bitxor" => .true
    | "_big_bitnot" => .true
    | "_big_gcd" => .true
    | "_big_hash" => .true
    | "_big_eq" => .true
    | "_big_lt" => .true
    | "_big_ge" => .true
    | "_int2big" => .true
    | "_big2int" => .true
    | "_ints2big" => .true
    | "_big2ints" => .true
    | "_str2big" => .true
    | "_big2str" => .true
    | "_big_format" => .true
    | "_fiber_eq" => .true
    | "_fiber" => .true
    | "_suspend" => .true
    | "_retire" => .true
    | "_resume" => .true
    | "sqrt" => .true
    | "exp" => .true
    | "log" => .true
    | "log10" => .true
    | "pi" => .true
    | "sin" => .true
    | "cos" => .true
    | "tan" => .true
    | "asin" => .true
    | "acos" => .true
    | "atan" => .true
    | "trunc" => .true
    | "floor" => .true
    | "ceil" => .true
    | "integral" => .true
    | "_irand" => .true
    | "_random" => .true
    | "_seed" => .true
    | "_ldexp" => .true
    | "_frexp" => .true
    | "_modf" => .true
    | "_band" => .true
    | "_bor" => .true
    | "_bxor" => .true
    | "_blsl" => .true
    | "_blsr" => .true
    | "_basr" => .true
    | "_bnot" => .true
    | "_cell" => .true
    | "_get" => .true
    | "_assign" => .true
    | "_cell_future" => .true
    | "_futureIsResolved" => .true
    | "_futureIsAccepted" => .true
    | "_futureIsRejected" => .true
    | "_futureVal" => .true
    | "_tuple_nth" => .true
    | "_tuple_set_nth" => .true
    | "_cwd" => .true
    | "_cd" => .true
    | "_rm" => .true
    | "_mv" => .true
    | "_mkdir" => .true
    | "_rmdir" => .true
    | "_isdir" => .true
    | "_file_chmod" => .true
    | "_ls" => .true
    | "_repo" => .true
    | "_file_mode" => .true
    | "_file_present" => .true
    | "_file_type" => .true
    | "_file_size" => .true
    | "_file_modified" => .true
    | "_file_date" => .true
    | "_openInFile" => .true
    | "_openOutFile" => .true
    | "_openAppendFile" => .true
    | "_openAppendIOFile" => .true
    | "_popen" => .true
    | "_close" => .true
    | "_end_of_file" => .true
    | "_inchars" => .true
    | "_inchars_async" => .true
    | "_inchar" => .true
    | "_inchar_async" => .true
    | "_inbyte" => .true
    | "_inbyte_async" => .true
    | "_inbytes" => .true
    | "_inbytes_async" => .true
    | "_inline" => .true
    | "_inline_async" => .true
    | "_outchar" => .true
    | "_outchar_async" => .true
    | "_outbyte" => .true
    | "_outbyte_async" => .true
    | "_outbytes" => .true
    | "_outtext" => .true
    | "_outtext_async" => .true
    | "_stdfile" => .true
    | "_fposition" => .true
    | "_fseek" => .true
    | "_flush" => .true
    | "_flushall" => .true
    | "_fname" => .true
    | "_waitIo" => .true
    | "_setfileencoding" => .true
    | "_get_file" => .true
    | "_put_file" => .true
    | "_show" => .true
    | "_install_pkg" => .true
    | "_pkg_is_present" => .true
    | "_in_manifest" => .true
    | "_locate_in_manifest" => .true
    | "_logmsg" => .true
    | "_display_depth" => .true
    | "_connect" => .true
    | "_listen" => .true
    | "_accept" => .true
    | "_hosttoip" => .true
    | "_iptohost" => .true
    | "_delay" => .true
    | "_sleep" => .true
    | "_now" => .true
    | "_today" => .true
    | "_ticks" => .true
    | "_time2date" => .true
    | "_time2utc" => .true
    | "_date2time" => .true
    | "_utc2time" => .true
    | "_formattime" => .true
    | "_parsetime" => .true
    | "_uniCodeCategory" => .true
    | "_isCcChar" => .true
    | "_isCfChar" => .true
    | "_isCnChar" => .true
    | "_isCoChar" => .true
    | "_isCsChar" => .true
    | "_isLlChar" => .true
    | "_isLmChar" => .true
    | "_isLoChar" => .true
    | "_isLtChar" => .true
    | "_isLuChar" => .true
    | "_isMcChar" => .true
    | "_isMeChar" => .true
    | "_isMnChar" => .true
    | "_isNdChar" => .true
    | "_isNlChar" => .true
    | "_isNoChar" => .true
    | "_isPcChar" => .true
    | "_isPdChar" => .true
    | "_isPeChar" => .true
    | "_isPfChar" => .true
    | "_isPiChar" => .true
    | "_isPoChar" => .true
    | "_isPsChar" => .true
    | "_isScChar" => .true
    | "_isSkChar" => .true
    | "_isSmChar" => .true
    | "_isSoChar" => .true
    | "_isZlChar" => .true
    | "_isZpChar" => .true
    | "_isZsChar" => .true
    | "_isLetterChar" => .true
    | "_digitCode" => .true
    | "_codePoint" => .true
    | "_char" => .true
    | "_isIDStart" => .true
    | "_isIDContinue" => .true
    | "_int2str" => .true
    | "_flt2str" => .true
    | "_int_format" => .true
    | "_flt_format" => .true
    | "_str2flt" => .true
    | "_str2int" => .true
    | "_chr_eq" => .true
    | "_chr_lt" => .true
    | "_chr_ge" => .true
    | "_chr_hash" => .true
    | "_chr_quote" => .true
    | "_chr_format" => .true
    | "_str_eq" => .true
    | "_str_lt" => .true
    | "_str_ge" => .true
    | "_str_hash" => .true
    | "_str_len" => .true
    | "_str_gen" => .true
    | "_stringOf" => .true
    | "_explode" => .true
    | "_implode" => .true
    | "_str_find" => .true
    | "_sub_str" => .true
    | "_str_split" => .true
    | "_str_concat" => .true
    | "_str_reverse" => .true
    | "_str_start" => .true
    | "_str_end" => .true
    | "_str_splice" => .true
    | "_str_multicat" => .true
    | "_str_hdtl" => .true
    | "_str_back" => .true
    | "_str_cons" => .true
    | "_code2str" => .true
    | "_str_apnd" => .true
    | "_str_charat" => .true
    | "_str_quote" => .true
    | "_str_format" => .true
    | "_getenv" => .true
    | "_setenv" => .true
    | "_envir" => .true
    | "_fork" => .true
    | "_thread" => .true
    | "_kill" => .true
    | "_thread_state" => .true
    | "_waitfor" => .true
    | "_shell" => .true
    | "_ins_debug" => .true
    | "_stackTrace" => .true
    | "_jit_compile" => .true
    | _ default => .false.
  }
}.
