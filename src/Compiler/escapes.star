star.compiler.escapes{
  -- Automatically Generated -- Do NOT Edit
  import star.

  import star.compiler.types.

  public escapeType:(string)=>option[tipe].
  escapeType(Es) => case Es in {
    | "_exit" => .some(.prcType(.tupleType([.nomnal("integer")]),.voidType))
    | "_int_plus" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer")]),.nomnal("integer"),.voidType))
    | "_int_minus" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer")]),.nomnal("integer"),.voidType))
    | "_int_times" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer")]),.nomnal("integer"),.voidType))
    | "_int_div" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer")]),.nomnal("integer"),.nomnal("errorCode")))
    | "_int_mod" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer")]),.nomnal("integer"),.nomnal("errorCode")))
    | "_int_hash" => .some(.funType(.tupleType([.nomnal("integer")]),.nomnal("integer"),.voidType))
    | "_int_gcd" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer")]),.nomnal("integer"),.nomnal("errorCode")))
    | "_int_lg2" => .some(.funType(.tupleType([.nomnal("integer")]),.nomnal("integer"),.nomnal("errorCode")))
    | "_flt_plus" => .some(.funType(.tupleType([.nomnal("float"),.nomnal("float")]),.nomnal("float"),.voidType))
    | "_flt_minus" => .some(.funType(.tupleType([.nomnal("float"),.nomnal("float")]),.nomnal("float"),.voidType))
    | "_flt_times" => .some(.funType(.tupleType([.nomnal("float"),.nomnal("float")]),.nomnal("float"),.voidType))
    | "_flt_div" => .some(.funType(.tupleType([.nomnal("float"),.nomnal("float")]),.nomnal("float"),.nomnal("errorCode")))
    | "_flt_mod" => .some(.funType(.tupleType([.nomnal("float"),.nomnal("float")]),.nomnal("float"),.nomnal("errorCode")))
    | "_int_abs" => .some(.funType(.tupleType([.nomnal("integer")]),.nomnal("integer"),.voidType))
    | "_flt_abs" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("float"),.voidType))
    | "_int_eq" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer")]),.nomnal("boolean"),.voidType))
    | "_int_lt" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer")]),.nomnal("boolean"),.voidType))
    | "_int_ge" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer")]),.nomnal("boolean"),.voidType))
    | "_int_pow" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer")]),.nomnal("integer"),.nomnal("errorCode")))
    | "_flt_eq" => .some(.funType(.tupleType([.nomnal("float"),.nomnal("float")]),.nomnal("boolean"),.voidType))
    | "_flt_lt" => .some(.funType(.tupleType([.nomnal("float"),.nomnal("float")]),.nomnal("boolean"),.voidType))
    | "_flt_ge" => .some(.funType(.tupleType([.nomnal("float"),.nomnal("float")]),.nomnal("boolean"),.voidType))
    | "_int2flt" => .some(.funType(.tupleType([.nomnal("integer")]),.nomnal("float"),.nomnal("errorCode")))
    | "_flt2int" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("integer"),.nomnal("errorCode")))
    | "_bits_float" => .some(.funType(.tupleType([.nomnal("integer")]),.nomnal("float"),.voidType))
    | "_float_bits" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("integer"),.voidType))
    | "_flt_hash" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("integer"),.voidType))
    | "_flt_pwr" => .some(.funType(.tupleType([.nomnal("float"),.nomnal("float")]),.nomnal("float"),.voidType))
    | "_big_plus" => .some(.funType(.tupleType([.nomnal("bigint"),.nomnal("bigint")]),.nomnal("bigint"),.voidType))
    | "_big_minus" => .some(.funType(.tupleType([.nomnal("bigint"),.nomnal("bigint")]),.nomnal("bigint"),.voidType))
    | "_big_times" => .some(.funType(.tupleType([.nomnal("bigint"),.nomnal("bigint")]),.nomnal("bigint"),.voidType))
    | "_big_div" => .some(.funType(.tupleType([.nomnal("bigint"),.nomnal("bigint")]),.tupleType([.nomnal("bigint"),.nomnal("bigint")]),.nomnal("errorCode")))
    | "_big_bitand" => .some(.funType(.tupleType([.nomnal("bigint"),.nomnal("bigint")]),.nomnal("bigint"),.voidType))
    | "_big_bitor" => .some(.funType(.tupleType([.nomnal("bigint"),.nomnal("bigint")]),.nomnal("bigint"),.voidType))
    | "_big_bitxor" => .some(.funType(.tupleType([.nomnal("bigint"),.nomnal("bigint")]),.nomnal("bigint"),.voidType))
    | "_big_bitnot" => .some(.funType(.tupleType([.nomnal("bigint")]),.nomnal("bigint"),.voidType))
    | "_big_gcd" => .some(.funType(.tupleType([.nomnal("bigint"),.nomnal("bigint")]),.nomnal("bigint"),.nomnal("errorCode")))
    | "_big_hash" => .some(.funType(.tupleType([.nomnal("bigint")]),.nomnal("integer"),.voidType))
    | "_big_eq" => .some(.funType(.tupleType([.nomnal("bigint"),.nomnal("bigint")]),.nomnal("boolean"),.voidType))
    | "_big_lt" => .some(.funType(.tupleType([.nomnal("bigint"),.nomnal("bigint")]),.nomnal("boolean"),.voidType))
    | "_big_ge" => .some(.funType(.tupleType([.nomnal("bigint"),.nomnal("bigint")]),.nomnal("boolean"),.voidType))
    | "_int2big" => .some(.funType(.tupleType([.nomnal("integer")]),.nomnal("bigint"),.voidType))
    | "_big2int" => .some(.funType(.tupleType([.nomnal("bigint")]),.nomnal("integer"),.nomnal("errorCode")))
    | "_ints2big" => .some(.funType(.tupleType([.tpExp(.tpFun("cons",1),.nomnal("integer"))]),.nomnal("bigint"),.voidType))
    | "_big2ints" => .some(.funType(.tupleType([.nomnal("bigint")]),.tpExp(.tpFun("cons",1),.nomnal("integer")),.voidType))
    | "_str2big" => .some(.funType(.tupleType([.nomnal("string")]),.nomnal("bigint"),.nomnal("errorCode")))
    | "_big2str" => .some(.funType(.tupleType([.nomnal("bigint")]),.nomnal("string"),.voidType))
    | "_big_format" => .some(.funType(.tupleType([.nomnal("bigint"),.nomnal("string")]),.nomnal("string"),.nomnal("errorCode")))
    | "_fiber_eq" => .some(.allType(.kVar("r"),.allType(.kVar("s"),.funType(.tupleType([.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s")),.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s"))]),.nomnal("boolean"),.voidType))))
    | "_fiber" => .some(.allType(.kVar("r"),.allType(.kVar("s"),.funType(.tupleType([.funType(.tupleType([.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s")),.kVar("r")]),.kVar("s"),.voidType)]),.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s")),.voidType))))
    | "_sqrt" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("float"),.nomnal("errorCode")))
    | "_exp" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("float"),.nomnal("errorCode")))
    | "_ln" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("float"),.voidType))
    | "_lg10" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("float"),.voidType))
    | "pi" => .some(.funType(.tupleType([]),.nomnal("float"),.voidType))
    | "sin" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("float"),.voidType))
    | "cos" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("float"),.voidType))
    | "tan" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("float"),.voidType))
    | "asin" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("float"),.voidType))
    | "acos" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("float"),.voidType))
    | "atan" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("float"),.voidType))
    | "trunc" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("float"),.voidType))
    | "floor" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("float"),.voidType))
    | "ceil" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("float"),.voidType))
    | "integral" => .some(.funType(.tupleType([.nomnal("float")]),.nomnal("boolean"),.voidType))
    | "_irand" => .some(.funType(.tupleType([.nomnal("integer")]),.nomnal("integer"),.voidType))
    | "_random" => .some(.funType(.tupleType([]),.nomnal("float"),.voidType))
    | "_seed" => .some(.funType(.tupleType([.nomnal("integer")]),.tupleType([]),.voidType))
    | "_ldexp" => .some(.funType(.tupleType([.nomnal("float"),.nomnal("integer")]),.nomnal("float"),.voidType))
    | "_frexp" => .some(.funType(.tupleType([.nomnal("float")]),.tupleType([.nomnal("float"),.nomnal("integer")]),.voidType))
    | "_modf" => .some(.funType(.tupleType([.nomnal("float")]),.tupleType([.nomnal("float"),.nomnal("integer")]),.voidType))
    | "_band" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer")]),.nomnal("integer"),.voidType))
    | "_bor" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer")]),.nomnal("integer"),.voidType))
    | "_bxor" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer")]),.nomnal("integer"),.voidType))
    | "_blsl" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer")]),.nomnal("integer"),.voidType))
    | "_blsr" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer")]),.nomnal("integer"),.voidType))
    | "_basr" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer")]),.nomnal("integer"),.voidType))
    | "_bnot" => .some(.funType(.tupleType([.nomnal("integer")]),.nomnal("integer"),.voidType))
    | "_cell_future" => .some(.allType(.kVar("s"),.allType(.kVar("e"),.funType(.tupleType([.tpExp(.tpFun("ref",1),.tpExp(.tpExp(.tpFun("star.either*either",2),.kVar("s")),.kVar("e")))]),.tpExp(.tpExp(.tpFun("future",2),.kVar("s")),.kVar("e")),.voidType))))
    | "_futureIsResolved" => .some(.allType(.kVar("a"),.allType(.kVar("e"),.funType(.tupleType([.tpExp(.tpExp(.tpFun("future",2),.kVar("a")),.kVar("e"))]),.nomnal("boolean"),.voidType))))
    | "_futureIsAccepted" => .some(.allType(.kVar("a"),.allType(.kVar("e"),.funType(.tupleType([.tpExp(.tpExp(.tpFun("future",2),.kVar("a")),.kVar("e"))]),.nomnal("boolean"),.voidType))))
    | "_futureIsRejected" => .some(.allType(.kVar("a"),.allType(.kVar("e"),.funType(.tupleType([.tpExp(.tpExp(.tpFun("future",2),.kVar("a")),.kVar("e"))]),.nomnal("boolean"),.voidType))))
    | "_futureVal" => .some(.allType(.kVar("a"),.allType(.kVar("e"),.funType(.tupleType([.tpExp(.tpExp(.tpFun("future",2),.kVar("a")),.kVar("e"))]),.kVar("a"),.kVar("e")))))
    | "_cwd" => .some(.funType(.tupleType([]),.nomnal("string"),.voidType))
    | "_cd" => .some(.funType(.tupleType([.nomnal("string")]),.tupleType([]),.nomnal("errorCode")))
    | "_rm" => .some(.funType(.tupleType([.nomnal("string")]),.tupleType([]),.nomnal("errorCode")))
    | "_mv" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("string")]),.tupleType([]),.nomnal("errorCode")))
    | "_mkdir" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("integer")]),.tupleType([]),.nomnal("errorCode")))
    | "_rmdir" => .some(.funType(.tupleType([.nomnal("string")]),.tupleType([]),.nomnal("errorCode")))
    | "_isdir" => .some(.funType(.tupleType([.nomnal("string")]),.nomnal("boolean"),.voidType))
    | "_file_chmod" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("integer")]),.tupleType([]),.nomnal("errorCode")))
    | "_ls" => .some(.funType(.tupleType([.nomnal("string")]),.tpExp(.tpFun("cons",1),.nomnal("string")),.nomnal("errorCode")))
    | "_repo" => .some(.funType(.tupleType([]),.nomnal("string"),.voidType))
    | "_file_mode" => .some(.funType(.tupleType([.nomnal("string")]),.nomnal("integer"),.nomnal("errorCode")))
    | "_file_present" => .some(.funType(.tupleType([.nomnal("string")]),.nomnal("boolean"),.voidType))
    | "_file_type" => .some(.funType(.tupleType([.nomnal("string")]),.nomnal("integer"),.nomnal("errorCode")))
    | "_file_size" => .some(.funType(.tupleType([.nomnal("string")]),.nomnal("integer"),.nomnal("errorCode")))
    | "_file_modified" => .some(.funType(.tupleType([.nomnal("string")]),.nomnal("integer"),.nomnal("errorCode")))
    | "_file_date" => .some(.funType(.tupleType([.nomnal("string")]),.tupleType([.nomnal("integer"),.nomnal("integer"),.nomnal("integer")]),.nomnal("errorCode")))
    | "_openInFile" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("integer")]),.nomnal("ioHandle"),.nomnal("errorCode")))
    | "_openOutFile" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("integer")]),.nomnal("ioHandle"),.nomnal("errorCode")))
    | "_openAppendFile" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("integer")]),.nomnal("ioHandle"),.nomnal("errorCode")))
    | "_openAppendIOFile" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("integer")]),.nomnal("ioHandle"),.nomnal("errorCode")))
    | "_popen" => .some(.funType(.tupleType([.nomnal("string"),.tpExp(.tpFun("cons",1),.nomnal("string")),.tpExp(.tpFun("cons",1),.tupleType([.nomnal("string"),.nomnal("string")]))]),.tupleType([.nomnal("ioHandle"),.nomnal("ioHandle"),.nomnal("ioHandle")]),.nomnal("errorCode")))
    | "_close" => .some(.funType(.tupleType([.nomnal("ioHandle")]),.tupleType([]),.nomnal("errorCode")))
    | "_end_of_file" => .some(.funType(.tupleType([.nomnal("ioHandle")]),.nomnal("boolean"),.voidType))
    | "_inchars" => .some(.funType(.tupleType([.nomnal("ioHandle"),.nomnal("integer")]),.nomnal("string"),.nomnal("errorCode")))
    | "_inchars_async" => .some(.funType(.tupleType([.nomnal("ioHandle"),.nomnal("integer")]),.tpExp(.tpExp(.tpFun("future",2),.nomnal("string")),.nomnal("errorCode")),.nomnal("errorCode")))
    | "_inchar" => .some(.funType(.tupleType([.nomnal("ioHandle")]),.nomnal("char"),.nomnal("errorCode")))
    | "_inchar_async" => .some(.funType(.tupleType([.nomnal("ioHandle")]),.tpExp(.tpExp(.tpFun("future",2),.nomnal("char")),.nomnal("errorCode")),.nomnal("errorCode")))
    | "_inbyte" => .some(.funType(.tupleType([.nomnal("ioHandle")]),.nomnal("integer"),.nomnal("errorCode")))
    | "_inbyte_async" => .some(.funType(.tupleType([.nomnal("ioHandle")]),.tpExp(.tpExp(.tpFun("future",2),.nomnal("integer")),.nomnal("errorCode")),.nomnal("errorCode")))
    | "_inbytes" => .some(.funType(.tupleType([.nomnal("ioHandle"),.nomnal("integer")]),.tpExp(.tpFun("star.vector*vect",1),.nomnal("integer")),.nomnal("errorCode")))
    | "_inbytes_async" => .some(.funType(.tupleType([.nomnal("ioHandle"),.nomnal("integer")]),.tpExp(.tpExp(.tpFun("future",2),.tpExp(.tpFun("star.vector*vect",1),.nomnal("integer"))),.nomnal("errorCode")),.nomnal("errorCode")))
    | "_inline" => .some(.funType(.tupleType([.nomnal("ioHandle")]),.nomnal("string"),.nomnal("errorCode")))
    | "_inline_async" => .some(.funType(.tupleType([.nomnal("ioHandle")]),.tpExp(.tpExp(.tpFun("future",2),.nomnal("string")),.nomnal("errorCode")),.nomnal("errorCode")))
    | "_outchar" => .some(.funType(.tupleType([.nomnal("ioHandle"),.nomnal("char")]),.tupleType([]),.nomnal("errorCode")))
    | "_outchar_async" => .some(.funType(.tupleType([.nomnal("ioHandle"),.nomnal("char")]),.tpExp(.tpExp(.tpFun("future",2),.tupleType([])),.nomnal("errorCode")),.nomnal("errorCode")))
    | "_outbyte" => .some(.funType(.tupleType([.nomnal("ioHandle"),.nomnal("integer")]),.tupleType([]),.nomnal("errorCode")))
    | "_outbyte_async" => .some(.funType(.tupleType([.nomnal("ioHandle"),.nomnal("integer")]),.tpExp(.tpExp(.tpFun("future",2),.tupleType([])),.nomnal("errorCode")),.nomnal("errorCode")))
    | "_outbytes" => .some(.funType(.tupleType([.nomnal("ioHandle"),.tpExp(.tpFun("cons",1),.nomnal("integer"))]),.tupleType([]),.nomnal("errorCode")))
    | "_outtext" => .some(.funType(.tupleType([.nomnal("ioHandle"),.nomnal("string")]),.tupleType([]),.nomnal("errorCode")))
    | "_outtext_async" => .some(.funType(.tupleType([.nomnal("ioHandle"),.nomnal("string")]),.tpExp(.tpExp(.tpFun("future",2),.tupleType([])),.nomnal("errorCode")),.nomnal("errorCode")))
    | "_stdfile" => .some(.funType(.tupleType([.nomnal("integer")]),.nomnal("ioHandle"),.voidType))
    | "_fposition" => .some(.funType(.tupleType([.nomnal("ioHandle")]),.nomnal("integer"),.voidType))
    | "_fseek" => .some(.funType(.tupleType([.nomnal("ioHandle"),.nomnal("integer")]),.tupleType([]),.nomnal("errorCode")))
    | "_flush" => .some(.funType(.tupleType([.nomnal("ioHandle")]),.tupleType([]),.nomnal("errorCode")))
    | "_flushall" => .some(.funType(.tupleType([]),.tupleType([]),.voidType))
    | "_fname" => .some(.funType(.tupleType([.nomnal("ioHandle")]),.nomnal("string"),.voidType))
    | "_waitIo" => .some(.allType(.kVar("e"),.funType(.tupleType([.tpExp(.tpFun("cons",1),.tupleType([.nomnal("ioHandle"),.funType(.tupleType([]),.nomnal("boolean"),.voidType),.kVar("e")])),.nomnal("integer")]),.nomnal("boolean"),.voidType)))
    | "_setfileencoding" => .some(.funType(.tupleType([.nomnal("ioHandle"),.nomnal("integer")]),.tupleType([]),.voidType))
    | "_get_file" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("integer")]),.nomnal("string"),.nomnal("errorCode")))
    | "_put_file" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("integer"),.nomnal("string")]),.tupleType([]),.nomnal("errorCode")))
    | "_show" => .some(.funType(.tupleType([.nomnal("string")]),.tupleType([]),.voidType))
    | "_logmsg" => .some(.funType(.tupleType([.nomnal("string")]),.tupleType([]),.voidType))
    | "_display_depth" => .some(.funType(.tupleType([]),.nomnal("integer"),.voidType))
    | "_connect" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("integer"),.nomnal("integer")]),.tupleType([.nomnal("ioHandle"),.nomnal("ioHandle")]),.nomnal("errorCode")))
    | "_listen" => .some(.funType(.tupleType([.nomnal("integer")]),.nomnal("ioHandle"),.nomnal("errorCode")))
    | "_accept" => .some(.funType(.tupleType([.nomnal("ioHandle")]),.tupleType([.nomnal("ioHandle"),.nomnal("ioHandle"),.nomnal("string"),.nomnal("integer"),.nomnal("string")]),.nomnal("errorCode")))
    | "_hosttoip" => .some(.funType(.tupleType([.nomnal("string")]),.tpExp(.tpFun("cons",1),.nomnal("string")),.voidType))
    | "_iptohost" => .some(.funType(.tupleType([.nomnal("string")]),.nomnal("string"),.nomnal("errorCode")))
    | "_delay" => .some(.funType(.tupleType([.nomnal("float")]),.tupleType([]),.nomnal("errorCode")))
    | "_sleep" => .some(.funType(.tupleType([.nomnal("float")]),.tupleType([]),.nomnal("errorCode")))
    | "_now" => .some(.funType(.tupleType([]),.nomnal("float"),.voidType))
    | "_today" => .some(.funType(.tupleType([]),.nomnal("float"),.voidType))
    | "_ticks" => .some(.funType(.tupleType([]),.nomnal("integer"),.voidType))
    | "_time2date" => .some(.funType(.tupleType([.nomnal("float")]),.tupleType([.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("float"),.nomnal("integer")]),.voidType))
    | "_time2utc" => .some(.funType(.tupleType([.nomnal("float")]),.tupleType([.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("float"),.nomnal("integer")]),.voidType))
    | "_date2time" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("float"),.nomnal("integer")]),.nomnal("float"),.voidType))
    | "_utc2time" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("float"),.nomnal("integer")]),.nomnal("float"),.voidType))
    | "_formattime" => .some(.funType(.tupleType([.nomnal("float"),.nomnal("string")]),.nomnal("string"),.nomnal("errorCode")))
    | "_parsetime" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("string")]),.nomnal("float"),.nomnal("errorCode")))
    | "_uniCodeCategory" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("integer"),.voidType))
    | "_isCcChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isCfChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isCnChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isCoChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isCsChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isLlChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isLmChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isLoChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isLtChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isLuChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isMcChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isMeChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isMnChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isNdChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isNlChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isNoChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isPcChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isPdChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isPeChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isPfChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isPiChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isPoChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isPsChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isScChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isSkChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isSmChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isSoChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isZlChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isZpChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isZsChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_isLetterChar" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_digitCode" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("integer"),.nomnal("errorCode")))
    | "_codePoint" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("integer"),.voidType))
    | "_int2chr" => .some(.funType(.tupleType([.nomnal("integer")]),.nomnal("char"),.voidType))
    | "_int2str" => .some(.funType(.tupleType([.nomnal("integer")]),.nomnal("string"),.voidType))
    | "_flt2str" => .some(.funType(.tupleType([.nomnal("float"),.nomnal("integer"),.nomnal("char"),.nomnal("boolean")]),.nomnal("string"),.voidType))
    | "_int_format" => .some(.funType(.tupleType([.nomnal("integer"),.nomnal("string")]),.nomnal("string"),.nomnal("errorCode")))
    | "_flt_format" => .some(.funType(.tupleType([.nomnal("float"),.nomnal("string")]),.nomnal("string"),.nomnal("errorCode")))
    | "_str2flt" => .some(.funType(.tupleType([.nomnal("string")]),.nomnal("float"),.nomnal("errorCode")))
    | "_str2int" => .some(.funType(.tupleType([.nomnal("string")]),.nomnal("integer"),.nomnal("errorCode")))
    | "_chr_eq" => .some(.funType(.tupleType([.nomnal("char"),.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_chr_lt" => .some(.funType(.tupleType([.nomnal("char"),.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_chr_ge" => .some(.funType(.tupleType([.nomnal("char"),.nomnal("char")]),.nomnal("boolean"),.voidType))
    | "_chr_hash" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("integer"),.voidType))
    | "_chr_quote" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("string"),.voidType))
    | "_chr_format" => .some(.funType(.tupleType([.nomnal("char"),.nomnal("string")]),.nomnal("string"),.voidType))
    | "_str_eq" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("string")]),.nomnal("boolean"),.voidType))
    | "_str_lt" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("string")]),.nomnal("boolean"),.voidType))
    | "_str_ge" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("string")]),.nomnal("boolean"),.voidType))
    | "_str_hash" => .some(.funType(.tupleType([.nomnal("string")]),.nomnal("integer"),.voidType))
    | "_str_len" => .some(.funType(.tupleType([.nomnal("string")]),.nomnal("integer"),.voidType))
    | "_str_gen" => .some(.funType(.tupleType([.nomnal("string")]),.nomnal("string"),.voidType))
    | "_stringOf" => .some(.allType(.kVar("r"),.funType(.tupleType([.kVar("r"),.nomnal("integer")]),.nomnal("string"),.voidType)))
    | "_explode" => .some(.funType(.tupleType([.nomnal("string")]),.tpExp(.tpFun("cons",1),.nomnal("char")),.voidType))
    | "_implode" => .some(.funType(.tupleType([.tpExp(.tpFun("cons",1),.nomnal("char"))]),.nomnal("string"),.voidType))
    | "_str_find" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("string"),.nomnal("integer")]),.nomnal("integer"),.voidType))
    | "_sub_str" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("integer"),.nomnal("integer")]),.nomnal("string"),.voidType))
    | "_str_split" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("integer")]),.tupleType([.nomnal("string"),.nomnal("string")]),.voidType))
    | "_str_concat" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("string")]),.nomnal("string"),.voidType))
    | "_str_reverse" => .some(.funType(.tupleType([.nomnal("string")]),.nomnal("string"),.voidType))
    | "_str_start" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("string")]),.nomnal("boolean"),.voidType))
    | "_str_end" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("string")]),.nomnal("boolean"),.voidType))
    | "_str_splice" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("integer"),.nomnal("integer"),.nomnal("string")]),.nomnal("string"),.voidType))
    | "_str_multicat" => .some(.funType(.tupleType([.tpExp(.tpFun("cons",1),.nomnal("string"))]),.nomnal("string"),.voidType))
    | "_str_hdtl" => .some(.funType(.tupleType([.nomnal("string")]),.tpExp(.tpFun("option",1),.tupleType([.nomnal("char"),.nomnal("string")])),.voidType))
    | "_str_back" => .some(.funType(.tupleType([.nomnal("string")]),.tupleType([.nomnal("string"),.nomnal("char")]),.nomnal("errorCode")))
    | "_str_cons" => .some(.funType(.tupleType([.nomnal("char"),.nomnal("string")]),.nomnal("string"),.voidType))
    | "_code2str" => .some(.funType(.tupleType([.nomnal("char")]),.nomnal("string"),.voidType))
    | "_str_apnd" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("char")]),.nomnal("string"),.voidType))
    | "_str_charat" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("integer")]),.nomnal("char"),.nomnal("errorCode")))
    | "_str_set" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("integer"),.nomnal("char")]),.nomnal("string"),.voidType))
    | "_str_drop" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("integer")]),.nomnal("string"),.voidType))
    | "_str_quote" => .some(.funType(.tupleType([.nomnal("string")]),.nomnal("string"),.voidType))
    | "_str_format" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("string")]),.nomnal("string"),.voidType))
    | "_getenv" => .some(.funType(.tupleType([.nomnal("string")]),.tpExp(.tpFun("option",1),.nomnal("string")),.voidType))
    | "_setenv" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("string")]),.tupleType([]),.nomnal("errorCode")))
    | "_envir" => .some(.funType(.tupleType([]),.tpExp(.tpFun("cons",1),.tupleType([.nomnal("string"),.nomnal("string")])),.voidType))
    | "_fork" => .some(.funType(.tupleType([.funType(.tupleType([]),.tupleType([]),.voidType)]),.nomnal("star.thread*thread"),.voidType))
    | "_thread" => .some(.funType(.tupleType([]),.nomnal("star.thread*thread"),.voidType))
    | "_kill" => .some(.funType(.tupleType([.nomnal("star.thread*thread")]),.tupleType([]),.nomnal("errorCode")))
    | "_thread_state" => .some(.funType(.tupleType([.nomnal("star.thread*thread")]),.nomnal("star.thread*threadState"),.voidType))
    | "_waitfor" => .some(.funType(.tupleType([.nomnal("star.thread*thread")]),.tupleType([]),.nomnal("errorCode")))
    | "_shell" => .some(.funType(.tupleType([.nomnal("string"),.tpExp(.tpFun("cons",1),.nomnal("string")),.tpExp(.tpFun("cons",1),.tupleType([.nomnal("string"),.nomnal("string")]))]),.nomnal("integer"),.nomnal("errorCode")))
    | "_stackTrace" => .some(.funType(.tupleType([]),.nomnal("string"),.voidType))
    | "_gc" => .some(.funType(.tupleType([.nomnal("integer")]),.tupleType([]),.nomnal("errorCode")))
    | "_jit_compile" => .some(.funType(.tupleType([.nomnal("string"),.nomnal("integer")]),.tupleType([]),.nomnal("errorCode")))
    | _ default => .none
  }

  public escapeArity:(string) => option[integer].
  escapeArity(Es) => case Es in {
       | "_exit" => .some(1)
    | "_int_plus" => .some(2)
    | "_int_minus" => .some(2)
    | "_int_times" => .some(2)
    | "_int_div" => .some(2)
    | "_int_mod" => .some(2)
    | "_int_hash" => .some(1)
    | "_int_gcd" => .some(2)
    | "_int_lg2" => .some(1)
    | "_flt_plus" => .some(2)
    | "_flt_minus" => .some(2)
    | "_flt_times" => .some(2)
    | "_flt_div" => .some(2)
    | "_flt_mod" => .some(2)
    | "_int_abs" => .some(1)
    | "_flt_abs" => .some(1)
    | "_int_eq" => .some(2)
    | "_int_lt" => .some(2)
    | "_int_ge" => .some(2)
    | "_int_pow" => .some(2)
    | "_flt_eq" => .some(2)
    | "_flt_lt" => .some(2)
    | "_flt_ge" => .some(2)
    | "_int2flt" => .some(1)
    | "_flt2int" => .some(1)
    | "_bits_float" => .some(1)
    | "_float_bits" => .some(1)
    | "_flt_hash" => .some(1)
    | "_flt_pwr" => .some(2)
    | "_big_plus" => .some(2)
    | "_big_minus" => .some(2)
    | "_big_times" => .some(2)
    | "_big_div" => .some(2)
    | "_big_bitand" => .some(2)
    | "_big_bitor" => .some(2)
    | "_big_bitxor" => .some(2)
    | "_big_bitnot" => .some(1)
    | "_big_gcd" => .some(2)
    | "_big_hash" => .some(1)
    | "_big_eq" => .some(2)
    | "_big_lt" => .some(2)
    | "_big_ge" => .some(2)
    | "_int2big" => .some(1)
    | "_big2int" => .some(1)
    | "_ints2big" => .some(1)
    | "_big2ints" => .some(1)
    | "_str2big" => .some(1)
    | "_big2str" => .some(1)
    | "_big_format" => .some(2)
    | "_fiber_eq" => .some(2)
    | "_fiber" => .some(1)
    | "_sqrt" => .some(1)
    | "_exp" => .some(1)
    | "_ln" => .some(1)
    | "_lg10" => .some(1)
    | "pi" => .some(0)
    | "sin" => .some(1)
    | "cos" => .some(1)
    | "tan" => .some(1)
    | "asin" => .some(1)
    | "acos" => .some(1)
    | "atan" => .some(1)
    | "trunc" => .some(1)
    | "floor" => .some(1)
    | "ceil" => .some(1)
    | "integral" => .some(1)
    | "_irand" => .some(1)
    | "_random" => .some(0)
    | "_seed" => .some(1)
    | "_ldexp" => .some(2)
    | "_frexp" => .some(1)
    | "_modf" => .some(1)
    | "_band" => .some(2)
    | "_bor" => .some(2)
    | "_bxor" => .some(2)
    | "_blsl" => .some(2)
    | "_blsr" => .some(2)
    | "_basr" => .some(2)
    | "_bnot" => .some(1)
    | "_cell_future" => .some(1)
    | "_futureIsResolved" => .some(1)
    | "_futureIsAccepted" => .some(1)
    | "_futureIsRejected" => .some(1)
    | "_futureVal" => .some(1)
    | "_cwd" => .some(0)
    | "_cd" => .some(1)
    | "_rm" => .some(1)
    | "_mv" => .some(2)
    | "_mkdir" => .some(2)
    | "_rmdir" => .some(1)
    | "_isdir" => .some(1)
    | "_file_chmod" => .some(2)
    | "_ls" => .some(1)
    | "_repo" => .some(0)
    | "_file_mode" => .some(1)
    | "_file_present" => .some(1)
    | "_file_type" => .some(1)
    | "_file_size" => .some(1)
    | "_file_modified" => .some(1)
    | "_file_date" => .some(1)
    | "_openInFile" => .some(2)
    | "_openOutFile" => .some(2)
    | "_openAppendFile" => .some(2)
    | "_openAppendIOFile" => .some(2)
    | "_popen" => .some(3)
    | "_close" => .some(1)
    | "_end_of_file" => .some(1)
    | "_inchars" => .some(2)
    | "_inchars_async" => .some(2)
    | "_inchar" => .some(1)
    | "_inchar_async" => .some(1)
    | "_inbyte" => .some(1)
    | "_inbyte_async" => .some(1)
    | "_inbytes" => .some(2)
    | "_inbytes_async" => .some(2)
    | "_inline" => .some(1)
    | "_inline_async" => .some(1)
    | "_outchar" => .some(2)
    | "_outchar_async" => .some(2)
    | "_outbyte" => .some(2)
    | "_outbyte_async" => .some(2)
    | "_outbytes" => .some(2)
    | "_outtext" => .some(2)
    | "_outtext_async" => .some(2)
    | "_stdfile" => .some(1)
    | "_fposition" => .some(1)
    | "_fseek" => .some(2)
    | "_flush" => .some(1)
    | "_flushall" => .some(0)
    | "_fname" => .some(1)
    | "_waitIo" => .some(2)
    | "_setfileencoding" => .some(2)
    | "_get_file" => .some(2)
    | "_put_file" => .some(3)
    | "_show" => .some(1)
    | "_logmsg" => .some(1)
    | "_display_depth" => .some(0)
    | "_connect" => .some(3)
    | "_listen" => .some(1)
    | "_accept" => .some(1)
    | "_hosttoip" => .some(1)
    | "_iptohost" => .some(1)
    | "_delay" => .some(1)
    | "_sleep" => .some(1)
    | "_now" => .some(0)
    | "_today" => .some(0)
    | "_ticks" => .some(0)
    | "_time2date" => .some(1)
    | "_time2utc" => .some(1)
    | "_date2time" => .some(7)
    | "_utc2time" => .some(7)
    | "_formattime" => .some(2)
    | "_parsetime" => .some(2)
    | "_uniCodeCategory" => .some(1)
    | "_isCcChar" => .some(1)
    | "_isCfChar" => .some(1)
    | "_isCnChar" => .some(1)
    | "_isCoChar" => .some(1)
    | "_isCsChar" => .some(1)
    | "_isLlChar" => .some(1)
    | "_isLmChar" => .some(1)
    | "_isLoChar" => .some(1)
    | "_isLtChar" => .some(1)
    | "_isLuChar" => .some(1)
    | "_isMcChar" => .some(1)
    | "_isMeChar" => .some(1)
    | "_isMnChar" => .some(1)
    | "_isNdChar" => .some(1)
    | "_isNlChar" => .some(1)
    | "_isNoChar" => .some(1)
    | "_isPcChar" => .some(1)
    | "_isPdChar" => .some(1)
    | "_isPeChar" => .some(1)
    | "_isPfChar" => .some(1)
    | "_isPiChar" => .some(1)
    | "_isPoChar" => .some(1)
    | "_isPsChar" => .some(1)
    | "_isScChar" => .some(1)
    | "_isSkChar" => .some(1)
    | "_isSmChar" => .some(1)
    | "_isSoChar" => .some(1)
    | "_isZlChar" => .some(1)
    | "_isZpChar" => .some(1)
    | "_isZsChar" => .some(1)
    | "_isLetterChar" => .some(1)
    | "_digitCode" => .some(1)
    | "_codePoint" => .some(1)
    | "_int2chr" => .some(1)
    | "_int2str" => .some(1)
    | "_flt2str" => .some(4)
    | "_int_format" => .some(2)
    | "_flt_format" => .some(2)
    | "_str2flt" => .some(1)
    | "_str2int" => .some(1)
    | "_chr_eq" => .some(2)
    | "_chr_lt" => .some(2)
    | "_chr_ge" => .some(2)
    | "_chr_hash" => .some(1)
    | "_chr_quote" => .some(1)
    | "_chr_format" => .some(2)
    | "_str_eq" => .some(2)
    | "_str_lt" => .some(2)
    | "_str_ge" => .some(2)
    | "_str_hash" => .some(1)
    | "_str_len" => .some(1)
    | "_str_gen" => .some(1)
    | "_stringOf" => .some(2)
    | "_explode" => .some(1)
    | "_implode" => .some(1)
    | "_str_find" => .some(3)
    | "_sub_str" => .some(3)
    | "_str_split" => .some(2)
    | "_str_concat" => .some(2)
    | "_str_reverse" => .some(1)
    | "_str_start" => .some(2)
    | "_str_end" => .some(2)
    | "_str_splice" => .some(4)
    | "_str_multicat" => .some(1)
    | "_str_hdtl" => .some(1)
    | "_str_back" => .some(1)
    | "_str_cons" => .some(2)
    | "_code2str" => .some(1)
    | "_str_apnd" => .some(2)
    | "_str_charat" => .some(2)
    | "_str_set" => .some(3)
    | "_str_drop" => .some(2)
    | "_str_quote" => .some(1)
    | "_str_format" => .some(2)
    | "_getenv" => .some(1)
    | "_setenv" => .some(2)
    | "_envir" => .some(0)
    | "_fork" => .some(1)
    | "_thread" => .some(0)
    | "_kill" => .some(1)
    | "_thread_state" => .some(1)
    | "_waitfor" => .some(1)
    | "_shell" => .some(3)
    | "_stackTrace" => .some(0)
    | "_gc" => .some(1)
    | "_jit_compile" => .some(2)
    | _ default => .none
  }

  public isEscape:(string)=>boolean.
  isEscape(Es) => .some(_) .= escapeArity(Es).
}
