star.compiler.escapes{
  -- Automatically Generated -- Do NOT Edit
  import star.

  import star.compiler.types.

  public escapeType:(string)=>option[tipe].
  escapeType(Es) => case Es in {
    | "_exit" => .some(.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer")])),.kVar("e"))))
    | "_abort" => .some(.allType(.kVar("a"),.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.kVar("a"),.nomnal("string")])),.kVar("e")))))
    | "_definedLbl" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("integer")])),.nomnal("boolean")))
    | "_globalIsSet" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.nomnal("boolean")))
    | "_int_plus" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer")])),.nomnal("integer")))
    | "_int_minus" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer")])),.nomnal("integer")))
    | "_int_times" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer")])),.nomnal("integer")))
    | "_int_div" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer")])),.nomnal("integer")),.raisEs(.nomnal("errorCode"))))
    | "_int_mod" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer")])),.nomnal("integer")),.raisEs(.nomnal("errorCode"))))
    | "_int_hash" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer")])),.nomnal("integer")))
    | "_int_gcd" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer")])),.nomnal("integer")),.raisEs(.nomnal("errorCode"))))
    | "_int_lg2" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer")])),.nomnal("integer")),.raisEs(.nomnal("errorCode"))))
    | "_flt_plus" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float"),.nomnal("float")])),.nomnal("float")))
    | "_flt_minus" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float"),.nomnal("float")])),.nomnal("float")))
    | "_flt_times" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float"),.nomnal("float")])),.nomnal("float")))
    | "_flt_div" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float"),.nomnal("float")])),.nomnal("float")),.raisEs(.nomnal("errorCode"))))
    | "_flt_mod" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float"),.nomnal("float")])),.nomnal("float")),.raisEs(.nomnal("errorCode"))))
    | "_int_abs" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer")])),.nomnal("integer")))
    | "_flt_abs" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("float")))
    | "_int_eq" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer")])),.nomnal("boolean")))
    | "_int_lt" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer")])),.nomnal("boolean")))
    | "_int_ge" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer")])),.nomnal("boolean")))
    | "_int_pow" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer")])),.nomnal("integer")),.raisEs(.nomnal("errorCode"))))
    | "_flt_eq" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float"),.nomnal("float")])),.nomnal("boolean")))
    | "_flt_lt" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float"),.nomnal("float")])),.nomnal("boolean")))
    | "_flt_ge" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float"),.nomnal("float")])),.nomnal("boolean")))
    | "_int2flt" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer")])),.nomnal("float")))
    | "_flt2int" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("integer")))
    | "_bits_float" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer")])),.nomnal("float")))
    | "_float_bits" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("integer")))
    | "_flt_hash" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("integer")))
    | "_flt_pwr" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float"),.nomnal("float")])),.nomnal("float")))
    | "_big_plus" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint"),.nomnal("bigint")])),.nomnal("bigint")))
    | "_big_minus" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint"),.nomnal("bigint")])),.nomnal("bigint")))
    | "_big_times" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint"),.nomnal("bigint")])),.nomnal("bigint")))
    | "_big_div" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint"),.nomnal("bigint")])),.tupleType([.nomnal("bigint"),.nomnal("bigint")])),.raisEs(.nomnal("errorCode"))))
    | "_big_bitand" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint"),.nomnal("bigint")])),.nomnal("bigint")))
    | "_big_bitor" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint"),.nomnal("bigint")])),.nomnal("bigint")))
    | "_big_bitxor" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint"),.nomnal("bigint")])),.nomnal("bigint")))
    | "_big_bitnot" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint")])),.nomnal("bigint")))
    | "_big_gcd" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint"),.nomnal("bigint")])),.nomnal("bigint")),.raisEs(.nomnal("errorCode"))))
    | "_big_hash" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint")])),.nomnal("integer")))
    | "_big_eq" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint"),.nomnal("bigint")])),.nomnal("boolean")))
    | "_big_lt" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint"),.nomnal("bigint")])),.nomnal("boolean")))
    | "_big_ge" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint"),.nomnal("bigint")])),.nomnal("boolean")))
    | "_int2big" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer")])),.nomnal("bigint")))
    | "_big2int" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint")])),.tpExp(.tpFun("option",1),.nomnal("integer"))))
    | "_ints2big" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpFun("cons",1),.nomnal("integer"))])),.nomnal("bigint")))
    | "_big2ints" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint")])),.tpExp(.tpFun("cons",1),.nomnal("integer"))))
    | "_str2big" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.tpExp(.tpFun("option",1),.nomnal("bigint"))))
    | "_big2str" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint")])),.nomnal("string")))
    | "_big_format" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("bigint"),.nomnal("string")])),.nomnal("string")),.raisEs(.nomnal("errorCode"))))
    | "_fiber_eq" => .some(.allType(.kVar("r"),.allType(.kVar("s"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s")),.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s"))])),.nomnal("boolean")))))
    | "_fiber" => .some(.allType(.kVar("r"),.allType(.kVar("s"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s")),.kVar("r")])),.kVar("s"))])),.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s"))))))
    | "_suspend" => .some(.allType(.kVar("r"),.allType(.kVar("s"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s")),.kVar("s")])),.kVar("r")))))
    | "_retire" => .some(.allType(.kVar("r"),.allType(.kVar("s"),.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s")),.kVar("s")])),.kVar("e"))))))
    | "_resume" => .some(.allType(.kVar("r"),.allType(.kVar("s"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("fiber",2),.kVar("r")),.kVar("s")),.kVar("r")])),.kVar("s")))))
    | "sqrt" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("float")),.raisEs(.nomnal("errorCode"))))
    | "exp" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("float")),.raisEs(.nomnal("errorCode"))))
    | "log" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("float")))
    | "log10" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("float")))
    | "pi" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("float")))
    | "sin" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("float")))
    | "cos" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("float")))
    | "tan" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("float")))
    | "asin" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("float")))
    | "acos" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("float")))
    | "atan" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("float")))
    | "trunc" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("float")))
    | "floor" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("float")))
    | "ceil" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("float")))
    | "integral" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.nomnal("boolean")))
    | "_irand" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer")])),.nomnal("integer")))
    | "_random" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("float")))
    | "_seed" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer")])),.tupleType([])))
    | "_ldexp" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float"),.nomnal("integer")])),.nomnal("float")))
    | "_frexp" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.tupleType([.nomnal("float"),.nomnal("integer")])))
    | "_modf" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.tupleType([.nomnal("float"),.nomnal("integer")])))
    | "_band" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer")])),.nomnal("integer")))
    | "_bor" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer")])),.nomnal("integer")))
    | "_bxor" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer")])),.nomnal("integer")))
    | "_blsl" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer")])),.nomnal("integer")))
    | "_blsr" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer")])),.nomnal("integer")))
    | "_basr" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer")])),.nomnal("integer")))
    | "_bnot" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer")])),.nomnal("integer")))
    | "_cell" => .some(.allType(.kVar("r"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.kVar("r")])),.tpExp(.tpFun("ref",1),.kVar("r")))))
    | "_get" => .some(.allType(.kVar("r"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpFun("ref",1),.kVar("r"))])),.kVar("r"))))
    | "_assign" => .some(.allType(.kVar("r"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpFun("ref",1),.kVar("r")),.kVar("r")])),.tupleType([]))))
    | "_cell_future" => .some(.allType(.kVar("s"),.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpFun("ref",1),.tpExp(.tpExp(.tpFun("star.either*either",2),.kVar("s")),.kVar("e")))])),.tpExp(.tpExp(.tpFun("future",2),.kVar("s")),.kVar("e"))))))
    | "_futureIsResolved" => .some(.allType(.kVar("a"),.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("future",2),.kVar("a")),.kVar("e"))])),.nomnal("boolean")))))
    | "_futureIsAccepted" => .some(.allType(.kVar("a"),.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("future",2),.kVar("a")),.kVar("e"))])),.nomnal("boolean")))))
    | "_futureIsRejected" => .some(.allType(.kVar("a"),.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("future",2),.kVar("a")),.kVar("e"))])),.nomnal("boolean")))))
    | "_futureVal" => .some(.allType(.kVar("a"),.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("future",2),.kVar("a")),.kVar("e"))])),.tpExp(.tpExp(.tpFun("star.either*either",2),.kVar("a")),.kVar("e"))))))
    | "_tuple_nth" => .some(.allType(.kVar("a"),.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.kVar("a"),.nomnal("integer")])),.kVar("e")))))
    | "_tuple_set_nth" => .some(.allType(.kVar("a"),.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.kVar("a"),.nomnal("integer"),.kVar("e")])),.kVar("a")))))
    | "_cwd" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("string")))
    | "_cd" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_rm" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_mv" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("string")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_mkdir" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("integer")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_rmdir" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_isdir" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.nomnal("boolean")))
    | "_file_chmod" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("integer")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_ls" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.tpExp(.tpFun("cons",1),.nomnal("string"))),.raisEs(.nomnal("errorCode"))))
    | "_repo" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("string")))
    | "_file_mode" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.nomnal("integer")),.raisEs(.nomnal("errorCode"))))
    | "_file_present" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.nomnal("boolean")))
    | "_file_type" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.nomnal("integer")),.raisEs(.nomnal("errorCode"))))
    | "_file_size" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.nomnal("integer")),.raisEs(.nomnal("errorCode"))))
    | "_file_modified" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.nomnal("integer")),.raisEs(.nomnal("errorCode"))))
    | "_file_date" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.tupleType([.nomnal("integer"),.nomnal("integer"),.nomnal("integer")])),.raisEs(.nomnal("errorCode"))))
    | "_openInFile" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("integer")])),.nomnal("ioHandle")),.raisEs(.nomnal("errorCode"))))
    | "_openOutFile" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("integer")])),.nomnal("ioHandle")),.raisEs(.nomnal("errorCode"))))
    | "_openAppendFile" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("integer")])),.nomnal("ioHandle")),.raisEs(.nomnal("errorCode"))))
    | "_openAppendIOFile" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("integer")])),.nomnal("ioHandle")),.raisEs(.nomnal("errorCode"))))
    | "_popen" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.tpExp(.tpFun("cons",1),.nomnal("string")),.tpExp(.tpFun("cons",1),.tupleType([.nomnal("string"),.nomnal("string")]))])),.tupleType([.nomnal("ioHandle"),.nomnal("ioHandle"),.nomnal("ioHandle")])),.raisEs(.nomnal("errorCode"))))
    | "_close" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_end_of_file" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.nomnal("boolean")))
    | "_inchars" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("integer")])),.nomnal("string")),.raisEs(.nomnal("errorCode"))))
    | "_inchars_async" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("integer")])),.tpExp(.tpExp(.tpFun("future",2),.nomnal("string")),.nomnal("errorCode"))),.raisEs(.nomnal("errorCode"))))
    | "_inchar" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.nomnal("char")),.raisEs(.nomnal("errorCode"))))
    | "_inchar_async" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.tpExp(.tpExp(.tpFun("future",2),.nomnal("char")),.nomnal("errorCode"))),.raisEs(.nomnal("errorCode"))))
    | "_inbyte" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.nomnal("integer")),.raisEs(.nomnal("errorCode"))))
    | "_inbyte_async" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.tpExp(.tpExp(.tpFun("future",2),.nomnal("integer")),.nomnal("errorCode"))),.raisEs(.nomnal("errorCode"))))
    | "_inbytes" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("integer")])),.tpExp(.tpFun("star.vector*vect",1),.nomnal("integer"))),.raisEs(.nomnal("errorCode"))))
    | "_inbytes_async" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("integer")])),.tpExp(.tpExp(.tpFun("future",2),.tpExp(.tpFun("star.vector*vect",1),.nomnal("integer"))),.nomnal("errorCode"))),.raisEs(.nomnal("errorCode"))))
    | "_inline" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.nomnal("string")),.raisEs(.nomnal("errorCode"))))
    | "_inline_async" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.tpExp(.tpExp(.tpFun("future",2),.nomnal("string")),.nomnal("errorCode"))),.raisEs(.nomnal("errorCode"))))
    | "_outchar" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("char")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_outchar_async" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("char")])),.tpExp(.tpExp(.tpFun("future",2),.tupleType([])),.nomnal("errorCode"))),.raisEs(.nomnal("errorCode"))))
    | "_outbyte" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("integer")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_outbyte_async" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("integer")])),.tpExp(.tpExp(.tpFun("future",2),.tupleType([])),.nomnal("errorCode"))),.raisEs(.nomnal("errorCode"))))
    | "_outbytes" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.tpExp(.tpFun("cons",1),.nomnal("integer"))])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_outtext" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("string")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_outtext_async" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("string")])),.tpExp(.tpExp(.tpFun("future",2),.tupleType([])),.nomnal("errorCode"))),.raisEs(.nomnal("errorCode"))))
    | "_stdfile" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer")])),.nomnal("ioHandle")))
    | "_fposition" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.nomnal("integer")))
    | "_fseek" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("integer")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_flush" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_flushall" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.tupleType([])))
    | "_fname" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.nomnal("string")))
    | "_waitIo" => .some(.allType(.kVar("e"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpFun("cons",1),.tupleType([.nomnal("ioHandle"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("boolean")),.kVar("e")])),.nomnal("integer")])),.nomnal("boolean"))))
    | "_setfileencoding" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle"),.nomnal("integer")])),.tupleType([])))
    | "_get_file" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.nomnal("string")),.raisEs(.nomnal("errorCode"))))
    | "_put_file" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("string")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_show" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.tupleType([])))
    | "_install_pkg" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.tpExp(.tpFun("cons",1),.tupleType([.nomnal("string"),.nomnal("string")]))),.raisEs(.nomnal("errorCode"))))
    | "_pkg_is_present" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("string")])),.nomnal("boolean")),.raisEs(.nomnal("errorCode"))))
    | "_in_manifest" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("string"),.nomnal("string")])),.nomnal("boolean")),.raisEs(.nomnal("errorCode"))))
    | "_locate_in_manifest" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("string"),.nomnal("string")])),.nomnal("string")),.raisEs(.nomnal("errorCode"))))
    | "_logmsg" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.tupleType([])))
    | "_display_depth" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("integer")))
    | "_connect" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("integer"),.nomnal("integer")])),.tupleType([.nomnal("ioHandle"),.nomnal("ioHandle")])),.raisEs(.nomnal("errorCode"))))
    | "_listen" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer")])),.nomnal("ioHandle")),.raisEs(.nomnal("errorCode"))))
    | "_accept" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("ioHandle")])),.tupleType([.nomnal("ioHandle"),.nomnal("ioHandle"),.nomnal("string"),.nomnal("integer"),.nomnal("string")])),.raisEs(.nomnal("errorCode"))))
    | "_hosttoip" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.tpExp(.tpFun("cons",1),.nomnal("string"))))
    | "_iptohost" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.nomnal("string")),.raisEs(.nomnal("errorCode"))))
    | "_delay" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_sleep" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_now" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("float")))
    | "_today" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("float")))
    | "_ticks" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("integer")))
    | "_time2date" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.tupleType([.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("float"),.nomnal("integer")])))
    | "_time2utc" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float")])),.tupleType([.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("float"),.nomnal("integer")])))
    | "_date2time" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("float"),.nomnal("integer")])),.nomnal("float")))
    | "_utc2time" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("float"),.nomnal("integer")])),.nomnal("float")))
    | "_formattime" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float"),.nomnal("string")])),.nomnal("string")),.raisEs(.nomnal("errorCode"))))
    | "_parsetime" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("string")])),.tpExp(.tpFun("option",1),.nomnal("float"))))
    | "_uniCodeCategory" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("integer")))
    | "_isCcChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isCfChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isCnChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isCoChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isCsChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isLlChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isLmChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isLoChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isLtChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isLuChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isMcChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isMeChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isMnChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isNdChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isNlChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isNoChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isPcChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isPdChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isPeChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isPfChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isPiChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isPoChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isPsChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isScChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isSkChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isSmChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isSoChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isZlChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isZpChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isZsChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isLetterChar" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_digitCode" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("integer")),.raisEs(.nomnal("errorCode"))))
    | "_codePoint" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("integer")))
    | "_char" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer")])),.nomnal("char")))
    | "_isIDStart" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_isIDContinue" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("boolean")))
    | "_int2str" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("integer"),.nomnal("integer"),.nomnal("integer")])),.nomnal("string")))
    | "_flt2str" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float"),.nomnal("integer"),.nomnal("char"),.nomnal("boolean")])),.nomnal("string")))
    | "_int_format" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("integer"),.nomnal("string")])),.nomnal("string")),.raisEs(.nomnal("errorCode"))))
    | "_flt_format" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("float"),.nomnal("string")])),.nomnal("string")))
    | "_str2flt" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.tpExp(.tpFun("option",1),.nomnal("float"))))
    | "_str2int" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.tpExp(.tpFun("option",1),.nomnal("integer"))))
    | "_chr_eq" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char"),.nomnal("char")])),.nomnal("boolean")))
    | "_chr_lt" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char"),.nomnal("char")])),.nomnal("boolean")))
    | "_chr_ge" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char"),.nomnal("char")])),.nomnal("boolean")))
    | "_chr_hash" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("integer")))
    | "_chr_quote" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("string")))
    | "_chr_format" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char"),.nomnal("string")])),.nomnal("string")))
    | "_str_eq" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("string")])),.nomnal("boolean")))
    | "_str_lt" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("string")])),.nomnal("boolean")))
    | "_str_ge" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("string")])),.nomnal("boolean")))
    | "_str_hash" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.nomnal("integer")))
    | "_str_len" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.nomnal("integer")))
    | "_str_gen" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.nomnal("string")))
    | "_stringOf" => .some(.allType(.kVar("r"),.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.kVar("r"),.nomnal("integer")])),.nomnal("string"))))
    | "_explode" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.tpExp(.tpFun("cons",1),.nomnal("char"))))
    | "_implode" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpFun("cons",1),.nomnal("char"))])),.nomnal("string")))
    | "_str_find" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("string"),.nomnal("integer")])),.nomnal("integer")))
    | "_sub_str" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("integer"),.nomnal("integer")])),.nomnal("string")))
    | "_str_split" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("integer")])),.tupleType([.nomnal("string"),.nomnal("string")])))
    | "_str_concat" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("string")])),.nomnal("string")))
    | "_str_reverse" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.nomnal("string")))
    | "_str_start" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("string")])),.nomnal("boolean")))
    | "_str_end" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("string")])),.nomnal("boolean")))
    | "_str_splice" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("integer"),.nomnal("integer"),.nomnal("string")])),.nomnal("string")))
    | "_str_multicat" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpFun("cons",1),.nomnal("string"))])),.nomnal("string")))
    | "_str_hdtl" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.tpExp(.tpFun("option",1),.tupleType([.nomnal("char"),.nomnal("string")]))))
    | "_str_back" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.tupleType([.nomnal("string"),.nomnal("char")])),.raisEs(.nomnal("errorCode"))))
    | "_str_cons" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char"),.nomnal("string")])),.nomnal("string")))
    | "_code2str" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("char")])),.nomnal("string")))
    | "_str_apnd" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("char")])),.nomnal("string")))
    | "_str_charat" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("integer")])),.tpExp(.tpFun("option",1),.nomnal("char"))))
    | "_str_quote" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.nomnal("string")))
    | "_str_format" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("string")])),.nomnal("string")))
    | "_getenv" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string")])),.tpExp(.tpFun("option",1),.nomnal("string"))))
    | "_setenv" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.nomnal("string")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_envir" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.tpExp(.tpFun("cons",1),.tupleType([.nomnal("string"),.nomnal("string")]))))
    | "_fork" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.tupleType([]))])),.nomnal("star.thread*thread")))
    | "_thread" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("star.thread*thread")))
    | "_kill" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star.thread*thread")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_thread_state" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star.thread*thread")])),.nomnal("star.thread*threadState")))
    | "_waitfor" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("star.thread*thread")])),.tupleType([])),.raisEs(.nomnal("errorCode"))))
    | "_shell" => .some(.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.nomnal("string"),.tpExp(.tpFun("cons",1),.nomnal("string")),.tpExp(.tpFun("cons",1),.tupleType([.nomnal("string"),.nomnal("string")]))])),.nomnal("integer")),.raisEs(.nomnal("errorCode"))))
    | "_ins_debug" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.tupleType([])))
    | "_stackTrace" => .some(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([])),.nomnal("string")))
    | "_jit_compile" => .some(.allType(.kVar("a"),.allType(.kVar("e"),.constrainedType(.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.tpExp(.tpExp(.tpFun("=>",2),.tupleType([.kVar("a")])),.kVar("e"))])),.tupleType([])),.raisEs(.nomnal("errorCode"))))))
    | _ default => .none
  }

  public isEscape:(string)=>boolean.
  isEscape(Es) => case Es in {
    | "_exit" => .true
    | "_abort" => .true
    | "_definedLbl" => .true
    | "_globalIsSet" => .true
    | "_int_plus" => .true
    | "_int_minus" => .true
    | "_int_times" => .true
    | "_int_div" => .true
    | "_int_mod" => .true
    | "_int_hash" => .true
    | "_int_gcd" => .true
    | "_int_lg2" => .true
    | "_flt_plus" => .true
    | "_flt_minus" => .true
    | "_flt_times" => .true
    | "_flt_div" => .true
    | "_flt_mod" => .true
    | "_int_abs" => .true
    | "_flt_abs" => .true
    | "_int_eq" => .true
    | "_int_lt" => .true
    | "_int_ge" => .true
    | "_int_pow" => .true
    | "_flt_eq" => .true
    | "_flt_lt" => .true
    | "_flt_ge" => .true
    | "_int2flt" => .true
    | "_flt2int" => .true
    | "_bits_float" => .true
    | "_float_bits" => .true
    | "_flt_hash" => .true
    | "_flt_pwr" => .true
    | "_big_plus" => .true
    | "_big_minus" => .true
    | "_big_times" => .true
    | "_big_div" => .true
    | "_big_bitand" => .true
    | "_big_bitor" => .true
    | "_big_bitxor" => .true
    | "_big_bitnot" => .true
    | "_big_gcd" => .true
    | "_big_hash" => .true
    | "_big_eq" => .true
    | "_big_lt" => .true
    | "_big_ge" => .true
    | "_int2big" => .true
    | "_big2int" => .true
    | "_ints2big" => .true
    | "_big2ints" => .true
    | "_str2big" => .true
    | "_big2str" => .true
    | "_big_format" => .true
    | "_fiber_eq" => .true
    | "_fiber" => .true
    | "_suspend" => .true
    | "_retire" => .true
    | "_resume" => .true
    | "sqrt" => .true
    | "exp" => .true
    | "log" => .true
    | "log10" => .true
    | "pi" => .true
    | "sin" => .true
    | "cos" => .true
    | "tan" => .true
    | "asin" => .true
    | "acos" => .true
    | "atan" => .true
    | "trunc" => .true
    | "floor" => .true
    | "ceil" => .true
    | "integral" => .true
    | "_irand" => .true
    | "_random" => .true
    | "_seed" => .true
    | "_ldexp" => .true
    | "_frexp" => .true
    | "_modf" => .true
    | "_band" => .true
    | "_bor" => .true
    | "_bxor" => .true
    | "_blsl" => .true
    | "_blsr" => .true
    | "_basr" => .true
    | "_bnot" => .true
    | "_cell" => .true
    | "_get" => .true
    | "_assign" => .true
    | "_cell_future" => .true
    | "_futureIsResolved" => .true
    | "_futureIsAccepted" => .true
    | "_futureIsRejected" => .true
    | "_futureVal" => .true
    | "_tuple_nth" => .true
    | "_tuple_set_nth" => .true
    | "_cwd" => .true
    | "_cd" => .true
    | "_rm" => .true
    | "_mv" => .true
    | "_mkdir" => .true
    | "_rmdir" => .true
    | "_isdir" => .true
    | "_file_chmod" => .true
    | "_ls" => .true
    | "_repo" => .true
    | "_file_mode" => .true
    | "_file_present" => .true
    | "_file_type" => .true
    | "_file_size" => .true
    | "_file_modified" => .true
    | "_file_date" => .true
    | "_openInFile" => .true
    | "_openOutFile" => .true
    | "_openAppendFile" => .true
    | "_openAppendIOFile" => .true
    | "_popen" => .true
    | "_close" => .true
    | "_end_of_file" => .true
    | "_inchars" => .true
    | "_inchars_async" => .true
    | "_inchar" => .true
    | "_inchar_async" => .true
    | "_inbyte" => .true
    | "_inbyte_async" => .true
    | "_inbytes" => .true
    | "_inbytes_async" => .true
    | "_inline" => .true
    | "_inline_async" => .true
    | "_outchar" => .true
    | "_outchar_async" => .true
    | "_outbyte" => .true
    | "_outbyte_async" => .true
    | "_outbytes" => .true
    | "_outtext" => .true
    | "_outtext_async" => .true
    | "_stdfile" => .true
    | "_fposition" => .true
    | "_fseek" => .true
    | "_flush" => .true
    | "_flushall" => .true
    | "_fname" => .true
    | "_waitIo" => .true
    | "_setfileencoding" => .true
    | "_get_file" => .true
    | "_put_file" => .true
    | "_show" => .true
    | "_install_pkg" => .true
    | "_pkg_is_present" => .true
    | "_in_manifest" => .true
    | "_locate_in_manifest" => .true
    | "_logmsg" => .true
    | "_display_depth" => .true
    | "_connect" => .true
    | "_listen" => .true
    | "_accept" => .true
    | "_hosttoip" => .true
    | "_iptohost" => .true
    | "_delay" => .true
    | "_sleep" => .true
    | "_now" => .true
    | "_today" => .true
    | "_ticks" => .true
    | "_time2date" => .true
    | "_time2utc" => .true
    | "_date2time" => .true
    | "_utc2time" => .true
    | "_formattime" => .true
    | "_parsetime" => .true
    | "_uniCodeCategory" => .true
    | "_isCcChar" => .true
    | "_isCfChar" => .true
    | "_isCnChar" => .true
    | "_isCoChar" => .true
    | "_isCsChar" => .true
    | "_isLlChar" => .true
    | "_isLmChar" => .true
    | "_isLoChar" => .true
    | "_isLtChar" => .true
    | "_isLuChar" => .true
    | "_isMcChar" => .true
    | "_isMeChar" => .true
    | "_isMnChar" => .true
    | "_isNdChar" => .true
    | "_isNlChar" => .true
    | "_isNoChar" => .true
    | "_isPcChar" => .true
    | "_isPdChar" => .true
    | "_isPeChar" => .true
    | "_isPfChar" => .true
    | "_isPiChar" => .true
    | "_isPoChar" => .true
    | "_isPsChar" => .true
    | "_isScChar" => .true
    | "_isSkChar" => .true
    | "_isSmChar" => .true
    | "_isSoChar" => .true
    | "_isZlChar" => .true
    | "_isZpChar" => .true
    | "_isZsChar" => .true
    | "_isLetterChar" => .true
    | "_digitCode" => .true
    | "_codePoint" => .true
    | "_char" => .true
    | "_isIDStart" => .true
    | "_isIDContinue" => .true
    | "_int2str" => .true
    | "_flt2str" => .true
    | "_int_format" => .true
    | "_flt_format" => .true
    | "_str2flt" => .true
    | "_str2int" => .true
    | "_chr_eq" => .true
    | "_chr_lt" => .true
    | "_chr_ge" => .true
    | "_chr_hash" => .true
    | "_chr_quote" => .true
    | "_chr_format" => .true
    | "_str_eq" => .true
    | "_str_lt" => .true
    | "_str_ge" => .true
    | "_str_hash" => .true
    | "_str_len" => .true
    | "_str_gen" => .true
    | "_stringOf" => .true
    | "_explode" => .true
    | "_implode" => .true
    | "_str_find" => .true
    | "_sub_str" => .true
    | "_str_split" => .true
    | "_str_concat" => .true
    | "_str_reverse" => .true
    | "_str_start" => .true
    | "_str_end" => .true
    | "_str_splice" => .true
    | "_str_multicat" => .true
    | "_str_hdtl" => .true
    | "_str_back" => .true
    | "_str_cons" => .true
    | "_code2str" => .true
    | "_str_apnd" => .true
    | "_str_charat" => .true
    | "_str_quote" => .true
    | "_str_format" => .true
    | "_getenv" => .true
    | "_setenv" => .true
    | "_envir" => .true
    | "_fork" => .true
    | "_thread" => .true
    | "_kill" => .true
    | "_thread_state" => .true
    | "_waitfor" => .true
    | "_shell" => .true
    | "_ins_debug" => .true
    | "_stackTrace" => .true
    | "_jit_compile" => .true
    | _ default => .false
  }
}
